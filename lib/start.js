import require$$0$4 from 'node:crypto';
import require$$0$5 from 'node:events';
import require$$1$1 from 'node:net';
import require$$2 from 'node:tls';
import require$$4$1 from 'node:timers/promises';
import require$$7$1 from 'node:url';
import require$$0 from 'stream';
import tty from 'node:tty';
import http from 'http';
import https from 'https';
import require$$0$1, { gunzipSync } from 'zlib';
import require$$1, { createHmac, pbkdf2Sync, randomBytes as randomBytes$2, createHash } from 'crypto';
import require$$0$2 from 'buffer';
import require$$0$3 from 'events';
import require$$3$1 from 'net';
import require$$4 from 'tls';
import require$$7 from 'url';
import process$1 from 'process';
import { existsSync, readFileSync } from 'fs';

/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */
/**
 *  The current version of Ethers.
 */
const version$1 = "6.15.0";

/**
 *  Property helper functions.
 *
 *  @_subsection api/utils:Properties  [about-properties]
 */
function checkType(value, type, name) {
    const types = type.split("|").map(t => t.trim());
    for (let i = 0; i < types.length; i++) {
        switch (type) {
            case "any":
                return;
            case "bigint":
            case "boolean":
            case "number":
            case "string":
                if (typeof (value) === type) {
                    return;
                }
        }
    }
    const error = new Error(`invalid value for type ${type}`);
    error.code = "INVALID_ARGUMENT";
    error.argument = `value.${name}`;
    error.value = value;
    throw error;
}
/**
 *  Resolves to a new object that is a copy of %%value%%, but with all
 *  values resolved.
 */
async function resolveProperties(value) {
    const keys = Object.keys(value);
    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
    return results.reduce((accum, v, index) => {
        accum[keys[index]] = v;
        return accum;
    }, {});
}
/**
 *  Assigns the %%values%% to %%target%% as read-only values.
 *
 *  It %%types%% is specified, the values are checked.
 */
function defineProperties(target, values, types) {
    for (let key in values) {
        let value = values[key];
        const type = (types ? types[key] : null);
        if (type) {
            checkType(value, type, key);
        }
        Object.defineProperty(target, key, { enumerable: true, value, writable: false });
    }
}

/**
 *  All errors in ethers include properties to ensure they are both
 *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).
 *
 *  The [[isError]] function can be used to check the error ``code`` and
 *  provide a type guard for the properties present on that error interface.
 *
 *  @_section: api/utils/errors:Errors  [about-errors]
 */
function stringify(value, seen) {
    if (value == null) {
        return "null";
    }
    if (seen == null) {
        seen = new Set();
    }
    if (typeof (value) === "object") {
        if (seen.has(value)) {
            return "[Circular]";
        }
        seen.add(value);
    }
    if (Array.isArray(value)) {
        return "[ " + (value.map((v) => stringify(v, seen))).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
        const HEX = "0123456789abcdef";
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            result += HEX[value[i] >> 4];
            result += HEX[value[i] & 0xf];
        }
        return result;
    }
    if (typeof (value) === "object" && typeof (value.toJSON) === "function") {
        return stringify(value.toJSON(), seen);
    }
    switch (typeof (value)) {
        case "boolean":
        case "number":
        case "symbol":
            return value.toString();
        case "bigint":
            return BigInt(value).toString();
        case "string":
            return JSON.stringify(value);
        case "object": {
            const keys = Object.keys(value);
            keys.sort();
            return "{ " + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(", ") + " }";
        }
    }
    return `[ COULD NOT SERIALIZE ]`;
}
/**
 *  Returns true if the %%error%% matches an error thrown by ethers
 *  that matches the error %%code%%.
 *
 *  In TypeScript environments, this can be used to check that %%error%%
 *  matches an EthersError type, which means the expected properties will
 *  be set.
 *
 *  @See [ErrorCodes](api:ErrorCode)
 *  @example
 *    try {
 *      // code....
 *    } catch (e) {
 *      if (isError(e, "CALL_EXCEPTION")) {
 *          // The Type Guard has validated this object
 *          console.log(e.data);
 *      }
 *    }
 */
function isError(error, code) {
    return (error && error.code === code);
}
/**
 *  Returns true if %%error%% is a [[CallExceptionError].
 */
function isCallException(error) {
    return isError(error, "CALL_EXCEPTION");
}
/**
 *  Returns a new Error configured to the format ethers emits errors, with
 *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties
 *  for the corresponding EthersError.
 *
 *  Each error in ethers includes the version of ethers, a
 *  machine-readable [[ErrorCode]], and depending on %%code%%, additional
 *  required properties. The error message will also include the %%message%%,
 *  ethers version, %%code%% and all additional properties, serialized.
 */
function makeError(message, code, info) {
    let shortMessage = message;
    {
        const details = [];
        if (info) {
            if ("message" in info || "code" in info || "name" in info) {
                throw new Error(`value will overwrite populated values: ${stringify(info)}`);
            }
            for (const key in info) {
                if (key === "shortMessage") {
                    continue;
                }
                const value = (info[key]);
                //                try {
                details.push(key + "=" + stringify(value));
                //                } catch (error: any) {
                //                console.log("MMM", error.message);
                //                    details.push(key + "=[could not serialize object]");
                //                }
            }
        }
        details.push(`code=${code}`);
        details.push(`version=${version$1}`);
        if (details.length) {
            message += " (" + details.join(", ") + ")";
        }
    }
    let error;
    switch (code) {
        case "INVALID_ARGUMENT":
            error = new TypeError(message);
            break;
        case "NUMERIC_FAULT":
        case "BUFFER_OVERRUN":
            error = new RangeError(message);
            break;
        default:
            error = new Error(message);
    }
    defineProperties(error, { code });
    if (info) {
        Object.assign(error, info);
    }
    if (error.shortMessage == null) {
        defineProperties(error, { shortMessage });
    }
    return error;
}
/**
 *  Throws an EthersError with %%message%%, %%code%% and additional error
 *  %%info%% when %%check%% is falsish..
 *
 *  @see [[api:makeError]]
 */
function assert(check, message, code, info) {
    if (!check) {
        throw makeError(message, code, info);
    }
}
/**
 *  A simple helper to simply ensuring provided arguments match expected
 *  constraints, throwing if not.
 *
 *  In TypeScript environments, the %%check%% has been asserted true, so
 *  any further code does not need additional compile-time checks.
 */
function assertArgument(check, message, name, value) {
    assert(check, message, "INVALID_ARGUMENT", { argument: name, value: value });
}
function assertArgumentCount(count, expectedCount, message) {
    if (message == null) {
        message = "";
    }
    if (message) {
        message = ": " + message;
    }
    assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
        count: count,
        expectedCount: expectedCount
    });
    assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
        count: count,
        expectedCount: expectedCount
    });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
    try {
        // General test for normalize
        /* c8 ignore start */
        if ("test".normalize(form) !== "test") {
            throw new Error("bad");
        }
        ;
        /* c8 ignore stop */
        if (form === "NFD") {
            const check = String.fromCharCode(0xe9).normalize("NFD");
            const expected = String.fromCharCode(0x65, 0x0301);
            /* c8 ignore start */
            if (check !== expected) {
                throw new Error("broken");
            }
            /* c8 ignore stop */
        }
        accum.push(form);
    }
    catch (error) { }
    return accum;
}, []);
/**
 *  Many classes use file-scoped values to guard the constructor,
 *  making it effectively private. This facilitates that pattern
 *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,
 *  throwing if not, indicating the %%className%% if provided.
 */
function assertPrivate(givenGuard, guard, className) {
    if (className == null) {
        className = "";
    }
    if (givenGuard !== guard) {
        let method = className, operation = "new";
        if (className) {
            method += ".";
            operation += " " + className;
        }
        assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
            operation
        });
    }
}

/**
 *  Some data helpers.
 *
 *
 *  @_subsection api/utils:Data Helpers  [about-data]
 */
function _getBytes(value, name, copy) {
    if (value instanceof Uint8Array) {
        if (copy) {
            return new Uint8Array(value);
        }
        return value;
    }
    if (typeof (value) === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
        const result = new Uint8Array((value.length - 2) / 2);
        let offset = 2;
        for (let i = 0; i < result.length; i++) {
            result[i] = parseInt(value.substring(offset, offset + 2), 16);
            offset += 2;
        }
        return result;
    }
    assertArgument(false, "invalid BytesLike value", name || "value", value);
}
/**
 *  Get a typed Uint8Array for %%value%%. If already a Uint8Array
 *  the original %%value%% is returned; if a copy is required use
 *  [[getBytesCopy]].
 *
 *  @see: getBytesCopy
 */
function getBytes(value, name) {
    return _getBytes(value, name, false);
}
/**
 *  Get a typed Uint8Array for %%value%%, creating a copy if necessary
 *  to prevent any modifications of the returned value from being
 *  reflected elsewhere.
 *
 *  @see: getBytes
 */
function getBytesCopy(value, name) {
    return _getBytes(value, name, true);
}
/**
 *  Returns true if %%value%% is a valid [[HexString]].
 *
 *  If %%length%% is ``true`` or a //number//, it also checks that
 *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)
 *  bytes of data (e.g. ``0x1234`` is 2 bytes).
 */
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (typeof (length) === "number" && value.length !== 2 + 2 * length) {
        return false;
    }
    if (length === true && (value.length % 2) !== 0) {
        return false;
    }
    return true;
}
/**
 *  Returns true if %%value%% is a valid representation of arbitrary
 *  data (i.e. a valid [[DataHexString]] or a Uint8Array).
 */
function isBytesLike(value) {
    return (isHexString(value, true) || (value instanceof Uint8Array));
}
const HexCharacters = "0123456789abcdef";
/**
 *  Returns a [[DataHexString]] representation of %%data%%.
 */
function hexlify(data) {
    const bytes = getBytes(data);
    let result = "0x";
    for (let i = 0; i < bytes.length; i++) {
        const v = bytes[i];
        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }
    return result;
}
/**
 *  Returns a [[DataHexString]] by concatenating all values
 *  within %%data%%.
 */
function concat(datas) {
    return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
/**
 *  Returns the length of %%data%%, in bytes.
 */
function dataLength(data) {
    if (isHexString(data, true)) {
        return (data.length - 2) / 2;
    }
    return getBytes(data).length;
}
/**
 *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%
 *  offset to the %%end%% offset.
 *
 *  By default %%start%% is 0 and %%end%% is the length of %%data%%.
 */
function dataSlice(data, start, end) {
    const bytes = getBytes(data);
    if (end != null && end > bytes.length) {
        assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
            buffer: bytes, length: bytes.length, offset: end
        });
    }
    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));
}
function zeroPad(data, length, left) {
    const bytes = getBytes(data);
    assert(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
        buffer: new Uint8Array(bytes),
        length: length,
        offset: length + 1
    });
    const result = new Uint8Array(length);
    result.fill(0);
    if (left) {
        result.set(bytes, length - bytes.length);
    }
    else {
        result.set(bytes, 0);
    }
    return hexlify(result);
}
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **left**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **values** are in Solidity
 *  (e.g. ``uint128``).
 */
function zeroPadValue(data, length) {
    return zeroPad(data, length, true);
}
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **right**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **bytes** are in Solidity
 *  (e.g. ``bytes16``).
 */
function zeroPadBytes(data, length) {
    return zeroPad(data, length, false);
}

/**
 *  Some mathematic operations.
 *
 *  @_subsection: api/utils:Math Helpers  [about-maths]
 */
const BN_0$9 = BigInt(0);
const BN_1$4 = BigInt(1);
//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;
// IEEE 754 support 53-bits of mantissa
const maxValue = 0x1fffffffffffff;
/**
 *  Convert %%value%% from a twos-compliment representation of %%width%%
 *  bits to its value.
 *
 *  If the highest bit is ``1``, the result will be negative.
 */
function fromTwos(_value, _width) {
    const value = getUint(_value, "value");
    const width = BigInt(getNumber(_width, "width"));
    assert((value >> width) === BN_0$9, "overflow", "NUMERIC_FAULT", {
        operation: "fromTwos", fault: "overflow", value: _value
    });
    // Top bit set; treat as a negative value
    if (value >> (width - BN_1$4)) {
        const mask = (BN_1$4 << width) - BN_1$4;
        return -(((~value) & mask) + BN_1$4);
    }
    return value;
}
/**
 *  Convert %%value%% to a twos-compliment representation of
 *  %%width%% bits.
 *
 *  The result will always be positive.
 */
function toTwos(_value, _width) {
    let value = getBigInt(_value, "value");
    const width = BigInt(getNumber(_width, "width"));
    const limit = (BN_1$4 << (width - BN_1$4));
    if (value < BN_0$9) {
        value = -value;
        assert(value <= limit, "too low", "NUMERIC_FAULT", {
            operation: "toTwos", fault: "overflow", value: _value
        });
        const mask = (BN_1$4 << width) - BN_1$4;
        return ((~value) & mask) + BN_1$4;
    }
    else {
        assert(value < limit, "too high", "NUMERIC_FAULT", {
            operation: "toTwos", fault: "overflow", value: _value
        });
    }
    return value;
}
/**
 *  Mask %%value%% with a bitmask of %%bits%% ones.
 */
function mask(_value, _bits) {
    const value = getUint(_value, "value");
    const bits = BigInt(getNumber(_bits, "bits"));
    return value & ((BN_1$4 << bits) - BN_1$4);
}
/**
 *  Gets a BigInt from %%value%%. If it is an invalid value for
 *  a BigInt, then an ArgumentError will be thrown for %%name%%.
 */
function getBigInt(value, name) {
    switch (typeof (value)) {
        case "bigint": return value;
        case "number":
            assertArgument(Number.isInteger(value), "underflow", name || "value", value);
            assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return BigInt(value);
        case "string":
            try {
                if (value === "") {
                    throw new Error("empty string");
                }
                if (value[0] === "-" && value[1] !== "-") {
                    return -BigInt(value.substring(1));
                }
                return BigInt(value);
            }
            catch (e) {
                assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
            }
    }
    assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
/**
 *  Returns %%value%% as a bigint, validating it is valid as a bigint
 *  value and that it is positive.
 */
function getUint(value, name) {
    const result = getBigInt(value, name);
    assert(result >= BN_0$9, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow", operation: "getUint", value
    });
    return result;
}
const Nibbles = "0123456789abcdef";
/*
 * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it
 * is treated as Big Endian data.
 */
function toBigInt(value) {
    if (value instanceof Uint8Array) {
        let result = "0x0";
        for (const v of value) {
            result += Nibbles[v >> 4];
            result += Nibbles[v & 0x0f];
        }
        return BigInt(result);
    }
    return getBigInt(value);
}
/**
 *  Gets a //number// from %%value%%. If it is an invalid value for
 *  a //number//, then an ArgumentError will be thrown for %%name%%.
 */
function getNumber(value, name) {
    switch (typeof (value)) {
        case "bigint":
            assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return Number(value);
        case "number":
            assertArgument(Number.isInteger(value), "underflow", name || "value", value);
            assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return value;
        case "string":
            try {
                if (value === "") {
                    throw new Error("empty string");
                }
                return getNumber(BigInt(value), name);
            }
            catch (e) {
                assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
            }
    }
    assertArgument(false, "invalid numeric value", name || "value", value);
}
/**
 *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it
 *  is treated as Big Endian data. Throws if the value is not safe.
 */
function toNumber(value) {
    return getNumber(toBigInt(value));
}
/**
 *  Converts %%value%% to a Big Endian hexstring, optionally padded to
 *  %%width%% bytes.
 */
function toBeHex(_value, _width) {
    const value = getUint(_value, "value");
    let result = value.toString(16);
    if (_width == null) {
        // Ensure the value is of even length
        if (result.length % 2) {
            result = "0" + result;
        }
    }
    else {
        const width = getNumber(_width, "width");
        assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
            operation: "toBeHex",
            fault: "overflow",
            value: _value
        });
        // Pad the value to the required width
        while (result.length < (width * 2)) {
            result = "0" + result;
        }
    }
    return "0x" + result;
}
/**
 *  Converts %%value%% to a Big Endian Uint8Array.
 */
function toBeArray(_value) {
    const value = getUint(_value, "value");
    if (value === BN_0$9) {
        return new Uint8Array([]);
    }
    let hex = value.toString(16);
    if (hex.length % 2) {
        hex = "0" + hex;
    }
    const result = new Uint8Array(hex.length / 2);
    for (let i = 0; i < result.length; i++) {
        const offset = i * 2;
        result[i] = parseInt(hex.substring(offset, offset + 2), 16);
    }
    return result;
}
/**
 *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.
 *
 *  A //Quantity// does not have and leading 0 values unless the value is
 *  the literal value `0x0`. This is most commonly used for JSSON-RPC
 *  numeric values.
 */
function toQuantity(value) {
    let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
    while (result.startsWith("0")) {
        result = result.substring(1);
    }
    if (result === "") {
        result = "0";
    }
    return "0x" + result;
}

/**
 *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value
 *  to be encoded as a compact string using a radix of 58 using only
 *  alpha-numeric characters. Confusingly similar characters are omitted
 *  (i.e. ``"l0O"``).
 *
 *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,
 *  since any zero-bytes on the left would get removed. To mitigate this
 *  issue most schemes that use Base58 choose specific high-order values
 *  to ensure non-zero prefixes.
 *
 *  @_subsection: api/utils:Base58 Encoding [about-base58]
 */
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const BN_58 = BigInt(58);
/**
 *  Encode %%value%% as a Base58-encoded string.
 */
function encodeBase58(_value) {
    const bytes = getBytes(_value);
    let value = toBigInt(bytes);
    let result = "";
    while (value) {
        result = Alphabet[Number(value % BN_58)] + result;
        value /= BN_58;
    }
    // Account for leading padding zeros
    for (let i = 0; i < bytes.length; i++) {
        if (bytes[i]) {
            break;
        }
        result = Alphabet[0] + result;
    }
    return result;
}

/**
 *  [Base64 encoding](link-wiki-base64) using 6-bit words to encode
 *  arbitrary bytes into a string using 65 printable symbols, the
 *  upper-case and lower-case alphabet, the digits ``0`` through ``9``,
 *  ``"+"`` and ``"/"`` with the ``"="`` used for padding.
 *
 *  @_subsection: api/utils:Base64 Encoding  [about-base64]
 */
/**
 *  Decodes the base-64 encoded %%value%%.
 *
 *  @example:
 *    // The decoded value is always binary data...
 *    result = decodeBase64("SGVsbG8gV29ybGQhIQ==")
 *    //_result:
 *
 *    // ...use toUtf8String to convert it to a string.
 *    toUtf8String(result)
 *    //_result:
 *
 *    // Decoding binary data
 *    decodeBase64("EjQ=")
 *    //_result:
 */
function decodeBase64(value) {
    return getBytesCopy(Buffer.from(value, "base64"));
}
/**
 *  Encodes %%data%% as a base-64 encoded string.
 *
 *  @example:
 *    // Encoding binary data as a hexstring
 *    encodeBase64("0x1234")
 *    //_result:
 *
 *    // Encoding binary data as a Uint8Array
 *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))
 *    //_result:
 *
 *    // The input MUST be data...
 *    encodeBase64("Hello World!!")
 *    //_error:
 *
 *    // ...use toUtf8Bytes for this.
 *    encodeBase64(toUtf8Bytes("Hello World!!"))
 *    //_result:
 */
function encodeBase64(data) {
    return Buffer.from(getBytes(data)).toString("base64");
}

/**
 *  Events allow for applications to use the observer pattern, which
 *  allows subscribing and publishing events, outside the normal
 *  execution paths.
 *
 *  @_section api/utils/events:Events  [about-events]
 */
/**
 *  When an [[EventEmitterable]] triggers a [[Listener]], the
 *  callback always ahas one additional argument passed, which is
 *  an **EventPayload**.
 */
class EventPayload {
    /**
     *  The event filter.
     */
    filter;
    /**
     *  The **EventEmitterable**.
     */
    emitter;
    #listener;
    /**
     *  Create a new **EventPayload** for %%emitter%% with
     *  the %%listener%% and for %%filter%%.
     */
    constructor(emitter, listener, filter) {
        this.#listener = listener;
        defineProperties(this, { emitter, filter });
    }
    /**
     *  Unregister the triggered listener for future events.
     */
    async removeListener() {
        if (this.#listener == null) {
            return;
        }
        await this.emitter.off(this.filter, this.#listener);
    }
}

/**
 *  Using strings in Ethereum (or any security-basd system) requires
 *  additional care. These utilities attempt to mitigate some of the
 *  safety issues as well as provide the ability to recover and analyse
 *  strings.
 *
 *  @_subsection api/utils:Strings and UTF-8  [about-strings]
 */
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === "OVERRUN") {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === "OVERLONG") {
        assertArgument(typeof (badCodepoint) === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes);
}
/**
 *  A handful of popular, built-in UTF-8 error handling strategies.
 *
 *  **``"error"``** - throws on ANY illegal UTF-8 sequence or
 *  non-canonical (overlong) codepoints (this is the default)
 *
 *  **``"ignore"``** - silently drops any illegal UTF-8 sequence
 *  and accepts non-canonical (overlong) codepoints
 *
 *  **``"replace"``** - replace any illegal UTF-8 sequence with the
 *  UTF-8 replacement character (i.e. ``"\\ufffd"``) and accepts
 *  non-canonical (overlong) codepoints
 *
 *  @returns: Record<"error" | "ignore" | "replace", Utf8ErrorFunc>
 */
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(_bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    const bytes = getBytes(_bytes, "bytes");
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
            }
            else {
                i += onError("BAD_PREFIX", i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError("OVERRUN", i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError("MISSING_CONTINUE", i, bytes, result);
                res = null;
                break;
            }
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
/**
 *  Returns the UTF-8 byte representation of %%str%%.
 *
 *  If %%form%% is specified, the string is normalized.
 */
function toUtf8Bytes(str, form) {
    assertArgument(typeof (str) === "string", "invalid string value", "str", str);
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            assertArgument(i < str.length && ((c2 & 0xfc00) === 0xdc00), "invalid surrogate pair", "str", str);
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return new Uint8Array(result);
}
//export 
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
/**
 *  Returns the string represented by the UTF-8 data %%bytes%%.
 *
 *  When %%onError%% function is specified, it is called on UTF-8
 *  errors allowing recovery using the [[Utf8ErrorFunc]] API.
 *  (default: [error](Utf8ErrorFuncs))
 */
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}

/**
 *  @_ignore:
 */
function createGetUrl(options) {
    async function getUrl(req, signal) {
        // Make sure we weren't cancelled before sending
        assert(signal == null || !signal.cancelled, "request cancelled before sending", "CANCELLED");
        const protocol = req.url.split(":")[0].toLowerCase();
        assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
            info: { protocol },
            operation: "request"
        });
        assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
            operation: "request"
        });
        const method = req.method;
        const headers = Object.assign({}, req.headers);
        const reqOptions = { method, headers };
        if (options) {
            if (options.agent) {
                reqOptions.agent = options.agent;
            }
        }
        // Create a Node-specific AbortController, if available
        let abort = null;
        try {
            abort = new AbortController();
            reqOptions.abort = abort.signal;
        }
        catch (e) {
            console.log(e);
        }
        const request = ((protocol === "http") ? http : https).request(req.url, reqOptions);
        request.setTimeout(req.timeout);
        const body = req.body;
        if (body) {
            request.write(Buffer.from(body));
        }
        request.end();
        return new Promise((resolve, reject) => {
            if (signal) {
                signal.addListener(() => {
                    if (abort) {
                        abort.abort();
                    }
                    reject(makeError("request cancelled", "CANCELLED"));
                });
            }
            request.on("timeout", () => {
                reject(makeError("request timeout", "TIMEOUT"));
            });
            request.once("response", (resp) => {
                const statusCode = resp.statusCode || 0;
                const statusMessage = resp.statusMessage || "";
                const headers = Object.keys(resp.headers || {}).reduce((accum, name) => {
                    let value = resp.headers[name] || "";
                    if (Array.isArray(value)) {
                        value = value.join(", ");
                    }
                    accum[name] = value;
                    return accum;
                }, {});
                let body = null;
                //resp.setEncoding("utf8");
                resp.on("data", (chunk) => {
                    if (signal) {
                        try {
                            signal.checkSignal();
                        }
                        catch (error) {
                            return reject(error);
                        }
                    }
                    if (body == null) {
                        body = chunk;
                    }
                    else {
                        const newBody = new Uint8Array(body.length + chunk.length);
                        newBody.set(body, 0);
                        newBody.set(chunk, body.length);
                        body = newBody;
                    }
                });
                resp.on("end", () => {
                    try {
                        if (headers["content-encoding"] === "gzip" && body) {
                            body = getBytes(gunzipSync(body));
                        }
                        resolve({ statusCode, statusMessage, headers, body });
                    }
                    catch (error) {
                        reject(makeError("bad response data", "SERVER_ERROR", {
                            request: req, info: { response: resp, error }
                        }));
                    }
                });
                resp.on("error", (error) => {
                    //@TODO: Should this just return nornal response with a server error?
                    error.response = { statusCode, statusMessage, headers, body };
                    reject(error);
                });
            });
            request.on("error", (error) => { reject(error); });
        });
    }
    return getUrl;
}

/**
 *  Fetching content from the web is environment-specific, so Ethers
 *  provides an abstraction that each environment can implement to provide
 *  this service.
 *
 *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to
 *  create a request object, register event listeners and process data
 *  and populate the [[FetchResponse]].
 *
 *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting
 *  ``Promise`` is waited on to retrieve the payload.
 *
 *  The [[FetchRequest]] is responsible for handling many common situations,
 *  such as redirects, server throttling, authentication, etc.
 *
 *  It also handles common gateways, such as IPFS and data URIs.
 *
 *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]
 */
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
// The global FetchGetUrlFunc implementation.
let defaultGetUrlFunc = createGetUrl();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs:/\/(ipfs/)?(.*)$", "i");
// If locked, new Gateways cannot be added
let locked$5 = false;
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs
async function dataGatewayFunc(url, signal) {
    try {
        const match = url.match(reData);
        if (!match) {
            throw new Error("invalid data");
        }
        return new FetchResponse(200, "OK", {
            "content-type": (match[1] || "text/plain"),
        }, (match[2] ? decodeBase64(match[3]) : unpercent(match[3])));
    }
    catch (error) {
        return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
    }
}
/**
 *  Returns a [[FetchGatewayFunc]] for fetching content from a standard
 *  IPFS gateway hosted at %%baseUrl%%.
 */
function getIpfsGatewayFunc(baseUrl) {
    async function gatewayIpfs(url, signal) {
        try {
            const match = url.match(reIpfs);
            if (!match) {
                throw new Error("invalid link");
            }
            return new FetchRequest(`${baseUrl}${match[2]}`);
        }
        catch (error) {
            return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
        }
    }
    return gatewayIpfs;
}
const Gateways = {
    "data": dataGatewayFunc,
    "ipfs": getIpfsGatewayFunc("https:/\/gateway.ipfs.io/ipfs/")
};
const fetchSignals = new WeakMap();
/**
 *  @_ignore
 */
class FetchCancelSignal {
    #listeners;
    #cancelled;
    constructor(request) {
        this.#listeners = [];
        this.#cancelled = false;
        fetchSignals.set(request, () => {
            if (this.#cancelled) {
                return;
            }
            this.#cancelled = true;
            for (const listener of this.#listeners) {
                setTimeout(() => { listener(); }, 0);
            }
            this.#listeners = [];
        });
    }
    addListener(listener) {
        assert(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
            operation: "fetchCancelSignal.addCancelListener"
        });
        this.#listeners.push(listener);
    }
    get cancelled() { return this.#cancelled; }
    checkSignal() {
        assert(!this.cancelled, "cancelled", "CANCELLED", {});
    }
}
// Check the signal, throwing if it is cancelled
function checkSignal(signal) {
    if (signal == null) {
        throw new Error("missing signal; should not happen");
    }
    signal.checkSignal();
    return signal;
}
/**
 *  Represents a request for a resource using a URI.
 *
 *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,
 *  and ``IPFS:``.
 *
 *  Additional schemes can be added globally using [[registerGateway]].
 *
 *  @example:
 *    req = new FetchRequest("https://www.ricmoo.com")
 *    resp = await req.send()
 *    resp.body.length
 *    //_result:
 */
class FetchRequest {
    #allowInsecure;
    #gzip;
    #headers;
    #method;
    #timeout;
    #url;
    #body;
    #bodyType;
    #creds;
    // Hooks
    #preflight;
    #process;
    #retry;
    #signal;
    #throttle;
    #getUrlFunc;
    /**
     *  The fetch URL to request.
     */
    get url() { return this.#url; }
    set url(url) {
        this.#url = String(url);
    }
    /**
     *  The fetch body, if any, to send as the request body. //(default: null)//
     *
     *  When setting a body, the intrinsic ``Content-Type`` is automatically
     *  set and will be used if **not overridden** by setting a custom
     *  header.
     *
     *  If %%body%% is null, the body is cleared (along with the
     *  intrinsic ``Content-Type``).
     *
     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
     *  ``text/plain``.
     *
     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
     *  ``application/octet-stream``.
     *
     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
     *  set to ``application/json``.
     */
    get body() {
        if (this.#body == null) {
            return null;
        }
        return new Uint8Array(this.#body);
    }
    set body(body) {
        if (body == null) {
            this.#body = undefined;
            this.#bodyType = undefined;
        }
        else if (typeof (body) === "string") {
            this.#body = toUtf8Bytes(body);
            this.#bodyType = "text/plain";
        }
        else if (body instanceof Uint8Array) {
            this.#body = body;
            this.#bodyType = "application/octet-stream";
        }
        else if (typeof (body) === "object") {
            this.#body = toUtf8Bytes(JSON.stringify(body));
            this.#bodyType = "application/json";
        }
        else {
            throw new Error("invalid body");
        }
    }
    /**
     *  Returns true if the request has a body.
     */
    hasBody() {
        return (this.#body != null);
    }
    /**
     *  The HTTP method to use when requesting the URI. If no method
     *  has been explicitly set, then ``GET`` is used if the body is
     *  null and ``POST`` otherwise.
     */
    get method() {
        if (this.#method) {
            return this.#method;
        }
        if (this.hasBody()) {
            return "POST";
        }
        return "GET";
    }
    set method(method) {
        if (method == null) {
            method = "";
        }
        this.#method = String(method).toUpperCase();
    }
    /**
     *  The headers that will be used when requesting the URI. All
     *  keys are lower-case.
     *
     *  This object is a copy, so any changes will **NOT** be reflected
     *  in the ``FetchRequest``.
     *
     *  To set a header entry, use the ``setHeader`` method.
     */
    get headers() {
        const headers = Object.assign({}, this.#headers);
        if (this.#creds) {
            headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;
        }
        if (this.allowGzip) {
            headers["accept-encoding"] = "gzip";
        }
        if (headers["content-type"] == null && this.#bodyType) {
            headers["content-type"] = this.#bodyType;
        }
        if (this.body) {
            headers["content-length"] = String(this.body.length);
        }
        return headers;
    }
    /**
     *  Get the header for %%key%%, ignoring case.
     */
    getHeader(key) {
        return this.headers[key.toLowerCase()];
    }
    /**
     *  Set the header for %%key%% to %%value%%. All values are coerced
     *  to a string.
     */
    setHeader(key, value) {
        this.#headers[String(key).toLowerCase()] = String(value);
    }
    /**
     *  Clear all headers, resetting all intrinsic headers.
     */
    clearHeaders() {
        this.#headers = {};
    }
    [Symbol.iterator]() {
        const headers = this.headers;
        const keys = Object.keys(headers);
        let index = 0;
        return {
            next: () => {
                if (index < keys.length) {
                    const key = keys[index++];
                    return {
                        value: [key, headers[key]], done: false
                    };
                }
                return { value: undefined, done: true };
            }
        };
    }
    /**
     *  The value that will be sent for the ``Authorization`` header.
     *
     *  To set the credentials, use the ``setCredentials`` method.
     */
    get credentials() {
        return this.#creds || null;
    }
    /**
     *  Sets an ``Authorization`` for %%username%% with %%password%%.
     */
    setCredentials(username, password) {
        assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
        this.#creds = `${username}:${password}`;
    }
    /**
     *  Enable and request gzip-encoded responses. The response will
     *  automatically be decompressed. //(default: true)//
     */
    get allowGzip() {
        return this.#gzip;
    }
    set allowGzip(value) {
        this.#gzip = !!value;
    }
    /**
     *  Allow ``Authentication`` credentials to be sent over insecure
     *  channels. //(default: false)//
     */
    get allowInsecureAuthentication() {
        return !!this.#allowInsecure;
    }
    set allowInsecureAuthentication(value) {
        this.#allowInsecure = !!value;
    }
    /**
     *  The timeout (in milliseconds) to wait for a complete response.
     *  //(default: 5 minutes)//
     */
    get timeout() { return this.#timeout; }
    set timeout(timeout) {
        assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
        this.#timeout = timeout;
    }
    /**
     *  This function is called prior to each request, for example
     *  during a redirection or retry in case of server throttling.
     *
     *  This offers an opportunity to populate headers or update
     *  content before sending a request.
     */
    get preflightFunc() {
        return this.#preflight || null;
    }
    set preflightFunc(preflight) {
        this.#preflight = preflight;
    }
    /**
     *  This function is called after each response, offering an
     *  opportunity to provide client-level throttling or updating
     *  response data.
     *
     *  Any error thrown in this causes the ``send()`` to throw.
     *
     *  To schedule a retry attempt (assuming the maximum retry limit
     *  has not been reached), use [[response.throwThrottleError]].
     */
    get processFunc() {
        return this.#process || null;
    }
    set processFunc(process) {
        this.#process = process;
    }
    /**
     *  This function is called on each retry attempt.
     */
    get retryFunc() {
        return this.#retry || null;
    }
    set retryFunc(retry) {
        this.#retry = retry;
    }
    /**
     *  This function is called to fetch content from HTTP and
     *  HTTPS URLs and is platform specific (e.g. nodejs vs
     *  browsers).
     *
     *  This is by default the currently registered global getUrl
     *  function, which can be changed using [[registerGetUrl]].
     *  If this has been set, setting is to ``null`` will cause
     *  this FetchRequest (and any future clones) to revert back to
     *  using the currently registered global getUrl function.
     *
     *  Setting this is generally not necessary, but may be useful
     *  for developers that wish to intercept requests or to
     *  configurege a proxy or other agent.
     */
    get getUrlFunc() {
        return this.#getUrlFunc || defaultGetUrlFunc;
    }
    set getUrlFunc(value) {
        this.#getUrlFunc = value;
    }
    /**
     *  Create a new FetchRequest instance with default values.
     *
     *  Once created, each property may be set before issuing a
     *  ``.send()`` to make the request.
     */
    constructor(url) {
        this.#url = String(url);
        this.#allowInsecure = false;
        this.#gzip = true;
        this.#headers = {};
        this.#method = "";
        this.#timeout = 300000;
        this.#throttle = {
            slotInterval: SLOT_INTERVAL,
            maxAttempts: MAX_ATTEMPTS
        };
        this.#getUrlFunc = null;
    }
    toString() {
        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
    }
    /**
     *  Update the throttle parameters used to determine maximum
     *  attempts and exponential-backoff properties.
     */
    setThrottleParams(params) {
        if (params.slotInterval != null) {
            this.#throttle.slotInterval = params.slotInterval;
        }
        if (params.maxAttempts != null) {
            this.#throttle.maxAttempts = params.maxAttempts;
        }
    }
    async #send(attempt, expires, delay, _request, _response) {
        if (attempt >= this.#throttle.maxAttempts) {
            return _response.makeServerError("exceeded maximum retry limit");
        }
        assert(getTime$1() <= expires, "timeout", "TIMEOUT", {
            operation: "request.send", reason: "timeout", request: _request
        });
        if (delay > 0) {
            await wait(delay);
        }
        let req = this.clone();
        const scheme = (req.url.split(":")[0] || "").toLowerCase();
        // Process any Gateways
        if (scheme in Gateways) {
            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
            if (result instanceof FetchResponse) {
                let response = result;
                if (this.processFunc) {
                    checkSignal(_request.#signal);
                    try {
                        response = await this.processFunc(req, response);
                    }
                    catch (error) {
                        // Something went wrong during processing; throw a 5xx server error
                        if (error.throttle == null || typeof (error.stall) !== "number") {
                            response.makeServerError("error in post-processing function", error).assertOk();
                        }
                        // Ignore throttling
                    }
                }
                return response;
            }
            req = result;
        }
        // We have a preflight function; update the request
        if (this.preflightFunc) {
            req = await this.preflightFunc(req);
        }
        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
        if (response.statusCode === 301 || response.statusCode === 302) {
            // Redirect
            try {
                const location = response.headers.location || "";
                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
            }
            catch (error) { }
            // Things won't get any better on another attempt; abort
            return response;
        }
        else if (response.statusCode === 429) {
            // Throttle
            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {
                const retryAfter = response.headers["retry-after"];
                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
                if (typeof (retryAfter) === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                    delay = parseInt(retryAfter);
                }
                return req.clone().#send(attempt + 1, expires, delay, _request, response);
            }
        }
        if (this.processFunc) {
            checkSignal(_request.#signal);
            try {
                response = await this.processFunc(req, response);
            }
            catch (error) {
                // Something went wrong during processing; throw a 5xx server error
                if (error.throttle == null || typeof (error.stall) !== "number") {
                    response.makeServerError("error in post-processing function", error).assertOk();
                }
                // Throttle
                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
                if (error.stall >= 0) {
                    delay = error.stall;
                }
                return req.clone().#send(attempt + 1, expires, delay, _request, response);
            }
        }
        return response;
    }
    /**
     *  Resolves to the response by sending the request.
     */
    send() {
        assert(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
        this.#signal = new FetchCancelSignal(this);
        return this.#send(0, getTime$1() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
    }
    /**
     *  Cancels the inflight response, causing a ``CANCELLED``
     *  error to be rejected from the [[send]].
     */
    cancel() {
        assert(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
        const signal = fetchSignals.get(this);
        if (!signal) {
            throw new Error("missing signal; should not happen");
        }
        signal();
    }
    /**
     *  Returns a new [[FetchRequest]] that represents the redirection
     *  to %%location%%.
     */
    redirect(location) {
        // Redirection; for now we only support absolute locations
        const current = this.url.split(":")[0].toLowerCase();
        const target = location.split(":")[0].toLowerCase();
        // Don't allow redirecting:
        // - non-GET requests
        // - downgrading the security (e.g. https => http)
        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]
        assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
        });
        // Create a copy of this request, with a new URL
        const req = new FetchRequest(location);
        req.method = "GET";
        req.allowGzip = this.allowGzip;
        req.timeout = this.timeout;
        req.#headers = Object.assign({}, this.#headers);
        if (this.#body) {
            req.#body = new Uint8Array(this.#body);
        }
        req.#bodyType = this.#bodyType;
        // Do not forward credentials unless on the same domain; only absolute
        //req.allowInsecure = false;
        // paths are currently supported; may want a way to specify to forward?
        //setStore(req.#props, "creds", getStore(this.#pros, "creds"));
        return req;
    }
    /**
     *  Create a new copy of this request.
     */
    clone() {
        const clone = new FetchRequest(this.url);
        // Preserve "default method" (i.e. null)
        clone.#method = this.#method;
        // Preserve "default body" with type, copying the Uint8Array is present
        if (this.#body) {
            clone.#body = this.#body;
        }
        clone.#bodyType = this.#bodyType;
        // Preserve "default headers"
        clone.#headers = Object.assign({}, this.#headers);
        // Credentials is readonly, so we copy internally
        clone.#creds = this.#creds;
        if (this.allowGzip) {
            clone.allowGzip = true;
        }
        clone.timeout = this.timeout;
        if (this.allowInsecureAuthentication) {
            clone.allowInsecureAuthentication = true;
        }
        clone.#preflight = this.#preflight;
        clone.#process = this.#process;
        clone.#retry = this.#retry;
        clone.#throttle = Object.assign({}, this.#throttle);
        clone.#getUrlFunc = this.#getUrlFunc;
        return clone;
    }
    /**
     *  Locks all static configuration for gateways and FetchGetUrlFunc
     *  registration.
     */
    static lockConfig() {
        locked$5 = true;
    }
    /**
     *  Get the current Gateway function for %%scheme%%.
     */
    static getGateway(scheme) {
        return Gateways[scheme.toLowerCase()] || null;
    }
    /**
     *  Use the %%func%% when fetching URIs using %%scheme%%.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
    static registerGateway(scheme, func) {
        scheme = scheme.toLowerCase();
        if (scheme === "http" || scheme === "https") {
            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
        }
        if (locked$5) {
            throw new Error("gateways locked");
        }
        Gateways[scheme] = func;
    }
    /**
     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
    static registerGetUrl(getUrl) {
        if (locked$5) {
            throw new Error("gateways locked");
        }
        defaultGetUrlFunc = getUrl;
    }
    /**
     *  Creates a getUrl function that fetches content from HTTP and
     *  HTTPS URLs.
     *
     *  The available %%options%% are dependent on the platform
     *  implementation of the default getUrl function.
     *
     *  This is not generally something that is needed, but is useful
     *  when trying to customize simple behaviour when fetching HTTP
     *  content.
     */
    static createGetUrlFunc(options) {
        return createGetUrl(options);
    }
    /**
     *  Creates a function that can "fetch" data URIs.
     *
     *  Note that this is automatically done internally to support
     *  data URIs, so it is not necessary to register it.
     *
     *  This is not generally something that is needed, but may
     *  be useful in a wrapper to perfom custom data URI functionality.
     */
    static createDataGateway() {
        return dataGatewayFunc;
    }
    /**
     *  Creates a function that will fetch IPFS (unvalidated) from
     *  a custom gateway baseUrl.
     *
     *  The default IPFS gateway used internally is
     *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
     */
    static createIpfsGatewayFunc(baseUrl) {
        return getIpfsGatewayFunc(baseUrl);
    }
}
/**
 *  The response for a FetchRequest.
 */
class FetchResponse {
    #statusCode;
    #statusMessage;
    #headers;
    #body;
    #request;
    #error;
    toString() {
        return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : "null"}>`;
    }
    /**
     *  The response status code.
     */
    get statusCode() { return this.#statusCode; }
    /**
     *  The response status message.
     */
    get statusMessage() { return this.#statusMessage; }
    /**
     *  The response headers. All keys are lower-case.
     */
    get headers() { return Object.assign({}, this.#headers); }
    /**
     *  The response body, or ``null`` if there was no body.
     */
    get body() {
        return (this.#body == null) ? null : new Uint8Array(this.#body);
    }
    /**
     *  The response body as a UTF-8 encoded string, or the empty
     *  string (i.e. ``""``) if there was no body.
     *
     *  An error is thrown if the body is invalid UTF-8 data.
     */
    get bodyText() {
        try {
            return (this.#body == null) ? "" : toUtf8String(this.#body);
        }
        catch (error) {
            assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
                operation: "bodyText", info: { response: this }
            });
        }
    }
    /**
     *  The response body, decoded as JSON.
     *
     *  An error is thrown if the body is invalid JSON-encoded data
     *  or if there was no body.
     */
    get bodyJson() {
        try {
            return JSON.parse(this.bodyText);
        }
        catch (error) {
            assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
                operation: "bodyJson", info: { response: this }
            });
        }
    }
    [Symbol.iterator]() {
        const headers = this.headers;
        const keys = Object.keys(headers);
        let index = 0;
        return {
            next: () => {
                if (index < keys.length) {
                    const key = keys[index++];
                    return {
                        value: [key, headers[key]], done: false
                    };
                }
                return { value: undefined, done: true };
            }
        };
    }
    constructor(statusCode, statusMessage, headers, body, request) {
        this.#statusCode = statusCode;
        this.#statusMessage = statusMessage;
        this.#headers = Object.keys(headers).reduce((accum, k) => {
            accum[k.toLowerCase()] = String(headers[k]);
            return accum;
        }, {});
        this.#body = ((body == null) ? null : new Uint8Array(body));
        this.#request = (request || null);
        this.#error = { message: "" };
    }
    /**
     *  Return a Response with matching headers and body, but with
     *  an error status code (i.e. 599) and %%message%% with an
     *  optional %%error%%.
     */
    makeServerError(message, error) {
        let statusMessage;
        if (!message) {
            message = `${this.statusCode} ${this.statusMessage}`;
            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
        }
        else {
            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
        }
        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);
        response.#error = { message, error };
        return response;
    }
    /**
     *  If called within a [request.processFunc](FetchRequest-processFunc)
     *  call, causes the request to retry as if throttled for %%stall%%
     *  milliseconds.
     */
    throwThrottleError(message, stall) {
        if (stall == null) {
            stall = -1;
        }
        else {
            assertArgument(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
        }
        const error = new Error(message || "throttling requests");
        defineProperties(error, { stall, throttle: true });
        throw error;
    }
    /**
     *  Get the header value for %%key%%, ignoring case.
     */
    getHeader(key) {
        return this.headers[key.toLowerCase()];
    }
    /**
     *  Returns true if the response has a body.
     */
    hasBody() {
        return (this.#body != null);
    }
    /**
     *  The request made for this response.
     */
    get request() { return this.#request; }
    /**
     *  Returns true if this response was a success statusCode.
     */
    ok() {
        return (this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300);
    }
    /**
     *  Throws a ``SERVER_ERROR`` if this response is not ok.
     */
    assertOk() {
        if (this.ok()) {
            return;
        }
        let { message, error } = this.#error;
        if (message === "") {
            message = `server response ${this.statusCode} ${this.statusMessage}`;
        }
        let requestUrl = null;
        if (this.request) {
            requestUrl = this.request.url;
        }
        let responseBody = null;
        try {
            if (this.#body) {
                responseBody = toUtf8String(this.#body);
            }
        }
        catch (e) { }
        assert(false, message, "SERVER_ERROR", {
            request: (this.request || "unknown request"), response: this, error,
            info: {
                requestUrl, responseBody,
                responseStatus: `${this.statusCode} ${this.statusMessage}`
            }
        });
    }
}
function getTime$1() { return (new Date()).getTime(); }
function unpercent(value) {
    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
        return String.fromCharCode(parseInt(code, 16));
    }));
}
function wait(delay) {
    return new Promise((resolve) => setTimeout(resolve, delay));
}

/**
 *  The **FixedNumber** class permits using values with decimal places,
 *  using fixed-pont math.
 *
 *  Fixed-point math is still based on integers under-the-hood, but uses an
 *  internal offset to store fractional components below, and each operation
 *  corrects for this after each operation.
 *
 *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]
 */
const BN_N1 = BigInt(-1);
const BN_0$8 = BigInt(0);
const BN_1$3 = BigInt(1);
const BN_5 = BigInt(5);
const _guard$3 = {};
// Constant to pull zeros from for multipliers
let Zeros$1 = "0000";
while (Zeros$1.length < 80) {
    Zeros$1 += Zeros$1;
}
// Returns a string "1" followed by decimal "0"s
function getTens(decimals) {
    let result = Zeros$1;
    while (result.length < decimals) {
        result += result;
    }
    return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
    const width = BigInt(format.width);
    if (format.signed) {
        const limit = (BN_1$3 << (width - BN_1$3));
        assert(safeOp == null || (val >= -limit && val < limit), "overflow", "NUMERIC_FAULT", {
            operation: safeOp, fault: "overflow", value: val
        });
        if (val > BN_0$8) {
            val = fromTwos(mask(val, width), width);
        }
        else {
            val = -fromTwos(mask(-val, width), width);
        }
    }
    else {
        const limit = (BN_1$3 << width);
        assert(safeOp == null || (val >= 0 && val < limit), "overflow", "NUMERIC_FAULT", {
            operation: safeOp, fault: "overflow", value: val
        });
        val = (((val % limit) + limit) % limit) & (limit - BN_1$3);
    }
    return val;
}
function getFormat(value) {
    if (typeof (value) === "number") {
        value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof (value) === "string") {
        // Parse the format string
        if (value === "fixed") ;
        else if (value === "ufixed") {
            signed = false;
        }
        else {
            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            assertArgument(match, "invalid fixed format", "format", value);
            signed = (match[1] !== "u");
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
        }
    }
    else if (value) {
        // Extract the values from the object
        const v = value;
        const check = (key, type, defaultValue) => {
            if (v[key] == null) {
                return defaultValue;
            }
            assertArgument(typeof (v[key]) === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
            return v[key];
        };
        signed = check("signed", "boolean", signed);
        width = check("width", "number", width);
        decimals = check("decimals", "number", decimals);
    }
    assertArgument((width % 8) === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
    assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
    const name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    return { signed, width, decimals, name };
}
function toString$1(val, decimals) {
    let negative = "";
    if (val < BN_0$8) {
        negative = "-";
        val *= BN_N1;
    }
    let str = val.toString();
    // No decimal point for whole values
    if (decimals === 0) {
        return (negative + str);
    }
    // Pad out to the whole component (including a whole digit)
    while (str.length <= decimals) {
        str = Zeros$1 + str;
    }
    // Insert the decimal point
    const index = str.length - decimals;
    str = str.substring(0, index) + "." + str.substring(index);
    // Trim the whole component (leaving at least one 0)
    while (str[0] === "0" && str[1] !== ".") {
        str = str.substring(1);
    }
    // Trim the decimal component (leaving at least one 0)
    while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
        str = str.substring(0, str.length - 1);
    }
    return (negative + str);
}
/**
 *  A FixedNumber represents a value over its [[FixedFormat]]
 *  arithmetic field.
 *
 *  A FixedNumber can be used to perform math, losslessly, on
 *  values which have decmial places.
 *
 *  A FixedNumber has a fixed bit-width to store values in, and stores all
 *  values internally by multiplying the value by 10 raised to the power of
 *  %%decimals%%.
 *
 *  If operations are performed that cause a value to grow too high (close to
 *  positive infinity) or too low (close to negative infinity), the value
 *  is said to //overflow//.
 *
 *  For example, an 8-bit signed value, with 0 decimals may only be within
 *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become
 *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.
 *
 *  Many operation have a normal and //unsafe// variant. The normal variant
 *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//
 *  variant will silently allow overflow, corrupting its value value.
 *
 *  If operations are performed that cause a value to become too small
 *  (close to zero), the value loses precison and is said to //underflow//.
 *
 *  For example, a value with 1 decimal place may store a number as small
 *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit
 *  into 1 decimal place, so underflow occurs which means precision is lost
 *  and the value becomes ``0``.
 *
 *  Some operations have a normal and //signalling// variant. The normal
 *  variant will silently ignore underflow, while the //signalling// variant
 *  will thow a [[NumericFaultError]] on underflow.
 */
class FixedNumber {
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    format;
    #format;
    // The actual value (accounting for decimals)
    #val;
    // A base-10 value to multiple values by to maintain the magnitude
    #tens;
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    _value;
    // Use this when changing this file to get some typing info,
    // but then switch to any to mask the internal type
    //constructor(guard: any, value: bigint, format: _FixedFormat) {
    /**
     *  @private
     */
    constructor(guard, value, format) {
        assertPrivate(guard, _guard$3, "FixedNumber");
        this.#val = value;
        this.#format = format;
        const _value = toString$1(value, format.decimals);
        defineProperties(this, { format: format.name, _value });
        this.#tens = getTens(format.decimals);
    }
    /**
     *  If true, negative values are permitted, otherwise only
     *  positive values and zero are allowed.
     */
    get signed() { return this.#format.signed; }
    /**
     *  The number of bits available to store the value.
     */
    get width() { return this.#format.width; }
    /**
     *  The number of decimal places in the fixed-point arithment field.
     */
    get decimals() { return this.#format.decimals; }
    /**
     *  The value as an integer, based on the smallest unit the
     *  [[decimals]] allow.
     */
    get value() { return this.#val; }
    #checkFormat(other) {
        assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
    }
    #checkValue(val, safeOp) {
        /*
                const width = BigInt(this.width);
                if (this.signed) {
                    const limit = (BN_1 << (width - BN_1));
                    assert(safeOp == null || (val >= -limit  && val < limit), "overflow", "NUMERIC_FAULT", {
                        operation: <string>safeOp, fault: "overflow", value: val
                    });
        
                    if (val > BN_0) {
                        val = fromTwos(mask(val, width), width);
                    } else {
                        val = -fromTwos(mask(-val, width), width);
                    }
        
                } else {
                    const masked = mask(val, width);
                    assert(safeOp == null || (val >= 0 && val === masked), "overflow", "NUMERIC_FAULT", {
                        operation: <string>safeOp, fault: "overflow", value: val
                    });
                    val = masked;
                }
        */
        val = checkValue(val, this.#format, safeOp);
        return new FixedNumber(_guard$3, val, this.#format);
    }
    #add(o, safeOp) {
        this.#checkFormat(o);
        return this.#checkValue(this.#val + o.#val, safeOp);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%, ignoring overflow.
     */
    addUnsafe(other) { return this.#add(other); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
    add(other) { return this.#add(other, "add"); }
    #sub(o, safeOp) {
        this.#checkFormat(o);
        return this.#checkValue(this.#val - o.#val, safeOp);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%, ignoring overflow.
     */
    subUnsafe(other) { return this.#sub(other); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
    sub(other) { return this.#sub(other, "sub"); }
    #mul(o, safeOp) {
        this.#checkFormat(o);
        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%, ignoring overflow and underflow (precision loss).
     */
    mulUnsafe(other) { return this.#mul(other); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
    mul(other) { return this.#mul(other, "mul"); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs or if underflow (precision loss) occurs.
     */
    mulSignal(other) {
        this.#checkFormat(other);
        const value = this.#val * other.#val;
        assert((value % this.#tens) === BN_0$8, "precision lost during signalling mul", "NUMERIC_FAULT", {
            operation: "mulSignal", fault: "underflow", value: this
        });
        return this.#checkValue(value / this.#tens, "mulSignal");
    }
    #div(o, safeOp) {
        assert(o.#val !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
            operation: "div", fault: "divide-by-zero", value: this
        });
        this.#checkFormat(o);
        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
    divUnsafe(other) { return this.#div(other); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
    div(other) { return this.#div(other, "div"); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
     *  (precision loss) occurs.
     */
    divSignal(other) {
        assert(other.#val !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
            operation: "div", fault: "divide-by-zero", value: this
        });
        this.#checkFormat(other);
        const value = (this.#val * this.#tens);
        assert((value % other.#val) === BN_0$8, "precision lost during signalling div", "NUMERIC_FAULT", {
            operation: "divSignal", fault: "underflow", value: this
        });
        return this.#checkValue(value / other.#val, "divSignal");
    }
    /**
     *  Returns a comparison result between %%this%% and %%other%%.
     *
     *  This is suitable for use in sorting, where ``-1`` implies %%this%%
     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
     *  both are equal.
     */
    cmp(other) {
        let a = this.value, b = other.value;
        // Coerce a and b to the same magnitude
        const delta = this.decimals - other.decimals;
        if (delta > 0) {
            b *= getTens(delta);
        }
        else if (delta < 0) {
            a *= getTens(-delta);
        }
        // Comnpare
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    }
    /**
     *  Returns true if %%other%% is equal to %%this%%.
     */
    eq(other) { return this.cmp(other) === 0; }
    /**
     *  Returns true if %%other%% is less than to %%this%%.
     */
    lt(other) { return this.cmp(other) < 0; }
    /**
     *  Returns true if %%other%% is less than or equal to %%this%%.
     */
    lte(other) { return this.cmp(other) <= 0; }
    /**
     *  Returns true if %%other%% is greater than to %%this%%.
     */
    gt(other) { return this.cmp(other) > 0; }
    /**
     *  Returns true if %%other%% is greater than or equal to %%this%%.
     */
    gte(other) { return this.cmp(other) >= 0; }
    /**
     *  Returns a new [[FixedNumber]] which is the largest **integer**
     *  that is less than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
    floor() {
        let val = this.#val;
        if (this.#val < BN_0$8) {
            val -= this.#tens - BN_1$3;
        }
        val = (this.#val / this.#tens) * this.#tens;
        return this.#checkValue(val, "floor");
    }
    /**
     *  Returns a new [[FixedNumber]] which is the smallest **integer**
     *  that is greater than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
    ceiling() {
        let val = this.#val;
        if (this.#val > BN_0$8) {
            val += this.#tens - BN_1$3;
        }
        val = (this.#val / this.#tens) * this.#tens;
        return this.#checkValue(val, "ceiling");
    }
    /**
     *  Returns a new [[FixedNumber]] with the decimal component
     *  rounded up on ties at %%decimals%% places.
     */
    round(decimals) {
        if (decimals == null) {
            decimals = 0;
        }
        // Not enough precision to not already be rounded
        if (decimals >= this.decimals) {
            return this;
        }
        const delta = this.decimals - decimals;
        const bump = BN_5 * getTens(delta - 1);
        let value = this.value + bump;
        const tens = getTens(delta);
        value = (value / tens) * tens;
        checkValue(value, this.#format, "round");
        return new FixedNumber(_guard$3, value, this.#format);
    }
    /**
     *  Returns true if %%this%% is equal to ``0``.
     */
    isZero() { return (this.#val === BN_0$8); }
    /**
     *  Returns true if %%this%% is less than ``0``.
     */
    isNegative() { return (this.#val < BN_0$8); }
    /**
     *  Returns the string representation of %%this%%.
     */
    toString() { return this._value; }
    /**
     *  Returns a float approximation.
     *
     *  Due to IEEE 754 precission (or lack thereof), this function
     *  can only return an approximation and most values will contain
     *  rounding errors.
     */
    toUnsafeFloat() { return parseFloat(this.toString()); }
    /**
     *  Return a new [[FixedNumber]] with the same value but has had
     *  its field set to %%format%%.
     *
     *  This will throw if the value cannot fit into %%format%%.
     */
    toFormat(format) {
        return FixedNumber.fromString(this.toString(), format);
    }
    /**
     *  Creates a new [[FixedNumber]] for %%value%% divided by
     *  %%decimal%% places with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
     *  or underflow (precision loss).
     */
    static fromValue(_value, _decimals, _format) {
        const decimals = (_decimals == null) ? 0 : getNumber(_decimals);
        const format = getFormat(_format);
        let value = getBigInt(_value, "value");
        const delta = decimals - format.decimals;
        if (delta > 0) {
            const tens = getTens(delta);
            assert((value % tens) === BN_0$8, "value loses precision for format", "NUMERIC_FAULT", {
                operation: "fromValue", fault: "underflow", value: _value
            });
            value /= tens;
        }
        else if (delta < 0) {
            value *= getTens(-delta);
        }
        checkValue(value, format, "fromValue");
        return new FixedNumber(_guard$3, value, format);
    }
    /**
     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%%, either due to overflow or underflow (precision loss).
     */
    static fromString(_value, _format) {
        const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
        assertArgument(match && (match[2].length + match[3].length) > 0, "invalid FixedNumber string value", "value", _value);
        const format = getFormat(_format);
        let whole = (match[2] || "0"), decimal = (match[3] || "");
        // Pad out the decimals
        while (decimal.length < format.decimals) {
            decimal += Zeros$1;
        }
        // Check precision is safe
        assert(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
            operation: "fromString", fault: "underflow", value: _value
        });
        // Remove extra padding
        decimal = decimal.substring(0, format.decimals);
        const value = BigInt(match[1] + whole + decimal);
        checkValue(value, format, "fromString");
        return new FixedNumber(_guard$3, value, format);
    }
    /**
     *  Creates a new [[FixedNumber]] with the big-endian representation
     *  %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%% due to overflow.
     */
    static fromBytes(_value, _format) {
        let value = toBigInt(getBytes(_value, "value"));
        const format = getFormat(_format);
        if (format.signed) {
            value = fromTwos(value, format.width);
        }
        checkValue(value, format, "fromBytes");
        return new FixedNumber(_guard$3, value, format);
    }
}
//const f1 = FixedNumber.fromString("12.56", "fixed16x2");
//const f2 = FixedNumber.fromString("0.3", "fixed16x2");
//console.log(f1.divSignal(f2));
//const BUMP = FixedNumber.from("0.5");

//See: https://github.com/ethereum/wiki/wiki/RLP
function hexlifyByte(value) {
    let result = value.toString(16);
    while (result.length < 2) {
        result = "0" + result;
    }
    return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
            buffer: data, length, offset
        });
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
        buffer: data, length: 0, offset: 1
    });
    const checkOffset = (offset) => {
        assert(offset <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
            buffer: data, length: data.length, offset
        });
    };
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        checkOffset(offset + 1 + lengthLength);
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        checkOffset(offset + 1 + lengthLength + length);
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        checkOffset(offset + 1 + length);
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        checkOffset(offset + 1 + lengthLength);
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        checkOffset(offset + 1 + lengthLength + length);
        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        checkOffset(offset + 1 + length);
        const result = hexlify(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: hexlifyByte(data[offset]) };
}
/**
 *  Decodes %%data%% into the structured data it represents.
 */
function decodeRlp(_data) {
    const data = getBytes(_data, "data");
    const decoded = _decode(data, 0);
    assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
    return decoded.result;
}

//See: https://github.com/ethereum/wiki/wiki/RLP
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    const data = Array.prototype.slice.call(getBytes(object, "object"));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
const nibbles = "0123456789abcdef";
/**
 *  Encodes %%object%% as an RLP-encoded [[DataHexString]].
 */
function encodeRlp(object) {
    let result = "0x";
    for (const v of _encode(object)) {
        result += nibbles[v >> 4];
        result += nibbles[v & 0xf];
    }
    return result;
}

/**
 *  Most interactions with Ethereum requires integer values, which use
 *  the smallest magnitude unit.
 *
 *  For example, imagine dealing with dollars and cents. Since dollars
 *  are divisible, non-integer values are possible, such as ``$10.77``.
 *  By using the smallest indivisible unit (i.e. cents), the value can
 *  be kept as the integer ``1077``.
 *
 *  When receiving decimal input from the user (as a decimal string),
 *  the value should be converted to an integer and when showing a user
 *  a value, the integer value should be converted to a decimal string.
 *
 *  This creates a clear distinction, between values to be used by code
 *  (integers) and values used for display logic to users (decimals).
 *
 *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,
 *  where each individual unit is called a //wei//.
 *
 *  @_subsection api/utils:Unit Conversion  [about-units]
 */
const names$1 = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether",
];
/**
 *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal
 *  places. The %%unit%% may be the number of decimal places or the name of
 *  a unit (e.g. ``"gwei"`` for 9 decimal places).
 *
 */
function formatUnits(value, unit) {
    let decimals = 18;
    if (typeof (unit) === "string") {
        const index = names$1.indexOf(unit);
        assertArgument(index >= 0, "invalid unit", "unit", unit);
        decimals = 3 * index;
    }
    else if (unit != null) {
        decimals = getNumber(unit, "unit");
    }
    return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
/**
 *  Converts the //decimal string// %%value%% to a BigInt, assuming
 *  %%unit%% decimal places. The %%unit%% may the number of decimal places
 *  or the name of a unit (e.g. ``"gwei"`` for 9 decimal places).
 */
function parseUnits$1(value, unit) {
    assertArgument(typeof (value) === "string", "value must be a string", "value", value);
    let decimals = 18;
    if (typeof (unit) === "string") {
        const index = names$1.indexOf(unit);
        assertArgument(index >= 0, "invalid unit", "unit", unit);
        decimals = 3 * index;
    }
    else if (unit != null) {
        decimals = getNumber(unit, "unit");
    }
    return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
/**
 *  Converts %%value%% into a //decimal string// using 18 decimal places.
 */
function formatEther(wei) {
    return formatUnits(wei, 18);
}
/**
 *  Converts the //decimal string// %%ether%% to a BigInt, using 18
 *  decimal places.
 */
function parseEther(ether) {
    return parseUnits$1(ether, 18);
}

/**
 * @_ignore:
 */
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
// Properties used to immediate pass through to the underlying object
// - `then` is used to detect if an object is a Promise for await
const passProperties$1 = ["then"];
const _guard$2 = {};
const resultNames = new WeakMap();
function getNames(result) {
    return resultNames.get(result);
}
function setNames(result, names) {
    resultNames.set(result, names);
}
function throwError(name, error) {
    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
    wrapped.error = error;
    throw wrapped;
}
function toObject(names, items, deep) {
    if (names.indexOf(null) >= 0) {
        return items.map((item, index) => {
            if (item instanceof Result) {
                return toObject(getNames(item), item, deep);
            }
            return item;
        });
    }
    return names.reduce((accum, name, index) => {
        let item = items.getValue(name);
        if (!(name in accum)) {
            if (deep && item instanceof Result) {
                item = toObject(getNames(item), item, deep);
            }
            accum[name] = item;
        }
        return accum;
    }, {});
}
/**
 *  A [[Result]] is a sub-class of Array, which allows accessing any
 *  of its values either positionally by its index or, if keys are
 *  provided by its name.
 *
 *  @_docloc: api/abi
 */
class Result extends Array {
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    #names;
    /**
     *  @private
     */
    constructor(...args) {
        // To properly sub-class Array so the other built-in
        // functions work, the constructor has to behave fairly
        // well. So, in the event we are created via fromItems()
        // we build the read-only Result object we want, but on
        // any other input, we use the default constructor
        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);
        const guard = args[0];
        let items = args[1];
        let names = (args[2] || []).slice();
        let wrap = true;
        if (guard !== _guard$2) {
            items = args;
            names = [];
            wrap = false;
        }
        // Can't just pass in ...items since an array of length 1
        // is a special case in the super.
        super(items.length);
        items.forEach((item, index) => { this[index] = item; });
        // Find all unique keys
        const nameCounts = names.reduce((accum, name) => {
            if (typeof (name) === "string") {
                accum.set(name, (accum.get(name) || 0) + 1);
            }
            return accum;
        }, (new Map()));
        // Remove any key thats not unique
        setNames(this, Object.freeze(items.map((item, index) => {
            const name = names[index];
            if (name != null && nameCounts.get(name) === 1) {
                return name;
            }
            return null;
        })));
        // Dummy operations to prevent TypeScript from complaining
        this.#names = [];
        if (this.#names == null) {
            void (this.#names);
        }
        if (!wrap) {
            return;
        }
        // A wrapped Result is immutable
        Object.freeze(this);
        // Proxy indices and names so we can trap deferred errors
        const proxy = new Proxy(this, {
            get: (target, prop, receiver) => {
                if (typeof (prop) === "string") {
                    // Index accessor
                    if (prop.match(/^[0-9]+$/)) {
                        const index = getNumber(prop, "%index");
                        if (index < 0 || index >= this.length) {
                            throw new RangeError("out of result range");
                        }
                        const item = target[index];
                        if (item instanceof Error) {
                            throwError(`index ${index}`, item);
                        }
                        return item;
                    }
                    // Pass important checks (like `then` for Promise) through
                    if (passProperties$1.indexOf(prop) >= 0) {
                        return Reflect.get(target, prop, receiver);
                    }
                    const value = target[prop];
                    if (value instanceof Function) {
                        // Make sure functions work with private variables
                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding
                        return function (...args) {
                            return value.apply((this === receiver) ? target : this, args);
                        };
                    }
                    else if (!(prop in target)) {
                        // Possible name accessor
                        return target.getValue.apply((this === receiver) ? target : this, [prop]);
                    }
                }
                return Reflect.get(target, prop, receiver);
            }
        });
        setNames(proxy, getNames(this));
        return proxy;
    }
    /**
     *  Returns the Result as a normal Array. If %%deep%%, any children
     *  which are Result objects are also converted to a normal Array.
     *
     *  This will throw if there are any outstanding deferred
     *  errors.
     */
    toArray(deep) {
        const result = [];
        this.forEach((item, index) => {
            if (item instanceof Error) {
                throwError(`index ${index}`, item);
            }
            if (deep && item instanceof Result) {
                item = item.toArray(deep);
            }
            result.push(item);
        });
        return result;
    }
    /**
     *  Returns the Result as an Object with each name-value pair. If
     *  %%deep%%, any children which are Result objects are also
     *  converted to an Object.
     *
     *  This will throw if any value is unnamed, or if there are
     *  any outstanding deferred errors.
     */
    toObject(deep) {
        const names = getNames(this);
        return names.reduce((accum, name, index) => {
            assert(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
                operation: "toObject()"
            });
            return toObject(names, this, deep);
        }, {});
    }
    /**
     *  @_ignore
     */
    slice(start, end) {
        if (start == null) {
            start = 0;
        }
        if (start < 0) {
            start += this.length;
            if (start < 0) {
                start = 0;
            }
        }
        if (end == null) {
            end = this.length;
        }
        if (end < 0) {
            end += this.length;
            if (end < 0) {
                end = 0;
            }
        }
        if (end > this.length) {
            end = this.length;
        }
        const _names = getNames(this);
        const result = [], names = [];
        for (let i = start; i < end; i++) {
            result.push(this[i]);
            names.push(_names[i]);
        }
        return new Result(_guard$2, result, names);
    }
    /**
     *  @_ignore
     */
    filter(callback, thisArg) {
        const _names = getNames(this);
        const result = [], names = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            if (callback.call(thisArg, item, i, this)) {
                result.push(item);
                names.push(_names[i]);
            }
        }
        return new Result(_guard$2, result, names);
    }
    /**
     *  @_ignore
     */
    map(callback, thisArg) {
        const result = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            result.push(callback.call(thisArg, item, i, this));
        }
        return result;
    }
    /**
     *  Returns the value for %%name%%.
     *
     *  Since it is possible to have a key whose name conflicts with
     *  a method on a [[Result]] or its superclass Array, or any
     *  JavaScript keyword, this ensures all named values are still
     *  accessible by name.
     */
    getValue(name) {
        const index = getNames(this).indexOf(name);
        if (index === -1) {
            return undefined;
        }
        const value = this[index];
        if (value instanceof Error) {
            throwError(`property ${JSON.stringify(name)}`, value.error);
        }
        return value;
    }
    /**
     *  Creates a new [[Result]] for %%items%% with each entry
     *  also accessible by its corresponding name in %%keys%%.
     */
    static fromItems(items, keys) {
        return new Result(_guard$2, items, keys);
    }
}
function getValue$1(value) {
    let bytes = toBeArray(value);
    assert(bytes.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes, length: WordSize, offset: bytes.length });
    if (bytes.length !== WordSize) {
        bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));
    }
    return bytes;
}
/**
 *  @_ignore
 */
class Coder {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    name;
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    type;
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    localName;
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    dynamic;
    constructor(name, type, localName, dynamic) {
        defineProperties(this, { name, type, localName, dynamic }, {
            name: "string", type: "string", localName: "string", dynamic: "boolean"
        });
    }
    _throwError(message, value) {
        assertArgument(false, message, this.localName, value);
    }
}
/**
 *  @_ignore
 */
class Writer {
    // An array of WordSize lengthed objects to concatenation
    #data;
    #dataLength;
    constructor() {
        this.#data = [];
        this.#dataLength = 0;
    }
    get data() {
        return concat(this.#data);
    }
    get length() { return this.#dataLength; }
    #writeData(data) {
        this.#data.push(data);
        this.#dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this.#writeData(getBytesCopy(writer.data));
    }
    // Arrayish item; pad on the right to *nearest* WordSize
    writeBytes(value) {
        let bytes = getBytesCopy(value);
        const paddingOffset = bytes.length % WordSize;
        if (paddingOffset) {
            bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));
        }
        return this.#writeData(bytes);
    }
    // Numeric item; pad on the left *to* WordSize
    writeValue(value) {
        return this.#writeData(getValue$1(value));
    }
    // Inserts a numeric place-holder, returning a callback that can
    // be used to asjust the value later
    writeUpdatableValue() {
        const offset = this.#data.length;
        this.#data.push(Padding);
        this.#dataLength += WordSize;
        return (value) => {
            this.#data[offset] = getValue$1(value);
        };
    }
}
/**
 *  @_ignore
 */
class Reader {
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    allowLoose;
    #data;
    #offset;
    #bytesRead;
    #parent;
    #maxInflation;
    constructor(data, allowLoose, maxInflation) {
        defineProperties(this, { allowLoose: !!allowLoose });
        this.#data = getBytesCopy(data);
        this.#bytesRead = 0;
        this.#parent = null;
        this.#maxInflation = (maxInflation != null) ? maxInflation : 1024;
        this.#offset = 0;
    }
    get data() { return hexlify(this.#data); }
    get dataLength() { return this.#data.length; }
    get consumed() { return this.#offset; }
    get bytes() { return new Uint8Array(this.#data); }
    #incrementBytesRead(count) {
        if (this.#parent) {
            return this.#parent.#incrementBytesRead(count);
        }
        this.#bytesRead += count;
        // Check for excessive inflation (see: #4537)
        assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\/github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
            buffer: getBytesCopy(this.#data), offset: this.#offset,
            length: count, info: {
                bytesRead: this.#bytesRead,
                dataLength: this.dataLength
            }
        });
    }
    #peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / WordSize) * WordSize;
        if (this.#offset + alignedLength > this.#data.length) {
            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
                alignedLength = length;
            }
            else {
                assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
                    buffer: getBytesCopy(this.#data),
                    length: this.#data.length,
                    offset: this.#offset + alignedLength
                });
            }
        }
        return this.#data.slice(this.#offset, this.#offset + alignedLength);
    }
    // Create a sub-reader with the same underlying data, but offset
    subReader(offset) {
        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
        reader.#parent = this;
        return reader;
    }
    // Read bytes
    readBytes(length, loose) {
        let bytes = this.#peekBytes(0, length, !!loose);
        this.#incrementBytesRead(length);
        this.#offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    // Read a numeric values
    readValue() {
        return toBigInt(this.readBytes(WordSize));
    }
    readIndex() {
        return toNumber(this.readBytes(WordSize));
    }
}

/**
 *  An **HMAC** enables verification that a given key was used
 *  to authenticate a payload.
 *
 *  See: [[link-wiki-hmac]]
 *
 *  @_subsection: api/crypto:HMAC  [about-hmac]
 */
let locked$4 = false;
const _computeHmac = function (algorithm, key, data) {
    return createHmac(algorithm, key).update(data).digest();
};
let __computeHmac = _computeHmac;
/**
 *  Return the HMAC for %%data%% using the %%key%% key with the underlying
 *  %%algo%% used for compression.
 *
 *  @example:
 *    key = id("some-secret")
 *
 *    // Compute the HMAC
 *    computeHmac("sha256", key, "0x1337")
 *    //_result:
 *
 *    // To compute the HMAC of UTF-8 data, the data must be
 *    // converted to UTF-8 bytes
 *    computeHmac("sha256", key, toUtf8Bytes("Hello World"))
 *    //_result:
 *
 */
function computeHmac(algorithm, _key, _data) {
    const key = getBytes(_key, "key");
    const data = getBytes(_data, "data");
    return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function () { locked$4 = true; };
computeHmac.register = function (func) {
    if (locked$4) {
        throw new Error("computeHmac is locked");
    }
    __computeHmac = func;
};
Object.freeze(computeHmac);

function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}

const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split$1(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));

const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const u8a$1 = (a) => a instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!isLE)
    throw new Error('Non little-endian hardware is not supported');
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await nextTick();
        ts += diff;
    }
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes$1(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes$1(data);
    if (!u8a$1(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes$1(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a$1(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes$1(bytesLength = 32) {
    if (crypto && typeof crypto.getRandomValues === 'function') {
        return crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}

// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n$4 = /* @__PURE__ */ BigInt(0);
const _1n$5 = /* @__PURE__ */ BigInt(1);
const _2n$3 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n$5, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n$4;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n$5) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n$3)
            t ^= _1n$5 << ((_1n$5 << /* @__PURE__ */ BigInt(j)) - _1n$5);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split$1(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        exists(this);
        const { blockLen, state } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        exists(this, false);
        bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);

/**
 *  Cryptographic hashing functions
 *
 *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]
 */
let locked$3 = false;
const _keccak256 = function (data) {
    return keccak_256(data);
};
let __keccak256 = _keccak256;
/**
 *  Compute the cryptographic KECCAK256 hash of %%data%%.
 *
 *  The %%data%% **must** be a data representation, to compute the
 *  hash of UTF-8 data use the [[id]] function.
 *
 *  @returns DataHexstring
 *  @example:
 *    keccak256("0x")
 *    //_result:
 *
 *    keccak256("0x1337")
 *    //_result:
 *
 *    keccak256(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 *    // Strings are assumed to be DataHexString, otherwise it will
 *    // throw. To hash UTF-8 data, see the note above.
 *    keccak256("Hello World")
 *    //_error:
 */
function keccak256(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function () { locked$3 = true; };
keccak256.register = function (func) {
    if (locked$3) {
        throw new TypeError("keccak256 is locked");
    }
    __keccak256 = func;
};
Object.freeze(keccak256);

// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
    }
    update(data) {
        exists(this);
        const { view, buffer, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = createView(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        exists(this);
        output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}

// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
]);
const Kr = /* @__PURE__ */ new Uint32Array([
    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
]);
// The rotate left (circular left shift) operation for uint32
const rotl$1 = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl$1(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl$1(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl$1(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl$1(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
const ripemd160$1 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());

let locked$2 = false;
const _ripemd160 = function (data) {
    return ripemd160$1(data);
};
let __ripemd160 = _ripemd160;
/**
 *  Compute the cryptographic RIPEMD-160 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    ripemd160("0x")
 *    //_result:
 *
 *    ripemd160("0x1337")
 *    //_result:
 *
 *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 */
function ripemd160(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__ripemd160(data));
}
ripemd160._ = _ripemd160;
ripemd160.lock = function () { locked$2 = true; };
ripemd160.register = function (func) {
    if (locked$2) {
        throw new TypeError("ripemd160 is locked");
    }
    __ripemd160 = func;
};
Object.freeze(ripemd160);

/**
 *  A **Password-Based Key-Derivation Function** is designed to create
 *  a sequence of bytes suitible as a **key** from a human-rememberable
 *  password.
 *
 *  @_subsection: api/crypto:Passwords  [about-pbkdf]
 */
let locked$1 = false;
const _pbkdf2 = function (password, salt, iterations, keylen, algo) {
    return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
let __pbkdf2 = _pbkdf2;
/**
 *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using
 *  the %%salt%% and using %%iterations%% of %%algo%%.
 *
 *  This PBKDF is outdated and should not be used in new projects, but is
 *  required to decrypt older files.
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the PBKDF2
 *    pbkdf2(passwordBytes, salt, 1024, 16, "sha256")
 *    //_result:
 */
function pbkdf2$1(_password, _salt, iterations, keylen, algo) {
    const password = getBytes(_password, "password");
    const salt = getBytes(_salt, "salt");
    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2$1._ = _pbkdf2;
pbkdf2$1.lock = function () { locked$1 = true; };
pbkdf2$1.register = function (func) {
    if (locked$1) {
        throw new Error("pbkdf2 is locked");
    }
    __pbkdf2 = func;
};
Object.freeze(pbkdf2$1);

/**
 *  A **Cryptographically Secure Random Value** is one that has been
 *  generated with additional care take to prevent side-channels
 *  from allowing others to detect it and prevent others from through
 *  coincidence generate the same values.
 *
 *  @_subsection: api/crypto:Random Values  [about-crypto-random]
 */
let locked = false;
const _randomBytes = function (length) {
    return new Uint8Array(randomBytes$2(length));
};
let __randomBytes = _randomBytes;
/**
 *  Return %%length%% bytes of cryptographically secure random data.
 *
 *  @example:
 *    randomBytes(8)
 *    //_result:
 */
function randomBytes(length) {
    return __randomBytes(length);
}
randomBytes._ = _randomBytes;
randomBytes.lock = function () { locked = true; };
randomBytes.register = function (func) {
    if (locked) {
        throw new Error("randomBytes is locked");
    }
    __randomBytes = func;
};
Object.freeze(randomBytes);

// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// HMAC (RFC 2104)
class HMAC extends Hash {
    constructor(hash$1, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        hash(hash$1);
        const key = toBytes(_key);
        this.iHash = hash$1.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash$1.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash$1.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        exists(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        exists(this);
        bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash$1, _password, _salt, _opts) {
    hash(hash$1);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    number(c);
    number(dkLen);
    number(asyncTick);
    if (c < 1)
        throw new Error('PBKDF2: iterations (c) should be >= 1');
    const password = toBytes(_password);
    const salt = toBytes(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac.create(hash$1, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    u.fill(0);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            // Uc = PRF(Password, Uc1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// RFC 7914 Scrypt KDF
// Left rotate for uint32
const rotl = (a, b) => (a << b) | (a >>> (32 - b));
// The main Scrypt loop: uses Salsa extensively.
// Six versions of the function were tried, this is the fastest one.
// prettier-ignore
function XorAndSalsa(prev, pi, input, ii, out, oi) {
    // Based on https://cr.yp.to/salsa20.html
    // Xor blocks
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    // Save state to temporary variables (salsa)
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    // Main loop (salsa)
    for (let i = 0; i < 8; i += 2) {
        x04 ^= rotl(x00 + x12 | 0, 7);
        x08 ^= rotl(x04 + x00 | 0, 9);
        x12 ^= rotl(x08 + x04 | 0, 13);
        x00 ^= rotl(x12 + x08 | 0, 18);
        x09 ^= rotl(x05 + x01 | 0, 7);
        x13 ^= rotl(x09 + x05 | 0, 9);
        x01 ^= rotl(x13 + x09 | 0, 13);
        x05 ^= rotl(x01 + x13 | 0, 18);
        x14 ^= rotl(x10 + x06 | 0, 7);
        x02 ^= rotl(x14 + x10 | 0, 9);
        x06 ^= rotl(x02 + x14 | 0, 13);
        x10 ^= rotl(x06 + x02 | 0, 18);
        x03 ^= rotl(x15 + x11 | 0, 7);
        x07 ^= rotl(x03 + x15 | 0, 9);
        x11 ^= rotl(x07 + x03 | 0, 13);
        x15 ^= rotl(x11 + x07 | 0, 18);
        x01 ^= rotl(x00 + x03 | 0, 7);
        x02 ^= rotl(x01 + x00 | 0, 9);
        x03 ^= rotl(x02 + x01 | 0, 13);
        x00 ^= rotl(x03 + x02 | 0, 18);
        x06 ^= rotl(x05 + x04 | 0, 7);
        x07 ^= rotl(x06 + x05 | 0, 9);
        x04 ^= rotl(x07 + x06 | 0, 13);
        x05 ^= rotl(x04 + x07 | 0, 18);
        x11 ^= rotl(x10 + x09 | 0, 7);
        x08 ^= rotl(x11 + x10 | 0, 9);
        x09 ^= rotl(x08 + x11 | 0, 13);
        x10 ^= rotl(x09 + x08 | 0, 18);
        x12 ^= rotl(x15 + x14 | 0, 7);
        x13 ^= rotl(x12 + x15 | 0, 9);
        x14 ^= rotl(x13 + x12 | 0, 13);
        x15 ^= rotl(x14 + x13 | 0, 18);
    }
    // Write output (salsa)
    out[oi++] = (y00 + x00) | 0;
    out[oi++] = (y01 + x01) | 0;
    out[oi++] = (y02 + x02) | 0;
    out[oi++] = (y03 + x03) | 0;
    out[oi++] = (y04 + x04) | 0;
    out[oi++] = (y05 + x05) | 0;
    out[oi++] = (y06 + x06) | 0;
    out[oi++] = (y07 + x07) | 0;
    out[oi++] = (y08 + x08) | 0;
    out[oi++] = (y09 + x09) | 0;
    out[oi++] = (y10 + x10) | 0;
    out[oi++] = (y11 + x11) | 0;
    out[oi++] = (y12 + x12) | 0;
    out[oi++] = (y13 + x13) | 0;
    out[oi++] = (y14 + x14) | 0;
    out[oi++] = (y15 + x15) | 0;
}
function BlockMix(input, ii, out, oi, r) {
    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
        if (i > 0)
            tail += 16; // First iteration overwrites tmp value in tail
        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
    }
}
// Common prologue and epilogue for sync/async functions
function scryptInit(password, salt, _opts) {
    // Maxmem - 1GB+1KB by default
    const opts = checkOpts({
        dkLen: 32,
        asyncTick: 10,
        maxmem: 1024 ** 3 + 1024,
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    number(N);
    number(r);
    number(p);
    number(dkLen);
    number(asyncTick);
    number(maxmem);
    if (onProgress !== undefined && typeof onProgress !== 'function')
        throw new Error('progressCb should be function');
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function
        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.
        throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');
    }
    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {
        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');
    }
    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');
    }
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem) {
        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
    }
    // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
    // Since it has only one iteration there is no reason to use async variant
    const B = pbkdf2(sha256$1, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u32(B);
    // Re-used between parallel iterations. Array(iterations) of B
    const V = u32(new Uint8Array(blockSize * N));
    const tmp = u32(new Uint8Array(blockSize));
    let blockMixCb = () => { };
    if (onProgress) {
        const totalBlockMix = 2 * N * p;
        // Invoke callback if progress changes from 10.01 to 10.02
        // Allows to draw smooth progress bar on up to 8K screen
        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
        let blockMixCnt = 0;
        blockMixCb = () => {
            blockMixCnt++;
            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
                onProgress(blockMixCnt / totalBlockMix);
        };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf2(sha256$1, password, B, { c: 1, dkLen });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
}
/**
 * Scrypt KDF from RFC 7914.
 * @param password - pass
 * @param salt - salt
 * @param opts - parameters
 * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)
 * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance
 * - `p` is parallelization factor (1 is common)
 * - `dkLen` is output key length in bytes e.g. 32.
 * - `asyncTick` - (default: 10) max time in ms for which async function can block execution
 * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt
 * - `onProgress` - callback function that would be executed for progress report
 * @returns Derived key
 */
function scrypt$1(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
    for (let pi = 0; pi < p; pi++) {
        const Pi = blockSize32 * pi;
        for (let i = 0; i < blockSize32; i++)
            V[i] = B32[Pi + i]; // V[0] = B[i]
        for (let i = 0, pos = 0; i < N - 1; i++) {
            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);
            blockMixCb();
        }
        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
        blockMixCb();
        for (let i = 0; i < N; i++) {
            // First u32 of the last 64-byte block (u32 is LE)
            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
            for (let k = 0; k < blockSize32; k++)
                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
            blockMixCb();
        }
    }
    return scryptOutput(password, dkLen, B, V, tmp);
}
/**
 * Scrypt KDF from RFC 7914.
 */
async function scryptAsync(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
    for (let pi = 0; pi < p; pi++) {
        const Pi = blockSize32 * pi;
        for (let i = 0; i < blockSize32; i++)
            V[i] = B32[Pi + i]; // V[0] = B[i]
        let pos = 0;
        await asyncLoop(N - 1, asyncTick, () => {
            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);
            blockMixCb();
        });
        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
        blockMixCb();
        await asyncLoop(N, asyncTick, () => {
            // First u32 of the last 64-byte block (u32 is LE)
            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
            for (let k = 0; k < blockSize32; k++)
                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
            blockMixCb();
        });
    }
    return scryptOutput(password, dkLen, B, V, tmp);
}

let lockedSync = false, lockedAsync = false;
const _scryptAsync = async function (passwd, salt, N, r, p, dkLen, onProgress) {
    return await scryptAsync(passwd, salt, { N, r, p, dkLen, onProgress });
};
const _scryptSync = function (passwd, salt, N, r, p, dkLen) {
    return scrypt$1(passwd, salt, { N, r, p, dkLen });
};
let __scryptAsync = _scryptAsync;
let __scryptSync = _scryptSync;
/**
 *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of
 *  derivation to increase the resource cost to brute-force a password
 *  for a given key.
 *
 *  This means this algorithm is intentionally slow, and can be tuned to
 *  become slower. As computation and memory speed improve over time,
 *  increasing the difficulty maintains the cost of an attacker.
 *
 *  For example, if a target time of 5 seconds is used, a legitimate user
 *  which knows their password requires only 5 seconds to unlock their
 *  account. A 6 character password has 68 billion possibilities, which
 *  would require an attacker to invest over 10,000 years of CPU time. This
 *  is of course a crude example (as password generally aren't random),
 *  but demonstrates to value of imposing large costs to decryption.
 *
 *  For this reason, if building a UI which involved decrypting or
 *  encrypting datsa using scrypt, it is recommended to use a
 *  [[ProgressCallback]] (as event short periods can seem lik an eternity
 *  if the UI freezes). Including the phrase //"decrypting"// in the UI
 *  can also help, assuring the user their waiting is for a good reason.
 *
 *  @_docloc: api/crypto:Passwords
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the scrypt
 *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)
 *    //_result:
 */
async function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {
    const passwd = getBytes(_passwd, "passwd");
    const salt = getBytes(_salt, "salt");
    return hexlify(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));
}
scrypt._ = _scryptAsync;
scrypt.lock = function () { lockedAsync = true; };
scrypt.register = function (func) {
    if (lockedAsync) {
        throw new Error("scrypt is locked");
    }
    __scryptAsync = func;
};
Object.freeze(scrypt);
/**
 *  Provides a synchronous variant of [[scrypt]].
 *
 *  This will completely lock up and freeze the UI in a browser and will
 *  prevent any event loop from progressing. For this reason, it is
 *  preferred to use the [async variant](scrypt).
 *
 *  @_docloc: api/crypto:Passwords
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the scrypt
 *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)
 *    //_result:
 */
function scryptSync(_passwd, _salt, N, r, p, dkLen) {
    const passwd = getBytes(_passwd, "passwd");
    const salt = getBytes(_salt, "salt");
    return hexlify(__scryptSync(passwd, salt, N, r, p, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function () { lockedSync = true; };
scryptSync.register = function (func) {
    if (lockedSync) {
        throw new Error("scryptSync is locked");
    }
    __scryptSync = func;
};
Object.freeze(scryptSync);

const _sha256 = function (data) {
    return createHash("sha256").update(data).digest();
};
let __sha256 = _sha256;
let locked256 = false;
/**
 *  Compute the cryptographic SHA2-256 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    sha256("0x")
 *    //_result:
 *
 *    sha256("0x1337")
 *    //_result:
 *
 *    sha256(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 */
function sha256(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__sha256(data));
}
sha256._ = _sha256;
sha256.lock = function () { locked256 = true; };
sha256.register = function (func) {
    if (locked256) {
        throw new Error("sha256 is locked");
    }
    __sha256 = func;
};
Object.freeze(sha256);
Object.freeze(sha256);

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n$3 = BigInt(0);
const _1n$4 = BigInt(1);
const _2n$2 = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        }
        catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    }
    else if (u8a(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
function equalBytes(b1, b2) {
    // We don't care about timing attacks here
    if (b1.length !== b2.length)
        return false;
    for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
            return false;
    return true;
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n$3; n >>= _1n$4, len += 1)
        ;
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n$4;
}
/**
 * Sets single bit at position.
 */
const bitSet = (n, pos, value) => {
    return n | ((value ? _1n$4 : _0n$3) << BigInt(pos));
};
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_2n$2 << BigInt(n - 1)) - _1n$4;
// DRBG
const u8n = (data) => new Uint8Array(data); // creates Uint8Array
const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n()) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });

var ut = /*#__PURE__*/Object.freeze({
    __proto__: null,
    bitGet: bitGet,
    bitLen: bitLen,
    bitMask: bitMask,
    bitSet: bitSet,
    bytesToHex: bytesToHex,
    bytesToNumberBE: bytesToNumberBE,
    bytesToNumberLE: bytesToNumberLE,
    concatBytes: concatBytes,
    createHmacDrbg: createHmacDrbg,
    ensureBytes: ensureBytes,
    equalBytes: equalBytes,
    hexToBytes: hexToBytes,
    hexToNumber: hexToNumber,
    numberToBytesBE: numberToBytesBE,
    numberToBytesLE: numberToBytesLE,
    numberToHexUnpadded: numberToHexUnpadded,
    numberToVarBytesBE: numberToVarBytesBE,
    utf8ToBytes: utf8ToBytes,
    validateObject: validateObject
});

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities for modular arithmetics and finite fields
// prettier-ignore
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
BigInt(9); BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n$2 ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n$2 || power < _0n$2)
        throw new Error('Expected power/modulo > 0');
    if (modulo === _1n$3)
        return _0n$2;
    let res = _1n$3;
    while (power > _0n$2) {
        if (power & _1n$3)
            res = (res * num) % modulo;
        num = (num * num) % modulo;
        power >>= _1n$3;
    }
    return res;
}
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n$2) {
        res *= res;
        res %= modulo;
    }
    return res;
}
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n$2 || modulo <= _0n$2) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n$2, u = _1n$3;
    while (a !== _0n$2) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        // prettier-ignore
        b = a, a = r, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n$3)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p)  1    if a is a square (mod p)
    // (a | p)  -1   if a is not a square (mod p)
    // (a | p)  0    if a  0 (mod p)
    const legendreC = (P - _1n$3) / _2n$1;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for (Q = P - _1n$3, S = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S++)
        ;
    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
    for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$3; Z++)
        ;
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n$3) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n$3) / _2n$1;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be  -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error('Cannot find square root');
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
                if (Fp.eql(t2, Fp.ONE))
                    break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n$3 << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P  3 (mod 4)
    // n = n^((P+1)/4)
    if (P % _4n === _3n$1) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n$3) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n$1);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n$1), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    return validateObject(field, opts);
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n$2)
        throw new Error('Expected power > 0');
    if (power === _0n$2)
        return f.ONE;
    if (power === _1n$3)
        return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n$2) {
        if (power & _1n$3)
            p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n$3;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n$2)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
        throw new Error('Field lengths over 2048 bytes are not supported');
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: bitMask(BITS),
        ZERO: _0n$2,
        ONE: _1n$3,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n$2 <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n$2,
        isOdd: (num) => (num & _1n$3) === _1n$3,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => (c ? b : a),
        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
        },
    });
    return Object.freeze(f);
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Abelian group utilities
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
    };
    const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return { windows, windowSize };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n$1) {
                if (n & _1n$2)
                    p = p.add(d);
                d = d.double();
                n >>= _1n$2;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // =1, because we skip zero
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n$2;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                }
                else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
            // @ts-ignore
            const W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    precomputesMap.set(P, transform(comp));
                }
            }
            return this.wNAF(W, comp, n);
        },
    };
}
function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...nLength(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y = x + ax + b
function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
        a: 'field',
        b: 'field',
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function',
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze({ ...opts });
}
// ASN.1 DER encoding utilities
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
const DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = '') {
            super(m);
        }
    },
    _parseInt(data) {
        const { Err: E } = DER;
        if (data.length < 2 || data[0] !== 0x02)
            throw new E('Invalid signature integer tag');
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
            throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 0b10000000)
            throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 0b10000000))
            throw new E('Invalid signature integer: unnecessary leading zero');
        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E } = DER;
        const data = typeof hex === 'string' ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
            throw new Error('ui8a expected');
        let l = data.length;
        if (l < 2 || data[0] != 0x30)
            throw new E('Invalid signature tag');
        if (data[1] !== l - 2)
            throw new E('Invalid signature: incorrect length');
        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
        if (rBytesLeft.length)
            throw new E('Invalid signature: left bytes after parsing');
        return { r, s };
    },
    hexFromSig(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
        const h = (num) => {
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n$1 = BigInt(1); BigInt(2); const _3n = BigInt(3); BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const toBytes = CURVE.toBytes ||
        ((_c, point, _isCompressed) => {
            const a = point.toAffine();
            return concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
    const fromBytes = CURVE.fromBytes ||
        ((bytes) => {
            // const head = bytes[0];
            const tail = bytes.subarray(1);
            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
        });
    /**
     * y = x + ax + b: Short weierstrass curve formula
     * @returns y
     */
    function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num))
            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== 'bigint') {
            if (key instanceof Uint8Array)
                key = bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length))
                throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        let num;
        try {
            num =
                typeof key === 'bigint'
                    ? key
                    : bytesToNumberBE(ensureBytes('private key', key, nByteLength));
        }
        catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
            num = mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    const pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
                throw new Error('x required');
            if (py == null || !Fp.isValid(py))
                throw new Error('y required');
            if (pz == null || !Fp.isValid(pz))
                throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                    return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            const { x, y } = this.toAffine();
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('bad point: x or y not FE');
            const left = Fp.sqr(y); // y
            const right = weierstrassEquation(x); // x + ax + b
            if (!Fp.eql(left, right))
                throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree())
                throw new Error('bad point: not in prime-order subgroup');
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
                return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n)
                return I;
            assertGE(n); // Will throw on 0
            if (n === _1n$1)
                return this;
            const { endo } = CURVE;
            if (!endo)
                return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n$1)
                    k1p = k1p.add(d);
                if (k2 & _1n$1)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n$1;
                k2 >>= _1n$1;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake; // Fake point is used to const-time mult
            const { endo } = CURVE;
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            ) => (a === _0n || a === _1n$1 || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null)
                iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0)
                return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
                throw new Error('invZ was invalid');
            return { x: ax, y: ay };
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n$1)
                return true; // No subgroups, always torsion-free
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n$1)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    };
}
function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function',
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean',
    });
    return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            }
            else {
                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = bytesToNumberBE(tail);
                if (!isValidFieldElement(x))
                    throw new Error('Point is not on curve');
                const y2 = weierstrassEquation(x); // y = x + ax + b
                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                const isYOdd = (y & _1n$1) === _1n$1;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd)
                    y = Fp.neg(y);
                return { x, y };
            }
            else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x, y };
            }
            else {
                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
        },
    });
    const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n$1;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = ensureBytes('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = DER.toSig(ensureBytes('DER', hex));
            return new Signature(r, s);
        }
        assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r))
                throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s))
                throw new Error('s must be 0 < s < CURVE.n');
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
                throw new Error('recovery id 2 or 3 invalid');
            const prefix = (rec & 1) === 0 ? '02' : '03';
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q)
                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const length = getMinHashLength(CURVE.n);
            return mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr)
            return len === compressedLen || len === uncompressedLen;
        if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
            return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
            throw new Error('first arg must be private key');
        if (!isProbPub(publicB))
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int ||
        function (bytes) {
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = bytesToNumberBE(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = CURVE.bits2int_modN ||
        function (bytes) {
            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        if (typeof num !== 'bigint')
            throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        // works with order, can have different size than numToField!
        return numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = ensureBytes('msgHash', msgHash);
        if (prehash)
            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes
        }
        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k))
                return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = ensureBytes('msgHash', msgHash);
        publicKey = ensureBytes('publicKey', publicKey);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === 'string' || sg instanceof Uint8Array) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof DER.Err))
                        throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            }
            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            }
            else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            if (error.message === 'PARSE')
                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS())
            return false;
        if (prehash)
            msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P
        if (!R)
            return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils,
    };
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs) => hmac(hash, key, concatBytes$1(...msgs)),
        randomBytes: randomBytes$1,
    };
}
function createCurve(curveDef, defHash) {
    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });
    return Object.freeze({ ...create(defHash), create });
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b) => (a + b / _2n) / b;
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = (pow2(b3, _3n, P) * b3) % P;
    const b9 = (pow2(b6, _3n, P) * b3) % P;
    const b11 = (pow2(b9, _2n, P) * b2) % P;
    const b22 = (pow2(b11, _11n, P) * b11) % P;
    const b44 = (pow2(b22, _22n, P) * b22) % P;
    const b88 = (pow2(b44, _44n, P) * b44) % P;
    const b176 = (pow2(b88, _88n, P) * b88) % P;
    const b220 = (pow2(b176, _44n, P) * b44) % P;
    const b223 = (pow2(b220, _3n, P) * b3) % P;
    const t1 = (pow2(b223, _23n, P) * b22) % P;
    const t2 = (pow2(t1, _6n, P) * b2) % P;
    const root = pow2(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
const secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: (k) => {
            const n = secp256k1N;
            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            const b2 = a1;
            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = mod(k - c1 * a1 - c2 * a2, n);
            let k2 = mod(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
                k1 = n - k1;
            if (k2neg)
                k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
                throw new Error('splitScalar: Endomorphism failed, k=' + k);
            }
            return { k1neg, k1, k2neg, k2 };
        },
    },
}, sha256$1);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
BigInt(0);
secp256k1.ProjectivePoint;

/**
 *  A constant for the zero address.
 *
 *  (**i.e.** ``"0x0000000000000000000000000000000000000000"``)
 */
const ZeroAddress = "0x0000000000000000000000000000000000000000";

/**
 *  A constant for the zero hash.
 *
 *  (**i.e.** ``"0x0000000000000000000000000000000000000000000000000000000000000000"``)
 */
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";

/**
 *  A constant for the order N for the secp256k1 curve.
 *
 *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)
 */
BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
/**
 *  A constant for the number of wei in a single ether.
 *
 *  (**i.e.** ``1000000000000000000n``)
 */
BigInt("1000000000000000000");
/**
 *  A constant for the maximum value for a ``uint256``.
 *
 *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
 */
BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/**
 *  A constant for the minimum value for an ``int256``.
 *
 *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)
 */
BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
/**
 *  A constant for the maximum value for an ``int256``.
 *
 *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
 */
BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// Constants
const BN_0$7 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_2$2 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const _guard$1 = {};
function toUint256(value) {
    return zeroPadValue(toBeArray(value), 32);
}
/**
 *  A Signature  @TODO
 *
 *
 *  @_docloc: api/crypto:Signing
 */
class Signature {
    #r;
    #s;
    #v;
    #networkV;
    /**
     *  The ``r`` value for a signature.
     *
     *  This represents the ``x`` coordinate of a "reference" or
     *  challenge point, from which the ``y`` can be computed.
     */
    get r() { return this.#r; }
    set r(value) {
        assertArgument(dataLength(value) === 32, "invalid r", "value", value);
        this.#r = hexlify(value);
    }
    /**
     *  The ``s`` value for a signature.
     */
    get s() {
        assertArgument(parseInt(this.#s.substring(0, 3)) < 8, "non-canonical s; use ._s", "s", this.#s);
        return this.#s;
    }
    set s(_value) {
        assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
        this.#s = hexlify(_value);
    }
    /**
     *  Return the s value, unchecked for EIP-2 compliance.
     *
     *  This should generally not be used and is for situations where
     *  a non-canonical S value might be relevant, such as Frontier blocks
     *  that were mined prior to EIP-2 or invalid Authorization List
     *  signatures.
     */
    get _s() { return this.#s; }
    /**
     *  Returns true if the Signature is valid for [[link-eip-2]] signatures.
     */
    isValid() {
        return (parseInt(this.#s.substring(0, 3)) < 8);
    }
    /**
     *  The ``v`` value for a signature.
     *
     *  Since a given ``x`` value for ``r`` has two possible values for
     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
     *  values to use.
     *
     *  It is normalized to the values ``27`` or ``28`` for legacy
     *  purposes.
     */
    get v() { return this.#v; }
    set v(value) {
        const v = getNumber(value, "value");
        assertArgument(v === 27 || v === 28, "invalid v", "v", value);
        this.#v = v;
    }
    /**
     *  The EIP-155 ``v`` for legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
    get networkV() { return this.#networkV; }
    /**
     *  The chain ID for EIP-155 legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
    get legacyChainId() {
        const v = this.networkV;
        if (v == null) {
            return null;
        }
        return Signature.getChainId(v);
    }
    /**
     *  The ``yParity`` for the signature.
     *
     *  See ``v`` for more details on how this value is used.
     */
    get yParity() {
        return (this.v === 27) ? 0 : 1;
    }
    /**
     *  The [[link-eip-2098]] compact representation of the ``yParity``
     *  and ``s`` compacted into a single ``bytes32``.
     */
    get yParityAndS() {
        // The EIP-2098 compact representation
        const yParityAndS = getBytes(this.s);
        if (this.yParity) {
            yParityAndS[0] |= 0x80;
        }
        return hexlify(yParityAndS);
    }
    /**
     *  The [[link-eip-2098]] compact representation.
     */
    get compactSerialized() {
        return concat([this.r, this.yParityAndS]);
    }
    /**
     *  The serialized representation.
     */
    get serialized() {
        return concat([this.r, this.s, (this.yParity ? "0x1c" : "0x1b")]);
    }
    /**
     *  @private
     */
    constructor(guard, r, s, v) {
        assertPrivate(guard, _guard$1, "Signature");
        this.#r = r;
        this.#s = s;
        this.#v = v;
        this.#networkV = null;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
    }
    /**
     *  Returns a new identical [[Signature]].
     */
    clone() {
        const clone = new Signature(_guard$1, this.r, this._s, this.v);
        if (this.networkV) {
            clone.#networkV = this.networkV;
        }
        return clone;
    }
    /**
     *  Returns a representation that is compatible with ``JSON.stringify``.
     */
    toJSON() {
        const networkV = this.networkV;
        return {
            _type: "signature",
            networkV: ((networkV != null) ? networkV.toString() : null),
            r: this.r, s: this._s, v: this.v,
        };
    }
    /**
     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
     *
     *  @example:
     *    Signature.getChainId(45)
     *    //_result:
     *
     *    Signature.getChainId(46)
     *    //_result:
     */
    static getChainId(v) {
        const bv = getBigInt(v, "v");
        // The v is not an EIP-155 v, so it is the unspecified chain ID
        if ((bv == BN_27$1) || (bv == BN_28$1)) {
            return BN_0$7;
        }
        // Bad value for an EIP-155 v
        assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v);
        return (bv - BN_35$1) / BN_2$2;
    }
    /**
     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
     *
     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
     *  property to include the chain ID.
     *
     *  @example:
     *    Signature.getChainIdV(5, 27)
     *    //_result:
     *
     *    Signature.getChainIdV(5, 28)
     *    //_result:
     *
     */
    static getChainIdV(chainId, v) {
        return (getBigInt(chainId) * BN_2$2) + BigInt(35 + v - 27);
    }
    /**
     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
     *
     *  @example:
     *    // The values 0 and 1 imply v is actually yParity
     *    Signature.getNormalizedV(0)
     *    //_result:
     *
     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
     *    Signature.getNormalizedV(27)
     *    //_result:
     *
     *    // Legacy EIP-155 transaction (i.e. >= 35)
     *    Signature.getNormalizedV(46)
     *    //_result:
     *
     *    // Invalid values throw
     *    Signature.getNormalizedV(5)
     *    //_error:
     */
    static getNormalizedV(v) {
        const bv = getBigInt(v);
        if (bv === BN_0$7 || bv === BN_27$1) {
            return 27;
        }
        if (bv === BN_1$2 || bv === BN_28$1) {
            return 28;
        }
        assertArgument(bv >= BN_35$1, "invalid v", "v", v);
        // Otherwise, EIP-155 v means odd is 27 and even is 28
        return (bv & BN_1$2) ? 27 : 28;
    }
    /**
     *  Creates a new [[Signature]].
     *
     *  If no %%sig%% is provided, a new [[Signature]] is created
     *  with default values.
     *
     *  If %%sig%% is a string, it is parsed.
     */
    static from(sig) {
        function assertError(check, message) {
            assertArgument(check, message, "signature", sig);
        }
        if (sig == null) {
            return new Signature(_guard$1, ZeroHash, ZeroHash, 27);
        }
        if (typeof (sig) === "string") {
            const bytes = getBytes(sig, "signature");
            if (bytes.length === 64) {
                const r = hexlify(bytes.slice(0, 32));
                const s = bytes.slice(32, 64);
                const v = (s[0] & 0x80) ? 28 : 27;
                s[0] &= 0x7f;
                return new Signature(_guard$1, r, hexlify(s), v);
            }
            if (bytes.length === 65) {
                const r = hexlify(bytes.slice(0, 32));
                const s = hexlify(bytes.slice(32, 64));
                const v = Signature.getNormalizedV(bytes[64]);
                return new Signature(_guard$1, r, s, v);
            }
            assertError(false, "invalid raw signature length");
        }
        if (sig instanceof Signature) {
            return sig.clone();
        }
        // Get r
        const _r = sig.r;
        assertError(_r != null, "missing r");
        const r = toUint256(_r);
        // Get s; by any means necessary (we check consistency below)
        const s = (function (s, yParityAndS) {
            if (s != null) {
                return toUint256(s);
            }
            if (yParityAndS != null) {
                assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
                const bytes = getBytes(yParityAndS);
                bytes[0] &= 0x7f;
                return hexlify(bytes);
            }
            assertError(false, "missing s");
        })(sig.s, sig.yParityAndS);
        // Get v; by any means necessary (we check consistency below)
        const { networkV, v } = (function (_v, yParityAndS, yParity) {
            if (_v != null) {
                const v = getBigInt(_v);
                return {
                    networkV: ((v >= BN_35$1) ? v : undefined),
                    v: Signature.getNormalizedV(v)
                };
            }
            if (yParityAndS != null) {
                assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
                return { v: ((getBytes(yParityAndS)[0] & 0x80) ? 28 : 27) };
            }
            if (yParity != null) {
                switch (getNumber(yParity, "sig.yParity")) {
                    case 0: return { v: 27 };
                    case 1: return { v: 28 };
                }
                assertError(false, "invalid yParity");
            }
            assertError(false, "missing v");
        })(sig.v, sig.yParityAndS, sig.yParity);
        const result = new Signature(_guard$1, r, s, v);
        if (networkV) {
            result.#networkV = networkV;
        }
        // If multiple of v, yParity, yParityAndS we given, check they match
        assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
        return result;
    }
}

/**
 *  Add details about signing here.
 *
 *  @_subsection: api/crypto:Signing  [about-signing]
 */
/**
 *  A **SigningKey** provides high-level access to the elliptic curve
 *  cryptography (ECC) operations and key management.
 */
class SigningKey {
    #privateKey;
    /**
     *  Creates a new **SigningKey** for %%privateKey%%.
     */
    constructor(privateKey) {
        assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
        this.#privateKey = hexlify(privateKey);
    }
    /**
     *  The private key.
     */
    get privateKey() { return this.#privateKey; }
    /**
     *  The uncompressed public key.
     *
     * This will always begin with the prefix ``0x04`` and be 132
     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
     */
    get publicKey() { return SigningKey.computePublicKey(this.#privateKey); }
    /**
     *  The compressed public key.
     *
     *  This will always begin with either the prefix ``0x02`` or ``0x03``
     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
     *  nibbles)
     */
    get compressedPublicKey() { return SigningKey.computePublicKey(this.#privateKey, true); }
    /**
     *  Return the signature of the signed %%digest%%.
     */
    sign(digest) {
        assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
        const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
            lowS: true
        });
        return Signature.from({
            r: toBeHex(sig.r, 32),
            s: toBeHex(sig.s, 32),
            v: (sig.recovery ? 0x1c : 0x1b)
        });
    }
    /**
     *  Returns the [[link-wiki-ecdh]] shared secret between this
     *  private key and the %%other%% key.
     *
     *  The %%other%% key may be any type of key, a raw public key,
     *  a compressed/uncompressed pubic key or aprivate key.
     *
     *  Best practice is usually to use a cryptographic hash on the
     *  returned value before using it as a symetric secret.
     *
     *  @example:
     *    sign1 = new SigningKey(id("some-secret-1"))
     *    sign2 = new SigningKey(id("some-secret-2"))
     *
     *    // Notice that privA.computeSharedSecret(pubB)...
     *    sign1.computeSharedSecret(sign2.publicKey)
     *    //_result:
     *
     *    // ...is equal to privB.computeSharedSecret(pubA).
     *    sign2.computeSharedSecret(sign1.publicKey)
     *    //_result:
     */
    computeSharedSecret(other) {
        const pubKey = SigningKey.computePublicKey(other);
        return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));
    }
    /**
     *  Compute the public key for %%key%%, optionally %%compressed%%.
     *
     *  The %%key%% may be any type of key, a raw public key, a
     *  compressed/uncompressed public key or private key.
     *
     *  @example:
     *    sign = new SigningKey(id("some-secret"));
     *
     *    // Compute the uncompressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey)
     *    //_result:
     *
     *    // Compute the compressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey, true)
     *    //_result:
     *
     *    // Compute the uncompressed public key
     *    SigningKey.computePublicKey(sign.publicKey, false);
     *    //_result:
     *
     *    // Compute the Compressed a public key
     *    SigningKey.computePublicKey(sign.publicKey, true);
     *    //_result:
     */
    static computePublicKey(key, compressed) {
        let bytes = getBytes(key, "key");
        // private key
        if (bytes.length === 32) {
            const pubKey = secp256k1.getPublicKey(bytes, !!compressed);
            return hexlify(pubKey);
        }
        // raw public key; use uncompressed key with 0x04 prefix
        if (bytes.length === 64) {
            const pub = new Uint8Array(65);
            pub[0] = 0x04;
            pub.set(bytes, 1);
            bytes = pub;
        }
        const point = secp256k1.ProjectivePoint.fromHex(bytes);
        return hexlify(point.toRawBytes(compressed));
    }
    /**
     *  Returns the public key for the private key which produced the
     *  %%signature%% for the given %%digest%%.
     *
     *  @example:
     *    key = new SigningKey(id("some-secret"))
     *    digest = id("hello world")
     *    sig = key.sign(digest)
     *
     *    // Notice the signer public key...
     *    key.publicKey
     *    //_result:
     *
     *    // ...is equal to the recovered public key
     *    SigningKey.recoverPublicKey(digest, sig)
     *    //_result:
     *
     */
    static recoverPublicKey(digest, signature) {
        assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
        const sig = Signature.from(signature);
        let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
        secpSig = secpSig.addRecoveryBit(sig.yParity);
        const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
        assertArgument(pubKey != null, "invalid signature for digest", "signature", signature);
        return "0x" + pubKey.toHex(false);
    }
    /**
     *  Returns the point resulting from adding the ellipic curve points
     *  %%p0%% and %%p1%%.
     *
     *  This is not a common function most developers should require, but
     *  can be useful for certain privacy-specific techniques.
     *
     *  For example, it is used by [[HDNodeWallet]] to compute child
     *  addresses from parent public keys and chain codes.
     */
    static addPoints(p0, p1, compressed) {
        const pub0 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));
        const pub1 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));
        return "0x" + pub0.add(pub1).toHex(!!compressed);
    }
}

const BN_0$6 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
    //    if (!isHexString(address, 20)) {
    //        logger.throwArgumentError("invalid address", "address", address);
    //    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = getBytes(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));
const safeDigits = 15;
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
const Base36 = (function () {
    const result = {};
    for (let i = 0; i < 36; i++) {
        const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
        result[key] = BigInt(i);
    }
    return result;
})();
function fromBase36(value) {
    value = value.toLowerCase();
    let result = BN_0$6;
    for (let i = 0; i < value.length; i++) {
        result = result * BN_36 + Base36[value[i]];
    }
    return result;
}
/**
 *  Returns a normalized and checksumed address for %%address%%.
 *  This accepts non-checksum addresses, checksum addresses and
 *  [[getIcapAddress]] formats.
 *
 *  The checksum in Ethereum uses the capitalization (upper-case
 *  vs lower-case) of the characters within an address to encode
 *  its checksum, which offers, on average, a checksum of 15-bits.
 *
 *  If %%address%% contains both upper-case and lower-case, it is
 *  assumed to already be a checksum address and its checksum is
 *  validated, and if the address fails its expected checksum an
 *  error is thrown.
 *
 *  If you wish the checksum of %%address%% to be ignore, it should
 *  be converted to lower-case (i.e. ``.toLowercase()``) before
 *  being passed in. This should be a very rare situation though,
 *  that you wish to bypass the safegaurds in place to protect
 *  against an address that has been incorrectly copied from another
 *  source.
 *
 *  @example:
 *    // Adds the checksum (via upper-casing specific letters)
 *    getAddress("0x8ba1f109551bd432803012645ac136ddd64dba72")
 *    //_result:
 *
 *    // Converts ICAP address and adds checksum
 *    getAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
 *    //_result:
 *
 *    // Throws an error if an address contains mixed case,
 *    // but the checksum fails
 *    getAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_error:
 */
function getAddress(address) {
    assertArgument(typeof (address) === "string", "invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (!address.startsWith("0x")) {
            address = "0x" + address;
        }
        const result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
        return result;
    }
    // Maybe ICAP? (we only support direct mode)
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
        let result = fromBase36(address.substring(4)).toString(16);
        while (result.length < 40) {
            result = "0" + result;
        }
        return getChecksumAddress("0x" + result);
    }
    assertArgument(false, "invalid address", "address", address);
}

// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
/**
 *  Returns the address that would result from a ``CREATE`` for %%tx%%.
 *
 *  This can be used to compute the address a contract will be
 *  deployed to by an EOA when sending a deployment transaction (i.e.
 *  when the ``to`` address is ``null``).
 *
 *  This can also be used to compute the address a contract will be
 *  deployed to by a contract, by using the contract's address as the
 *  ``to`` and the contract's nonce.
 *
 *  @example
 *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72";
 *    nonce = 5;
 *
 *    getCreateAddress({ from, nonce });
 *    //_result:
 */
function getCreateAddress(tx) {
    const from = getAddress(tx.from);
    const nonce = getBigInt(tx.nonce, "tx.nonce");
    let nonceHex = nonce.toString(16);
    if (nonceHex === "0") {
        nonceHex = "0x";
    }
    else if (nonceHex.length % 2) {
        nonceHex = "0x0" + nonceHex;
    }
    else {
        nonceHex = "0x" + nonceHex;
    }
    return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}

/**
 *  Returns true if %%value%% is an object which implements the
 *  [[Addressable]] interface.
 *
 *  @example:
 *    // Wallets and AbstractSigner sub-classes
 *    isAddressable(Wallet.createRandom())
 *    //_result:
 *
 *    // Contracts
 *    contract = new Contract("dai.tokens.ethers.eth", [ ], provider)
 *    isAddressable(contract)
 *    //_result:
 */
function isAddressable(value) {
    return (value && typeof (value.getAddress) === "function");
}
async function checkAddress(target, promise) {
    const result = await promise;
    if (result == null || result === "0x0000000000000000000000000000000000000000") {
        assert(typeof (target) !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
        assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
    }
    return getAddress(result);
}
/**
 *  Resolves to an address for the %%target%%, which may be any
 *  supported address type, an [[Addressable]] or a Promise which
 *  resolves to an address.
 *
 *  If an ENS name is provided, but that name has not been correctly
 *  configured a [[UnconfiguredNameError]] is thrown.
 *
 *  @example:
 *    addr = "0x6B175474E89094C44Da98b954EedeAC495271d0F"
 *
 *    // Addresses are return synchronously
 *    resolveAddress(addr, provider)
 *    //_result:
 *
 *    // Address promises are resolved asynchronously
 *    resolveAddress(Promise.resolve(addr))
 *    //_result:
 *
 *    // ENS names are resolved asynchronously
 *    resolveAddress("dai.tokens.ethers.eth", provider)
 *    //_result:
 *
 *    // Addressable objects are resolved asynchronously
 *    contract = new Contract(addr, [ ])
 *    resolveAddress(contract, provider)
 *    //_result:
 *
 *    // Unconfigured ENS names reject
 *    resolveAddress("nothing-here.ricmoo.eth", provider)
 *    //_error:
 *
 *    // ENS names require a NameResolver object passed in
 *    // (notice the provider was omitted)
 *    resolveAddress("nothing-here.ricmoo.eth")
 *    //_error:
 */
function resolveAddress(target, resolver) {
    if (typeof (target) === "string") {
        if (target.match(/^0x[0-9a-f]{40}$/i)) {
            return getAddress(target);
        }
        assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
        return checkAddress(target, resolver.resolveName(target));
    }
    else if (isAddressable(target)) {
        return checkAddress(target, target.getAddress());
    }
    else if (target && typeof (target.then) === "function") {
        return checkAddress(target, target);
    }
    assertArgument(false, "unsupported addressable value", "target", target);
}

/**
 *  A Typed object allows a value to have its type explicitly
 *  specified.
 *
 *  For example, in Solidity, the value ``45`` could represent a
 *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent
 *  a ``bytes2`` or ``bytes``.
 *
 *  Since JavaScript has no meaningful way to explicitly inform any
 *  APIs which what the type is, this allows transparent interoperation
 *  with Soldity.
 *
 *  @_subsection: api/abi:Typed Values
 */
const _gaurd = {};
function n(value, width) {
    let signed = false;
    if (width < 0) {
        signed = true;
        width *= -1;
    }
    // @TODO: Check range is valid for value
    return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, { signed, width });
}
function b(value, size) {
    // @TODO: Check range is valid for value
    return new Typed(_gaurd, `bytes${(size) ? size : ""}`, value, { size });
}
const _typedSymbol = Symbol.for("_ethers_typed");
/**
 *  The **Typed** class to wrap values providing explicit type information.
 */
class Typed {
    /**
     *  The type, as a Solidity-compatible type.
     */
    type;
    /**
     *  The actual value.
     */
    value;
    #options;
    /**
     *  @_ignore:
     */
    _typedSymbol;
    /**
     *  @_ignore:
     */
    constructor(gaurd, type, value, options) {
        if (options == null) {
            options = null;
        }
        assertPrivate(_gaurd, gaurd, "Typed");
        defineProperties(this, { _typedSymbol, type, value });
        this.#options = options;
        // Check the value is valid
        this.format();
    }
    /**
     *  Format the type as a Human-Readable type.
     */
    format() {
        if (this.type === "array") {
            throw new Error("");
        }
        else if (this.type === "dynamicArray") {
            throw new Error("");
        }
        else if (this.type === "tuple") {
            return `tuple(${this.value.map((v) => v.format()).join(",")})`;
        }
        return this.type;
    }
    /**
     *  The default value returned by this type.
     */
    defaultValue() {
        return 0;
    }
    /**
     *  The minimum value for numeric types.
     */
    minValue() {
        return 0;
    }
    /**
     *  The maximum value for numeric types.
     */
    maxValue() {
        return 0;
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
     */
    isBigInt() {
        return !!(this.type.match(/^u?int[0-9]+$/));
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
     */
    isData() {
        return this.type.startsWith("bytes");
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
     */
    isString() {
        return (this.type === "string");
    }
    /**
     *  Returns the tuple name, if this is a tuple. Throws otherwise.
     */
    get tupleName() {
        if (this.type !== "tuple") {
            throw TypeError("not a tuple");
        }
        return this.#options;
    }
    // Returns the length of this type as an array
    // - `null` indicates the length is unforced, it could be dynamic
    // - `-1` indicates the length is dynamic
    // - any other value indicates it is a static array and is its length
    /**
     *  Returns the length of the array type or ``-1`` if it is dynamic.
     *
     *  Throws if the type is not an array.
     */
    get arrayLength() {
        if (this.type !== "array") {
            throw TypeError("not an array");
        }
        if (this.#options === true) {
            return -1;
        }
        if (this.#options === false) {
            return (this.value).length;
        }
        return null;
    }
    /**
     *  Returns a new **Typed** of %%type%% with the %%value%%.
     */
    static from(type, value) {
        return new Typed(_gaurd, type, value);
    }
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
    static uint8(v) { return n(v, 8); }
    /**
     *  Return a new ``uint16`` type for %%v%%.
     */
    static uint16(v) { return n(v, 16); }
    /**
     *  Return a new ``uint24`` type for %%v%%.
     */
    static uint24(v) { return n(v, 24); }
    /**
     *  Return a new ``uint32`` type for %%v%%.
     */
    static uint32(v) { return n(v, 32); }
    /**
     *  Return a new ``uint40`` type for %%v%%.
     */
    static uint40(v) { return n(v, 40); }
    /**
     *  Return a new ``uint48`` type for %%v%%.
     */
    static uint48(v) { return n(v, 48); }
    /**
     *  Return a new ``uint56`` type for %%v%%.
     */
    static uint56(v) { return n(v, 56); }
    /**
     *  Return a new ``uint64`` type for %%v%%.
     */
    static uint64(v) { return n(v, 64); }
    /**
     *  Return a new ``uint72`` type for %%v%%.
     */
    static uint72(v) { return n(v, 72); }
    /**
     *  Return a new ``uint80`` type for %%v%%.
     */
    static uint80(v) { return n(v, 80); }
    /**
     *  Return a new ``uint88`` type for %%v%%.
     */
    static uint88(v) { return n(v, 88); }
    /**
     *  Return a new ``uint96`` type for %%v%%.
     */
    static uint96(v) { return n(v, 96); }
    /**
     *  Return a new ``uint104`` type for %%v%%.
     */
    static uint104(v) { return n(v, 104); }
    /**
     *  Return a new ``uint112`` type for %%v%%.
     */
    static uint112(v) { return n(v, 112); }
    /**
     *  Return a new ``uint120`` type for %%v%%.
     */
    static uint120(v) { return n(v, 120); }
    /**
     *  Return a new ``uint128`` type for %%v%%.
     */
    static uint128(v) { return n(v, 128); }
    /**
     *  Return a new ``uint136`` type for %%v%%.
     */
    static uint136(v) { return n(v, 136); }
    /**
     *  Return a new ``uint144`` type for %%v%%.
     */
    static uint144(v) { return n(v, 144); }
    /**
     *  Return a new ``uint152`` type for %%v%%.
     */
    static uint152(v) { return n(v, 152); }
    /**
     *  Return a new ``uint160`` type for %%v%%.
     */
    static uint160(v) { return n(v, 160); }
    /**
     *  Return a new ``uint168`` type for %%v%%.
     */
    static uint168(v) { return n(v, 168); }
    /**
     *  Return a new ``uint176`` type for %%v%%.
     */
    static uint176(v) { return n(v, 176); }
    /**
     *  Return a new ``uint184`` type for %%v%%.
     */
    static uint184(v) { return n(v, 184); }
    /**
     *  Return a new ``uint192`` type for %%v%%.
     */
    static uint192(v) { return n(v, 192); }
    /**
     *  Return a new ``uint200`` type for %%v%%.
     */
    static uint200(v) { return n(v, 200); }
    /**
     *  Return a new ``uint208`` type for %%v%%.
     */
    static uint208(v) { return n(v, 208); }
    /**
     *  Return a new ``uint216`` type for %%v%%.
     */
    static uint216(v) { return n(v, 216); }
    /**
     *  Return a new ``uint224`` type for %%v%%.
     */
    static uint224(v) { return n(v, 224); }
    /**
     *  Return a new ``uint232`` type for %%v%%.
     */
    static uint232(v) { return n(v, 232); }
    /**
     *  Return a new ``uint240`` type for %%v%%.
     */
    static uint240(v) { return n(v, 240); }
    /**
     *  Return a new ``uint248`` type for %%v%%.
     */
    static uint248(v) { return n(v, 248); }
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
    static uint256(v) { return n(v, 256); }
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
    static uint(v) { return n(v, 256); }
    /**
     *  Return a new ``int8`` type for %%v%%.
     */
    static int8(v) { return n(v, -8); }
    /**
     *  Return a new ``int16`` type for %%v%%.
     */
    static int16(v) { return n(v, -16); }
    /**
     *  Return a new ``int24`` type for %%v%%.
     */
    static int24(v) { return n(v, -24); }
    /**
     *  Return a new ``int32`` type for %%v%%.
     */
    static int32(v) { return n(v, -32); }
    /**
     *  Return a new ``int40`` type for %%v%%.
     */
    static int40(v) { return n(v, -40); }
    /**
     *  Return a new ``int48`` type for %%v%%.
     */
    static int48(v) { return n(v, -48); }
    /**
     *  Return a new ``int56`` type for %%v%%.
     */
    static int56(v) { return n(v, -56); }
    /**
     *  Return a new ``int64`` type for %%v%%.
     */
    static int64(v) { return n(v, -64); }
    /**
     *  Return a new ``int72`` type for %%v%%.
     */
    static int72(v) { return n(v, -72); }
    /**
     *  Return a new ``int80`` type for %%v%%.
     */
    static int80(v) { return n(v, -80); }
    /**
     *  Return a new ``int88`` type for %%v%%.
     */
    static int88(v) { return n(v, -88); }
    /**
     *  Return a new ``int96`` type for %%v%%.
     */
    static int96(v) { return n(v, -96); }
    /**
     *  Return a new ``int104`` type for %%v%%.
     */
    static int104(v) { return n(v, -104); }
    /**
     *  Return a new ``int112`` type for %%v%%.
     */
    static int112(v) { return n(v, -112); }
    /**
     *  Return a new ``int120`` type for %%v%%.
     */
    static int120(v) { return n(v, -120); }
    /**
     *  Return a new ``int128`` type for %%v%%.
     */
    static int128(v) { return n(v, -128); }
    /**
     *  Return a new ``int136`` type for %%v%%.
     */
    static int136(v) { return n(v, -136); }
    /**
     *  Return a new ``int144`` type for %%v%%.
     */
    static int144(v) { return n(v, -144); }
    /**
     *  Return a new ``int52`` type for %%v%%.
     */
    static int152(v) { return n(v, -152); }
    /**
     *  Return a new ``int160`` type for %%v%%.
     */
    static int160(v) { return n(v, -160); }
    /**
     *  Return a new ``int168`` type for %%v%%.
     */
    static int168(v) { return n(v, -168); }
    /**
     *  Return a new ``int176`` type for %%v%%.
     */
    static int176(v) { return n(v, -176); }
    /**
     *  Return a new ``int184`` type for %%v%%.
     */
    static int184(v) { return n(v, -184); }
    /**
     *  Return a new ``int92`` type for %%v%%.
     */
    static int192(v) { return n(v, -192); }
    /**
     *  Return a new ``int200`` type for %%v%%.
     */
    static int200(v) { return n(v, -200); }
    /**
     *  Return a new ``int208`` type for %%v%%.
     */
    static int208(v) { return n(v, -208); }
    /**
     *  Return a new ``int216`` type for %%v%%.
     */
    static int216(v) { return n(v, -216); }
    /**
     *  Return a new ``int224`` type for %%v%%.
     */
    static int224(v) { return n(v, -224); }
    /**
     *  Return a new ``int232`` type for %%v%%.
     */
    static int232(v) { return n(v, -232); }
    /**
     *  Return a new ``int240`` type for %%v%%.
     */
    static int240(v) { return n(v, -240); }
    /**
     *  Return a new ``int248`` type for %%v%%.
     */
    static int248(v) { return n(v, -248); }
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
    static int256(v) { return n(v, -256); }
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
    static int(v) { return n(v, -256); }
    /**
     *  Return a new ``bytes1`` type for %%v%%.
     */
    static bytes1(v) { return b(v, 1); }
    /**
     *  Return a new ``bytes2`` type for %%v%%.
     */
    static bytes2(v) { return b(v, 2); }
    /**
     *  Return a new ``bytes3`` type for %%v%%.
     */
    static bytes3(v) { return b(v, 3); }
    /**
     *  Return a new ``bytes4`` type for %%v%%.
     */
    static bytes4(v) { return b(v, 4); }
    /**
     *  Return a new ``bytes5`` type for %%v%%.
     */
    static bytes5(v) { return b(v, 5); }
    /**
     *  Return a new ``bytes6`` type for %%v%%.
     */
    static bytes6(v) { return b(v, 6); }
    /**
     *  Return a new ``bytes7`` type for %%v%%.
     */
    static bytes7(v) { return b(v, 7); }
    /**
     *  Return a new ``bytes8`` type for %%v%%.
     */
    static bytes8(v) { return b(v, 8); }
    /**
     *  Return a new ``bytes9`` type for %%v%%.
     */
    static bytes9(v) { return b(v, 9); }
    /**
     *  Return a new ``bytes10`` type for %%v%%.
     */
    static bytes10(v) { return b(v, 10); }
    /**
     *  Return a new ``bytes11`` type for %%v%%.
     */
    static bytes11(v) { return b(v, 11); }
    /**
     *  Return a new ``bytes12`` type for %%v%%.
     */
    static bytes12(v) { return b(v, 12); }
    /**
     *  Return a new ``bytes13`` type for %%v%%.
     */
    static bytes13(v) { return b(v, 13); }
    /**
     *  Return a new ``bytes14`` type for %%v%%.
     */
    static bytes14(v) { return b(v, 14); }
    /**
     *  Return a new ``bytes15`` type for %%v%%.
     */
    static bytes15(v) { return b(v, 15); }
    /**
     *  Return a new ``bytes16`` type for %%v%%.
     */
    static bytes16(v) { return b(v, 16); }
    /**
     *  Return a new ``bytes17`` type for %%v%%.
     */
    static bytes17(v) { return b(v, 17); }
    /**
     *  Return a new ``bytes18`` type for %%v%%.
     */
    static bytes18(v) { return b(v, 18); }
    /**
     *  Return a new ``bytes19`` type for %%v%%.
     */
    static bytes19(v) { return b(v, 19); }
    /**
     *  Return a new ``bytes20`` type for %%v%%.
     */
    static bytes20(v) { return b(v, 20); }
    /**
     *  Return a new ``bytes21`` type for %%v%%.
     */
    static bytes21(v) { return b(v, 21); }
    /**
     *  Return a new ``bytes22`` type for %%v%%.
     */
    static bytes22(v) { return b(v, 22); }
    /**
     *  Return a new ``bytes23`` type for %%v%%.
     */
    static bytes23(v) { return b(v, 23); }
    /**
     *  Return a new ``bytes24`` type for %%v%%.
     */
    static bytes24(v) { return b(v, 24); }
    /**
     *  Return a new ``bytes25`` type for %%v%%.
     */
    static bytes25(v) { return b(v, 25); }
    /**
     *  Return a new ``bytes26`` type for %%v%%.
     */
    static bytes26(v) { return b(v, 26); }
    /**
     *  Return a new ``bytes27`` type for %%v%%.
     */
    static bytes27(v) { return b(v, 27); }
    /**
     *  Return a new ``bytes28`` type for %%v%%.
     */
    static bytes28(v) { return b(v, 28); }
    /**
     *  Return a new ``bytes29`` type for %%v%%.
     */
    static bytes29(v) { return b(v, 29); }
    /**
     *  Return a new ``bytes30`` type for %%v%%.
     */
    static bytes30(v) { return b(v, 30); }
    /**
     *  Return a new ``bytes31`` type for %%v%%.
     */
    static bytes31(v) { return b(v, 31); }
    /**
     *  Return a new ``bytes32`` type for %%v%%.
     */
    static bytes32(v) { return b(v, 32); }
    /**
     *  Return a new ``address`` type for %%v%%.
     */
    static address(v) { return new Typed(_gaurd, "address", v); }
    /**
     *  Return a new ``bool`` type for %%v%%.
     */
    static bool(v) { return new Typed(_gaurd, "bool", !!v); }
    /**
     *  Return a new ``bytes`` type for %%v%%.
     */
    static bytes(v) { return new Typed(_gaurd, "bytes", v); }
    /**
     *  Return a new ``string`` type for %%v%%.
     */
    static string(v) { return new Typed(_gaurd, "string", v); }
    /**
     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
     */
    static array(v, dynamic) {
        throw new Error("not implemented yet");
    }
    /**
     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
     */
    static tuple(v, name) {
        throw new Error("not implemented yet");
    }
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
    static overrides(v) {
        return new Typed(_gaurd, "overrides", Object.assign({}, v));
    }
    /**
     *  Returns true only if %%value%% is a [[Typed]] instance.
     */
    static isTyped(value) {
        return (value
            && typeof (value) === "object"
            && "_typedSymbol" in value
            && value._typedSymbol === _typedSymbol);
    }
    /**
     *  If the value is a [[Typed]] instance, validates the underlying value
     *  and returns it, otherwise returns value directly.
     *
     *  This is useful for functions that with to accept either a [[Typed]]
     *  object or values.
     */
    static dereference(value, type) {
        if (Typed.isTyped(value)) {
            if (value.type !== type) {
                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
            }
            return value.value;
        }
        return value;
    }
}

/**
 *  @_ignore
 */
class AddressCoder extends Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, _value) {
        let value = Typed.dereference(_value, "string");
        try {
            value = getAddress(value);
        }
        catch (error) {
            return this._throwError(error.message, _value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return getAddress(toBeHex(reader.readValue(), 20));
    }
}

/**
 *  Clones the functionality of an existing Coder, but without a localName
 *
 *  @_ignore
 */
class AnonymousCoder extends Coder {
    coder;
    constructor(coder) {
        super(coder.name, coder.type, "_", coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

/**
 *  @_ignore
 */
function pack(writer, coders, values) {
    let arrayValues = [];
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
            assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
            unique[name] = true;
            return values[name];
        });
    }
    else {
        assertArgument(false, "invalid tuple value", "tuple", values);
    }
    assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
    let staticWriter = new Writer();
    let dynamicWriter = new Writer();
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
/**
 *  @_ignore
 */
function unpack(reader, coders) {
    let values = [];
    let keys = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readIndex();
            let offsetReader = baseReader.subReader(offset);
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (isError(error, "BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (isError(error, "BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value == undefined) {
            throw new Error("investigate");
        }
        values.push(value);
        keys.push(coder.localName || null);
    });
    return Result.fromItems(values, keys);
}
/**
 *  @_ignore
 */
class ArrayCoder extends Coder {
    coder;
    length;
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        defineProperties(this, { coder, length });
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, _value) {
        const value = Typed.dereference(_value, "array");
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        assertArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readIndex();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
        }
        return unpack(reader, coders);
    }
}

/**
 *  @_ignore
 */
class BooleanCoder extends Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, _value) {
        const value = Typed.dereference(_value, "bool");
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return !!reader.readValue();
    }
}

/**
 *  @_ignore
 */
class DynamicBytesCoder extends Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = getBytesCopy(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readIndex(), true);
    }
}
/**
 *  @_ignore
 */
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return hexlify(super.decode(reader));
    }
}

/**
 *  @_ignore
 */
class FixedBytesCoder extends Coder {
    size;
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        defineProperties(this, { size }, { size: "number" });
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, _value) {
        let data = getBytesCopy(Typed.dereference(_value, this.type));
        if (data.length !== this.size) {
            this._throwError("incorrect data length", _value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return hexlify(reader.readBytes(this.size));
    }
}

const Empty = new Uint8Array([]);
/**
 *  @_ignore
 */
class NullCoder extends Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes(Empty);
    }
    decode(reader) {
        reader.readBytes(0);
        return null;
    }
}

const BN_0$5 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/**
 *  @_ignore
 */
class NumberCoder extends Coder {
    size;
    signed;
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        defineProperties(this, { size, signed }, { size: "number", signed: "boolean" });
    }
    defaultValue() {
        return 0;
    }
    encode(writer, _value) {
        let value = getBigInt(Typed.dereference(_value, this.type));
        // Check bounds are safe for encoding
        let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
        if (this.signed) {
            let bounds = mask(maxUintValue, (this.size * 8) - 1);
            if (value > bounds || value < -(bounds + BN_1$1)) {
                this._throwError("value out-of-bounds", _value);
            }
            value = toTwos(value, 8 * WordSize);
        }
        else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
            this._throwError("value out-of-bounds", _value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        let value = mask(reader.readValue(), this.size * 8);
        if (this.signed) {
            value = fromTwos(value, this.size * 8);
        }
        return value;
    }
}

/**
 *  @_ignore
 */
class StringCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, _value) {
        return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
    }
    decode(reader) {
        return toUtf8String(super.decode(reader));
    }
}

/**
 *  @_ignore
 */
class TupleCoder extends Coder {
    coders;
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        defineProperties(this, { coders: Object.freeze(coders.slice()) });
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, _value) {
        const value = Typed.dereference(_value, "tuple");
        return pack(writer, this.coders, value);
    }
    decode(reader) {
        return unpack(reader, this.coders);
    }
}

function accessSetify(addr, storageKeys) {
    return {
        address: getAddress(addr),
        storageKeys: storageKeys.map((storageKey, index) => {
            assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
            return storageKey.toLowerCase();
        })
    };
}
/**
 *  Returns a [[AccessList]] from any ethers-supported access-list structure.
 */
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
                return accessSetify(set[0], set[1]);
            }
            assertArgument(set != null && typeof (set) === "object", "invalid address-slot set", "value", value);
            return accessSetify(set.address, set.storageKeys);
        });
    }
    assertArgument(value != null && typeof (value) === "object", "invalid access list", "value", value);
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => (a.address.localeCompare(b.address)));
    return result;
}

function authorizationify(auth) {
    return {
        address: getAddress(auth.address),
        nonce: getBigInt((auth.nonce != null) ? auth.nonce : 0),
        chainId: getBigInt((auth.chainId != null) ? auth.chainId : 0),
        signature: Signature.from(auth.signature)
    };
}

/**
 *  Returns the address for the %%key%%.
 *
 *  The key may be any standard form of public key or a private key.
 */
function computeAddress(key) {
    let pubkey;
    if (typeof (key) === "string") {
        pubkey = SigningKey.computePublicKey(key, false);
    }
    else {
        pubkey = key.publicKey;
    }
    return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
/**
 *  Returns the recovered address for the private key that was
 *  used to sign %%digest%% that resulted in %%signature%%.
 */
function recoverAddress(digest, signature) {
    return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}

const BN_0$4 = BigInt(0);
const BN_2$1 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getKzgLibrary(kzg) {
    const blobToKzgCommitment = (blob) => {
        if ("computeBlobProof" in kzg) {
            // micro-ecc-signer; check for computeBlobProof since this API
            // expects a string while the kzg-wasm below expects a Unit8Array
            if ("blobToKzgCommitment" in kzg && typeof (kzg.blobToKzgCommitment) === "function") {
                return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));
            }
        }
        else if ("blobToKzgCommitment" in kzg && typeof (kzg.blobToKzgCommitment) === "function") {
            // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array
            return getBytes(kzg.blobToKzgCommitment(blob));
        }
        // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string
        if ("blobToKZGCommitment" in kzg && typeof (kzg.blobToKZGCommitment) === "function") {
            return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));
        }
        assertArgument(false, "unsupported KZG library", "kzg", kzg);
    };
    const computeBlobKzgProof = (blob, commitment) => {
        // micro-ecc-signer
        if ("computeBlobProof" in kzg && typeof (kzg.computeBlobProof) === "function") {
            return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));
        }
        // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array
        if ("computeBlobKzgProof" in kzg && typeof (kzg.computeBlobKzgProof) === "function") {
            return kzg.computeBlobKzgProof(blob, commitment);
        }
        // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string
        if ("computeBlobKZGProof" in kzg && typeof (kzg.computeBlobKZGProof) === "function") {
            return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));
        }
        assertArgument(false, "unsupported KZG library", "kzg", kzg);
    };
    return { blobToKzgCommitment, computeBlobKzgProof };
}
function getVersionedHash(version, hash) {
    let versioned = version.toString(16);
    while (versioned.length < 2) {
        versioned = "0" + versioned;
    }
    versioned += sha256(hash).substring(4);
    return "0x" + versioned;
}
function handleAddress(value) {
    if (value === "0x") {
        return null;
    }
    return getAddress(value);
}
function handleAccessList(value, param) {
    try {
        return accessListify(value);
    }
    catch (error) {
        assertArgument(false, error.message, param, value);
    }
}
function handleAuthorizationList(value, param) {
    try {
        if (!Array.isArray(value)) {
            throw new Error("authorizationList: invalid array");
        }
        const result = [];
        for (let i = 0; i < value.length; i++) {
            const auth = value[i];
            if (!Array.isArray(auth)) {
                throw new Error(`authorization[${i}]: invalid array`);
            }
            if (auth.length !== 6) {
                throw new Error(`authorization[${i}]: wrong length`);
            }
            if (!auth[1]) {
                throw new Error(`authorization[${i}]: null address`);
            }
            result.push({
                address: handleAddress(auth[1]),
                nonce: handleUint(auth[2], "nonce"),
                chainId: handleUint(auth[0], "chainId"),
                signature: Signature.from({
                    yParity: handleNumber(auth[3], "yParity"),
                    r: zeroPadValue(auth[4], 32),
                    s: zeroPadValue(auth[5], 32)
                })
            });
        }
        return result;
    }
    catch (error) {
        assertArgument(false, error.message, param, value);
    }
}
function handleNumber(_value, param) {
    if (_value === "0x") {
        return 0;
    }
    return getNumber(_value, param);
}
function handleUint(_value, param) {
    if (_value === "0x") {
        return BN_0$4;
    }
    const value = getBigInt(_value, param);
    assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
    return value;
}
function formatNumber(_value, name) {
    const value = getBigInt(_value, "value");
    const result = toBeArray(value);
    assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
    return result;
}
function formatAccessList(value) {
    return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatAuthorizationList(value) {
    return value.map((a) => {
        return [
            formatNumber(a.chainId, "chainId"),
            a.address,
            formatNumber(a.nonce, "nonce"),
            formatNumber(a.signature.yParity, "yParity"),
            toBeArray(a.signature.r),
            toBeArray(a.signature.s)
        ];
    });
}
function formatHashes(value, param) {
    assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
    for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
    }
    return value;
}
function _parseLegacy(data) {
    const fields = decodeRlp(data);
    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
    const tx = {
        type: 0,
        nonce: handleNumber(fields[0], "nonce"),
        gasPrice: handleUint(fields[1], "gasPrice"),
        gasLimit: handleUint(fields[2], "gasLimit"),
        to: handleAddress(fields[3]),
        value: handleUint(fields[4], "value"),
        data: hexlify(fields[5]),
        chainId: BN_0$4
    };
    // Legacy unsigned transaction
    if (fields.length === 6) {
        return tx;
    }
    const v = handleUint(fields[6], "v");
    const r = handleUint(fields[7], "r");
    const s = handleUint(fields[8], "s");
    if (r === BN_0$4 && s === BN_0$4) {
        // EIP-155 unsigned transaction
        tx.chainId = v;
    }
    else {
        // Compute the EIP-155 chain ID (or 0 for legacy)
        let chainId = (v - BN_35) / BN_2$1;
        if (chainId < BN_0$4) {
            chainId = BN_0$4;
        }
        tx.chainId = chainId;
        // Signed Legacy Transaction
        assertArgument(chainId !== BN_0$4 || (v === BN_27 || v === BN_28), "non-canonical legacy v", "v", fields[6]);
        tx.signature = Signature.from({
            r: zeroPadValue(fields[7], 32),
            s: zeroPadValue(fields[8], 32),
            v
        });
        //tx.hash = keccak256(data);
    }
    return tx;
}
function _serializeLegacy(tx, sig) {
    const fields = [
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.gasPrice || 0, "gasPrice"),
        formatNumber(tx.gasLimit, "gasLimit"),
        (tx.to || "0x"),
        formatNumber(tx.value, "value"),
        tx.data,
    ];
    let chainId = BN_0$4;
    if (tx.chainId != BN_0$4) {
        // A chainId was provided; if non-zero we'll use EIP-155
        chainId = getBigInt(tx.chainId, "tx.chainId");
        // We have a chainId in the tx and an EIP-155 v in the signature,
        // make sure they agree with each other
        assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
    }
    else if (tx.signature) {
        // No explicit chainId, but EIP-155 have a derived implicit chainId
        const legacy = tx.signature.legacyChainId;
        if (legacy != null) {
            chainId = legacy;
        }
    }
    // Requesting an unsigned transaction
    if (!sig) {
        // We have an EIP-155 transaction (chainId was specified and non-zero)
        if (chainId !== BN_0$4) {
            fields.push(toBeArray(chainId));
            fields.push("0x");
            fields.push("0x");
        }
        return encodeRlp(fields);
    }
    // @TODO: We should probably check that tx.signature, chainId, and sig
    //        match but that logic could break existing code, so schedule
    //        this for the next major bump.
    // Compute the EIP-155 v
    let v = BigInt(27 + sig.yParity);
    if (chainId !== BN_0$4) {
        v = Signature.getChainIdV(chainId, sig.v);
    }
    else if (BigInt(sig.v) !== v) {
        assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
    }
    // Add the signature
    fields.push(toBeArray(v));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
    let yParity;
    try {
        yParity = handleNumber(fields[0], "yParity");
        if (yParity !== 0 && yParity !== 1) {
            throw new Error("bad yParity");
        }
    }
    catch (error) {
        assertArgument(false, "invalid yParity", "yParity", fields[0]);
    }
    const r = zeroPadValue(fields[1], 32);
    const s = zeroPadValue(fields[2], 32);
    const signature = Signature.from({ r, s, yParity });
    tx.signature = signature;
}
function _parseEip1559(data) {
    const fields = decodeRlp(getBytes(data).slice(1));
    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
    const tx = {
        type: 2,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
        maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: handleUint(fields[4], "gasLimit"),
        to: handleAddress(fields[5]),
        value: handleUint(fields[6], "value"),
        data: hexlify(fields[7]),
        accessList: handleAccessList(fields[8], "accessList"),
    };
    // Unsigned EIP-1559 Transaction
    if (fields.length === 9) {
        return tx;
    }
    //tx.hash = keccak256(data);
    _parseEipSignature(tx, fields.slice(9));
    return tx;
}
function _serializeEip1559(tx, sig) {
    const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(tx.gasLimit, "gasLimit"),
        (tx.to || "0x"),
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || [])
    ];
    if (sig) {
        fields.push(formatNumber(sig.yParity, "yParity"));
        fields.push(toBeArray(sig.r));
        fields.push(toBeArray(sig.s));
    }
    return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
    const fields = decodeRlp(getBytes(data).slice(1));
    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
    const tx = {
        type: 1,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        gasPrice: handleUint(fields[2], "gasPrice"),
        gasLimit: handleUint(fields[3], "gasLimit"),
        to: handleAddress(fields[4]),
        value: handleUint(fields[5], "value"),
        data: hexlify(fields[6]),
        accessList: handleAccessList(fields[7], "accessList")
    };
    // Unsigned EIP-2930 Transaction
    if (fields.length === 8) {
        return tx;
    }
    //tx.hash = keccak256(data);
    _parseEipSignature(tx, fields.slice(8));
    return tx;
}
function _serializeEip2930(tx, sig) {
    const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.gasPrice || 0, "gasPrice"),
        formatNumber(tx.gasLimit, "gasLimit"),
        (tx.to || "0x"),
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || [])
    ];
    if (sig) {
        fields.push(formatNumber(sig.yParity, "recoveryParam"));
        fields.push(toBeArray(sig.r));
        fields.push(toBeArray(sig.s));
    }
    return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
    let fields = decodeRlp(getBytes(data).slice(1));
    let typeName = "3";
    let blobs = null;
    // Parse the network format
    if (fields.length === 4 && Array.isArray(fields[0])) {
        typeName = "3 (network format)";
        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
        assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
        assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
        assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
        assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
        assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
        blobs = [];
        for (let i = 0; i < fields[1].length; i++) {
            blobs.push({
                data: fBlobs[i],
                commitment: fCommits[i],
                proof: fProofs[i],
            });
        }
        fields = fields[0];
    }
    assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
    const tx = {
        type: 3,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
        maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: handleUint(fields[4], "gasLimit"),
        to: handleAddress(fields[5]),
        value: handleUint(fields[6], "value"),
        data: hexlify(fields[7]),
        accessList: handleAccessList(fields[8], "accessList"),
        maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
        blobVersionedHashes: fields[10]
    };
    if (blobs) {
        tx.blobs = blobs;
    }
    assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
    assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
        assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
    }
    // Unsigned EIP-4844 Transaction
    if (fields.length === 11) {
        return tx;
    }
    // @TODO: Do we need to do this? This is only called internally
    // and used to verify hashes; it might save time to not do this
    //tx.hash = keccak256(concat([ "0x03", encodeRlp(fields) ]));
    _parseEipSignature(tx, fields.slice(11));
    return tx;
}
function _serializeEip4844(tx, sig, blobs) {
    const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(tx.gasLimit, "gasLimit"),
        (tx.to || ZeroAddress),
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || []),
        formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
        formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
    ];
    if (sig) {
        fields.push(formatNumber(sig.yParity, "yParity"));
        fields.push(toBeArray(sig.r));
        fields.push(toBeArray(sig.s));
        // We have blobs; return the network wrapped format
        if (blobs) {
            return concat([
                "0x03",
                encodeRlp([
                    fields,
                    blobs.map((b) => b.data),
                    blobs.map((b) => b.commitment),
                    blobs.map((b) => b.proof),
                ])
            ]);
        }
    }
    return concat(["0x03", encodeRlp(fields)]);
}
function _parseEip7702(data) {
    const fields = decodeRlp(getBytes(data).slice(1));
    assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), "invalid field count for transaction type: 4", "data", hexlify(data));
    const tx = {
        type: 4,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
        maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: handleUint(fields[4], "gasLimit"),
        to: handleAddress(fields[5]),
        value: handleUint(fields[6], "value"),
        data: hexlify(fields[7]),
        accessList: handleAccessList(fields[8], "accessList"),
        authorizationList: handleAuthorizationList(fields[9], "authorizationList"),
    };
    // Unsigned EIP-7702 Transaction
    if (fields.length === 10) {
        return tx;
    }
    _parseEipSignature(tx, fields.slice(10));
    return tx;
}
function _serializeEip7702(tx, sig) {
    const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(tx.gasLimit, "gasLimit"),
        (tx.to || "0x"),
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || []),
        formatAuthorizationList(tx.authorizationList || [])
    ];
    if (sig) {
        fields.push(formatNumber(sig.yParity, "yParity"));
        fields.push(toBeArray(sig.r));
        fields.push(toBeArray(sig.s));
    }
    return concat(["0x04", encodeRlp(fields)]);
}
/**
 *  A **Transaction** describes an operation to be executed on
 *  Ethereum by an Externally Owned Account (EOA). It includes
 *  who (the [[to]] address), what (the [[data]]) and how much (the
 *  [[value]] in ether) the operation should entail.
 *
 *  @example:
 *    tx = new Transaction()
 *    //_result:
 *
 *    tx.data = "0x1234";
 *    //_result:
 */
class Transaction {
    #type;
    #to;
    #data;
    #nonce;
    #gasLimit;
    #gasPrice;
    #maxPriorityFeePerGas;
    #maxFeePerGas;
    #value;
    #chainId;
    #sig;
    #accessList;
    #maxFeePerBlobGas;
    #blobVersionedHashes;
    #kzg;
    #blobs;
    #auths;
    /**
     *  The transaction type.
     *
     *  If null, the type will be automatically inferred based on
     *  explicit properties.
     */
    get type() { return this.#type; }
    set type(value) {
        switch (value) {
            case null:
                this.#type = null;
                break;
            case 0:
            case "legacy":
                this.#type = 0;
                break;
            case 1:
            case "berlin":
            case "eip-2930":
                this.#type = 1;
                break;
            case 2:
            case "london":
            case "eip-1559":
                this.#type = 2;
                break;
            case 3:
            case "cancun":
            case "eip-4844":
                this.#type = 3;
                break;
            case 4:
            case "pectra":
            case "eip-7702":
                this.#type = 4;
                break;
            default:
                assertArgument(false, "unsupported transaction type", "type", value);
        }
    }
    /**
     *  The name of the transaction type.
     */
    get typeName() {
        switch (this.type) {
            case 0: return "legacy";
            case 1: return "eip-2930";
            case 2: return "eip-1559";
            case 3: return "eip-4844";
            case 4: return "eip-7702";
        }
        return null;
    }
    /**
     *  The ``to`` address for the transaction or ``null`` if the
     *  transaction is an ``init`` transaction.
     */
    get to() {
        const value = this.#to;
        if (value == null && this.type === 3) {
            return ZeroAddress;
        }
        return value;
    }
    set to(value) {
        this.#to = (value == null) ? null : getAddress(value);
    }
    /**
     *  The transaction nonce.
     */
    get nonce() { return this.#nonce; }
    set nonce(value) { this.#nonce = getNumber(value, "value"); }
    /**
     *  The gas limit.
     */
    get gasLimit() { return this.#gasLimit; }
    set gasLimit(value) { this.#gasLimit = getBigInt(value); }
    /**
     *  The gas price.
     *
     *  On legacy networks this defines the fee that will be paid. On
     *  EIP-1559 networks, this should be ``null``.
     */
    get gasPrice() {
        const value = this.#gasPrice;
        if (value == null && (this.type === 0 || this.type === 1)) {
            return BN_0$4;
        }
        return value;
    }
    set gasPrice(value) {
        this.#gasPrice = (value == null) ? null : getBigInt(value, "gasPrice");
    }
    /**
     *  The maximum priority fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
    get maxPriorityFeePerGas() {
        const value = this.#maxPriorityFeePerGas;
        if (value == null) {
            if (this.type === 2 || this.type === 3) {
                return BN_0$4;
            }
            return null;
        }
        return value;
    }
    set maxPriorityFeePerGas(value) {
        this.#maxPriorityFeePerGas = (value == null) ? null : getBigInt(value, "maxPriorityFeePerGas");
    }
    /**
     *  The maximum total fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
    get maxFeePerGas() {
        const value = this.#maxFeePerGas;
        if (value == null) {
            if (this.type === 2 || this.type === 3) {
                return BN_0$4;
            }
            return null;
        }
        return value;
    }
    set maxFeePerGas(value) {
        this.#maxFeePerGas = (value == null) ? null : getBigInt(value, "maxFeePerGas");
    }
    /**
     *  The transaction data. For ``init`` transactions this is the
     *  deployment code.
     */
    get data() { return this.#data; }
    set data(value) { this.#data = hexlify(value); }
    /**
     *  The amount of ether (in wei) to send in this transactions.
     */
    get value() { return this.#value; }
    set value(value) {
        this.#value = getBigInt(value, "value");
    }
    /**
     *  The chain ID this transaction is valid on.
     */
    get chainId() { return this.#chainId; }
    set chainId(value) { this.#chainId = getBigInt(value); }
    /**
     *  If signed, the signature for this transaction.
     */
    get signature() { return this.#sig || null; }
    set signature(value) {
        this.#sig = (value == null) ? null : Signature.from(value);
    }
    /**
     *  The access list.
     *
     *  An access list permits discounted (but pre-paid) access to
     *  bytecode and state variable access within contract execution.
     */
    get accessList() {
        const value = this.#accessList || null;
        if (value == null) {
            if (this.type === 1 || this.type === 2 || this.type === 3) {
                // @TODO: in v7, this should assign the value or become
                // a live object itself, otherwise mutation is inconsistent
                return [];
            }
            return null;
        }
        return value;
    }
    set accessList(value) {
        this.#accessList = (value == null) ? null : accessListify(value);
    }
    get authorizationList() {
        const value = this.#auths || null;
        if (value == null) {
            if (this.type === 4) {
                // @TODO: in v7, this should become a live object itself,
                // otherwise mutation is inconsistent
                return [];
            }
        }
        return value;
    }
    set authorizationList(auths) {
        this.#auths = (auths == null) ? null : auths.map((a) => authorizationify(a));
    }
    /**
     *  The max fee per blob gas for Cancun transactions.
     */
    get maxFeePerBlobGas() {
        const value = this.#maxFeePerBlobGas;
        if (value == null && this.type === 3) {
            return BN_0$4;
        }
        return value;
    }
    set maxFeePerBlobGas(value) {
        this.#maxFeePerBlobGas = (value == null) ? null : getBigInt(value, "maxFeePerBlobGas");
    }
    /**
     *  The BLOb versioned hashes for Cancun transactions.
     */
    get blobVersionedHashes() {
        // @TODO: Mutation is inconsistent; if unset, the returned value
        // cannot mutate the object, if set it can
        let value = this.#blobVersionedHashes;
        if (value == null && this.type === 3) {
            return [];
        }
        return value;
    }
    set blobVersionedHashes(value) {
        if (value != null) {
            assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
            value = value.slice();
            for (let i = 0; i < value.length; i++) {
                assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
            }
        }
        this.#blobVersionedHashes = value;
    }
    /**
     *  The BLObs for the Transaction, if any.
     *
     *  If ``blobs`` is non-``null``, then the [[seriailized]]
     *  will return the network formatted sidecar, otherwise it
     *  will return the standard [[link-eip-2718]] payload. The
     *  [[unsignedSerialized]] is unaffected regardless.
     *
     *  When setting ``blobs``, either fully valid [[Blob]] objects
     *  may be specified (i.e. correctly padded, with correct
     *  committments and proofs) or a raw [[BytesLike]] may
     *  be provided.
     *
     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
     *  be already set. The blob will be correctly padded and the
     *  [[KzgLibrary]] will be used to compute the committment and
     *  proof for the blob.
     *
     *  A BLOb is a sequence of field elements, each of which must
     *  be within the BLS field modulo, so some additional processing
     *  may be required to encode arbitrary data to ensure each 32 byte
     *  field is within the valid range.
     *
     *  Setting this automatically populates [[blobVersionedHashes]],
     *  overwriting any existing values. Setting this to ``null``
     *  does **not** remove the [[blobVersionedHashes]], leaving them
     *  present.
     */
    get blobs() {
        if (this.#blobs == null) {
            return null;
        }
        return this.#blobs.map((b) => Object.assign({}, b));
    }
    set blobs(_blobs) {
        if (_blobs == null) {
            this.#blobs = null;
            return;
        }
        const blobs = [];
        const versionedHashes = [];
        for (let i = 0; i < _blobs.length; i++) {
            const blob = _blobs[i];
            if (isBytesLike(blob)) {
                assert(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
                    operation: "set blobs()"
                });
                let data = getBytes(blob);
                assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
                // Pad blob if necessary
                if (data.length !== BLOB_SIZE) {
                    const padded = new Uint8Array(BLOB_SIZE);
                    padded.set(data);
                    data = padded;
                }
                const commit = this.#kzg.blobToKzgCommitment(data);
                const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));
                blobs.push({
                    data: hexlify(data),
                    commitment: hexlify(commit),
                    proof
                });
                versionedHashes.push(getVersionedHash(1, commit));
            }
            else {
                const commit = hexlify(blob.commitment);
                blobs.push({
                    data: hexlify(blob.data),
                    commitment: commit,
                    proof: hexlify(blob.proof)
                });
                versionedHashes.push(getVersionedHash(1, commit));
            }
        }
        this.#blobs = blobs;
        this.#blobVersionedHashes = versionedHashes;
    }
    get kzg() { return this.#kzg; }
    set kzg(kzg) {
        if (kzg == null) {
            this.#kzg = null;
        }
        else {
            this.#kzg = getKzgLibrary(kzg);
        }
    }
    /**
     *  Creates a new Transaction with default values.
     */
    constructor() {
        this.#type = null;
        this.#to = null;
        this.#nonce = 0;
        this.#gasLimit = BN_0$4;
        this.#gasPrice = null;
        this.#maxPriorityFeePerGas = null;
        this.#maxFeePerGas = null;
        this.#data = "0x";
        this.#value = BN_0$4;
        this.#chainId = BN_0$4;
        this.#sig = null;
        this.#accessList = null;
        this.#maxFeePerBlobGas = null;
        this.#blobVersionedHashes = null;
        this.#kzg = null;
        this.#blobs = null;
        this.#auths = null;
    }
    /**
     *  The transaction hash, if signed. Otherwise, ``null``.
     */
    get hash() {
        if (this.signature == null) {
            return null;
        }
        return keccak256(this.#getSerialized(true, false));
    }
    /**
     *  The pre-image hash of this transaction.
     *
     *  This is the digest that a [[Signer]] must sign to authorize
     *  this transaction.
     */
    get unsignedHash() {
        return keccak256(this.unsignedSerialized);
    }
    /**
     *  The sending address, if signed. Otherwise, ``null``.
     */
    get from() {
        if (this.signature == null) {
            return null;
        }
        return recoverAddress(this.unsignedHash, this.signature);
    }
    /**
     *  The public key of the sender, if signed. Otherwise, ``null``.
     */
    get fromPublicKey() {
        if (this.signature == null) {
            return null;
        }
        return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
    }
    /**
     *  Returns true if signed.
     *
     *  This provides a Type Guard that properties requiring a signed
     *  transaction are non-null.
     */
    isSigned() {
        return this.signature != null;
    }
    #getSerialized(signed, sidecar) {
        assert(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
        const sig = signed ? this.signature : null;
        switch (this.inferType()) {
            case 0:
                return _serializeLegacy(this, sig);
            case 1:
                return _serializeEip2930(this, sig);
            case 2:
                return _serializeEip1559(this, sig);
            case 3:
                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
            case 4:
                return _serializeEip7702(this, sig);
        }
        assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    }
    /**
     *  The serialized transaction.
     *
     *  This throws if the transaction is unsigned. For the pre-image,
     *  use [[unsignedSerialized]].
     */
    get serialized() {
        return this.#getSerialized(true, true);
    }
    /**
     *  The transaction pre-image.
     *
     *  The hash of this is the digest which needs to be signed to
     *  authorize this transaction.
     */
    get unsignedSerialized() {
        return this.#getSerialized(false, false);
    }
    /**
     *  Return the most "likely" type; currently the highest
     *  supported transaction type.
     */
    inferType() {
        const types = this.inferTypes();
        // Prefer London (EIP-1559) over Cancun (BLOb)
        if (types.indexOf(2) >= 0) {
            return 2;
        }
        // Return the highest inferred type
        return (types.pop());
    }
    /**
     *  Validates the explicit properties and returns a list of compatible
     *  transaction types.
     */
    inferTypes() {
        // Checks that there are no conflicting properties set
        const hasGasPrice = this.gasPrice != null;
        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);
        const hasAccessList = (this.accessList != null);
        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);
        //if (hasGasPrice && hasFee) {
        //    throw new Error("transaction cannot have gasPrice and maxFeePerGas");
        //}
        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
            assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
        }
        //if (this.type === 2 && hasGasPrice) {
        //    throw new Error("eip-1559 transaction cannot have gasPrice");
        //}
        assert(!hasFee || (this.type !== 0 && this.type !== 1), "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
        assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
        const types = [];
        // Explicit type
        if (this.type != null) {
            types.push(this.type);
        }
        else {
            if (this.authorizationList && this.authorizationList.length) {
                types.push(4);
            }
            else if (hasFee) {
                types.push(2);
            }
            else if (hasGasPrice) {
                types.push(1);
                if (!hasAccessList) {
                    types.push(0);
                }
            }
            else if (hasAccessList) {
                types.push(1);
                types.push(2);
            }
            else if (hasBlob && this.to) {
                types.push(3);
            }
            else {
                types.push(0);
                types.push(1);
                types.push(2);
                types.push(3);
            }
        }
        types.sort();
        return types;
    }
    /**
     *  Returns true if this transaction is a legacy transaction (i.e.
     *  ``type === 0``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isLegacy() {
        return (this.type === 0);
    }
    /**
     *  Returns true if this transaction is berlin hardform transaction (i.e.
     *  ``type === 1``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isBerlin() {
        return (this.type === 1);
    }
    /**
     *  Returns true if this transaction is london hardform transaction (i.e.
     *  ``type === 2``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isLondon() {
        return (this.type === 2);
    }
    /**
     *  Returns true if this transaction is an [[link-eip-4844]] BLOB
     *  transaction.
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isCancun() {
        return (this.type === 3);
    }
    /**
     *  Create a copy of this transaciton.
     */
    clone() {
        return Transaction.from(this);
    }
    /**
     *  Return a JSON-friendly object.
     */
    toJSON() {
        const s = (v) => {
            if (v == null) {
                return null;
            }
            return v.toString();
        };
        return {
            type: this.type,
            to: this.to,
            //            from: this.from,
            data: this.data,
            nonce: this.nonce,
            gasLimit: s(this.gasLimit),
            gasPrice: s(this.gasPrice),
            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
            maxFeePerGas: s(this.maxFeePerGas),
            value: s(this.value),
            chainId: s(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList
        };
    }
    /**
     *  Create a **Transaction** from a serialized transaction or a
     *  Transaction-like object.
     */
    static from(tx) {
        if (tx == null) {
            return new Transaction();
        }
        if (typeof (tx) === "string") {
            const payload = getBytes(tx);
            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??
                return Transaction.from(_parseLegacy(payload));
            }
            switch (payload[0]) {
                case 1: return Transaction.from(_parseEip2930(payload));
                case 2: return Transaction.from(_parseEip1559(payload));
                case 3: return Transaction.from(_parseEip4844(payload));
                case 4: return Transaction.from(_parseEip7702(payload));
            }
            assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
        }
        const result = new Transaction();
        if (tx.type != null) {
            result.type = tx.type;
        }
        if (tx.to != null) {
            result.to = tx.to;
        }
        if (tx.nonce != null) {
            result.nonce = tx.nonce;
        }
        if (tx.gasLimit != null) {
            result.gasLimit = tx.gasLimit;
        }
        if (tx.gasPrice != null) {
            result.gasPrice = tx.gasPrice;
        }
        if (tx.maxPriorityFeePerGas != null) {
            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
        }
        if (tx.maxFeePerGas != null) {
            result.maxFeePerGas = tx.maxFeePerGas;
        }
        if (tx.maxFeePerBlobGas != null) {
            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
        }
        if (tx.data != null) {
            result.data = tx.data;
        }
        if (tx.value != null) {
            result.value = tx.value;
        }
        if (tx.chainId != null) {
            result.chainId = tx.chainId;
        }
        if (tx.signature != null) {
            result.signature = Signature.from(tx.signature);
        }
        if (tx.accessList != null) {
            result.accessList = tx.accessList;
        }
        if (tx.authorizationList != null) {
            result.authorizationList = tx.authorizationList;
        }
        // This will get overwritten by blobs, if present
        if (tx.blobVersionedHashes != null) {
            result.blobVersionedHashes = tx.blobVersionedHashes;
        }
        // Make sure we assign the kzg before assigning blobs, which
        // require the library in the event raw blob data is provided.
        if (tx.kzg != null) {
            result.kzg = tx.kzg;
        }
        if (tx.blobs != null) {
            result.blobs = tx.blobs;
        }
        if (tx.hash != null) {
            assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
            assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
        }
        if (tx.from != null) {
            assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
            assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
        }
        return result;
    }
}

/**
 *  A simple hashing function which operates on UTF-8 strings to
 *  compute an 32-byte identifier.
 *
 *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes
 *  the [[keccak256]].
 *
 *  @example:
 *    id("hello world")
 *    //_result:
 */
function id$1(value) {
    return keccak256(toUtf8Bytes(value));
}

// created 2023-09-25T01:01:55.148Z
// compressed base64-encoded blob for include-ens data
// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
// see: https://github.com/adraffy/ens-normalize.js#security
// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32
var COMPRESSED$1 = 'AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI';
const FENCED = new Map([[8217,"apostrophe"],[8260,"fraction slash"],[12539,"middle dot"]]);
const NSM_MAX = 4;

function decode_arithmetic(bytes) {
	let pos = 0;
	function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }
	
	// decode the frequency table
	let symbol_count = u16();
	let total = 1;
	let acc = [0, 1]; // first symbol has frequency 1
	for (let i = 1; i < symbol_count; i++) {
		acc.push(total += u16());
	}

	// skip the sized-payload that the last 3 symbols index into
	let skip = u16();
	let pos_payload = pos;
	pos += skip;

	let read_width = 0;
	let read_buffer = 0; 
	function read_bit() {
		if (read_width == 0) {
			// this will read beyond end of buffer
			// but (undefined|0) => zero pad
			read_buffer = (read_buffer << 8) | bytes[pos++];
			read_width = 8;
		}
		return (read_buffer >> --read_width) & 1;
	}

	const N = 31;
	const FULL = 2**N;
	const HALF = FULL >>> 1;
	const QRTR = HALF >> 1;
	const MASK = FULL - 1;

	// fill register
	let register = 0;
	for (let i = 0; i < N; i++) register = (register << 1) | read_bit();

	let symbols = [];
	let low = 0;
	let range = FULL; // treat like a float
	while (true) {
		let value = Math.floor((((register - low + 1) * total) - 1) / range);
		let start = 0;
		let end = symbol_count;
		while (end - start > 1) { // binary search
			let mid = (start + end) >>> 1;
			if (value < acc[mid]) {
				end = mid;
			} else {
				start = mid;
			}
		}
		if (start == 0) break; // first symbol is end mark
		symbols.push(start);
		let a = low + Math.floor(range * acc[start]   / total);
		let b = low + Math.floor(range * acc[start+1] / total) - 1;
		while (((a ^ b) & HALF) == 0) {
			register = (register << 1) & MASK | read_bit();
			a = (a << 1) & MASK;
			b = (b << 1) & MASK | 1;
		}
		while (a & ~b & QRTR) {
			register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();
			a = (a << 1) ^ HALF;
			b = ((b ^ HALF) << 1) | HALF | 1;
		}
		low = a;
		range = 1 + b - a;
	}
	let offset = symbol_count - 4;
	return symbols.map(x => { // index into payload
		switch (x - offset) {
			case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);
			case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);
			case 1: return offset + bytes[pos_payload++];
			default: return x - 1;
		}
	});
}	

// returns an iterator which returns the next symbol
function read_payload(v) {
	let pos = 0;
	return () => v[pos++];
}
function read_compressed_payload(s) {
	return read_payload(decode_arithmetic(unsafe_atob(s)));
}

// unsafe in the sense:
// expected well-formed Base64 w/o padding 
// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4
function unsafe_atob(s) {
	let lookup = [];
	[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
	let n = s.length;
	let ret = new Uint8Array((6 * n) >> 3);
	for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
		carry = (carry << 6) | lookup[s.charCodeAt(i)];
		width += 6;
		if (width >= 8) {
			ret[pos++] = (carry >> (width -= 8));
		}
	}
	return ret;
}

// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) { 
	return (i & 1) ? (~i >> 1) : (i >> 1);
}

function read_deltas(n, next) {
	let v = Array(n);
	for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
	return v;
}

// [123][5] => [0 3] [1 1] [0 0]
function read_sorted(next, prev = 0) {
	let ret = [];
	while (true) {
		let x = next();
		let n = next();
		if (!n) break;
		prev += x;
		for (let i = 0; i < n; i++) {
			ret.push(prev + i);
		}
		prev += n + 1;
	}
	return ret;
}

function read_sorted_arrays(next) {
	return read_array_while(() => { 
		let v = read_sorted(next);
		if (v.length) return v;
	});
}

// returns map of x => ys
function read_mapped(next) {
	let ret = [];
	while (true) {
		let w = next();
		if (w == 0) break;
		ret.push(read_linear_table(w, next));
	}
	while (true) {
		let w = next() - 1;
		if (w < 0) break;
		ret.push(read_replacement_table(w, next));
	}
	return ret.flat();
}

// read until next is falsy
// return array of read values
function read_array_while(next) {
	let v = [];
	while (true) {
		let x = next(v.length);
		if (!x) break;
		v.push(x);
	}
	return v;
}

// read w columns of length n
// return as n rows of length w
function read_transposed(n, w, next) {
	let m = Array(n).fill().map(() => []);
	for (let i = 0; i < w; i++) {
		read_deltas(n, next).forEach((x, j) => m[j].push(x));
	}
	return m;
}
 
// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]
// where dx/dy = steps, n = run size, w = length of y
function read_linear_table(w, next) {
	let dx = 1 + next();
	let dy = next();
	let vN = read_array_while(next);
	let m = read_transposed(vN.length, 1+w, next);
	return m.flatMap((v, i) => {
		let [x, ...ys] = v;
		return Array(vN[i]).fill().map((_, j) => {
			let j_dy = j * dy;
			return [x + j * dx, ys.map(y => y + j_dy)];
		});
	});
}

// return [[x, ys...], ...]
// where w = length of y
function read_replacement_table(w, next) { 
	let n = 1 + next();
	let m = read_transposed(n, 1+w, next);
	return m.map(v => [v[0], v.slice(1)]);
}


function read_trie(next) {
	let ret = [];
	let sorted = read_sorted(next); 
	expand(decode([]), []);
	return ret; // not sorted
	function decode(Q) { // characters that lead into this node
		let S = next(); // state: valid, save, check
		let B = read_array_while(() => { // buckets leading to new nodes
			let cps = read_sorted(next).map(i => sorted[i]);
			if (cps.length) return decode(cps);
		});
		return {S, B, Q};
	}
	function expand({S, B}, cps, saved) {
		if (S & 4 && saved === cps[cps.length-1]) return;
		if (S & 2) saved = cps[cps.length-1];
		if (S & 1) ret.push(cps); 
		for (let br of B) {
			for (let cp of br.Q) {
				expand(br, [...cps, cp], saved);
			}
		}
	}
}

function hex_cp(cp) {
	return cp.toString(16).toUpperCase().padStart(2, '0');
}

function quote_cp(cp) {
	return `{${hex_cp(cp)}}`; // raffy convention: like "\u{X}" w/o the "\u"
}

/*
export function explode_cp(s) {
	return [...s].map(c => c.codePointAt(0));
}
*/
function explode_cp(s) { // this is about 2x faster
	let cps = [];
	for (let pos = 0, len = s.length; pos < len; ) {
		let cp = s.codePointAt(pos);
		pos += cp < 0x10000 ? 1 : 2;
		cps.push(cp);
	}
	return cps;
}

function str_from_cps(cps) {
	const chunk = 4096;
	let len = cps.length;
	if (len < chunk) return String.fromCodePoint(...cps);
	let buf = [];
	for (let i = 0; i < len; ) {
		buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
	}
	return buf.join('');
}

function compare_arrays(a, b) {
	let n = a.length;
	let c = n - b.length;
	for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
	return c;
}

// created 2023-09-25T01:01:55.148Z
// compressed base64-encoded blob for include-nf data
// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
// see: https://github.com/adraffy/ens-normalize.js#security
// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e
var COMPRESSED = 'AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g';

// https://unicode.org/reports/tr15/
// for reference implementation
// see: /derive/nf.js


// algorithmic hangul
// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)
const S0 = 0xAC00;
const L0 = 0x1100;
const V0 = 0x1161;
const T0 = 0x11A7;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1 = T0 + T_COUNT;

function unpack_cc(packed) {
	return (packed >> 24) & 0xFF;
}
function unpack_cp(packed) {
	return packed & 0xFFFFFF;
}

let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;

function init$1() {
	//console.time('nf');
	let r = read_compressed_payload(COMPRESSED);
	SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted
	EXCLUSIONS = new Set(read_sorted(r));
	DECOMP = new Map();
	RECOMP = new Map();
	for (let [cp, cps] of read_mapped(r)) {
		if (!EXCLUSIONS.has(cp) && cps.length == 2) {
			let [a, b] = cps;
			let bucket = RECOMP.get(a);
			if (!bucket) {
				bucket = new Map();
				RECOMP.set(a, bucket);
			}
			bucket.set(b, cp);
		}
		DECOMP.set(cp, cps.reverse()); // stored reversed
	}
	//console.timeEnd('nf');
	// 20230905: 11ms
}

function is_hangul(cp) {
	return cp >= S0 && cp < S1;
}

function compose_pair(a, b) {
	if (a >= L0 && a < L1 && b >= V0 && b < V1) {
		return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
	} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
		return a + (b - T0);
	} else {
		let recomp = RECOMP.get(a);
		if (recomp) {
			recomp = recomp.get(b);
			if (recomp) {
				return recomp;
			}
		}
		return -1;
	}
}

function decomposed(cps) {
	if (!SHIFTED_RANK) init$1();
	let ret = [];
	let buf = [];
	let check_order = false;
	function add(cp) {
		let cc = SHIFTED_RANK.get(cp);
		if (cc) {
			check_order = true;
			cp |= cc;
		}
		ret.push(cp);
	}
	for (let cp of cps) {
		while (true) {
			if (cp < 0x80) {
				ret.push(cp);
			} else if (is_hangul(cp)) {
				let s_index = cp - S0;
				let l_index = s_index / N_COUNT | 0;
				let v_index = (s_index % N_COUNT) / T_COUNT | 0;
				let t_index = s_index % T_COUNT;
				add(L0 + l_index);
				add(V0 + v_index);
				if (t_index > 0) add(T0 + t_index);
			} else {
				let mapped = DECOMP.get(cp);
				if (mapped) {
					buf.push(...mapped);
				} else {
					add(cp);
				}
			}
			if (!buf.length) break;
			cp = buf.pop();
		}
	}
	if (check_order && ret.length > 1) {
		let prev_cc = unpack_cc(ret[0]);
		for (let i = 1; i < ret.length; i++) {
			let cc = unpack_cc(ret[i]);
			if (cc == 0 || prev_cc <= cc) {
				prev_cc = cc;
				continue;
			}
			let j = i-1;
			while (true) {
				let tmp = ret[j+1];
				ret[j+1] = ret[j];
				ret[j] = tmp;
				if (!j) break;
				prev_cc = unpack_cc(ret[--j]);
				if (prev_cc <= cc) break;
			}
			prev_cc = unpack_cc(ret[i]);
		}
	}
	return ret;
}

function composed_from_decomposed(v) {
	let ret = [];
	let stack = [];
	let prev_cp = -1;
	let prev_cc = 0;
	for (let packed of v) {
		let cc = unpack_cc(packed);
		let cp = unpack_cp(packed);
		if (prev_cp == -1) {
			if (cc == 0) {
				prev_cp = cp;
			} else {
				ret.push(cp);
			}
		} else if (prev_cc > 0 && prev_cc >= cc) {
			if (cc == 0) {
				ret.push(prev_cp, ...stack);
				stack.length = 0;
				prev_cp = cp;
			} else {
				stack.push(cp);
			}
			prev_cc = cc;
		} else {
			let composed = compose_pair(prev_cp, cp);
			if (composed >= 0) {
				prev_cp = composed;
			} else if (prev_cc == 0 && cc == 0) {
				ret.push(prev_cp);
				prev_cp = cp;
			} else {
				stack.push(cp);
				prev_cc = cc;
			}
		}
	}
	if (prev_cp >= 0) {
		ret.push(prev_cp, ...stack);	
	}
	return ret;
}

// note: cps can be iterable
function nfd(cps) {
	return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
	return composed_from_decomposed(decomposed(cps));
}

const HYPHEN = 0x2D;
const STOP_CH = '.';
const FE0F = 0xFE0F;
const UNIQUE_PH = 1;

// 20230913: replace [...v] with Array_from(v) to avoid large spreads
const Array_from = x => Array.from(x); // Array.from.bind(Array);

function group_has_cp(g, cp) {
	// 20230913: keep primary and secondary distinct instead of creating valid union
	return g.P.has(cp) || g.Q.has(cp);
}

class Emoji extends Array {
	get is_emoji() { return true; } // free tagging system
}

let MAPPED, IGNORED, CM, NSM, ESCAPE, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;

function init() {
	if (MAPPED) return;
	
	let r = read_compressed_payload(COMPRESSED$1);
	const read_sorted_array = () => read_sorted(r);
	const read_sorted_set = () => new Set(read_sorted_array());
	const set_add_many = (set, v) => v.forEach(x => set.add(x));

	MAPPED = new Map(read_mapped(r)); 
	IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints

	/*
	// direct include from payload is smaller than the decompression code
	const FENCED = new Map(read_array_while(() => {
		let cp = r();
		if (cp) return [cp, read_str(r())];
	}));
	*/
	// 20230217: we still need all CM for proper error formatting
	// but norm only needs NSM subset that are potentially-valid
	CM = read_sorted_array();
	NSM = new Set(read_sorted_array().map(i => CM[i]));
	CM = new Set(CM);
	
	ESCAPE = read_sorted_set(); // characters that should not be printed
	read_sorted_set(); // only needed to illustrate ens_tokenize() transformations

	let chunks = read_sorted_arrays(r);
	let unrestricted = r();
	//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));
	const read_chunked = () => {
		// 20230921: build set in parts, 2x faster
		let set = new Set();
		read_sorted_array().forEach(i => set_add_many(set, chunks[i]));
		set_add_many(set, read_sorted_array());
		return set; 
	};
	GROUPS = read_array_while(i => {
		// minifier property mangling seems unsafe
		// so these are manually renamed to single chars
		let N = read_array_while(r).map(x => x+0x60);
		if (N.length) {
			let R = i >= unrestricted; // unrestricted then restricted
			N[0] -= 32; // capitalize
			N = str_from_cps(N);
			if (R) N=`Restricted[${N}]`;
			let P = read_chunked(); // primary
			let Q = read_chunked(); // secondary
			let M = !r(); // not-whitelisted, check for NSM
			// *** this code currently isn't needed ***
			/*
			let V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid
			let M = r()-1; // number of combining mark
			if (M < 0) { // whitelisted
				M = new Map(read_array_while(() => {
					let i = r();
					if (i) return [V[i-1], read_array_while(() => {
						let v = read_array_while(r);
						if (v.length) return v.map(x => x-1);
					})];
				}));
			}*/
			return {N, P, Q, M, R};
		}
	});

	// decode compressed wholes
	WHOLE_VALID = read_sorted_set();
	WHOLE_MAP = new Map();
	let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted
	wholes.forEach((cp, i) => {
		let d = r(); 
		let w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};
		w.V.push(cp); // add to member set
		if (!WHOLE_VALID.has(cp)) {
			WHOLE_MAP.set(cp, w);  // register with whole map
		}
	});

	// compute confusable-extent complements
	// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set
	for (let {V, M} of new Set(WHOLE_MAP.values())) {
		// connect all groups that have each whole character
		let recs = [];
		for (let cp of V) {
			let gs = GROUPS.filter(g => group_has_cp(g, cp));
			let rec = recs.find(({G}) => gs.some(g => G.has(g)));
			if (!rec) {
				rec = {G: new Set(), V: []};
				recs.push(rec);
			}
			rec.V.push(cp);
			set_add_many(rec.G, gs);
		}
		// per character cache groups which are not a member of the extent
		let union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole
		for (let {G, V} of recs) {
			let complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent
			for (let cp of V) {
				M.set(cp, complement); // this is the same reference
			}
		}
	}

	// compute valid set
	// 20230924: VALID was union but can be re-used
	VALID = new Set(); // exists in 1+ groups
	let multi = new Set(); // exists in 2+ groups
	const add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
	for (let g of GROUPS) {
		for (let cp of g.P) add_to_union(cp);
		for (let cp of g.Q) add_to_union(cp);
	}
	// dual purpose WHOLE_MAP: return placeholder if unique non-confusable
	for (let cp of VALID) {
		if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
			WHOLE_MAP.set(cp, UNIQUE_PH);
		}
	}
	// add all decomposed parts
	// see derive: "Valid is Closed (via Brute-force)"
	set_add_many(VALID, nfd(VALID));
	
	// decode emoji
	// 20230719: emoji are now fully-expanded to avoid quirk logic 
	EMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);
	EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)
	for (let cps of EMOJI_LIST) {
		// 20230719: change to *slightly* stricter algorithm which disallows 
		// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)
		// example: beautified [A B] (eg. flag emoji) 
		//  before: allow: [A FE0F B], error: [A FE0F FE0F B] 
		//   after: error: both
		// note: this code now matches ENSNormalize.{cs,java} logic
		let prev = [EMOJI_ROOT];
		for (let cp of cps) {
			let next = prev.map(node => {
				let child = node.get(cp);
				if (!child) {
					// should this be object? 
					// (most have 1-2 items, few have many)
					// 20230719: no, v8 default map is 4?
					child = new Map();
					node.set(cp, child);
				}
				return child;
			});
			if (cp === FE0F) {
				prev.push(...next); // less than 20 elements
			} else {
				prev = next;
			}
		}
		for (let x of prev) {
			x.V = cps;
		}
	}
}

// if escaped: {HEX}
//       else: "x" {HEX}
function quoted_cp(cp) {
	return (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}

// 20230211: some messages can be mixed-directional and result in spillover
// use 200E after a quoted string to force the remainder of a string from 
// acquring the direction of the quote
// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions
function bidi_qq(s) {
	return `"${s}"\u200E`; // strong LTR
}

function check_label_extension(cps) {
	if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
		throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`); // this can only be ascii so cant be bidi
	}
}
function check_leading_underscore(cps) {
	const UNDERSCORE = 0x5F;
	for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
		if (cps[--i] !== UNDERSCORE) {
			throw new Error('underscore allowed only at start');
		}
	}
}
// check that a fenced cp is not leading, trailing, or touching another fenced cp
function check_fenced(cps) {
	let cp = cps[0];
	let prev = FENCED.get(cp);
	if (prev) throw error_placement(`leading ${prev}`);
	let n = cps.length;
	let last = -1; // prevents trailing from throwing
	for (let i = 1; i < n; i++) {
		cp = cps[i];
		let match = FENCED.get(cp);
		if (match) {
			// since cps[0] isn't fenced, cps[1] cannot throw
			if (last == i) throw error_placement(`${prev} + ${match}`);
			last = i + 1;
			prev = match;
		}
	}
	if (last == n) throw error_placement(`trailing ${prev}`);
}

// create a safe to print string 
// invisibles are escaped
// leading cm uses placeholder
// if cps exceed max, middle truncate with ellipsis
// quoter(cp) => string, eg. 3000 => "{3000}"
// note: in html, you'd call this function then replace [<>&] with entities
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
	//if (Number.isInteger(cps)) cps = [cps];
	//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);
	let buf = [];
	if (is_combining_mark(cps[0])) buf.push('');
	if (cps.length > max) {
		max >>= 1;
		cps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];
	}
	let prev = 0;
	let n = cps.length;
	for (let i = 0; i < n; i++) {
		let cp = cps[i];
		if (should_escape(cp)) {
			buf.push(str_from_cps(cps.slice(prev, i)));
			buf.push(quoter(cp));
			prev = i + 1;
		}
	}
	buf.push(str_from_cps(cps.slice(prev, n)));
	return buf.join('');
}

// note: set(s) cannot be exposed because they can be modified
// note: Object.freeze() doesn't work
function is_combining_mark(cp) {
	init();
	return CM.has(cp);
}
function should_escape(cp) {
	init();
	return ESCAPE.has(cp);
}

function ens_normalize(name) {
	return flatten(split(name, nfc, filter_fe0f));
}

function split(name, nf, ef) {
	if (!name) return []; // 20230719: empty name allowance
	init();
	let offset = 0;
	// https://unicode.org/reports/tr46/#Validity_Criteria
	// 4.) "The label must not contain a U+002E ( . ) FULL STOP."
	return name.split(STOP_CH).map(label => {
		let input = explode_cp(label);
		let info = {
			input,
			offset, // codepoint, not substring!
		};
		offset += input.length + 1; // + stop
		try {
			// 1.) "The label must be in Unicode Normalization Form NFC"
			let tokens = info.tokens = tokens_from_str(input, nf, ef);
			let token_count = tokens.length;
			let type;
			if (!token_count) { // the label was effectively empty (could of had ignored characters)
				//norm = [];
				//type = 'None'; // use this instead of next match, "ASCII"
				// 20230120: change to strict
				// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59
				throw new Error(`empty label`);
			} 
			let norm = info.output = tokens.flat();
			check_leading_underscore(norm);
			let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);
			if (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii
				// 20230123: matches matches WHATWG, see note 3.3
				check_label_extension(norm); // only needed for ascii
				// cant have fenced
				// cant have cm
				// cant have wholes
				// see derive: "Fastpath ASCII"
				type = 'ASCII';
			} else {
				let chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together
				if (!chars.length) { // theres no text, just emoji
					type = 'Emoji';
				} else {
					// 5.) "The label must not begin with a combining mark, that is: General_Category=Mark."
					if (CM.has(norm[0])) throw error_placement('leading combining mark');
					for (let i = 1; i < token_count; i++) { // we've already checked the first token
						let cps = tokens[i];
						if (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...
							// bidi_qq() not needed since emoji is LTR and cps is a CM
							throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}"`); 
						}
					}
					check_fenced(norm);
					let unique = Array_from(new Set(chars));
					let [g] = determine_group(unique); // take the first match
					// see derive: "Matching Groups have Same CM Style"
					// alternative: could form a hybrid type: Latin/Japanese/...	
					check_group(g, chars); // need text in order
					check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)
					type = g.N;
					// 20230121: consider exposing restricted flag
					// it's simpler to just check for 'Restricted'
					// or even better: type.endsWith(']')
					//if (g.R) info.restricted = true;
				}
			}
			info.type = type;
		} catch (err) {
			info.error = err; // use full error object
		}
		return info;
	});
}

function check_whole(group, unique) {
	let maker;
	let shared = [];
	for (let cp of unique) {
		let whole = WHOLE_MAP.get(cp);
		if (whole === UNIQUE_PH) return; // unique, non-confusable
		if (whole) {
			let set = whole.M.get(cp); // groups which have a character that look-like this character
			maker = maker ? maker.filter(g => set.has(g)) : Array_from(set);
			if (!maker.length) return; // confusable intersection is empty
		} else {
			shared.push(cp); 
		}
	}
	if (maker) {
		// we have 1+ confusable
		// check if any of the remaining groups
		// contain the shared characters too
		for (let g of maker) {
			if (shared.every(cp => group_has_cp(g, cp))) {
				throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
			}
		}
	}
}

// assumption: unique.size > 0
// returns list of matching groups
function determine_group(unique) {
	let groups = GROUPS;
	for (let cp of unique) {
		// note: we need to dodge CM that are whitelisted
		// but that code isn't currently necessary
		let gs = groups.filter(g => group_has_cp(g, cp));
		if (!gs.length) {
			if (!GROUPS.some(g => group_has_cp(g, cp))) { 
				// the character was composed of valid parts
				// but it's NFC form is invalid
				// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}
				// note: this doesn't have to be a composition
				// 20230720: change to full check
				throw error_disallowed(cp); // this should be rare
			} else {
				// there is no group that contains all these characters
				// throw using the highest priority group that matched
				// https://www.unicode.org/reports/tr39/#mixed_script_confusables
				throw error_group_member(groups[0], cp);
			}
		}
		groups = gs;
		if (gs.length == 1) break; // there is only one group left
	}
	// there are at least 1 group(s) with all of these characters
	return groups;
}

// throw on first error
function flatten(split) {
	return split.map(({input, error, output}) => {
		if (error) {
			// don't print label again if just a single label
			let msg = error.message;
			// bidi_qq() only necessary if msg is digits
			throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); 
		}
		return str_from_cps(output);
	}).join(STOP_CH);
}

function error_disallowed(cp) {
	// TODO: add cp to error?
	return new Error(`disallowed character: ${quoted_cp(cp)}`); 
}
function error_group_member(g, cp) {
	let quoted = quoted_cp(cp);
	let gg = GROUPS.find(g => g.P.has(cp)); // only check primary
	if (gg) {
		quoted = `${gg.N} ${quoted}`;
	}
	return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
	return new Error(`illegal placement: ${where}`);
}

// assumption: cps.length > 0
// assumption: cps[0] isn't a CM
// assumption: the previous character isn't an emoji
function check_group(g, cps) {
	for (let cp of cps) {
		if (!group_has_cp(g, cp)) {
			// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. "e{300}{300}"
			// at the moment, it's unnecessary to introduce an extra error type
			// until there exists a whitelisted multi-character
			//   eg. if (M < 0 && is_combining_mark(cp)) { ... }
			// there are 3 cases:
			//   1. illegal cm for wrong group => mixture error
			//   2. illegal cm for same group => cm error
			//       requires set of whitelist cm per group: 
			//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))
			//   3. wrong group => mixture error
			throw error_group_member(g, cp);
		}
	}
	//if (M >= 0) { // we have a known fixed cm count
	if (g.M) { // we need to check for NSM
		let decomposed = nfd(cps);
		for (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption
			// 20230210: bugfix: using cps instead of decomposed h/t Carbon225
			/*
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);
				}
				i = j;
			}
			*/
			// 20230217: switch to NSM counting
			// https://www.unicode.org/reports/tr39/#Optional_Detection
			if (NSM.has(decomposed[i])) {
				let j = i + 1;
				for (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {
					// a. Forbid sequences of the same nonspacing mark.
					for (let k = i; k < j; k++) { // O(n^2) but n < 100
						if (decomposed[k] == cp) {
							throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
						}
					}
				}
				// parse to end so we have full nsm count
				// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).
				if (j - i > NSM_MAX) {
					// note: this slice starts with a base char or spacing-mark cm
					throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);
				}
				i = j;
			}
		}
	}
	// *** this code currently isn't needed ***
	/*
	let cm_whitelist = M instanceof Map;
	for (let i = 0, e = cps.length; i < e; ) {
		let cp = cps[i++];
		let seqs = cm_whitelist && M.get(cp);
		if (seqs) { 
			// list of codepoints that can follow
			// if this exists, this will always be 1+
			let j = i;
			while (j < e && CM.has(cps[j])) j++;
			let cms = cps.slice(i, j);
			let match = seqs.find(seq => !compare_arrays(seq, cms));
			if (!match) throw new Error(`disallowed combining mark sequence: "${safe_str_from_cps([cp, ...cms])}"`);
			i = j;
		} else if (!V.has(cp)) {
			// https://www.unicode.org/reports/tr39/#mixed_script_confusables
			let quoted = quoted_cp(cp);
			for (let cp of cps) {
				let u = UNIQUE.get(cp);
				if (u && u !== g) {
					// if both scripts are restricted this error is confusing
					// because we don't differentiate RestrictedA from RestrictedB 
					if (!u.R) quoted = `${quoted} is ${u.N}`;
					break;
				}
			}
			throw new Error(`disallowed ${g.N} character: ${quoted}`);
			//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);
			//throw new Error(`${g.N} does not allow: ${quoted}`);
		}
	}
	if (!cm_whitelist) {
		let decomposed = nfd(cps);
		for (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: "${str_from_cps(decomposed.slice(i-1, j))}" (${j-i}/${M})`);
				}
				i = j;
			}
		}
	}
	*/
}

// given a list of codepoints
// returns a list of lists, where emoji are a fully-qualified (as Array subclass)
// eg. explode_cp("abcd") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]
// 20230818: rename for 'process' name collision h/t Javarome
// https://github.com/adraffy/ens-normalize.js/issues/23
function tokens_from_str(input, nf, ef) {
	let ret = [];
	let chars = [];
	input = input.slice().reverse(); // flip so we can pop
	while (input.length) {
		let emoji = consume_emoji_reversed(input);
		if (emoji) {
			if (chars.length) {
				ret.push(nf(chars));
				chars = [];
			}
			ret.push(ef(emoji));
		} else {
			let cp = input.pop();
			if (VALID.has(cp)) {
				chars.push(cp);
			} else {
				let cps = MAPPED.get(cp);
				if (cps) {
					chars.push(...cps); // less than 10 elements
				} else if (!IGNORED.has(cp)) {
					// 20230912: unicode 15.1 changed the order of processing such that
					// disallowed parts are only rejected after NFC
					// https://unicode.org/reports/tr46/#Validity_Criteria
					// this doesn't impact normalization as of today
					// technically, this error can be removed as the group logic will apply similar logic
					// however the error type might be less clear
					throw error_disallowed(cp);
				}
			}
		}
	}
	if (chars.length) {
		ret.push(nf(chars));
	}
	return ret;
}

function filter_fe0f(cps) {
	return cps.filter(cp => cp != FE0F);
}

// given array of codepoints
// returns the longest valid emoji sequence (or undefined if no match)
// *MUTATES* the supplied array
// disallows interleaved ignored characters
// fills (optional) eaten array with matched codepoints
function consume_emoji_reversed(cps, eaten) {
	let node = EMOJI_ROOT;
	let emoji;
	let pos = cps.length;
	while (pos) {
		node = node.get(cps[--pos]);
		if (!node) break;
		let {V} = node;
		if (V) { // this is a valid emoji (so far)
			emoji = V;
			cps.length = pos; // truncate
		}
	}
	return emoji;
}

const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
    assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
    return comp;
}
function ensNameSplit(name) {
    const bytes = toUtf8Bytes(ensNormalize(name));
    const comps = [];
    if (name.length === 0) {
        return comps;
    }
    let last = 0;
    for (let i = 0; i < bytes.length; i++) {
        const d = bytes[i];
        // A separator (i.e. "."); copy this component
        if (d === 0x2e) {
            comps.push(checkComponent(bytes.slice(last, i)));
            last = i + 1;
        }
    }
    // There was a stray separator at the end of the name
    assertArgument(last < bytes.length, "invalid ENS name; empty component", "name", name);
    comps.push(checkComponent(bytes.slice(last)));
    return comps;
}
/**
 *  Returns the ENS %%name%% normalized.
 */
function ensNormalize(name) {
    try {
        if (name.length === 0) {
            throw new Error("empty label");
        }
        return ens_normalize(name);
    }
    catch (error) {
        assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
    }
}
/**
 *  Returns the [[link-namehash]] for %%name%%.
 */
function namehash(name) {
    assertArgument(typeof (name) === "string", "invalid ENS name; not a string", "name", name);
    assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
    let result = Zeros;
    const comps = ensNameSplit(name);
    while (comps.length) {
        result = keccak256(concat([result, keccak256((comps.pop()))]));
    }
    return hexlify(result);
}
/**
 *  Returns the DNS encoded %%name%%.
 *
 *  This is used for various parts of ENS name resolution, such
 *  as the wildcard resolution.
 */
function dnsEncode(name, _maxLength) {
    const length = _maxLength ;
    assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
    return hexlify(concat(ensNameSplit(name).map((comp) => {
        assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
        const bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
    }))) + "00";
}

//import { TypedDataDomain, TypedDataField } from "@ethersproject/providerabstract-signer";
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0$3 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
    const bytes = getBytes(value);
    const padOffset = bytes.length % 32;
    if (padOffset) {
        return concat([bytes, padding.slice(padOffset)]);
    }
    return hexlify(bytes);
}
const hexTrue = toBeHex(BN_1, 32);
const hexFalse = toBeHex(BN_0$3, 32);
const domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
};
const domainFieldNames = [
    "name", "version", "chainId", "verifyingContract", "salt"
];
function checkString(key) {
    return function (value) {
        assertArgument(typeof (value) === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
        return value;
    };
}
const domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function (_value) {
        const value = getBigInt(_value, "domain.chainId");
        assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value);
        if (Number.isSafeInteger(value)) {
            return Number(value);
        }
        return toQuantity(value);
    },
    verifyingContract: function (value) {
        try {
            return getAddress(value).toLowerCase();
        }
        catch (error) { }
        assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function (value) {
        const bytes = getBytes(value, "domain.salt");
        assertArgument(bytes.length === 32, `invalid domain value "salt"`, "domain.salt", value);
        return hexlify(bytes);
    }
};
function getBaseEncoder(type) {
    // intXX and uintXX
    {
        const match = type.match(/^(u?)int(\d+)$/);
        if (match) {
            const signed = (match[1] === "");
            const width = parseInt(match[2]);
            assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
            const boundsUpper = mask(BN_MAX_UINT256, signed ? (width - 1) : width);
            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1) : BN_0$3;
            return function (_value) {
                const value = getBigInt(_value, "value");
                assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
                return toBeHex(signed ? toTwos(value, 256) : value, 32);
            };
        }
    }
    // bytesXX
    {
        const match = type.match(/^bytes(\d+)$/);
        if (match) {
            const width = parseInt(match[1]);
            assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
            return function (value) {
                const bytes = getBytes(value);
                assertArgument(bytes.length === width, `invalid length for ${type}`, "value", value);
                return hexPadRight(value);
            };
        }
    }
    switch (type) {
        case "address": return function (value) {
            return zeroPadValue(getAddress(value), 32);
        };
        case "bool": return function (value) {
            return ((!value) ? hexFalse : hexTrue);
        };
        case "bytes": return function (value) {
            return keccak256(value);
        };
        case "string": return function (value) {
            return id$1(value);
        };
    }
    return null;
}
function encodeType(name, fields) {
    return `${name}(${fields.map(({ name, type }) => (type + " " + name)).join(",")})`;
}
// foo[][3] => { base: "foo", index: "[][3]", array: {
//     base: "foo", prefix: "foo[]", count: 3 } }
function splitArray(type) {
    const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    if (match) {
        return {
            base: match[1],
            index: (match[2] + match[4]),
            array: {
                base: match[1],
                prefix: (match[1] + match[2]),
                count: (match[5] ? parseInt(match[5]) : -1),
            }
        };
    }
    return { base: type };
}
/**
 *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads
 *  for signed typed data.
 *
 *  This is useful for those that wish to compute various components of a
 *  typed data hash, primary types, or sub-components, but generally the
 *  higher level [[Signer-signTypedData]] is more useful.
 */
class TypedDataEncoder {
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    primaryType;
    #types;
    /**
     *  The types.
     */
    get types() {
        return JSON.parse(this.#types);
    }
    #fullTypes;
    #encoderCache;
    /**
     *  Create a new **TypedDataEncoder** for %%types%%.
     *
     *  This performs all necessary checking that types are valid and
     *  do not violate the [[link-eip-712]] structural constraints as
     *  well as computes the [[primaryType]].
     */
    constructor(_types) {
        this.#fullTypes = new Map();
        this.#encoderCache = new Map();
        // Link struct types to their direct child structs
        const links = new Map();
        // Link structs to structs which contain them as a child
        const parents = new Map();
        // Link all subtypes within a given struct
        const subtypes = new Map();
        const types = {};
        Object.keys(_types).forEach((type) => {
            types[type] = _types[type].map(({ name, type }) => {
                // Normalize the base type (unless name conflict)
                let { base, index } = splitArray(type);
                if (base === "int" && !_types["int"]) {
                    base = "int256";
                }
                if (base === "uint" && !_types["uint"]) {
                    base = "uint256";
                }
                return { name, type: (base + (index || "")) };
            });
            links.set(type, new Set());
            parents.set(type, []);
            subtypes.set(type, new Set());
        });
        this.#types = JSON.stringify(types);
        for (const name in types) {
            const uniqueNames = new Set();
            for (const field of types[name]) {
                // Check each field has a unique name
                assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
                uniqueNames.add(field.name);
                // Get the base type (drop any array specifiers)
                const baseType = splitArray(field.type).base;
                assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
                // Is this a base encoding type?
                const encoder = getBaseEncoder(baseType);
                if (encoder) {
                    continue;
                }
                assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
                // Add linkage
                parents.get(baseType).push(name);
                links.get(name).add(baseType);
            }
        }
        // Deduce the primary type
        const primaryTypes = Array.from(parents.keys()).filter((n) => (parents.get(n).length === 0));
        assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types);
        assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(", ")}`, "types", _types);
        defineProperties(this, { primaryType: primaryTypes[0] });
        // Check for circular type references
        function checkCircular(type, found) {
            assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types);
            found.add(type);
            for (const child of links.get(type)) {
                if (!parents.has(child)) {
                    continue;
                }
                // Recursively check children
                checkCircular(child, found);
                // Mark all ancestors as having this decendant
                for (const subtype of found) {
                    subtypes.get(subtype).add(child);
                }
            }
            found.delete(type);
        }
        checkCircular(this.primaryType, new Set());
        // Compute each fully describe type
        for (const [name, set] of subtypes) {
            const st = Array.from(set);
            st.sort();
            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(""));
        }
    }
    /**
     *  Returnthe encoder for the specific %%type%%.
     */
    getEncoder(type) {
        let encoder = this.#encoderCache.get(type);
        if (!encoder) {
            encoder = this.#getEncoder(type);
            this.#encoderCache.set(type, encoder);
        }
        return encoder;
    }
    #getEncoder(type) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return encoder;
            }
        }
        // Array
        const array = splitArray(type).array;
        if (array) {
            const subtype = array.prefix;
            const subEncoder = this.getEncoder(subtype);
            return (value) => {
                assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
                let result = value.map(subEncoder);
                if (this.#fullTypes.has(subtype)) {
                    result = result.map(keccak256);
                }
                return keccak256(concat(result));
            };
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            const encodedType = id$1(this.#fullTypes.get(type));
            return (value) => {
                const values = fields.map(({ name, type }) => {
                    const result = this.getEncoder(type)(value[name]);
                    if (this.#fullTypes.has(type)) {
                        return keccak256(result);
                    }
                    return result;
                });
                values.unshift(encodedType);
                return concat(values);
            };
        }
        assertArgument(false, `unknown type: ${type}`, "type", type);
    }
    /**
     *  Return the full type for %%name%%.
     */
    encodeType(name) {
        const result = this.#fullTypes.get(name);
        assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
        return result;
    }
    /**
     *  Return the encoded %%value%% for the %%type%%.
     */
    encodeData(type, value) {
        return this.getEncoder(type)(value);
    }
    /**
     *  Returns the hash of %%value%% for the type of %%name%%.
     */
    hashStruct(name, value) {
        return keccak256(this.encodeData(name, value));
    }
    /**
     *  Return the fulled encoded %%value%% for the [[types]].
     */
    encode(value) {
        return this.encodeData(this.primaryType, value);
    }
    /**
     *  Return the hash of the fully encoded %%value%% for the [[types]].
     */
    hash(value) {
        return this.hashStruct(this.primaryType, value);
    }
    /**
     *  @_ignore:
     */
    _visit(type, value, callback) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return callback(type, value);
            }
        }
        // Array
        const array = splitArray(type).array;
        if (array) {
            assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
            return value.map((v) => this._visit(array.prefix, v, callback));
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            return fields.reduce((accum, { name, type }) => {
                accum[name] = this._visit(type, value[name], callback);
                return accum;
            }, {});
        }
        assertArgument(false, `unknown type: ${type}`, "type", type);
    }
    /**
     *  Call %%calback%% for each value in %%value%%, passing the type and
     *  component within %%value%%.
     *
     *  This is useful for replacing addresses or other transformation that
     *  may be desired on each component, based on its type.
     */
    visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
    }
    /**
     *  Create a new **TypedDataEncoder** for %%types%%.
     */
    static from(types) {
        return new TypedDataEncoder(types);
    }
    /**
     *  Return the primary type for %%types%%.
     */
    static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
    }
    /**
     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
     */
    static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    /**
     *  Return the domain hash for %%domain%%.
     */
    static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
            if (domain[name] == null) {
                continue;
            }
            const type = domainFieldTypes[name];
            assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            domainFields.push({ name, type });
        }
        domainFields.sort((a, b) => {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
    }
    /**
     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
     */
    static encode(domain, types, value) {
        return concat([
            "0x1901",
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value)
        ]);
    }
    /**
     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
     */
    static hash(domain, types, value) {
        return keccak256(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    /**
     * Resolves to the value from resolving all addresses in %%value%% for
     * %%types%% and the %%domain%%.
     */
    static async resolveNames(domain, types, value, resolveName) {
        // Make a copy to isolate it from the object passed in
        domain = Object.assign({}, domain);
        // Allow passing null to ignore value
        for (const key in domain) {
            if (domain[key] == null) {
                delete domain[key];
            }
        }
        // Look up all ENS names
        const ensCache = {};
        // Do we need to look up the domain's verifyingContract?
        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
            ensCache[domain.verifyingContract] = "0x";
        }
        // We are going to use the encoder to visit all the base values
        const encoder = TypedDataEncoder.from(types);
        // Get a list of all the addresses
        encoder.visit(value, (type, value) => {
            if (type === "address" && !isHexString(value, 20)) {
                ensCache[value] = "0x";
            }
            return value;
        });
        // Lookup each name
        for (const name in ensCache) {
            ensCache[name] = await resolveName(name);
        }
        // Replace the domain verifyingContract if needed
        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
            domain.verifyingContract = ensCache[domain.verifyingContract];
        }
        // Replace all ENS names with their address
        value = encoder.visit(value, (type, value) => {
            if (type === "address" && ensCache[value]) {
                return ensCache[value];
            }
            return value;
        });
        return { domain, value };
    }
    /**
     *  Returns the JSON-encoded payload expected by nodes which implement
     *  the JSON-RPC [[link-eip-712]] method.
     */
    static getPayload(domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name) => {
            const value = domain[name];
            if (value == null) {
                return;
            }
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder = TypedDataEncoder.from(types);
        // Get the normalized types
        types = encoder.types;
        const typesWithDomain = Object.assign({}, types);
        assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
        typesWithDomain.EIP712Domain = domainTypes;
        // Validate the data structures and types
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value) => {
                // bytes
                if (type.match(/^bytes(\d*)/)) {
                    return hexlify(getBytes(value));
                }
                // uint or int
                if (type.match(/^u?int/)) {
                    return getBigInt(value).toString();
                }
                switch (type) {
                    case "address":
                        return value.toLowerCase();
                    case "bool":
                        return !!value;
                    case "string":
                        assertArgument(typeof (value) === "string", "invalid string", "value", value);
                        return value;
                }
                assertArgument(false, "unsupported type", "type", type);
            })
        };
    }
}

/**
 *  A fragment is a single item from an ABI, which may represent any of:
 *
 *  - [Functions](FunctionFragment)
 *  - [Events](EventFragment)
 *  - [Constructors](ConstructorFragment)
 *  - Custom [Errors](ErrorFragment)
 *  - [Fallback or Receive](FallbackFragment) functions
 *
 *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]
 */
// [ "a", "b" ] => { "a": 1, "b": 1 }
function setify(items) {
    const result = new Set();
    items.forEach((k) => result.add(k));
    return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
// Visibility Keywords
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
// All Keywords
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
// Single character tokens
const SimpleTokens = {
    "(": "OPEN_PAREN", ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET", "]": "CLOSE_BRACKET",
    ",": "COMMA", "@": "AT"
};
// Parser regexes to consume the next token
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
// Parser regexs to check validity
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class TokenString {
    #offset;
    #tokens;
    get offset() { return this.#offset; }
    get length() { return this.#tokens.length - this.#offset; }
    constructor(tokens) {
        this.#offset = 0;
        this.#tokens = tokens.slice();
    }
    clone() { return new TokenString(this.#tokens); }
    reset() { this.#offset = 0; }
    #subTokenString(from = 0, to = 0) {
        return new TokenString(this.#tokens.slice(from, to).map((t) => {
            return Object.freeze(Object.assign({}, t, {
                match: (t.match - from),
                linkBack: (t.linkBack - from),
                linkNext: (t.linkNext - from),
            }));
        }));
    }
    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
    popKeyword(allowed) {
        const top = this.peek();
        if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
            throw new Error(`expected keyword ${top.text}`);
        }
        return this.pop().text;
    }
    // Pops and returns the value of the next token if it is `type`; throws if out of tokens
    popType(type) {
        if (this.peek().type !== type) {
            const top = this.peek();
            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
        }
        return this.pop().text;
    }
    // Pops and returns a "(" TOKENS ")"
    popParen() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = this.#subTokenString(this.#offset + 1, top.match + 1);
        this.#offset = top.match + 1;
        return result;
    }
    // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
    popParams() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = [];
        while (this.#offset < top.match - 1) {
            const link = this.peek().linkNext;
            result.push(this.#subTokenString(this.#offset + 1, link));
            this.#offset = link;
        }
        this.#offset = top.match + 1;
        return result;
    }
    // Returns the top Token, throwing if out of tokens
    peek() {
        if (this.#offset >= this.#tokens.length) {
            throw new Error("out-of-bounds");
        }
        return this.#tokens[this.#offset];
    }
    // Returns the next value, if it is a keyword in `allowed`
    peekKeyword(allowed) {
        const top = this.peekType("KEYWORD");
        return (top != null && allowed.has(top)) ? top : null;
    }
    // Returns the value of the next token if it is `type`
    peekType(type) {
        if (this.length === 0) {
            return null;
        }
        const top = this.peek();
        return (top.type === type) ? top.text : null;
    }
    // Returns the next token; throws if out of tokens
    pop() {
        const result = this.peek();
        this.#offset++;
        return result;
    }
    toString() {
        const tokens = [];
        for (let i = this.#offset; i < this.#tokens.length; i++) {
            const token = this.#tokens[i];
            tokens.push(`${token.type}:${token.text}`);
        }
        return `<TokenString ${tokens.join(" ")}>`;
    }
}
function lex(text) {
    const tokens = [];
    const throwError = (message) => {
        const token = (offset < text.length) ? JSON.stringify(text[offset]) : "$EOI";
        throw new Error(`invalid token ${token} at ${offset}: ${message}`);
    };
    let brackets = [];
    let commas = [];
    let offset = 0;
    while (offset < text.length) {
        // Strip off any leading whitespace
        let cur = text.substring(offset);
        let match = cur.match(regexWhitespacePrefix);
        if (match) {
            offset += match[1].length;
            cur = text.substring(offset);
        }
        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
        tokens.push(token);
        let type = (SimpleTokens[cur[0]] || "");
        if (type) {
            token.type = type;
            token.text = cur[0];
            offset++;
            if (type === "OPEN_PAREN") {
                brackets.push(tokens.length - 1);
                commas.push(tokens.length - 1);
            }
            else if (type == "CLOSE_PAREN") {
                if (brackets.length === 0) {
                    throwError("no matching open bracket");
                }
                token.match = brackets.pop();
                (tokens[token.match]).match = tokens.length - 1;
                token.depth--;
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
            }
            else if (type === "COMMA") {
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
                commas.push(tokens.length - 1);
            }
            else if (type === "OPEN_BRACKET") {
                token.type = "BRACKET";
            }
            else if (type === "CLOSE_BRACKET") {
                // Remove the CLOSE_BRACKET
                let suffix = tokens.pop().text;
                if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
                    const value = tokens.pop().text;
                    suffix = value + suffix;
                    (tokens[tokens.length - 1]).value = getNumber(value);
                }
                if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
                    throw new Error("missing opening bracket");
                }
                (tokens[tokens.length - 1]).text += suffix;
            }
            continue;
        }
        match = cur.match(regexIdPrefix);
        if (match) {
            token.text = match[1];
            offset += token.text.length;
            if (Keywords.has(token.text)) {
                token.type = "KEYWORD";
                continue;
            }
            if (token.text.match(regexType)) {
                token.type = "TYPE";
                continue;
            }
            token.type = "ID";
            continue;
        }
        match = cur.match(regexNumberPrefix);
        if (match) {
            token.text = match[1];
            token.type = "NUMBER";
            offset += token.text.length;
            continue;
        }
        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
    }
    return new TokenString(tokens.map((t) => Object.freeze(t)));
}
// Check only one of `allowed` is in `set`
function allowSingle(set, allowed) {
    let included = [];
    for (const key in allowed.keys()) {
        if (set.has(key)) {
            included.push(key);
        }
    }
    if (included.length > 1) {
        throw new Error(`conflicting types: ${included.join(", ")}`);
    }
}
// Functions to process a Solidity Signature TokenString from left-to-right for...
// ...the name with an optional type, returning the name
function consumeName(type, tokens) {
    if (tokens.peekKeyword(KwTypes)) {
        const keyword = tokens.pop().text;
        if (keyword !== type) {
            throw new Error(`expected ${type}, got ${keyword}`);
        }
    }
    return tokens.popType("ID");
}
// ...all keywords matching allowed, returning the keywords
function consumeKeywords(tokens, allowed) {
    const keywords = new Set();
    while (true) {
        const keyword = tokens.peekType("KEYWORD");
        if (keyword == null || (allowed && !allowed.has(keyword))) {
            break;
        }
        tokens.pop();
        if (keywords.has(keyword)) {
            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
        }
        keywords.add(keyword);
    }
    return Object.freeze(keywords);
}
// ...all visibility keywords, returning the coalesced mutability
function consumeMutability(tokens) {
    let modifiers = consumeKeywords(tokens, KwVisib);
    // Detect conflicting modifiers
    allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
    allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
    // Process mutability states
    if (modifiers.has("view")) {
        return "view";
    }
    if (modifiers.has("pure")) {
        return "pure";
    }
    if (modifiers.has("payable")) {
        return "payable";
    }
    if (modifiers.has("nonpayable")) {
        return "nonpayable";
    }
    // Process legacy `constant` last
    if (modifiers.has("constant")) {
        return "view";
    }
    return "nonpayable";
}
// ...a parameter list, returning the ParamType list
function consumeParams(tokens, allowIndexed) {
    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
// ...a gas limit, returning a BigNumber or null if none
function consumeGas(tokens) {
    if (tokens.peekType("AT")) {
        tokens.pop();
        if (tokens.peekType("NUMBER")) {
            return getBigInt(tokens.pop().text);
        }
        throw new Error("invalid gas");
    }
    return null;
}
function consumeEoi(tokens) {
    if (tokens.length) {
        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
    }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
    const match = type.match(regexType);
    assertArgument(match, "invalid type", "type", type);
    if (type === "uint") {
        return "uint256";
    }
    if (type === "int") {
        return "int256";
    }
    if (match[2]) {
        // bytesXX
        const length = parseInt(match[2]);
        assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
    }
    else if (match[3]) {
        // intXX or uintXX
        const size = parseInt(match[3]);
        assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, "invalid numeric width", "type", type);
    }
    return type;
}
// Make the Fragment constructors effectively private
const _guard = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
/**
 *  Each input and output of a [[Fragment]] is an Array of **ParamType**.
 */
class ParamType {
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    name;
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    type;
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    baseType;
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    indexed;
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    components;
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    arrayLength;
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    arrayChildren;
    /**
     *  @private
     */
    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
        assertPrivate(guard, _guard, "ParamType");
        Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
        if (components) {
            components = Object.freeze(components.slice());
        }
        if (baseType === "array") {
            if (arrayLength == null || arrayChildren == null) {
                throw new Error("");
            }
        }
        else if (arrayLength != null || arrayChildren != null) {
            throw new Error("");
        }
        if (baseType === "tuple") {
            if (components == null) {
                throw new Error("");
            }
        }
        else if (components != null) {
            throw new Error("");
        }
        defineProperties(this, {
            name, type, baseType, indexed, components, arrayLength, arrayChildren
        });
    }
    /**
     *  Return a string representation of this type.
     *
     *  For example,
     *
     *  ``sighash" => "(uint256,address)"``
     *
     *  ``"minimal" => "tuple(uint256,address) indexed"``
     *
     *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            const name = this.name || "";
            if (this.isArray()) {
                const result = JSON.parse(this.arrayChildren.format("json"));
                result.name = name;
                result.type += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
                return JSON.stringify(result);
            }
            const result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.isTuple()) {
                result.components = this.components.map((c) => JSON.parse(c.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.isArray()) {
            result += this.arrayChildren.format(format);
            result += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
        }
        else {
            if (this.isTuple()) {
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === "full") ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== "sighash") {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === "full" && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    /**
     *  Returns true if %%this%% is an Array type.
     *
     *  This provides a type gaurd ensuring that [[arrayChildren]]
     *  and [[arrayLength]] are non-null.
     */
    isArray() {
        return (this.baseType === "array");
    }
    /**
     *  Returns true if %%this%% is a Tuple type.
     *
     *  This provides a type gaurd ensuring that [[components]]
     *  is non-null.
     */
    isTuple() {
        return (this.baseType === "tuple");
    }
    /**
     *  Returns true if %%this%% is an Indexable type.
     *
     *  This provides a type gaurd ensuring that [[indexed]]
     *  is non-null.
     */
    isIndexable() {
        return (this.indexed != null);
    }
    /**
     *  Walks the **ParamType** with %%value%%, calling %%process%%
     *  on each type, destructing the %%value%% recursively.
     */
    walk(value, process) {
        if (this.isArray()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v) => (_this.arrayChildren.walk(v, process)));
        }
        if (this.isTuple()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid tuple value");
            }
            if (value.length !== this.components.length) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v, i) => (_this.components[i].walk(v, process)));
        }
        return process(this.type, value);
    }
    #walkAsync(promises, value, process, setValue) {
        if (this.isArray()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                throw new Error("array is wrong length");
            }
            const childType = this.arrayChildren;
            const result = value.slice();
            result.forEach((value, index) => {
                childType.#walkAsync(promises, value, process, (value) => {
                    result[index] = value;
                });
            });
            setValue(result);
            return;
        }
        if (this.isTuple()) {
            const components = this.components;
            // Convert the object into an array
            let result;
            if (Array.isArray(value)) {
                result = value.slice();
            }
            else {
                if (value == null || typeof (value) !== "object") {
                    throw new Error("invalid tuple value");
                }
                result = components.map((param) => {
                    if (!param.name) {
                        throw new Error("cannot use object value with unnamed components");
                    }
                    if (!(param.name in value)) {
                        throw new Error(`missing value for component ${param.name}`);
                    }
                    return value[param.name];
                });
            }
            if (result.length !== this.components.length) {
                throw new Error("array is wrong length");
            }
            result.forEach((value, index) => {
                components[index].#walkAsync(promises, value, process, (value) => {
                    result[index] = value;
                });
            });
            setValue(result);
            return;
        }
        const result = process(this.type, value);
        if (result.then) {
            promises.push((async function () { setValue(await result); })());
        }
        else {
            setValue(result);
        }
    }
    /**
     *  Walks the **ParamType** with %%value%%, asynchronously calling
     *  %%process%% on each type, destructing the %%value%% recursively.
     *
     *  This can be used to resolve ENS names by walking and resolving each
     *  ``"address"`` type.
     */
    async walkAsync(value, process) {
        const promises = [];
        const result = [value];
        this.#walkAsync(promises, value, process, (value) => {
            result[0] = value;
        });
        if (promises.length) {
            await Promise.all(promises);
        }
        return result[0];
    }
    /**
     *  Creates a new **ParamType** for %%obj%%.
     *
     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
     *  otherwise the ``indexed`` keyword will throw an error.
     */
    static from(obj, allowIndexed) {
        if (ParamType.isParamType(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ParamType.from(lex(obj), allowIndexed);
            }
            catch (error) {
                assertArgument(false, "invalid param type", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            let type = "", baseType = "";
            let comps = null;
            if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
                // Tuple
                baseType = "tuple";
                comps = obj.popParams().map((t) => ParamType.from(t));
                type = `tuple(${comps.map((c) => c.format()).join(",")})`;
            }
            else {
                // Normal
                type = verifyBasicType(obj.popType("TYPE"));
                baseType = type;
            }
            // Check for Array
            let arrayChildren = null;
            let arrayLength = null;
            while (obj.length && obj.peekType("BRACKET")) {
                const bracket = obj.pop(); //arrays[i];
                arrayChildren = new ParamType(_guard, "", type, baseType, null, comps, arrayLength, arrayChildren);
                arrayLength = bracket.value;
                type += bracket.text;
                baseType = "array";
                comps = null;
            }
            let indexed = null;
            const keywords = consumeKeywords(obj, KwModifiers);
            if (keywords.has("indexed")) {
                if (!allowIndexed) {
                    throw new Error("");
                }
                indexed = true;
            }
            const name = (obj.peekType("ID") ? obj.pop().text : "");
            if (obj.length) {
                throw new Error("leftover tokens");
            }
            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);
        }
        const name = obj.name;
        assertArgument(!name || (typeof (name) === "string" && name.match(regexId)), "invalid name", "obj.name", name);
        let indexed = obj.indexed;
        if (indexed != null) {
            assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
            indexed = !!indexed;
        }
        let type = obj.type;
        let arrayMatch = type.match(regexArrayType);
        if (arrayMatch) {
            const arrayLength = parseInt(arrayMatch[2] || "-1");
            const arrayChildren = ParamType.from({
                type: arrayMatch[1],
                components: obj.components
            });
            return new ParamType(_guard, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
        }
        if (type === "tuple" || type.startsWith("tuple(" /* fix: ) */) || type.startsWith("(" /* fix: ) */)) {
            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;
            const tuple = new ParamType(_guard, name || "", type, "tuple", indexed, comps, null, null);
            // @TODO: use lexer to validate and normalize type
            return tuple;
        }
        type = verifyBasicType(obj.type);
        return new ParamType(_guard, name || "", type, type, indexed, null, null, null);
    }
    /**
     *  Returns true if %%value%% is a **ParamType**.
     */
    static isParamType(value) {
        return (value && value[internal$1] === ParamTypeInternal);
    }
}
/**
 *  An abstract class to represent An individual fragment from a parse ABI.
 */
class Fragment {
    /**
     *  The type of the fragment.
     */
    type;
    /**
     *  The inputs for the fragment.
     */
    inputs;
    /**
     *  @private
     */
    constructor(guard, type, inputs) {
        assertPrivate(guard, _guard, "Fragment");
        inputs = Object.freeze(inputs.slice());
        defineProperties(this, { type, inputs });
    }
    /**
     *  Creates a new **Fragment** for %%obj%%, wich can be any supported
     *  ABI frgament type.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            // Try parsing JSON...
            try {
                Fragment.from(JSON.parse(obj));
            }
            catch (e) { }
            // ...otherwise, use the human-readable lexer
            return Fragment.from(lex(obj));
        }
        if (obj instanceof TokenString) {
            // Human-readable ABI (already lexed)
            const type = obj.peekKeyword(KwTypes);
            switch (type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
        }
        else if (typeof (obj) === "object") {
            // JSON ABI
            switch (obj.type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
            assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from"
            });
        }
        assertArgument(false, "unsupported frgament object", "obj", obj);
    }
    /**
     *  Returns true if %%value%% is a [[ConstructorFragment]].
     */
    static isConstructor(value) {
        return ConstructorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[ErrorFragment]].
     */
    static isError(value) {
        return ErrorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[EventFragment]].
     */
    static isEvent(value) {
        return EventFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[FunctionFragment]].
     */
    static isFunction(value) {
        return FunctionFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[StructFragment]].
     */
    static isStruct(value) {
        return StructFragment.isFragment(value);
    }
}
/**
 *  An abstract class to represent An individual fragment
 *  which has a name from a parse ABI.
 */
class NamedFragment extends Fragment {
    /**
     *  The name of the fragment.
     */
    name;
    /**
     *  @private
     */
    constructor(guard, type, name, inputs) {
        super(guard, type, inputs);
        assertArgument(typeof (name) === "string" && name.match(regexId), "invalid identifier", "name", name);
        inputs = Object.freeze(inputs.slice());
        defineProperties(this, { name });
    }
}
function joinParams(format, params) {
    return "(" + params.map((p) => p.format(format)).join((format === "full") ? ", " : ",") + ")";
}
/**
 *  A Fragment which represents a //Custom Error//.
 */
class ErrorFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "error", name, inputs);
        Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
    }
    /**
     *  The Custom Error selector.
     */
    get selector() {
        return id$1(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this fragment as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("error");
        }
        result.push(this.name + joinParams(format, this.inputs));
        return result.join(" ");
    }
    /**
     *  Returns a new **ErrorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ErrorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            return ErrorFragment.from(lex(obj));
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("error", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new ErrorFragment(_guard, name, inputs);
        }
        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **ErrorFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === ErrorFragmentInternal);
    }
}
/**
 *  A Fragment which represents an Event.
 */
class EventFragment extends NamedFragment {
    /**
     *  Whether this event is anonymous.
     */
    anonymous;
    /**
     *  @private
     */
    constructor(guard, name, inputs, anonymous) {
        super(guard, "event", name, inputs);
        Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
        defineProperties(this, { anonymous });
    }
    /**
     *  The Event topic hash.
     */
    get topicHash() {
        return id$1(this.format("sighash"));
    }
    /**
     *  Returns a string representation of this event as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("event");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash" && this.anonymous) {
            result.push("anonymous");
        }
        return result.join(" ");
    }
    /**
     *  Return the topic hash for an event with %%name%% and %%params%%.
     */
    static getTopicHash(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new EventFragment(_guard, name, params, false);
        return fragment.topicHash;
    }
    /**
     *  Returns a new **EventFragment** for %%obj%%.
     */
    static from(obj) {
        if (EventFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return EventFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid event fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("event", obj);
            const inputs = consumeParams(obj, true);
            const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
            consumeEoi(obj);
            return new EventFragment(_guard, name, inputs, anonymous);
        }
        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **EventFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === EventFragmentInternal);
    }
}
/**
 *  A Fragment which represents a constructor.
 */
class ConstructorFragment extends Fragment {
    /**
     *  Whether the constructor can receive an endowment.
     */
    payable;
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    gas;
    /**
     *  @private
     */
    constructor(guard, type, inputs, payable, gas) {
        super(guard, type, inputs);
        Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
        defineProperties(this, { payable, gas });
    }
    /**
     *  Returns a string representation of this constructor as %%format%%.
     */
    format(format) {
        assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
        if (format === "json") {
            return JSON.stringify({
                type: "constructor",
                stateMutability: (this.payable ? "payable" : "undefined"),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [`constructor${joinParams(format, this.inputs)}`];
        if (this.payable) {
            result.push("payable");
        }
        if (this.gas != null) {
            result.push(`@${this.gas.toString()}`);
        }
        return result.join(" ");
    }
    /**
     *  Returns a new **ConstructorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ConstructorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ConstructorFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid constuctor fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            consumeKeywords(obj, setify(["constructor"]));
            const inputs = consumeParams(obj);
            const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
        }
        return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **ConstructorFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === ConstructorFragmentInternal);
    }
}
/**
 *  A Fragment which represents a method.
 */
class FallbackFragment extends Fragment {
    /**
     *  If the function can be sent value during invocation.
     */
    payable;
    constructor(guard, inputs, payable) {
        super(guard, "fallback", inputs);
        Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
        defineProperties(this, { payable });
    }
    /**
     *  Returns a string representation of this fallback as %%format%%.
     */
    format(format) {
        const type = ((this.inputs.length === 0) ? "receive" : "fallback");
        if (format === "json") {
            const stateMutability = (this.payable ? "payable" : "nonpayable");
            return JSON.stringify({ type, stateMutability });
        }
        return `${type}()${this.payable ? " payable" : ""}`;
    }
    /**
     *  Returns a new **FallbackFragment** for %%obj%%.
     */
    static from(obj) {
        if (FallbackFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FallbackFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid fallback fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const errorObj = obj.toString();
            const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
            assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
            const type = obj.popKeyword(setify(["fallback", "receive"]));
            // receive()
            if (type === "receive") {
                const inputs = consumeParams(obj);
                assertArgument(inputs.length === 0, `receive cannot have arguments`, "obj.inputs", inputs);
                consumeKeywords(obj, setify(["payable"]));
                consumeEoi(obj);
                return new FallbackFragment(_guard, [], true);
            }
            // fallback() [payable]
            // fallback(bytes) [payable] returns (bytes)
            let inputs = consumeParams(obj);
            if (inputs.length) {
                assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
            }
            else {
                inputs = [ParamType.from("bytes")];
            }
            const mutability = consumeMutability(obj);
            assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                const outputs = consumeParams(obj);
                assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
            }
            consumeEoi(obj);
            return new FallbackFragment(_guard, inputs, mutability === "payable");
        }
        if (obj.type === "receive") {
            return new FallbackFragment(_guard, [], true);
        }
        if (obj.type === "fallback") {
            const inputs = [ParamType.from("bytes")];
            const payable = (obj.stateMutability === "payable");
            return new FallbackFragment(_guard, inputs, payable);
        }
        assertArgument(false, "invalid fallback description", "obj", obj);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FallbackFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === FallbackFragmentInternal);
    }
}
/**
 *  A Fragment which represents a method.
 */
class FunctionFragment extends NamedFragment {
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    constant;
    /**
     *  The returned types for the result of calling this function.
     */
    outputs;
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    stateMutability;
    /**
     *  If the function can be sent value during invocation.
     */
    payable;
    /**
     *  The recommended gas limit to send when calling this function.
     */
    gas;
    /**
     *  @private
     */
    constructor(guard, name, stateMutability, inputs, outputs, gas) {
        super(guard, "function", name, inputs);
        Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
        outputs = Object.freeze(outputs.slice());
        const constant = (stateMutability === "view" || stateMutability === "pure");
        const payable = (stateMutability === "payable");
        defineProperties(this, { constant, gas, outputs, payable, stateMutability });
    }
    /**
     *  The Function selector.
     */
    get selector() {
        return id$1(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this function as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("function");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash") {
            if (this.stateMutability !== "nonpayable") {
                result.push(this.stateMutability);
            }
            if (this.outputs && this.outputs.length) {
                result.push("returns");
                result.push(joinParams(format, this.outputs));
            }
            if (this.gas != null) {
                result.push(`@${this.gas.toString()}`);
            }
        }
        return result.join(" ");
    }
    /**
     *  Return the selector for a function with %%name%% and %%params%%.
     */
    static getSelector(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
        return fragment.selector;
    }
    /**
     *  Returns a new **FunctionFragment** for %%obj%%.
     */
    static from(obj) {
        if (FunctionFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FunctionFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid function fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("function", obj);
            const inputs = consumeParams(obj);
            const mutability = consumeMutability(obj);
            let outputs = [];
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                outputs = consumeParams(obj);
            }
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
        }
        let stateMutability = obj.stateMutability;
        // Use legacy Solidity ABI logic if stateMutability is missing
        if (stateMutability == null) {
            stateMutability = "payable";
            if (typeof (obj.constant) === "boolean") {
                stateMutability = "view";
                if (!obj.constant) {
                    stateMutability = "payable";
                    if (typeof (obj.payable) === "boolean" && !obj.payable) {
                        stateMutability = "nonpayable";
                    }
                }
            }
            else if (typeof (obj.payable) === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
            }
        }
        // @TODO: verifyState for stateMutability (e.g. throw if
        //        payable: false but stateMutability is "nonpayable")
        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FunctionFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === FunctionFragmentInternal);
    }
}
/**
 *  A Fragment which represents a structure.
 */
class StructFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "struct", name, inputs);
        Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
    }
    /**
     *  Returns a string representation of this struct as %%format%%.
     */
    format() {
        throw new Error("@TODO");
    }
    /**
     *  Returns a new **StructFragment** for %%obj%%.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            try {
                return StructFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid struct fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("struct", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new StructFragment(_guard, name, inputs);
        }
        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    // @TODO: fix this return type
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **StructFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === StructFragmentInternal);
    }
}

/**
 *  When sending values to or receiving values from a [[Contract]], the
 *  data is generally encoded using the [ABI standard](link-solc-abi).
 *
 *  The AbiCoder provides a utility to encode values to ABI data and
 *  decode values from ABI data.
 *
 *  Most of the time, developers should favour the [[Contract]] class,
 *  which further abstracts a lot of the finer details of ABI data.
 *
 *  @_section api/abi/abi-coder:ABI Encoding
 */
// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
// https://docs.soliditylang.org/en/v0.8.17/control-structures.html
const PanicReasons$1 = new Map();
PanicReasons$1.set(0x00, "GENERIC_PANIC");
PanicReasons$1.set(0x01, "ASSERT_FALSE");
PanicReasons$1.set(0x11, "OVERFLOW");
PanicReasons$1.set(0x12, "DIVIDE_BY_ZERO");
PanicReasons$1.set(0x21, "ENUM_RANGE_ERROR");
PanicReasons$1.set(0x22, "BAD_STORAGE_DATA");
PanicReasons$1.set(0x31, "STACK_UNDERFLOW");
PanicReasons$1.set(0x32, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(0x41, "OUT_OF_MEMORY");
PanicReasons$1.set(0x51, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
    let message = "missing revert data";
    let reason = null;
    const invocation = null;
    let revert = null;
    if (data) {
        message = "execution reverted";
        const bytes = getBytes(data);
        data = hexlify(data);
        if (bytes.length === 0) {
            message += " (no data present; likely require(false) occurred";
            reason = "require(false)";
        }
        else if (bytes.length % 32 !== 4) {
            message += " (could not decode reason; invalid data length)";
        }
        else if (hexlify(bytes.slice(0, 4)) === "0x08c379a0") {
            // Error(string)
            try {
                reason = abiCoder.decode(["string"], bytes.slice(4))[0];
                revert = {
                    signature: "Error(string)",
                    name: "Error",
                    args: [reason]
                };
                message += `: ${JSON.stringify(reason)}`;
            }
            catch (error) {
                message += " (could not decode reason; invalid string data)";
            }
        }
        else if (hexlify(bytes.slice(0, 4)) === "0x4e487b71") {
            // Panic(uint256)
            try {
                const code = Number(abiCoder.decode(["uint256"], bytes.slice(4))[0]);
                revert = {
                    signature: "Panic(uint256)",
                    name: "Panic",
                    args: [code]
                };
                reason = `Panic due to ${PanicReasons$1.get(code) || "UNKNOWN"}(${code})`;
                message += `: ${reason}`;
            }
            catch (error) {
                message += " (could not decode panic code)";
            }
        }
        else {
            message += " (unknown custom error)";
        }
    }
    const transaction = {
        to: (tx.to ? getAddress(tx.to) : null),
        data: (tx.data || "0x")
    };
    if (tx.from) {
        transaction.from = getAddress(tx.from);
    }
    return makeError(message, "CALL_EXCEPTION", {
        action, data, reason, transaction, invocation, revert
    });
}
/**
 *  The **AbiCoder** is a low-level class responsible for encoding JavaScript
 *  values into binary data and decoding binary data into JavaScript values.
 */
class AbiCoder {
    #getCoder(param) {
        if (param.isArray()) {
            return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
        }
        if (param.isTuple()) {
            return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);
        }
        switch (param.baseType) {
            case "address":
                return new AddressCoder(param.name);
            case "bool":
                return new BooleanCoder(param.name);
            case "string":
                return new StringCoder(param.name);
            case "bytes":
                return new BytesCoder(param.name);
            case "":
                return new NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, "invalid " + match[1] + " bit length", "param", param);
            return new NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
            return new FixedBytesCoder(size, param.name);
        }
        assertArgument(false, "invalid type", "type", param.type);
    }
    /**
     *  Get the default values for the given %%types%%.
     *
     *  For example, a ``uint`` is by default ``0`` and ``bool``
     *  is by default ``false``.
     */
    getDefaultValue(types) {
        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    /**
     *  Encode the %%values%% as the %%types%% into ABI data.
     *
     *  @returns DataHexstring
     */
    encode(types, values) {
        assertArgumentCount(values.length, types.length, "types/values length mismatch");
        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
        const coder = (new TupleCoder(coders, "_"));
        const writer = new Writer();
        coder.encode(writer, values);
        return writer.data;
    }
    /**
     *  Decode the ABI %%data%% as the %%types%% into values.
     *
     *  If %%loose%% decoding is enabled, then strict padding is
     *  not enforced. Some older versions of Solidity incorrectly
     *  padded event data emitted from ``external`` functions.
     */
    decode(types, data, loose) {
        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(new Reader(data, loose, defaultMaxInflation));
    }
    static _setDefaultMaxInflation(value) {
        assertArgument(typeof (value) === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
        defaultMaxInflation = value;
    }
    /**
     *  Returns the shared singleton instance of a default [[AbiCoder]].
     *
     *  On the first call, the instance is created internally.
     */
    static defaultAbiCoder() {
        if (defaultCoder == null) {
            defaultCoder = new AbiCoder();
        }
        return defaultCoder;
    }
    /**
     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
     *  result %%data%% for the [[CallExceptionAction]] %%action%% against
     *  the Transaction %%tx%%.
     */
    static getBuiltinCallException(action, tx, data) {
        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
    }
}

/**
 *  The Interface class is a low-level class that accepts an
 *  ABI and provides all the necessary functionality to encode
 *  and decode paramaters to and results from methods, events
 *  and errors.
 *
 *  It also provides several convenience methods to automatically
 *  search and find matching transactions and events to parse them.
 *
 *  @_subsection api/abi:Interfaces  [interfaces]
 */
/**
 *  When using the [[Interface-parseLog]] to automatically match a Log to its event
 *  for parsing, a **LogDescription** is returned.
 */
class LogDescription {
    /**
     *  The matching fragment for the ``topic0``.
     */
    fragment;
    /**
     *  The name of the Event.
     */
    name;
    /**
     *  The full Event signature.
     */
    signature;
    /**
     *  The topic hash for the Event.
     */
    topic;
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    args;
    /**
     *  @_ignore:
     */
    constructor(fragment, topic, args) {
        const name = fragment.name, signature = fragment.format();
        defineProperties(this, {
            fragment, name, signature, topic, args
        });
    }
}
/**
 *  When using the [[Interface-parseTransaction]] to automatically match
 *  a transaction data to its function for parsing,
 *  a **TransactionDescription** is returned.
 */
class TransactionDescription {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    fragment;
    /**
     *  The name of the Function from the transaction ``data``.
     */
    name;
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    args;
    /**
     *  The full Function signature from the transaction ``data``.
     */
    signature;
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    selector;
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    value;
    /**
     *  @_ignore:
     */
    constructor(fragment, selector, args, value) {
        const name = fragment.name, signature = fragment.format();
        defineProperties(this, {
            fragment, name, args, signature, selector, value
        });
    }
}
/**
 *  When using the [[Interface-parseError]] to automatically match an
 *  error for a call result for parsing, an **ErrorDescription** is returned.
 */
class ErrorDescription {
    /**
     *  The matching fragment.
     */
    fragment;
    /**
     *  The name of the Error.
     */
    name;
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    args;
    /**
     *  The full Error signature.
     */
    signature;
    /**
     *  The selector for the Error.
     */
    selector;
    /**
     *  @_ignore:
     */
    constructor(fragment, selector, args) {
        const name = fragment.name, signature = fragment.format();
        defineProperties(this, {
            fragment, name, args, signature, selector
        });
    }
}
/**
 *  An **Indexed** is used as a value when a value that does not
 *  fit within a topic (i.e. not a fixed-length, 32-byte type). It
 *  is the ``keccak256`` of the value, and used for types such as
 *  arrays, tuples, bytes and strings.
 */
class Indexed {
    /**
     *  The ``keccak256`` of the value logged.
     */
    hash;
    /**
     *  @_ignore:
     */
    _isIndexed;
    /**
     *  Returns ``true`` if %%value%% is an **Indexed**.
     *
     *  This provides a Type Guard for property access.
     */
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
    /**
     *  @_ignore:
     */
    constructor(hash) {
        defineProperties(this, { hash, _isIndexed: true });
    }
}
// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require
const PanicReasons = {
    "0": "generic panic",
    "1": "assert(false)",
    "17": "arithmetic overflow",
    "18": "division or modulo by zero",
    "33": "enum overflow",
    "34": "invalid encoded storage byte array accessed",
    "49": "out-of-bounds array access; popping on an empty array",
    "50": "out-of-bounds access of an array or bytesN",
    "65": "out of memory",
    "81": "uninitialized function",
};
const BuiltinErrors = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: (message) => {
            return `reverted with reason string ${JSON.stringify(message)}`;
        }
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"],
        reason: (code) => {
            let reason = "unknown panic code";
            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {
                reason = PanicReasons[code.toString()];
            }
            return `reverted with panic code 0x${code.toString(16)} (${reason})`;
        }
    }
};
/**
 *  An Interface abstracts many of the low-level details for
 *  encoding and decoding the data on the blockchain.
 *
 *  An ABI provides information on how to encode data to send to
 *  a Contract, how to decode the results and events and how to
 *  interpret revert errors.
 *
 *  The ABI can be specified by [any supported format](InterfaceAbi).
 */
class Interface {
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    fragments;
    /**
     *  The Contract constructor.
     */
    deploy;
    /**
     *  The Fallback method, if any.
     */
    fallback;
    /**
     *  If receiving ether is supported.
     */
    receive;
    #errors;
    #events;
    #functions;
    //    #structs: Map<string, StructFragment>;
    #abiCoder;
    /**
     *  Create a new Interface for the %%fragments%%.
     */
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        this.#functions = new Map();
        this.#errors = new Map();
        this.#events = new Map();
        //        this.#structs = new Map();
        const frags = [];
        for (const a of abi) {
            try {
                frags.push(Fragment.from(a));
            }
            catch (error) {
                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);
            }
        }
        defineProperties(this, {
            fragments: Object.freeze(frags)
        });
        let fallback = null;
        let receive = false;
        this.#abiCoder = this.getAbiCoder();
        // Add all fragments by their signature
        this.fragments.forEach((fragment, index) => {
            let bucket;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        console.log("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    defineProperties(this, { deploy: fragment });
                    return;
                case "fallback":
                    if (fragment.inputs.length === 0) {
                        receive = true;
                    }
                    else {
                        assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
                        fallback = fragment;
                        receive = fallback.payable;
                    }
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.#functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.#events;
                    break;
                case "error":
                    bucket = this.#errors;
                    break;
                default:
                    return;
            }
            // Two identical entries; ignore it
            const signature = fragment.format();
            if (bucket.has(signature)) {
                return;
            }
            bucket.set(signature, fragment);
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            defineProperties(this, {
                deploy: ConstructorFragment.from("constructor()")
            });
        }
        defineProperties(this, { fallback, receive });
    }
    /**
     *  Returns the entire Human-Readable ABI, as an array of
     *  signatures, optionally as %%minimal%% strings, which
     *  removes parameter names and unneceesary spaces.
     */
    format(minimal) {
        const format = (minimal ? "minimal" : "full");
        const abi = this.fragments.map((f) => f.format(format));
        return abi;
    }
    /**
     *  Return the JSON-encoded ABI. This is the format Solidiy
     *  returns.
     */
    formatJson() {
        const abi = this.fragments.map((f) => f.format("json"));
        // We need to re-bundle the JSON fragments a bit
        return JSON.stringify(abi.map((j) => JSON.parse(j)));
    }
    /**
     *  The ABI coder that will be used to encode and decode binary
     *  data.
     */
    getAbiCoder() {
        return AbiCoder.defaultAbiCoder();
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    #getFunction(key, values, forceUnique) {
        // Selector
        if (isHexString(key)) {
            const selector = key.toLowerCase();
            for (const fragment of this.#functions.values()) {
                if (selector === fragment.selector) {
                    return fragment;
                }
            }
            return null;
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#functions) {
                if (name.split("(" /* fix:) */)[0] === key) {
                    matching.push(fragment);
                }
            }
            if (values) {
                const lastValue = (values.length > 0) ? values[values.length - 1] : null;
                let valueLength = values.length;
                let allowOptions = true;
                if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
                    allowOptions = false;
                    valueLength--;
                }
                // Remove all matches that don't have a compatible length. The args
                // may contain an overrides, so the match may have n or n - 1 parameters
                for (let i = matching.length - 1; i >= 0; i--) {
                    const inputs = matching[i].inputs.length;
                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
                        matching.splice(i, 1);
                    }
                }
                // Remove all matches that don't match the Typed signature
                for (let i = matching.length - 1; i >= 0; i--) {
                    const inputs = matching[i].inputs;
                    for (let j = 0; j < values.length; j++) {
                        // Not a typed value
                        if (!Typed.isTyped(values[j])) {
                            continue;
                        }
                        // We are past the inputs
                        if (j >= inputs.length) {
                            if (values[j].type === "overrides") {
                                continue;
                            }
                            matching.splice(i, 1);
                            break;
                        }
                        // Make sure the value type matches the input type
                        if (values[j].type !== inputs[j].baseType) {
                            matching.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            // We found a single matching signature with an overrides, but the
            // last value is something that cannot possibly be an options
            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
                const lastArg = values[values.length - 1];
                if (lastArg == null || Array.isArray(lastArg) || typeof (lastArg) !== "object") {
                    matching.splice(0, 1);
                }
            }
            if (matching.length === 0) {
                return null;
            }
            if (matching.length > 1 && forceUnique) {
                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
                assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
            }
            return matching[0];
        }
        // Normalize the signature and lookup the function
        const result = this.#functions.get(FunctionFragment.from(key).format());
        if (result) {
            return result;
        }
        return null;
    }
    /**
     *  Get the function name for %%key%%, which may be a function selector,
     *  function name or function signature that belongs to the ABI.
     */
    getFunctionName(key) {
        const fragment = this.#getFunction(key, null, false);
        assertArgument(fragment, "no matching function", "key", key);
        return fragment.name;
    }
    /**
     *  Returns true if %%key%% (a function selector, function name or
     *  function signature) is present in the ABI.
     *
     *  In the case of a function name, the name may be ambiguous, so
     *  accessing the [[FunctionFragment]] may require refinement.
     */
    hasFunction(key) {
        return !!this.#getFunction(key, null, false);
    }
    /**
     *  Get the [[FunctionFragment]] for %%key%%, which may be a function
     *  selector, function name or function signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple functions match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single function in
     *  the ABI, this will throw.
     */
    getFunction(key, values) {
        return this.#getFunction(key, values || null, true);
    }
    /**
     *  Iterate over all functions, calling %%callback%%, sorted by their name.
     */
    forEachFunction(callback) {
        const names = Array.from(this.#functions.keys());
        names.sort((a, b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback((this.#functions.get(name)), i);
        }
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    #getEvent(key, values, forceUnique) {
        // EventTopic
        if (isHexString(key)) {
            const eventTopic = key.toLowerCase();
            for (const fragment of this.#events.values()) {
                if (eventTopic === fragment.topicHash) {
                    return fragment;
                }
            }
            return null;
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#events) {
                if (name.split("(" /* fix:) */)[0] === key) {
                    matching.push(fragment);
                }
            }
            if (values) {
                // Remove all matches that don't have a compatible length.
                for (let i = matching.length - 1; i >= 0; i--) {
                    if (matching[i].inputs.length < values.length) {
                        matching.splice(i, 1);
                    }
                }
                // Remove all matches that don't match the Typed signature
                for (let i = matching.length - 1; i >= 0; i--) {
                    const inputs = matching[i].inputs;
                    for (let j = 0; j < values.length; j++) {
                        // Not a typed value
                        if (!Typed.isTyped(values[j])) {
                            continue;
                        }
                        // Make sure the value type matches the input type
                        if (values[j].type !== inputs[j].baseType) {
                            matching.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            if (matching.length === 0) {
                return null;
            }
            if (matching.length > 1 && forceUnique) {
                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
                assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
            }
            return matching[0];
        }
        // Normalize the signature and lookup the function
        const result = this.#events.get(EventFragment.from(key).format());
        if (result) {
            return result;
        }
        return null;
    }
    /**
     *  Get the event name for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     */
    getEventName(key) {
        const fragment = this.#getEvent(key, null, false);
        assertArgument(fragment, "no matching event", "key", key);
        return fragment.name;
    }
    /**
     *  Returns true if %%key%% (an event topic hash, event name or
     *  event signature) is present in the ABI.
     *
     *  In the case of an event name, the name may be ambiguous, so
     *  accessing the [[EventFragment]] may require refinement.
     */
    hasEvent(key) {
        return !!this.#getEvent(key, null, false);
    }
    /**
     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple events match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single event in
     *  the ABI, this will throw.
     */
    getEvent(key, values) {
        return this.#getEvent(key, values || null, true);
    }
    /**
     *  Iterate over all events, calling %%callback%%, sorted by their name.
     */
    forEachEvent(callback) {
        const names = Array.from(this.#events.keys());
        names.sort((a, b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback((this.#events.get(name)), i);
        }
    }
    /**
     *  Get the [[ErrorFragment]] for %%key%%, which may be an error
     *  selector, error name or error signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple errors match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single error in
     *  the ABI, this will throw.
     */
    getError(key, values) {
        if (isHexString(key)) {
            const selector = key.toLowerCase();
            if (BuiltinErrors[selector]) {
                return ErrorFragment.from(BuiltinErrors[selector].signature);
            }
            for (const fragment of this.#errors.values()) {
                if (selector === fragment.selector) {
                    return fragment;
                }
            }
            return null;
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#errors) {
                if (name.split("(" /* fix:) */)[0] === key) {
                    matching.push(fragment);
                }
            }
            if (matching.length === 0) {
                if (key === "Error") {
                    return ErrorFragment.from("error Error(string)");
                }
                if (key === "Panic") {
                    return ErrorFragment.from("error Panic(uint256)");
                }
                return null;
            }
            else if (matching.length > 1) {
                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
                assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
            }
            return matching[0];
        }
        // Normalize the signature and lookup the function
        key = ErrorFragment.from(key).format();
        if (key === "Error(string)") {
            return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic(uint256)") {
            return ErrorFragment.from("error Panic(uint256)");
        }
        const result = this.#errors.get(key);
        if (result) {
            return result;
        }
        return null;
    }
    /**
     *  Iterate over all errors, calling %%callback%%, sorted by their name.
     */
    forEachError(callback) {
        const names = Array.from(this.#errors.keys());
        names.sort((a, b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback((this.#errors.get(name)), i);
        }
    }
    // Get the 4-byte selector used by Solidity to identify a function
    /*
getSelector(fragment: ErrorFragment | FunctionFragment): string {
    if (typeof(fragment) === "string") {
        const matches: Array<Fragment> = [ ];

        try { matches.push(this.getFunction(fragment)); } catch (error) { }
        try { matches.push(this.getError(<string>fragment)); } catch (_) { }

        if (matches.length === 0) {
            logger.throwArgumentError("unknown fragment", "key", fragment);
        } else if (matches.length > 1) {
            logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
        }

        fragment = matches[0];
    }

    return dataSlice(id(fragment.format()), 0, 4);
}
    */
    // Get the 32-byte topic hash used by Solidity to identify an event
    /*
    getEventTopic(fragment: EventFragment): string {
        //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
        return id(fragment.format());
    }
    */
    _decodeParams(params, data) {
        return this.#abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this.#abiCoder.encode(params, values);
    }
    /**
     *  Encodes a ``tx.data`` object for deploying the Contract with
     *  the %%values%% as the constructor arguments.
     */
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified error (see [[getError]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            const f = this.getError(fragment);
            assertArgument(f, "unknown error", "fragment", fragment);
            fragment = f;
        }
        assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
        return this._decodeParams(fragment.inputs, dataSlice(data, 4));
    }
    /**
     *  Encodes the transaction revert data for a call result that
     *  reverted from the the Contract with the sepcified %%error%%
     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getError(fragment);
            assertArgument(f, "unknown error", "fragment", fragment);
            fragment = f;
        }
        return concat([
            fragment.selector,
            this._encodeParams(fragment.inputs, values || [])
        ]);
    }
    /**
     *  Decodes the %%data%% from a transaction ``tx.data`` for
     *  the function specified (see [[getFunction]] for valid values
     *  for %%fragment%%).
     *
     *  Most developers should prefer the [[parseTransaction]] method
     *  instead, which will automatically detect the fragment.
     */
    decodeFunctionData(fragment, data) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            assertArgument(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
        return this._decodeParams(fragment.inputs, dataSlice(data, 4));
    }
    /**
     *  Encodes the ``tx.data`` for a transaction that calls the function
     *  specified (see [[getFunction]] for valid values for %%fragment%%) with
     *  the %%values%%.
     */
    encodeFunctionData(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            assertArgument(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        return concat([
            fragment.selector,
            this._encodeParams(fragment.inputs, values || [])
        ]);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
    decodeFunctionResult(fragment, data) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            assertArgument(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        let message = "invalid length for result data";
        const bytes = getBytesCopy(data);
        if ((bytes.length % 32) === 0) {
            try {
                return this.#abiCoder.decode(fragment.outputs, bytes);
            }
            catch (error) {
                message = "could not decode result data";
            }
        }
        // Call returned data with no error, but the data is junk
        assert(false, message, "BAD_DATA", {
            value: hexlify(bytes),
            info: { method: fragment.name, signature: fragment.format() }
        });
    }
    makeError(_data, tx) {
        const data = getBytes(_data, "data");
        const error = AbiCoder.getBuiltinCallException("call", tx, data);
        // Not a built-in error; try finding a custom error
        const customPrefix = "execution reverted (unknown custom error)";
        if (error.message.startsWith(customPrefix)) {
            const selector = hexlify(data.slice(0, 4));
            const ef = this.getError(selector);
            if (ef) {
                try {
                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
                    error.revert = {
                        name: ef.name, signature: ef.format(), args
                    };
                    error.reason = error.revert.signature;
                    error.message = `execution reverted: ${error.reason}`;
                }
                catch (e) {
                    error.message = `execution reverted (coult not decode custom error)`;
                }
            }
        }
        // Add the invocation, if available
        const parsed = this.parseTransaction(tx);
        if (parsed) {
            error.invocation = {
                method: parsed.name,
                signature: parsed.signature,
                args: parsed.args
            };
        }
        return error;
    }
    /**
     *  Encodes the result data (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values
     *  for %%fragment%%) with %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
    encodeFunctionResult(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            assertArgument(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
    }
    /*
        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
            const promises: Array<Promise<>> = [ ];
            const process = function(type: ParamType, value: any): any {
                if (type.baseType === "array") {
                    return descend(type.child
                }
                if (type. === "address") {
                }
            };
    
            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
                if (inputs.length !== values.length) { throw new Error("length mismatch"); }
                
            };
    
            const result: Array<any> = [ ];
            values.forEach((value, index) => {
                if (value == null) {
                    topics.push(null);
                } else if (param.baseType === "array" || param.baseType === "tuple") {
                    logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
                } else if (Array.isArray(value)) {
                    topics.push(value.map((value) => encodeTopic(param, value)));
                } else {
                    topics.push(encodeTopic(param, value));
                }
            });
        }
    */
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getEvent(fragment);
            assertArgument(f, "unknown event", "eventFragment", fragment);
            fragment = f;
        }
        assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
        const topics = [];
        if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
        }
        // @TODO: Use the coders for this; to properly support tuples, etc.
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return id$1(value);
            }
            else if (param.type === "bytes") {
                return keccak256(hexlify(value));
            }
            if (param.type === "bool" && typeof (value) === "boolean") {
                value = (value ? "0x01" : "0x00");
            }
            else if (param.type.match(/^u?int/)) {
                value = toBeHex(value); // @TODO: Should this toTwos??
            }
            else if (param.type.match(/^bytes/)) {
                value = zeroPadBytes(value, 32);
            }
            else if (param.type === "address") {
                // Check addresses are valid
                this.#abiCoder.encode(["address"], [value]);
            }
            return zeroPadValue(hexlify(value), 32);
        };
        values.forEach((value, index) => {
            const param = fragment.inputs[index];
            if (!param.indexed) {
                assertArgument(value == null, "cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                assertArgument(false, "filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getEvent(fragment);
            assertArgument(f, "unknown event", "eventFragment", fragment);
            fragment = f;
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
        }
        assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
        fragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push(id$1(value));
                }
                else if (param.type === "bytes") {
                    topics.push(keccak256(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this.#abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this.#abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(fragment, data, topics) {
        if (typeof (fragment) === "string") {
            const f = this.getEvent(fragment);
            assertArgument(f, "unknown event", "eventFragment", fragment);
            fragment = f;
        }
        if (topics != null && !fragment.anonymous) {
            const eventTopic = fragment.topicHash;
            assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
            topics = topics.slice(1);
        }
        const indexed = [];
        const nonIndexed = [];
        const dynamic = [];
        fragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, concat(topics)) : null;
        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
        //const result: (Array<any> & { [ key: string ]: any }) = [ ];
        const values = [];
        const keys = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        fragment.inputs.forEach((param, index) => {
            let value = null;
            if (param.indexed) {
                if (resultIndexed == null) {
                    value = new Indexed(null);
                }
                else if (dynamic[index]) {
                    value = new Indexed(resultIndexed[indexedIndex++]);
                }
                else {
                    try {
                        value = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        value = error;
                    }
                }
            }
            else {
                try {
                    value = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    value = error;
                }
            }
            values.push(value);
            keys.push(param.name || null);
        });
        return Result.fromItems(values, keys);
    }
    /**
     *  Parses a transaction, finding the matching function and extracts
     *  the parameter values along with other useful function details.
     *
     *  If the matching function cannot be found, return null.
     */
    parseTransaction(tx) {
        const data = getBytes(tx.data, "tx.data");
        const value = getBigInt((tx.value != null) ? tx.value : 0, "tx.value");
        const fragment = this.getFunction(hexlify(data.slice(0, 4)));
        if (!fragment) {
            return null;
        }
        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
        return new TransactionDescription(fragment, fragment.selector, args, value);
    }
    parseCallResult(data) {
        throw new Error("@TODO");
    }
    /**
     *  Parses a receipt log, finding the matching event and extracts
     *  the parameter values along with other useful event details.
     *
     *  If the matching event cannot be found, returns null.
     */
    parseLog(log) {
        const fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
    }
    /**
     *  Parses a revert data, finding the matching error and extracts
     *  the parameter values along with other useful error details.
     *
     *  If the matching error cannot be found, returns null.
     */
    parseError(data) {
        const hexData = hexlify(data);
        const fragment = this.getError(dataSlice(hexData, 0, 4));
        if (!fragment) {
            return null;
        }
        const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
        return new ErrorDescription(fragment, fragment.selector, args);
    }
    /**
     *  Creates a new [[Interface]] from the ABI %%value%%.
     *
     *  The %%value%% may be provided as an existing [[Interface]] object,
     *  a JSON-encoded ABI or any Human-Readable ABI format.
     */
    static from(value) {
        // Already an Interface, which is immutable
        if (value instanceof Interface) {
            return value;
        }
        // JSON
        if (typeof (value) === "string") {
            return new Interface(JSON.parse(value));
        }
        // An Interface; possibly from another v6 instance
        if (typeof (value.formatJson) === "function") {
            return new Interface(value.formatJson());
        }
        // A legacy Interface; from an older version
        if (typeof (value.format) === "function") {
            return new Interface(value.format("json"));
        }
        // Array of fragments
        return new Interface(value);
    }
}

//import { resolveAddress } from "@ethersproject/address";
const BN_0$2 = BigInt(0);
// -----------------------
function getValue(value) {
    if (value == null) {
        return null;
    }
    return value;
}
function toJson(value) {
    if (value == null) {
        return null;
    }
    return value.toString();
}
// @TODO? <T extends FeeData = { }> implements Required<T>
/**
 *  A **FeeData** wraps all the fee-related values associated with
 *  the network.
 */
class FeeData {
    /**
     *  The gas price for legacy networks.
     */
    gasPrice;
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    maxFeePerGas;
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    maxPriorityFeePerGas;
    /**
     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
     *  %%maxPriorityFeePerGas%%.
     */
    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
        defineProperties(this, {
            gasPrice: getValue(gasPrice),
            maxFeePerGas: getValue(maxFeePerGas),
            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
        });
    }
    /**
     *  Returns a JSON-friendly value.
     */
    toJSON() {
        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
        return {
            _type: "FeeData",
            gasPrice: toJson(gasPrice),
            maxFeePerGas: toJson(maxFeePerGas),
            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),
        };
    }
}
/**
 *  Returns a copy of %%req%% with all properties coerced to their strict
 *  types.
 */
function copyRequest(req) {
    const result = {};
    // These could be addresses, ENS names or Addressables
    if (req.to) {
        result.to = req.to;
    }
    if (req.from) {
        result.from = req.from;
    }
    if (req.data) {
        result.data = hexlify(req.data);
    }
    const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const key of bigIntKeys) {
        if (!(key in req) || req[key] == null) {
            continue;
        }
        result[key] = getBigInt(req[key], `request.${key}`);
    }
    const numberKeys = "type,nonce".split(/,/);
    for (const key of numberKeys) {
        if (!(key in req) || req[key] == null) {
            continue;
        }
        result[key] = getNumber(req[key], `request.${key}`);
    }
    if (req.accessList) {
        result.accessList = accessListify(req.accessList);
    }
    if (req.authorizationList) {
        result.authorizationList = req.authorizationList.slice();
    }
    if ("blockTag" in req) {
        result.blockTag = req.blockTag;
    }
    if ("enableCcipRead" in req) {
        result.enableCcipRead = !!req.enableCcipRead;
    }
    if ("customData" in req) {
        result.customData = req.customData;
    }
    if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
        result.blobVersionedHashes = req.blobVersionedHashes.slice();
    }
    if ("kzg" in req) {
        result.kzg = req.kzg;
    }
    if ("blobs" in req && req.blobs) {
        result.blobs = req.blobs.map((b) => {
            if (isBytesLike(b)) {
                return hexlify(b);
            }
            return Object.assign({}, b);
        });
    }
    return result;
}
/**
 *  A **Block** represents the data associated with a full block on
 *  Ethereum.
 */
class Block {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    provider;
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    number;
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    hash;
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    timestamp;
    /**
     *  The block hash of the parent block.
     */
    parentHash;
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    parentBeaconBlockRoot;
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    nonce;
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    difficulty;
    /**
     *  The total gas limit for this block.
     */
    gasLimit;
    /**
     *  The total gas used in this block.
     */
    gasUsed;
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    stateRoot;
    /**
     *  The hash of the transaction receipts trie.
     */
    receiptsRoot;
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    blobGasUsed;
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    excessBlobGas;
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    miner;
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    prevRandao;
    /**
     *  Any extra data the validator wished to include.
     */
    extraData;
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    baseFeePerGas;
    #transactions;
    /**
     *  Create a new **Block** object.
     *
     *  This should generally not be necessary as the unless implementing a
     *  low-level library.
     */
    constructor(block, provider) {
        this.#transactions = block.transactions.map((tx) => {
            if (typeof (tx) !== "string") {
                return new TransactionResponse(tx, provider);
            }
            return tx;
        });
        defineProperties(this, {
            provider,
            hash: getValue(block.hash),
            number: block.number,
            timestamp: block.timestamp,
            parentHash: block.parentHash,
            parentBeaconBlockRoot: block.parentBeaconBlockRoot,
            nonce: block.nonce,
            difficulty: block.difficulty,
            gasLimit: block.gasLimit,
            gasUsed: block.gasUsed,
            blobGasUsed: block.blobGasUsed,
            excessBlobGas: block.excessBlobGas,
            miner: block.miner,
            prevRandao: getValue(block.prevRandao),
            extraData: block.extraData,
            baseFeePerGas: getValue(block.baseFeePerGas),
            stateRoot: block.stateRoot,
            receiptsRoot: block.receiptsRoot,
        });
    }
    /**
     *  Returns the list of transaction hashes, in the order
     *  they were executed within the block.
     */
    get transactions() {
        return this.#transactions.map((tx) => {
            if (typeof (tx) === "string") {
                return tx;
            }
            return tx.hash;
        });
    }
    /**
     *  Returns the complete transactions, in the order they
     *  were executed within the block.
     *
     *  This is only available for blocks which prefetched
     *  transactions, by passing ``true`` to %%prefetchTxs%%
     *  into [[Provider-getBlock]].
     */
    get prefetchedTransactions() {
        const txs = this.#transactions.slice();
        // Doesn't matter...
        if (txs.length === 0) {
            return [];
        }
        // Make sure we prefetched the transactions
        assert(typeof (txs[0]) === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
            operation: "transactionResponses()"
        });
        return txs;
    }
    /**
     *  Returns a JSON-friendly value.
     */
    toJSON() {
        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
        return {
            _type: "Block",
            baseFeePerGas: toJson(baseFeePerGas),
            difficulty: toJson(difficulty),
            extraData,
            gasLimit: toJson(gasLimit),
            gasUsed: toJson(gasUsed),
            blobGasUsed: toJson(this.blobGasUsed),
            excessBlobGas: toJson(this.excessBlobGas),
            hash, miner, prevRandao, nonce, number, parentHash, timestamp,
            parentBeaconBlockRoot, stateRoot, receiptsRoot,
            transactions,
        };
    }
    [Symbol.iterator]() {
        let index = 0;
        const txs = this.transactions;
        return {
            next: () => {
                if (index < this.length) {
                    return {
                        value: txs[index++], done: false
                    };
                }
                return { value: undefined, done: true };
            }
        };
    }
    /**
     *  The number of transactions in this block.
     */
    get length() { return this.#transactions.length; }
    /**
     *  The [[link-js-date]] this block was included at.
     */
    get date() {
        if (this.timestamp == null) {
            return null;
        }
        return new Date(this.timestamp * 1000);
    }
    /**
     *  Get the transaction at %%indexe%% within this block.
     */
    async getTransaction(indexOrHash) {
        // Find the internal value by its index or hash
        let tx = undefined;
        if (typeof (indexOrHash) === "number") {
            tx = this.#transactions[indexOrHash];
        }
        else {
            const hash = indexOrHash.toLowerCase();
            for (const v of this.#transactions) {
                if (typeof (v) === "string") {
                    if (v !== hash) {
                        continue;
                    }
                    tx = v;
                    break;
                }
                else {
                    if (v.hash !== hash) {
                        continue;
                    }
                    tx = v;
                    break;
                }
            }
        }
        if (tx == null) {
            throw new Error("no such tx");
        }
        if (typeof (tx) === "string") {
            return (await this.provider.getTransaction(tx));
        }
        else {
            return tx;
        }
    }
    /**
     *  If a **Block** was fetched with a request to include the transactions
     *  this will allow synchronous access to those transactions.
     *
     *  If the transactions were not prefetched, this will throw.
     */
    getPrefetchedTransaction(indexOrHash) {
        const txs = this.prefetchedTransactions;
        if (typeof (indexOrHash) === "number") {
            return txs[indexOrHash];
        }
        indexOrHash = indexOrHash.toLowerCase();
        for (const tx of txs) {
            if (tx.hash === indexOrHash) {
                return tx;
            }
        }
        assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
    }
    /**
     *  Returns true if this block been mined. This provides a type guard
     *  for all properties on a [[MinedBlock]].
     */
    isMined() { return !!this.hash; }
    /**
     *  Returns true if this block is an [[link-eip-2930]] block.
     */
    isLondon() {
        return !!this.baseFeePerGas;
    }
    /**
     *  @_ignore:
     */
    orphanedEvent() {
        if (!this.isMined()) {
            throw new Error("");
        }
        return createOrphanedBlockFilter(this);
    }
}
//////////////////////
// Log
/**
 *  A **Log** in Ethereum represents an event that has been included in a
 *  transaction using the ``LOG*`` opcodes, which are most commonly used by
 *  Solidity's emit for announcing events.
 */
class Log {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    provider;
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    transactionHash;
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    blockHash;
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    blockNumber;
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    removed;
    /**
     *  The address of the contract that emitted this log.
     */
    address;
    /**
     *  The data included in this log when it was emitted.
     */
    data;
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    topics;
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    index;
    /**
     *  The index within the transaction of this log.
     */
    transactionIndex;
    /**
     *  @_ignore:
     */
    constructor(log, provider) {
        this.provider = provider;
        const topics = Object.freeze(log.topics.slice());
        defineProperties(this, {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            removed: log.removed,
            address: log.address,
            data: log.data,
            topics,
            index: log.index,
            transactionIndex: log.transactionIndex,
        });
    }
    /**
     *  Returns a JSON-compatible object.
     */
    toJSON() {
        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
        return {
            _type: "log",
            address, blockHash, blockNumber, data, index,
            removed, topics, transactionHash, transactionIndex
        };
    }
    /**
     *  Returns the block that this log occurred in.
     */
    async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
        return block;
    }
    /**
     *  Returns the transaction that this log occurred in.
     */
    async getTransaction() {
        const tx = await this.provider.getTransaction(this.transactionHash);
        assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
        return tx;
    }
    /**
     *  Returns the transaction receipt fot the transaction that this
     *  log occurred in.
     */
    async getTransactionReceipt() {
        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
        assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
        return receipt;
    }
    /**
     *  @_ignore:
     */
    removedEvent() {
        return createRemovedLogFilter(this);
    }
}
//////////////////////
// Transaction Receipt
/*
export interface LegacyTransactionReceipt {
    byzantium: false;
    status: null;
    root: string;
}

export interface ByzantiumTransactionReceipt {
    byzantium: true;
    status: number;
    root: null;
}
*/
/**
 *  A **TransactionReceipt** includes additional information about a
 *  transaction that is only available after it has been mined.
 */
class TransactionReceipt {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    provider;
    /**
     *  The address the transaction was sent to.
     */
    to;
    /**
     *  The sender of the transaction.
     */
    from;
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    contractAddress;
    /**
     *  The transaction hash.
     */
    hash;
    /**
     *  The index of this transaction within the block transactions.
     */
    index;
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    blockHash;
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    blockNumber;
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    logsBloom;
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    gasUsed;
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    blobGasUsed;
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    cumulativeGasUsed;
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    gasPrice;
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    blobGasPrice;
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    type;
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    status;
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    root;
    #logs;
    /**
     *  @_ignore:
     */
    constructor(tx, provider) {
        this.#logs = Object.freeze(tx.logs.map((log) => {
            return new Log(log, provider);
        }));
        let gasPrice = BN_0$2;
        if (tx.effectiveGasPrice != null) {
            gasPrice = tx.effectiveGasPrice;
        }
        else if (tx.gasPrice != null) {
            gasPrice = tx.gasPrice;
        }
        defineProperties(this, {
            provider,
            to: tx.to,
            from: tx.from,
            contractAddress: tx.contractAddress,
            hash: tx.hash,
            index: tx.index,
            blockHash: tx.blockHash,
            blockNumber: tx.blockNumber,
            logsBloom: tx.logsBloom,
            gasUsed: tx.gasUsed,
            cumulativeGasUsed: tx.cumulativeGasUsed,
            blobGasUsed: tx.blobGasUsed,
            gasPrice,
            blobGasPrice: tx.blobGasPrice,
            type: tx.type,
            //byzantium: tx.byzantium,
            status: tx.status,
            root: tx.root
        });
    }
    /**
     *  The logs for this transaction.
     */
    get logs() { return this.#logs; }
    /**
     *  Returns a JSON-compatible representation.
     */
    toJSON() {
        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, 
        status, root } = this;
        return {
            _type: "TransactionReceipt",
            blockHash, blockNumber,
            //byzantium, 
            contractAddress,
            cumulativeGasUsed: toJson(this.cumulativeGasUsed),
            from,
            gasPrice: toJson(this.gasPrice),
            blobGasUsed: toJson(this.blobGasUsed),
            blobGasPrice: toJson(this.blobGasPrice),
            gasUsed: toJson(this.gasUsed),
            hash, index, logs, logsBloom, root, status, to
        };
    }
    /**
     *  @_ignore:
     */
    get length() { return this.logs.length; }
    [Symbol.iterator]() {
        let index = 0;
        return {
            next: () => {
                if (index < this.length) {
                    return { value: this.logs[index++], done: false };
                }
                return { value: undefined, done: true };
            }
        };
    }
    /**
     *  The total fee for this transaction, in wei.
     */
    get fee() {
        return this.gasUsed * this.gasPrice;
    }
    /**
     *  Resolves to the block this transaction occurred in.
     */
    async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        if (block == null) {
            throw new Error("TODO");
        }
        return block;
    }
    /**
     *  Resolves to the transaction this transaction occurred in.
     */
    async getTransaction() {
        const tx = await this.provider.getTransaction(this.hash);
        if (tx == null) {
            throw new Error("TODO");
        }
        return tx;
    }
    /**
     *  Resolves to the return value of the execution of this transaction.
     *
     *  Support for this feature is limited, as it requires an archive node
     *  with the ``debug_`` or ``trace_`` API enabled.
     */
    async getResult() {
        return (await this.provider.getTransactionResult(this.hash));
    }
    /**
     *  Resolves to the number of confirmations this transaction has.
     */
    async confirmations() {
        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
    }
    /**
     *  @_ignore:
     */
    removedEvent() {
        return createRemovedTransactionFilter(this);
    }
    /**
     *  @_ignore:
     */
    reorderedEvent(other) {
        assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
        return createReorderedTransactionFilter(this, other);
    }
}
/**
 *  A **TransactionResponse** includes all properties about a transaction
 *  that was sent to the network, which may or may not be included in a
 *  block.
 *
 *  The [[TransactionResponse-isMined]] can be used to check if the
 *  transaction has been mined as well as type guard that the otherwise
 *  possibly ``null`` properties are defined.
 */
class TransactionResponse {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    provider;
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    blockNumber;
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    blockHash;
    /**
     *  The index within the block that this transaction resides at.
     */
    index;
    /**
     *  The transaction hash.
     */
    hash;
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    type;
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    to;
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    from;
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    nonce;
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    gasLimit;
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    gasPrice;
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    maxPriorityFeePerGas;
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    maxFeePerGas;
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    maxFeePerBlobGas;
    /**
     *  The data.
     */
    data;
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    value;
    /**
     *  The chain ID.
     */
    chainId;
    /**
     *  The signature.
     */
    signature;
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    accessList;
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    blobVersionedHashes;
    /**
     *  The [[link-eip-7702]] authorizations (if any).
     */
    authorizationList;
    #startBlock;
    /**
     *  @_ignore:
     */
    constructor(tx, provider) {
        this.provider = provider;
        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;
        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;
        this.hash = tx.hash;
        this.index = tx.index;
        this.type = tx.type;
        this.from = tx.from;
        this.to = tx.to || null;
        this.gasLimit = tx.gasLimit;
        this.nonce = tx.nonce;
        this.data = tx.data;
        this.value = tx.value;
        this.gasPrice = tx.gasPrice;
        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;
        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;
        this.maxFeePerBlobGas = (tx.maxFeePerBlobGas != null) ? tx.maxFeePerBlobGas : null;
        this.chainId = tx.chainId;
        this.signature = tx.signature;
        this.accessList = (tx.accessList != null) ? tx.accessList : null;
        this.blobVersionedHashes = (tx.blobVersionedHashes != null) ? tx.blobVersionedHashes : null;
        this.authorizationList = (tx.authorizationList != null) ? tx.authorizationList : null;
        this.#startBlock = -1;
    }
    /**
     *  Returns a JSON-compatible representation of this transaction.
     */
    toJSON() {
        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
        return {
            _type: "TransactionResponse",
            accessList, blockNumber, blockHash,
            blobVersionedHashes,
            chainId: toJson(this.chainId),
            data, from,
            gasLimit: toJson(this.gasLimit),
            gasPrice: toJson(this.gasPrice),
            hash,
            maxFeePerGas: toJson(this.maxFeePerGas),
            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
            nonce, signature, to, index, type,
            value: toJson(this.value),
        };
    }
    /**
     *  Resolves to the Block that this transaction was included in.
     *
     *  This will return null if the transaction has not been included yet.
     */
    async getBlock() {
        let blockNumber = this.blockNumber;
        if (blockNumber == null) {
            const tx = await this.getTransaction();
            if (tx) {
                blockNumber = tx.blockNumber;
            }
        }
        if (blockNumber == null) {
            return null;
        }
        const block = this.provider.getBlock(blockNumber);
        if (block == null) {
            throw new Error("TODO");
        }
        return block;
    }
    /**
     *  Resolves to this transaction being re-requested from the
     *  provider. This can be used if you have an unmined transaction
     *  and wish to get an up-to-date populated instance.
     */
    async getTransaction() {
        return this.provider.getTransaction(this.hash);
    }
    /**
     *  Resolve to the number of confirmations this transaction has.
     */
    async confirmations() {
        if (this.blockNumber == null) {
            const { tx, blockNumber } = await resolveProperties({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber()
            });
            // Not mined yet...
            if (tx == null || tx.blockNumber == null) {
                return 0;
            }
            return blockNumber - tx.blockNumber + 1;
        }
        const blockNumber = await this.provider.getBlockNumber();
        return blockNumber - this.blockNumber + 1;
    }
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    async wait(_confirms, _timeout) {
        const confirms = (_confirms == null) ? 1 : _confirms;
        const timeout = (_timeout == null) ? 0 : _timeout;
        let startBlock = this.#startBlock;
        let nextScan = -1;
        let stopScanning = (startBlock === -1) ? true : false;
        const checkReplacement = async () => {
            // Get the current transaction count for this sender
            if (stopScanning) {
                return null;
            }
            const { blockNumber, nonce } = await resolveProperties({
                blockNumber: this.provider.getBlockNumber(),
                nonce: this.provider.getTransactionCount(this.from)
            });
            // No transaction or our nonce has not been mined yet; but we
            // can start scanning later when we do start
            if (nonce < this.nonce) {
                startBlock = blockNumber;
                return;
            }
            // We were mined; no replacement
            if (stopScanning) {
                return null;
            }
            const mined = await this.getTransaction();
            if (mined && mined.blockNumber != null) {
                return;
            }
            // We were replaced; start scanning for that transaction
            // Starting to scan; look back a few extra blocks for safety
            if (nextScan === -1) {
                nextScan = startBlock - 3;
                if (nextScan < this.#startBlock) {
                    nextScan = this.#startBlock;
                }
            }
            while (nextScan <= blockNumber) {
                // Get the next block to scan
                if (stopScanning) {
                    return null;
                }
                const block = await this.provider.getBlock(nextScan, true);
                // This should not happen; but we'll try again shortly
                if (block == null) {
                    return;
                }
                // We were mined; no replacement
                for (const hash of block) {
                    if (hash === this.hash) {
                        return;
                    }
                }
                // Search for the transaction that replaced us
                for (let i = 0; i < block.length; i++) {
                    const tx = await block.getTransaction(i);
                    if (tx.from === this.from && tx.nonce === this.nonce) {
                        // Get the receipt
                        if (stopScanning) {
                            return null;
                        }
                        const receipt = await this.provider.getTransactionReceipt(tx.hash);
                        // This should not happen; but we'll try again shortly
                        if (receipt == null) {
                            return;
                        }
                        // We will retry this on the next block (this case could be optimized)
                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {
                            return;
                        }
                        // The reason we were replaced
                        let reason = "replaced";
                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                            reason = "repriced";
                        }
                        else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
                            reason = "cancelled";
                        }
                        assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                            cancelled: (reason === "replaced" || reason === "cancelled"),
                            reason,
                            replacement: tx.replaceableTransaction(startBlock),
                            hash: tx.hash,
                            receipt
                        });
                    }
                }
                nextScan++;
            }
            return;
        };
        const checkReceipt = (receipt) => {
            if (receipt == null || receipt.status !== 0) {
                return receipt;
            }
            assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
                action: "sendTransaction",
                data: null, reason: null, invocation: null, revert: null,
                transaction: {
                    to: receipt.to,
                    from: receipt.from,
                    data: "" // @TODO: in v7, split out sendTransaction properties
                }, receipt
            });
        };
        const receipt = await this.provider.getTransactionReceipt(this.hash);
        if (confirms === 0) {
            return checkReceipt(receipt);
        }
        if (receipt) {
            if (confirms === 1 || (await receipt.confirmations()) >= confirms) {
                return checkReceipt(receipt);
            }
        }
        else {
            // Check for a replacement; throws if a replacement was found
            await checkReplacement();
            // Allow null only when the confirms is 0
            if (confirms === 0) {
                return null;
            }
        }
        const waiter = new Promise((resolve, reject) => {
            // List of things to cancel when we have a result (one way or the other)
            const cancellers = [];
            const cancel = () => { cancellers.forEach((c) => c()); };
            // On cancel, stop scanning for replacements
            cancellers.push(() => { stopScanning = true; });
            // Set up any timeout requested
            if (timeout > 0) {
                const timer = setTimeout(() => {
                    cancel();
                    reject(makeError("wait for transaction timeout", "TIMEOUT"));
                }, timeout);
                cancellers.push(() => { clearTimeout(timer); });
            }
            const txListener = async (receipt) => {
                // Done; return it!
                if ((await receipt.confirmations()) >= confirms) {
                    cancel();
                    try {
                        resolve(checkReceipt(receipt));
                    }
                    catch (error) {
                        reject(error);
                    }
                }
            };
            cancellers.push(() => { this.provider.off(this.hash, txListener); });
            this.provider.on(this.hash, txListener);
            // We support replacement detection; start checking
            if (startBlock >= 0) {
                const replaceListener = async () => {
                    try {
                        // Check for a replacement; this throws only if one is found
                        await checkReplacement();
                    }
                    catch (error) {
                        // We were replaced (with enough confirms); re-throw the error
                        if (isError(error, "TRANSACTION_REPLACED")) {
                            cancel();
                            reject(error);
                            return;
                        }
                    }
                    // Rescheudle a check on the next block
                    if (!stopScanning) {
                        this.provider.once("block", replaceListener);
                    }
                };
                cancellers.push(() => { this.provider.off("block", replaceListener); });
                this.provider.once("block", replaceListener);
            }
        });
        return await waiter;
    }
    /**
     *  Returns ``true`` if this transaction has been included.
     *
     *  This is effective only as of the time the TransactionResponse
     *  was instantiated. To get up-to-date information, use
     *  [[getTransaction]].
     *
     *  This provides a Type Guard that this transaction will have
     *  non-null property values for properties that are null for
     *  unmined transactions.
     */
    isMined() {
        return (this.blockHash != null);
    }
    /**
     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
     *  transaction.
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isLegacy() {
        return (this.type === 0);
    }
    /**
     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
     *  transaction. See [[link-eip-2070]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isBerlin() {
        return (this.type === 1);
    }
    /**
     *  Returns true if the transaction is a London (i.e. ``type == 2``)
     *  transaction. See [[link-eip-1559]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isLondon() {
        return (this.type === 2);
    }
    /**
     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
     *  transaction. See [[link-eip-4844]].
     */
    isCancun() {
        return (this.type === 3);
    }
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that evict this transaction.
     */
    removedEvent() {
        assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createRemovedTransactionFilter(this);
    }
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that re-order this event against %%other%%.
     */
    reorderedEvent(other) {
        assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createReorderedTransactionFilter(this, other);
    }
    /**
     *  Returns a new TransactionResponse instance which has the ability to
     *  detect (and throw an error) if the transaction is replaced, which
     *  will begin scanning at %%startBlock%%.
     *
     *  This should generally not be used by developers and is intended
     *  primarily for internal use. Setting an incorrect %%startBlock%% can
     *  have devastating performance consequences if used incorrectly.
     */
    replaceableTransaction(startBlock) {
        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
        const tx = new TransactionResponse(this, this.provider);
        tx.#startBlock = startBlock;
        return tx;
    }
}
function createOrphanedBlockFilter(block) {
    return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
    return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
    return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
    return { orphan: "drop-log", log: {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            address: log.address,
            data: log.data,
            topics: Object.freeze(log.topics.slice()),
            index: log.index
        } };
}

// import from provider.ts instead of index.ts to prevent circular dep
// from EtherscanProvider
/**
 *  An **EventLog** contains additional properties parsed from the [[Log]].
 */
class EventLog extends Log {
    /**
     *  The Contract Interface.
     */
    interface;
    /**
     *  The matching event.
     */
    fragment;
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    args;
    /**
     * @_ignore:
     */
    constructor(log, iface, fragment) {
        super(log, log.provider);
        const args = iface.decodeEventLog(fragment, log.data, log.topics);
        defineProperties(this, { args, fragment, interface: iface });
    }
    /**
     *  The name of the event.
     */
    get eventName() { return this.fragment.name; }
    /**
     *  The signature of the event.
     */
    get eventSignature() { return this.fragment.format(); }
}
/**
 *  An **EventLog** contains additional properties parsed from the [[Log]].
 */
class UndecodedEventLog extends Log {
    /**
     *  The error encounted when trying to decode the log.
     */
    error;
    /**
     * @_ignore:
     */
    constructor(log, error) {
        super(log, log.provider);
        defineProperties(this, { error });
    }
}
/**
 *  A **ContractTransactionReceipt** includes the parsed logs from a
 *  [[TransactionReceipt]].
 */
class ContractTransactionReceipt extends TransactionReceipt {
    #iface;
    /**
     *  @_ignore:
     */
    constructor(iface, provider, tx) {
        super(tx, provider);
        this.#iface = iface;
    }
    /**
     *  The parsed logs for any [[Log]] which has a matching event in the
     *  Contract ABI.
     */
    get logs() {
        return super.logs.map((log) => {
            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
            if (fragment) {
                try {
                    return new EventLog(log, this.#iface, fragment);
                }
                catch (error) {
                    return new UndecodedEventLog(log, error);
                }
            }
            return log;
        });
    }
}
/**
 *  A **ContractTransactionResponse** will return a
 *  [[ContractTransactionReceipt]] when waited on.
 */
class ContractTransactionResponse extends TransactionResponse {
    #iface;
    /**
     *  @_ignore:
     */
    constructor(iface, provider, tx) {
        super(tx, provider);
        this.#iface = iface;
    }
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    async wait(confirms, timeout) {
        const receipt = await super.wait(confirms, timeout);
        if (receipt == null) {
            return null;
        }
        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
    }
}
/**
 *  A **ContractUnknownEventPayload** is included as the last parameter to
 *  Contract Events when the event does not match any events in the ABI.
 */
class ContractUnknownEventPayload extends EventPayload {
    /**
     *  The log with no matching events.
     */
    log;
    /**
     *  @_event:
     */
    constructor(contract, listener, filter, log) {
        super(contract, listener, filter);
        defineProperties(this, { log });
    }
    /**
     *  Resolves to the block the event occured in.
     */
    async getBlock() {
        return await this.log.getBlock();
    }
    /**
     *  Resolves to the transaction the event occured in.
     */
    async getTransaction() {
        return await this.log.getTransaction();
    }
    /**
     *  Resolves to the transaction receipt the event occured in.
     */
    async getTransactionReceipt() {
        return await this.log.getTransactionReceipt();
    }
}
/**
 *  A **ContractEventPayload** is included as the last parameter to
 *  Contract Events when the event is known.
 */
class ContractEventPayload extends ContractUnknownEventPayload {
    /**
     *  @_ignore:
     */
    constructor(contract, listener, filter, fragment, _log) {
        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
        defineProperties(this, { args, fragment });
    }
    /**
     *  The event name.
     */
    get eventName() {
        return this.fragment.name;
    }
    /**
     *  The event signature.
     */
    get eventSignature() {
        return this.fragment.format();
    }
}

const BN_0$1 = BigInt(0);
function canCall(value) {
    return (value && typeof (value.call) === "function");
}
function canEstimate(value) {
    return (value && typeof (value.estimateGas) === "function");
}
function canResolve(value) {
    return (value && typeof (value.resolveName) === "function");
}
function canSend(value) {
    return (value && typeof (value.sendTransaction) === "function");
}
function getResolver(value) {
    if (value != null) {
        if (canResolve(value)) {
            return value;
        }
        if (value.provider) {
            return value.provider;
        }
    }
    return undefined;
}
class PreparedTopicFilter {
    #filter;
    fragment;
    constructor(contract, fragment, args) {
        defineProperties(this, { fragment });
        if (fragment.inputs.length < args.length) {
            throw new Error("too many arguments");
        }
        // Recursively descend into args and resolve any addresses
        const runner = getRunner(contract.runner, "resolveName");
        const resolver = canResolve(runner) ? runner : null;
        this.#filter = (async function () {
            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
                const arg = args[index];
                if (arg == null) {
                    return null;
                }
                return param.walkAsync(args[index], (type, value) => {
                    if (type === "address") {
                        if (Array.isArray(value)) {
                            return Promise.all(value.map((v) => resolveAddress(v, resolver)));
                        }
                        return resolveAddress(value, resolver);
                    }
                    return value;
                });
            }));
            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
        })();
    }
    getTopicFilter() {
        return this.#filter;
    }
}
// A = Arguments passed in as a tuple
// R = The result type of the call (i.e. if only one return type,
//     the qualified type, otherwise Result)
// D = The type the default call will return (i.e. R for view/pure,
//     TransactionResponse otherwise)
//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {
function getRunner(value, feature) {
    if (value == null) {
        return null;
    }
    if (typeof (value[feature]) === "function") {
        return value;
    }
    if (value.provider && typeof (value.provider[feature]) === "function") {
        return value.provider;
    }
    return null;
}
function getProvider$1(value) {
    if (value == null) {
        return null;
    }
    return value.provider || null;
}
/**
 *  @_ignore:
 */
async function copyOverrides(arg, allowed) {
    // Make sure the overrides passed in are a valid overrides object
    const _overrides = Typed.dereference(arg, "overrides");
    assertArgument(typeof (_overrides) === "object", "invalid overrides parameter", "overrides", arg);
    // Create a shallow copy (we'll deep-ify anything needed during normalizing)
    const overrides = copyRequest(_overrides);
    assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
    assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
    // Resolve any from
    if (overrides.from) {
        overrides.from = overrides.from;
    }
    return overrides;
}
/**
 *  @_ignore:
 */
async function resolveArgs(_runner, inputs, args) {
    // Recursively descend into args and resolve any addresses
    const runner = getRunner(_runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    return await Promise.all(inputs.map((param, index) => {
        return param.walkAsync(args[index], (type, value) => {
            value = Typed.dereference(value, type);
            if (type === "address") {
                return resolveAddress(value, resolver);
            }
            return value;
        });
    }));
}
function buildWrappedFallback(contract) {
    const populateTransaction = async function (overrides) {
        // If an overrides was passed in, copy it and normalize the values
        const tx = (await copyOverrides(overrides, ["data"]));
        tx.to = await contract.getAddress();
        if (tx.from) {
            tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
        }
        const iface = contract.interface;
        const noValue = (getBigInt((tx.value || BN_0$1), "overrides.value") === BN_0$1);
        const noData = ((tx.data || "0x") === "0x");
        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
            assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
        }
        assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
        // Only allow payable contracts to set non-zero value
        const payable = iface.receive || (iface.fallback && iface.fallback.payable);
        assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
        // Only allow fallback contracts to set non-empty data
        assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
        return tx;
    };
    const staticCall = async function (overrides) {
        const runner = getRunner(contract.runner, "call");
        assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
        const tx = await populateTransaction(overrides);
        try {
            return await runner.call(tx);
        }
        catch (error) {
            if (isCallException(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
            }
            throw error;
        }
    };
    const send = async function (overrides) {
        const runner = contract.runner;
        assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
        const tx = await runner.sendTransaction(await populateTransaction(overrides));
        const provider = getProvider$1(contract.runner);
        // @TODO: the provider can be null; make a custom dummy provider that will throw a
        // meaningful error
        return new ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas = async function (overrides) {
        const runner = getRunner(contract.runner, "estimateGas");
        assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
        return await runner.estimateGas(await populateTransaction(overrides));
    };
    const method = async (overrides) => {
        return await send(overrides);
    };
    defineProperties(method, {
        _contract: contract,
        estimateGas,
        populateTransaction,
        send, staticCall
    });
    return method;
}
function buildWrappedMethod(contract, key) {
    const getFragment = function (...args) {
        const fragment = contract.interface.getFunction(key, args);
        assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key, args }
        });
        return fragment;
    };
    const populateTransaction = async function (...args) {
        const fragment = getFragment(...args);
        // If an overrides was passed in, copy it and normalize the values
        let overrides = {};
        if (fragment.inputs.length + 1 === args.length) {
            overrides = await copyOverrides(args.pop());
            if (overrides.from) {
                overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
            }
        }
        if (fragment.inputs.length !== args.length) {
            throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
        }
        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
        return Object.assign({}, overrides, await resolveProperties({
            to: contract.getAddress(),
            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
        }));
    };
    const staticCall = async function (...args) {
        const result = await staticCallResult(...args);
        if (result.length === 1) {
            return result[0];
        }
        return result;
    };
    const send = async function (...args) {
        const runner = contract.runner;
        assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
        const tx = await runner.sendTransaction(await populateTransaction(...args));
        const provider = getProvider$1(contract.runner);
        // @TODO: the provider can be null; make a custom dummy provider that will throw a
        // meaningful error
        return new ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas = async function (...args) {
        const runner = getRunner(contract.runner, "estimateGas");
        assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
        return await runner.estimateGas(await populateTransaction(...args));
    };
    const staticCallResult = async function (...args) {
        const runner = getRunner(contract.runner, "call");
        assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
        const tx = await populateTransaction(...args);
        let result = "0x";
        try {
            result = await runner.call(tx);
        }
        catch (error) {
            if (isCallException(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
            }
            throw error;
        }
        const fragment = getFragment(...args);
        return contract.interface.decodeFunctionResult(fragment, result);
    };
    const method = async (...args) => {
        const fragment = getFragment(...args);
        if (fragment.constant) {
            return await staticCall(...args);
        }
        return await send(...args);
    };
    defineProperties(method, {
        name: contract.interface.getFunctionName(key),
        _contract: contract, _key: key,
        getFragment,
        estimateGas,
        populateTransaction,
        send, staticCall, staticCallResult,
    });
    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
    Object.defineProperty(method, "fragment", {
        configurable: false,
        enumerable: true,
        get: () => {
            const fragment = contract.interface.getFunction(key);
            assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: { key }
            });
            return fragment;
        }
    });
    return method;
}
function buildWrappedEvent(contract, key) {
    const getFragment = function (...args) {
        const fragment = contract.interface.getEvent(key, args);
        assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key, args }
        });
        return fragment;
    };
    const method = function (...args) {
        return new PreparedTopicFilter(contract, getFragment(...args), args);
    };
    defineProperties(method, {
        name: contract.interface.getEventName(key),
        _contract: contract, _key: key,
        getFragment
    });
    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
    Object.defineProperty(method, "fragment", {
        configurable: false,
        enumerable: true,
        get: () => {
            const fragment = contract.interface.getEvent(key);
            assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: { key }
            });
            return fragment;
        }
    });
    return method;
}
// The combination of TypeScrype, Private Fields and Proxies makes
// the world go boom; so we hide variables with some trickery keeping
// a symbol attached to each BaseContract which its sub-class (even
// via a Proxy) can reach and use to look up its internal values.
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = new WeakMap();
function setInternal(contract, values) {
    internalValues.set(contract[internal], values);
}
function getInternal(contract) {
    return internalValues.get(contract[internal]);
}
function isDeferred(value) {
    return (value && typeof (value) === "object" && ("getTopicFilter" in value) &&
        (typeof (value.getTopicFilter) === "function") && value.fragment);
}
async function getSubInfo(contract, event) {
    let topics;
    let fragment = null;
    // Convert named events to topicHash and get the fragment for
    // events which need deconstructing.
    if (Array.isArray(event)) {
        const topicHashify = function (name) {
            if (isHexString(name, 32)) {
                return name;
            }
            const fragment = contract.interface.getEvent(name);
            assertArgument(fragment, "unknown fragment", "name", name);
            return fragment.topicHash;
        };
        // Array of Topics and Names; e.g. `[ "0x1234...89ab", "Transfer(address)" ]`
        topics = event.map((e) => {
            if (e == null) {
                return null;
            }
            if (Array.isArray(e)) {
                return e.map(topicHashify);
            }
            return topicHashify(e);
        });
    }
    else if (event === "*") {
        topics = [null];
    }
    else if (typeof (event) === "string") {
        if (isHexString(event, 32)) {
            // Topic Hash
            topics = [event];
        }
        else {
            // Name or Signature; e.g. `"Transfer", `"Transfer(address)"`
            fragment = contract.interface.getEvent(event);
            assertArgument(fragment, "unknown fragment", "event", event);
            topics = [fragment.topicHash];
        }
    }
    else if (isDeferred(event)) {
        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`
        topics = await event.getTopicFilter();
    }
    else if ("fragment" in event) {
        // ContractEvent; e.g. `contract.filter.Transfer`
        fragment = event.fragment;
        topics = [fragment.topicHash];
    }
    else {
        assertArgument(false, "unknown event name", "event", event);
    }
    // Normalize topics and sort TopicSets
    topics = topics.map((t) => {
        if (t == null) {
            return null;
        }
        if (Array.isArray(t)) {
            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());
            if (items.length === 1) {
                return items[0];
            }
            items.sort();
            return items;
        }
        return t.toLowerCase();
    });
    const tag = topics.map((t) => {
        if (t == null) {
            return "null";
        }
        if (Array.isArray(t)) {
            return t.join("|");
        }
        return t;
    }).join("&");
    return { fragment, tag, topics };
}
async function hasSub(contract, event) {
    const { subs } = getInternal(contract);
    return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
    // Make sure our runner can actually subscribe to events
    const provider = getProvider$1(contract.runner);
    assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
    const { fragment, tag, topics } = await getSubInfo(contract, event);
    const { addr, subs } = getInternal(contract);
    let sub = subs.get(tag);
    if (!sub) {
        const address = (addr ? addr : contract);
        const filter = { address, topics };
        const listener = (log) => {
            let foundFragment = fragment;
            if (foundFragment == null) {
                try {
                    foundFragment = contract.interface.getEvent(log.topics[0]);
                }
                catch (error) { }
            }
            // If fragment is null, we do not deconstruct the args to emit
            if (foundFragment) {
                const _foundFragment = foundFragment;
                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
                emit(contract, event, args, (listener) => {
                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);
                });
            }
            else {
                emit(contract, event, [], (listener) => {
                    return new ContractUnknownEventPayload(contract, listener, event, log);
                });
            }
        };
        let starting = [];
        const start = () => {
            if (starting.length) {
                return;
            }
            starting.push(provider.on(filter, listener));
        };
        const stop = async () => {
            if (starting.length == 0) {
                return;
            }
            let started = starting;
            starting = [];
            await Promise.all(started);
            provider.off(filter, listener);
        };
        sub = { tag, listeners: [], start, stop };
        subs.set(tag, sub);
    }
    return sub;
}
// We use this to ensure one emit resolves before firing the next to
// ensure correct ordering (note this cannot throw and just adds the
// notice to the event queu using setTimeout).
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
    await lastEmit;
    const sub = await hasSub(contract, event);
    if (!sub) {
        return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
        const passArgs = Array.from(args);
        if (payloadFunc) {
            passArgs.push(payloadFunc(once ? null : listener));
        }
        try {
            listener.call(contract, ...passArgs);
        }
        catch (error) { }
        return !once;
    });
    if (sub.listeners.length === 0) {
        sub.stop();
        getInternal(contract).subs.delete(sub.tag);
    }
    return (count > 0);
}
async function emit(contract, event, args, payloadFunc) {
    try {
        await lastEmit;
    }
    catch (error) { }
    const resultPromise = _emit(contract, event, args, payloadFunc);
    lastEmit = resultPromise;
    return await resultPromise;
}
const passProperties = ["then"];
class BaseContract {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    target;
    /**
     *  The contract Interface.
     */
    interface;
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    runner;
    /**
     *  All the Events available on this contract.
     */
    filters;
    /**
     *  @_ignore:
     */
    [internal];
    /**
     *  The fallback or receive function if any.
     */
    fallback;
    /**
     *  Creates a new contract connected to %%target%% with the %%abi%% and
     *  optionally connected to a %%runner%% to perform operations on behalf
     *  of.
     */
    constructor(target, abi, runner, _deployTx) {
        assertArgument(typeof (target) === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
        if (runner == null) {
            runner = null;
        }
        const iface = Interface.from(abi);
        defineProperties(this, { target, runner, interface: iface });
        Object.defineProperty(this, internal, { value: {} });
        let addrPromise;
        let addr = null;
        let deployTx = null;
        if (_deployTx) {
            const provider = getProvider$1(runner);
            // @TODO: the provider can be null; make a custom dummy provider that will throw a
            // meaningful error
            deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
        }
        let subs = new Map();
        // Resolve the target as the address
        if (typeof (target) === "string") {
            if (isHexString(target)) {
                addr = target;
                addrPromise = Promise.resolve(target);
            }
            else {
                const resolver = getRunner(runner, "resolveName");
                if (!canResolve(resolver)) {
                    throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                        operation: "resolveName"
                    });
                }
                addrPromise = resolver.resolveName(target).then((addr) => {
                    if (addr == null) {
                        throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                            value: target
                        });
                    }
                    getInternal(this).addr = addr;
                    return addr;
                });
            }
        }
        else {
            addrPromise = target.getAddress().then((addr) => {
                if (addr == null) {
                    throw new Error("TODO");
                }
                getInternal(this).addr = addr;
                return addr;
            });
        }
        // Set our private values
        setInternal(this, { addrPromise, addr, deployTx, subs });
        // Add the event filters
        const filters = new Proxy({}, {
            get: (target, prop, receiver) => {
                // Pass important checks (like `then` for Promise) through
                if (typeof (prop) === "symbol" || passProperties.indexOf(prop) >= 0) {
                    return Reflect.get(target, prop, receiver);
                }
                try {
                    return this.getEvent(prop);
                }
                catch (error) {
                    if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                        throw error;
                    }
                }
                return undefined;
            },
            has: (target, prop) => {
                // Pass important checks (like `then` for Promise) through
                if (passProperties.indexOf(prop) >= 0) {
                    return Reflect.has(target, prop);
                }
                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));
            }
        });
        defineProperties(this, { filters });
        defineProperties(this, {
            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)
        });
        // Return a Proxy that will respond to functions
        return new Proxy(this, {
            get: (target, prop, receiver) => {
                if (typeof (prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
                    return Reflect.get(target, prop, receiver);
                }
                // Undefined properties should return undefined
                try {
                    return target.getFunction(prop);
                }
                catch (error) {
                    if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                        throw error;
                    }
                }
                return undefined;
            },
            has: (target, prop) => {
                if (typeof (prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
                    return Reflect.has(target, prop);
                }
                return target.interface.hasFunction(prop);
            }
        });
    }
    /**
     *  Return a new Contract instance with the same target and ABI, but
     *  a different %%runner%%.
     */
    connect(runner) {
        return new BaseContract(this.target, this.interface, runner);
    }
    /**
     *  Return a new Contract instance with the same ABI and runner, but
     *  a different %%target%%.
     */
    attach(target) {
        return new BaseContract(target, this.interface, this.runner);
    }
    /**
     *  Return the resolved address of this Contract.
     */
    async getAddress() { return await getInternal(this).addrPromise; }
    /**
     *  Return the deployed bytecode or null if no bytecode is found.
     */
    async getDeployedCode() {
        const provider = getProvider$1(this.runner);
        assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
        const code = await provider.getCode(await this.getAddress());
        if (code === "0x") {
            return null;
        }
        return code;
    }
    /**
     *  Resolve to this Contract once the bytecode has been deployed, or
     *  resolve immediately if already deployed.
     */
    async waitForDeployment() {
        // We have the deployement transaction; just use that (throws if deployement fails)
        const deployTx = this.deploymentTransaction();
        if (deployTx) {
            await deployTx.wait();
            return this;
        }
        // Check for code
        const code = await this.getDeployedCode();
        if (code != null) {
            return this;
        }
        // Make sure we can subscribe to a provider event
        const provider = getProvider$1(this.runner);
        assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
        return new Promise((resolve, reject) => {
            const checkCode = async () => {
                try {
                    const code = await this.getDeployedCode();
                    if (code != null) {
                        return resolve(this);
                    }
                    provider.once("block", checkCode);
                }
                catch (error) {
                    reject(error);
                }
            };
            checkCode();
        });
    }
    /**
     *  Return the transaction used to deploy this contract.
     *
     *  This is only available if this instance was returned from a
     *  [[ContractFactory]].
     */
    deploymentTransaction() {
        return getInternal(this).deployTx;
    }
    /**
     *  Return the function for a given name. This is useful when a contract
     *  method name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
    getFunction(key) {
        if (typeof (key) !== "string") {
            key = key.format();
        }
        const func = buildWrappedMethod(this, key);
        return func;
    }
    /**
     *  Return the event for a given name. This is useful when a contract
     *  event name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
    getEvent(key) {
        if (typeof (key) !== "string") {
            key = key.format();
        }
        return buildWrappedEvent(this, key);
    }
    /**
     *  @_ignore:
     */
    async queryTransaction(hash) {
        throw new Error("@TODO");
    }
    /*
    // @TODO: this is a non-backwards compatible change, but will be added
    //        in v7 and in a potential SmartContract class in an upcoming
    //        v6 release
    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
        const provider = getProvider(this.runner);
        assert(provider, "contract runner does not have a provider",
            "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });

        const receipt = await provider.getTransactionReceipt(hash);
        if (receipt == null) { return null; }

        return new ContractTransactionReceipt(this.interface, provider, receipt);
    }
    */
    /**
     *  Provide historic access to event data for %%event%% in the range
     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
     *  inclusive.
     */
    async queryFilter(event, fromBlock, toBlock) {
        if (fromBlock == null) {
            fromBlock = 0;
        }
        if (toBlock == null) {
            toBlock = "latest";
        }
        const { addr, addrPromise } = getInternal(this);
        const address = (addr ? addr : (await addrPromise));
        const { fragment, topics } = await getSubInfo(this, event);
        const filter = { address, topics, fromBlock, toBlock };
        const provider = getProvider$1(this.runner);
        assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
        return (await provider.getLogs(filter)).map((log) => {
            let foundFragment = fragment;
            if (foundFragment == null) {
                try {
                    foundFragment = this.interface.getEvent(log.topics[0]);
                }
                catch (error) { }
            }
            if (foundFragment) {
                try {
                    return new EventLog(log, this.interface, foundFragment);
                }
                catch (error) {
                    return new UndecodedEventLog(log, error);
                }
            }
            return new Log(log, provider);
        });
    }
    /**
     *  Add an event %%listener%% for the %%event%%.
     */
    async on(event, listener) {
        const sub = await getSub(this, "on", event);
        sub.listeners.push({ listener, once: false });
        sub.start();
        return this;
    }
    /**
     *  Add an event %%listener%% for the %%event%%, but remove the listener
     *  after it is fired once.
     */
    async once(event, listener) {
        const sub = await getSub(this, "once", event);
        sub.listeners.push({ listener, once: true });
        sub.start();
        return this;
    }
    /**
     *  Emit an %%event%% calling all listeners with %%args%%.
     *
     *  Resolves to ``true`` if any listeners were called.
     */
    async emit(event, ...args) {
        return await emit(this, event, args, null);
    }
    /**
     *  Resolves to the number of listeners of %%event%% or the total number
     *  of listeners if unspecified.
     */
    async listenerCount(event) {
        if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return 0;
            }
            return sub.listeners.length;
        }
        const { subs } = getInternal(this);
        let total = 0;
        for (const { listeners } of subs.values()) {
            total += listeners.length;
        }
        return total;
    }
    /**
     *  Resolves to the listeners subscribed to %%event%% or all listeners
     *  if unspecified.
     */
    async listeners(event) {
        if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return [];
            }
            return sub.listeners.map(({ listener }) => listener);
        }
        const { subs } = getInternal(this);
        let result = [];
        for (const { listeners } of subs.values()) {
            result = result.concat(listeners.map(({ listener }) => listener));
        }
        return result;
    }
    /**
     *  Remove the %%listener%% from the listeners for %%event%% or remove
     *  all listeners if unspecified.
     */
    async off(event, listener) {
        const sub = await hasSub(this, event);
        if (!sub) {
            return this;
        }
        if (listener) {
            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);
            if (index >= 0) {
                sub.listeners.splice(index, 1);
            }
        }
        if (listener == null || sub.listeners.length === 0) {
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
        }
        return this;
    }
    /**
     *  Remove all the listeners for %%event%% or remove all listeners if
     *  unspecified.
     */
    async removeAllListeners(event) {
        if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return this;
            }
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
        }
        else {
            const { subs } = getInternal(this);
            for (const { tag, stop } of subs.values()) {
                stop();
                subs.delete(tag);
            }
        }
        return this;
    }
    /**
     *  Alias for [on].
     */
    async addListener(event, listener) {
        return await this.on(event, listener);
    }
    /**
     *  Alias for [off].
     */
    async removeListener(event, listener) {
        return await this.off(event, listener);
    }
    /**
     *  Create a new Class for the %%abi%%.
     */
    static buildClass(abi) {
        class CustomContract extends BaseContract {
            constructor(address, runner = null) {
                super(address, abi, runner);
            }
        }
        return CustomContract;
    }
    ;
    /**
     *  Create a new BaseContract with a specified Interface.
     */
    static from(target, abi, runner) {
        if (runner == null) {
            runner = null;
        }
        const contract = new this(target, abi, runner);
        return contract;
    }
}
function _ContractBase() {
    return BaseContract;
}
/**
 *  A [[BaseContract]] with no type guards on its methods or events.
 */
class Contract extends _ContractBase() {
}

/**
 *  ENS is a service which allows easy-to-remember names to map to
 *  network addresses.
 *
 *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]
 */
// @TODO: This should use the fetch-data:ipfs gateway
// Trim off the ipfs:// prefix and return the default gateway URL
function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) {
        link = link.substring(12);
    }
    else if (link.match(/^ipfs:\/\//i)) {
        link = link.substring(7);
    }
    else {
        assertArgument(false, "unsupported IPFS format", "link", link);
    }
    return `https:/\/gateway.ipfs.io/ipfs/${link}`;
}
/**
 *  A provider plugin super-class for processing multicoin address types.
 */
class MulticoinProviderPlugin {
    /**
     *  The name.
     */
    name;
    /**
     *  Creates a new **MulticoinProviderPluing** for %%name%%.
     */
    constructor(name) {
        defineProperties(this, { name });
    }
    connect(proivder) {
        return this;
    }
    /**
     *  Returns ``true`` if %%coinType%% is supported by this plugin.
     */
    supportsCoinType(coinType) {
        return false;
    }
    /**
     *  Resolves to the encoded %%address%% for %%coinType%%.
     */
    async encodeAddress(coinType, address) {
        throw new Error("unsupported coin");
    }
    /**
     *  Resolves to the decoded %%data%% for %%coinType%%.
     */
    async decodeAddress(coinType, data) {
        throw new Error("unsupported coin");
    }
}
const matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
const matchers = [
    new RegExp("^(https):/\/(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    matcherIpfs,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
];
/**
 *  A connected object to a resolved ENS name resolver, which can be
 *  used to query additional details.
 */
class EnsResolver {
    /**
     *  The connected provider.
     */
    provider;
    /**
     *  The address of the resolver.
     */
    address;
    /**
     *  The name this resolver was resolved against.
     */
    name;
    // For EIP-2544 names, the ancestor that provided the resolver
    #supports2544;
    #resolver;
    constructor(provider, address, name) {
        defineProperties(this, { provider, address, name });
        this.#supports2544 = null;
        this.#resolver = new Contract(address, [
            "function supportsInterface(bytes4) view returns (bool)",
            "function resolve(bytes, bytes) view returns (bytes)",
            "function addr(bytes32) view returns (address)",
            "function addr(bytes32, uint) view returns (bytes)",
            "function text(bytes32, string) view returns (string)",
            "function contenthash(bytes32) view returns (bytes)",
        ], provider);
    }
    /**
     *  Resolves to true if the resolver supports wildcard resolution.
     */
    async supportsWildcard() {
        if (this.#supports2544 == null) {
            this.#supports2544 = (async () => {
                try {
                    return await this.#resolver.supportsInterface("0x9061b923");
                }
                catch (error) {
                    // Wildcard resolvers must understand supportsInterface
                    // and return true.
                    if (isError(error, "CALL_EXCEPTION")) {
                        return false;
                    }
                    // Let future attempts try again...
                    this.#supports2544 = null;
                    throw error;
                }
            })();
        }
        return await this.#supports2544;
    }
    async #fetch(funcName, params) {
        params = (params || []).slice();
        const iface = this.#resolver.interface;
        // The first parameters is always the nodehash
        params.unshift(namehash(this.name));
        let fragment = null;
        if (await this.supportsWildcard()) {
            fragment = iface.getFunction(funcName);
            assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
                info: { funcName }
            });
            params = [
                dnsEncode(this.name, 255),
                iface.encodeFunctionData(fragment, params)
            ];
            funcName = "resolve(bytes,bytes)";
        }
        params.push({
            enableCcipRead: true
        });
        try {
            const result = await this.#resolver[funcName](...params);
            if (fragment) {
                return iface.decodeFunctionResult(fragment, result)[0];
            }
            return result;
        }
        catch (error) {
            if (!isError(error, "CALL_EXCEPTION")) {
                throw error;
            }
        }
        return null;
    }
    /**
     *  Resolves to the address for %%coinType%% or null if the
     *  provided %%coinType%% has not been configured.
     */
    async getAddress(coinType) {
        if (coinType == null) {
            coinType = 60;
        }
        if (coinType === 60) {
            try {
                const result = await this.#fetch("addr(bytes32)");
                // No address
                if (result == null || result === ZeroAddress) {
                    return null;
                }
                return result;
            }
            catch (error) {
                if (isError(error, "CALL_EXCEPTION")) {
                    return null;
                }
                throw error;
            }
        }
        // Try decoding its EVM canonical chain as an EVM chain address first
        if (coinType >= 0 && coinType < 0x80000000) {
            let ethCoinType = coinType + 0x80000000;
            const data = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
            if (isHexString(data, 20)) {
                return getAddress(data);
            }
        }
        let coinPlugin = null;
        for (const plugin of this.provider.plugins) {
            if (!(plugin instanceof MulticoinProviderPlugin)) {
                continue;
            }
            if (plugin.supportsCoinType(coinType)) {
                coinPlugin = plugin;
                break;
            }
        }
        if (coinPlugin == null) {
            return null;
        }
        // keccak256("addr(bytes32,uint256")
        const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
        // No address
        if (data == null || data === "0x") {
            return null;
        }
        // Compute the address
        const address = await coinPlugin.decodeAddress(coinType, data);
        if (address != null) {
            return address;
        }
        assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
            operation: `getAddress(${coinType})`,
            info: { coinType, data }
        });
    }
    /**
     *  Resolves to the EIP-634 text record for %%key%%, or ``null``
     *  if unconfigured.
     */
    async getText(key) {
        const data = await this.#fetch("text(bytes32,string)", [key]);
        if (data == null || data === "0x") {
            return null;
        }
        return data;
    }
    /**
     *  Rsolves to the content-hash or ``null`` if unconfigured.
     */
    async getContentHash() {
        // keccak256("contenthash()")
        const data = await this.#fetch("contenthash(bytes32)");
        // No contenthash
        if (data == null || data === "0x") {
            return null;
        }
        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)
        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (ipfs) {
            const scheme = (ipfs[1] === "e3010170") ? "ipfs" : "ipns";
            const length = parseInt(ipfs[4], 16);
            if (ipfs[5].length === length * 2) {
                return `${scheme}:/\/${encodeBase58("0x" + ipfs[2])}`;
            }
        }
        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (swarm && swarm[1].length === 64) {
            return `bzz:/\/${swarm[1]}`;
        }
        assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
            operation: "getContentHash()",
            info: { data }
        });
    }
    /**
     *  Resolves to the avatar url or ``null`` if the avatar is either
     *  unconfigured or incorrectly configured (e.g. references an NFT
     *  not owned by the address).
     *
     *  If diagnosing issues with configurations, the [[_getAvatar]]
     *  method may be useful.
     */
    async getAvatar() {
        const avatar = await this._getAvatar();
        return avatar.url;
    }
    /**
     *  When resolving an avatar, there are many steps involved, such
     *  fetching metadata and possibly validating ownership of an
     *  NFT.
     *
     *  This method can be used to examine each step and the value it
     *  was working from.
     */
    async _getAvatar() {
        const linkage = [{ type: "name", value: this.name }];
        try {
            // test data for ricmoo.eth
            //const avatar = "eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233";
            const avatar = await this.getText("avatar");
            if (avatar == null) {
                linkage.push({ type: "!avatar", value: "" });
                return { url: null, linkage };
            }
            linkage.push({ type: "avatar", value: avatar });
            for (let i = 0; i < matchers.length; i++) {
                const match = avatar.match(matchers[i]);
                if (match == null) {
                    continue;
                }
                const scheme = match[1].toLowerCase();
                switch (scheme) {
                    case "https":
                    case "data":
                        linkage.push({ type: "url", value: avatar });
                        return { linkage, url: avatar };
                    case "ipfs": {
                        const url = getIpfsLink(avatar);
                        linkage.push({ type: "ipfs", value: avatar });
                        linkage.push({ type: "url", value: url });
                        return { linkage, url };
                    }
                    case "erc721":
                    case "erc1155": {
                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                        const selector = (scheme === "erc721") ? "tokenURI(uint256)" : "uri(uint256)";
                        linkage.push({ type: scheme, value: avatar });
                        // The owner of this name
                        const owner = await this.getAddress();
                        if (owner == null) {
                            linkage.push({ type: "!owner", value: "" });
                            return { url: null, linkage };
                        }
                        const comps = (match[2] || "").split("/");
                        if (comps.length !== 2) {
                            linkage.push({ type: `!${scheme}caip`, value: (match[2] || "") });
                            return { url: null, linkage };
                        }
                        const tokenId = comps[1];
                        const contract = new Contract(comps[0], [
                            // ERC-721
                            "function tokenURI(uint) view returns (string)",
                            "function ownerOf(uint) view returns (address)",
                            // ERC-1155
                            "function uri(uint) view returns (string)",
                            "function balanceOf(address, uint256) view returns (uint)"
                        ], this.provider);
                        // Check that this account owns the token
                        if (scheme === "erc721") {
                            const tokenOwner = await contract.ownerOf(tokenId);
                            if (owner !== tokenOwner) {
                                linkage.push({ type: "!owner", value: tokenOwner });
                                return { url: null, linkage };
                            }
                            linkage.push({ type: "owner", value: tokenOwner });
                        }
                        else if (scheme === "erc1155") {
                            const balance = await contract.balanceOf(owner, tokenId);
                            if (!balance) {
                                linkage.push({ type: "!balance", value: "0" });
                                return { url: null, linkage };
                            }
                            linkage.push({ type: "balance", value: balance.toString() });
                        }
                        // Call the token contract for the metadata URL
                        let metadataUrl = await contract[selector](tokenId);
                        if (metadataUrl == null || metadataUrl === "0x") {
                            linkage.push({ type: "!metadata-url", value: "" });
                            return { url: null, linkage };
                        }
                        linkage.push({ type: "metadata-url-base", value: metadataUrl });
                        // ERC-1155 allows a generic {id} in the URL
                        if (scheme === "erc1155") {
                            metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
                            linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
                        }
                        // Transform IPFS metadata links
                        if (metadataUrl.match(/^ipfs:/i)) {
                            metadataUrl = getIpfsLink(metadataUrl);
                        }
                        linkage.push({ type: "metadata-url", value: metadataUrl });
                        // Get the token metadata
                        let metadata = {};
                        const response = await (new FetchRequest(metadataUrl)).send();
                        response.assertOk();
                        try {
                            metadata = response.bodyJson;
                        }
                        catch (error) {
                            try {
                                linkage.push({ type: "!metadata", value: response.bodyText });
                            }
                            catch (error) {
                                const bytes = response.body;
                                if (bytes) {
                                    linkage.push({ type: "!metadata", value: hexlify(bytes) });
                                }
                                return { url: null, linkage };
                            }
                            return { url: null, linkage };
                        }
                        if (!metadata) {
                            linkage.push({ type: "!metadata", value: "" });
                            return { url: null, linkage };
                        }
                        linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
                        // Pull the image URL out
                        let imageUrl = metadata.image;
                        if (typeof (imageUrl) !== "string") {
                            linkage.push({ type: "!imageUrl", value: "" });
                            return { url: null, linkage };
                        }
                        if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                            // Allow
                        }
                        else {
                            // Transform IPFS link to gateway
                            const ipfs = imageUrl.match(matcherIpfs);
                            if (ipfs == null) {
                                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                                return { url: null, linkage };
                            }
                            linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
                            imageUrl = getIpfsLink(imageUrl);
                        }
                        linkage.push({ type: "url", value: imageUrl });
                        return { linkage, url: imageUrl };
                    }
                }
            }
        }
        catch (error) { }
        return { linkage, url: null };
    }
    static async getEnsAddress(provider) {
        const network = await provider.getNetwork();
        const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
        // No ENS...
        assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
            operation: "getEnsAddress", info: { network }
        });
        return ensPlugin.address;
    }
    static async #getResolver(provider, name) {
        const ensAddr = await EnsResolver.getEnsAddress(provider);
        try {
            const contract = new Contract(ensAddr, [
                "function resolver(bytes32) view returns (address)"
            ], provider);
            const addr = await contract.resolver(namehash(name), {
                enableCcipRead: true
            });
            if (addr === ZeroAddress) {
                return null;
            }
            return addr;
        }
        catch (error) {
            // ENS registry cannot throw errors on resolver(bytes32),
            // so probably a link error
            throw error;
        }
        return null;
    }
    /**
     *  Resolve to the ENS resolver for %%name%% using %%provider%% or
     *  ``null`` if unconfigured.
     */
    static async fromName(provider, name) {
        let currentName = name;
        while (true) {
            if (currentName === "" || currentName === ".") {
                return null;
            }
            // Optimization since the eth node cannot change and does
            // not have a wildcard resolver
            if (name !== "eth" && currentName === "eth") {
                return null;
            }
            // Check the current node for a resolver
            const addr = await EnsResolver.#getResolver(provider, currentName);
            // Found a resolver!
            if (addr != null) {
                const resolver = new EnsResolver(provider, addr, name);
                // Legacy resolver found, using EIP-2544 so it isn't safe to use
                if (currentName !== name && !(await resolver.supportsWildcard())) {
                    return null;
                }
                return resolver;
            }
            // Get the parent node
            currentName = currentName.split(".").slice(1).join(".");
        }
    }
}

/**
 *  @_ignore
 */
const BN_0 = BigInt(0);
function allowNull(format, nullValue) {
    return (function (value) {
        if (value == null) {
            return nullValue;
        }
        return format(value);
    });
}
function arrayOf(format, allowNull) {
    return ((array) => {
        if (allowNull && array == null) {
            return null;
        }
        if (!Array.isArray(array)) {
            throw new Error("not an array");
        }
        return array.map((i) => format(i));
    });
}
// Requires an object which matches a fleet of other formatters
// Any FormatFunc may return `undefined` to have the value omitted
// from the result object. Calls preserve `this`.
function object(format, altNames) {
    return ((value) => {
        const result = {};
        for (const key in format) {
            let srcKey = key;
            if (altNames && key in altNames && !(srcKey in value)) {
                for (const altKey of altNames[key]) {
                    if (altKey in value) {
                        srcKey = altKey;
                        break;
                    }
                }
            }
            try {
                const nv = format[key](value[srcKey]);
                if (nv !== undefined) {
                    result[key] = nv;
                }
            }
            catch (error) {
                const message = (error instanceof Error) ? error.message : "not-an-error";
                assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
            }
        }
        return result;
    });
}
function formatBoolean(value) {
    switch (value) {
        case true:
        case "true":
            return true;
        case false:
        case "false":
            return false;
    }
    assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
    assertArgument(isHexString(value, true), "invalid data", "value", value);
    return value;
}
function formatHash(value) {
    assertArgument(isHexString(value, 32), "invalid hash", "value", value);
    return value;
}
const _formatLog = object({
    address: getAddress,
    blockHash: formatHash,
    blockNumber: getNumber,
    data: formatData,
    index: getNumber,
    removed: allowNull(formatBoolean, false),
    topics: arrayOf(formatHash),
    transactionHash: formatHash,
    transactionIndex: getNumber,
}, {
    index: ["logIndex"]
});
function formatLog(value) {
    return _formatLog(value);
}
const _formatBlock = object({
    hash: allowNull(formatHash),
    parentHash: formatHash,
    parentBeaconBlockRoot: allowNull(formatHash, null),
    number: getNumber,
    timestamp: getNumber,
    nonce: allowNull(formatData),
    difficulty: getBigInt,
    gasLimit: getBigInt,
    gasUsed: getBigInt,
    stateRoot: allowNull(formatHash, null),
    receiptsRoot: allowNull(formatHash, null),
    blobGasUsed: allowNull(getBigInt, null),
    excessBlobGas: allowNull(getBigInt, null),
    miner: allowNull(getAddress),
    prevRandao: allowNull(formatHash, null),
    extraData: formatData,
    baseFeePerGas: allowNull(getBigInt)
}, {
    prevRandao: ["mixHash"]
});
function formatBlock(value) {
    const result = _formatBlock(value);
    result.transactions = value.transactions.map((tx) => {
        if (typeof (tx) === "string") {
            return tx;
        }
        return formatTransactionResponse(tx);
    });
    return result;
}
const _formatReceiptLog = object({
    transactionIndex: getNumber,
    blockNumber: getNumber,
    transactionHash: formatHash,
    address: getAddress,
    topics: arrayOf(formatHash),
    data: formatData,
    index: getNumber,
    blockHash: formatHash,
}, {
    index: ["logIndex"]
});
function formatReceiptLog(value) {
    return _formatReceiptLog(value);
}
const _formatTransactionReceipt = object({
    to: allowNull(getAddress, null),
    from: allowNull(getAddress, null),
    contractAddress: allowNull(getAddress, null),
    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
    index: getNumber,
    root: allowNull(hexlify),
    gasUsed: getBigInt,
    blobGasUsed: allowNull(getBigInt, null),
    logsBloom: allowNull(formatData),
    blockHash: formatHash,
    hash: formatHash,
    logs: arrayOf(formatReceiptLog),
    blockNumber: getNumber,
    //confirmations: allowNull(getNumber, null),
    cumulativeGasUsed: getBigInt,
    effectiveGasPrice: allowNull(getBigInt),
    blobGasPrice: allowNull(getBigInt, null),
    status: allowNull(getNumber),
    type: allowNull(getNumber, 0)
}, {
    effectiveGasPrice: ["gasPrice"],
    hash: ["transactionHash"],
    index: ["transactionIndex"],
});
function formatTransactionReceipt(value) {
    return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
    // Some clients (TestRPC) do strange things like return 0x0 for the
    // 0 address; correct this to be a real address
    if (value.to && getBigInt(value.to) === BN_0) {
        value.to = "0x0000000000000000000000000000000000000000";
    }
    const result = object({
        hash: formatHash,
        // Some nodes do not return this, usually test nodes (like Ganache)
        index: allowNull(getNumber, undefined),
        type: (value) => {
            if (value === "0x" || value == null) {
                return 0;
            }
            return getNumber(value);
        },
        accessList: allowNull(accessListify, null),
        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
        authorizationList: allowNull(arrayOf((v) => {
            let sig;
            if (v.signature) {
                sig = v.signature;
            }
            else {
                let yParity = v.yParity;
                if (yParity === "0x1b") {
                    yParity = 0;
                }
                else if (yParity === "0x1c") {
                    yParity = 1;
                }
                sig = Object.assign({}, v, { yParity });
            }
            return {
                address: getAddress(v.address),
                chainId: getBigInt(v.chainId),
                nonce: getBigInt(v.nonce),
                signature: Signature.from(sig)
            };
        }, false), null),
        blockHash: allowNull(formatHash, null),
        blockNumber: allowNull(getNumber, null),
        transactionIndex: allowNull(getNumber, null),
        from: getAddress,
        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
        gasPrice: allowNull(getBigInt),
        maxPriorityFeePerGas: allowNull(getBigInt),
        maxFeePerGas: allowNull(getBigInt),
        maxFeePerBlobGas: allowNull(getBigInt, null),
        gasLimit: getBigInt,
        to: allowNull(getAddress, null),
        value: getBigInt,
        nonce: getNumber,
        data: formatData,
        creates: allowNull(getAddress, null),
        chainId: allowNull(getBigInt, null)
    }, {
        data: ["input"],
        gasLimit: ["gas"],
        index: ["transactionIndex"]
    })(value);
    // If to and creates are empty, populate the creates from the value
    if (result.to == null && result.creates == null) {
        result.creates = getCreateAddress(result);
    }
    // @TODO: Check fee data
    // Add an access list to supported transaction types
    if ((value.type === 1 || value.type === 2) && value.accessList == null) {
        result.accessList = [];
    }
    // Compute the signature
    if (value.signature) {
        result.signature = Signature.from(value.signature);
    }
    else {
        result.signature = Signature.from(value);
    }
    // Some backends omit ChainId on legacy transactions, but we can compute it
    if (result.chainId == null) {
        const chainId = result.signature.legacyChainId;
        if (chainId != null) {
            result.chainId = chainId;
        }
    }
    // @TODO: check chainID
    /*
    if (value.chainId != null) {
        let chainId = value.chainId;

        if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
        }

        result.chainId = chainId;

    } else {
        let chainId = value.networkId;

        // geth-etc returns chainId
        if (chainId == null && result.v == null) {
            chainId = value.chainId;
        }

        if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
        }

        if (typeof(chainId) !== "number" && result.v != null) {
            chainId = (result.v - 35) / 2;
            if (chainId < 0) { chainId = 0; }
            chainId = parseInt(chainId);
        }

        if (typeof(chainId) !== "number") { chainId = 0; }

        result.chainId = chainId;
    }
    */
    // 0x0000... should actually be null
    if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
        result.blockHash = null;
    }
    return result;
}

const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
/**
 *  A **NetworkPlugin** provides additional functionality on a [[Network]].
 */
class NetworkPlugin {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    name;
    /**
     *  Creates a new **NetworkPlugin**.
     */
    constructor(name) {
        defineProperties(this, { name });
    }
    /**
     *  Creates a copy of this plugin.
     */
    clone() {
        return new NetworkPlugin(this.name);
    }
}
/**
 *  A **GasCostPlugin** allows a network to provide alternative values when
 *  computing the intrinsic gas required for a transaction.
 */
class GasCostPlugin extends NetworkPlugin {
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    effectiveBlock;
    /**
     *  The transactions base fee.
     */
    txBase;
    /**
     *  The fee for creating a new account.
     */
    txCreate;
    /**
     *  The fee per zero-byte in the data.
     */
    txDataZero;
    /**
     *  The fee per non-zero-byte in the data.
     */
    txDataNonzero;
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    txAccessListStorageKey;
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    txAccessListAddress;
    /**
     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
     *  latest block or another GasCostPlugin supercedes that block number,
     *  with the associated %%costs%%.
     */
    constructor(effectiveBlock, costs) {
        if (effectiveBlock == null) {
            effectiveBlock = 0;
        }
        super(`org.ethers.network.plugins.GasCost#${(effectiveBlock || 0)}`);
        const props = { effectiveBlock };
        function set(name, nullish) {
            let value = (costs || {})[name];
            if (value == null) {
                value = nullish;
            }
            assertArgument(typeof (value) === "number", `invalud value for ${name}`, "costs", costs);
            props[name] = value;
        }
        set("txBase", 21000);
        set("txCreate", 32000);
        set("txDataZero", 4);
        set("txDataNonzero", 16);
        set("txAccessListStorageKey", 1900);
        set("txAccessListAddress", 2400);
        defineProperties(this, props);
    }
    clone() {
        return new GasCostPlugin(this.effectiveBlock, this);
    }
}
/**
 *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry
 *  Contract address and the target network to use when using that
 *  contract.
 *
 *  Various testnets have their own instance of the contract to use, but
 *  in general, the mainnet instance supports multi-chain addresses and
 *  should be used.
 */
class EnsPlugin extends NetworkPlugin {
    /**
     *  The ENS Registrty Contract address.
     */
    address;
    /**
     *  The chain ID that the ENS contract lives on.
     */
    targetNetwork;
    /**
     *  Creates a new **EnsPlugin** connected to %%address%% on the
     *  %%targetNetwork%%. The default ENS address and mainnet is used
     *  if unspecified.
     */
    constructor(address, targetNetwork) {
        super("org.ethers.plugins.network.Ens");
        defineProperties(this, {
            address: (address || EnsAddress),
            targetNetwork: ((targetNetwork == null) ? 1 : targetNetwork)
        });
    }
    clone() {
        return new EnsPlugin(this.address, this.targetNetwork);
    }
}
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
    #url;
    #processFunc;
    /**
     *  The URL to initialize the FetchRequest with in %%processFunc%%.
     */
    get url() { return this.#url; }
    /**
     *  The callback to use when computing the FeeData.
     */
    get processFunc() { return this.#processFunc; }
    /**
     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
     *  be used when computing the fee data for the network.
     */
    constructor(url, processFunc) {
        super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        this.#url = url;
        this.#processFunc = processFunc;
    }
    // We are immutable, so we can serve as our own clone
    clone() { return this; }
}
/*
export class CustomBlockNetworkPlugin extends NetworkPlugin {
    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;
    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;

    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {
        super("org.ethers.network-plugins.custom-block");
        this.#blockFunc = blockFunc;
        this.#blockWithTxsFunc = blockWithTxsFunc;
    }

    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {
        return await this.#blockFunc(provider, block);
    }

    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {
        return await this.#blockWithTxsFunc(provider, block);
    }

    clone(): CustomBlockNetworkPlugin {
        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);
    }
}
*/

/**
 *  A **Network** encapsulates the various properties required to
 *  interact with a specific chain.
 *
 *  @_subsection: api/providers:Networks  [networks]
 */
/* * * *
// Networks which operation against an L2 can use this plugin to
// specify how to access L1, for the purpose of resolving ENS,
// for example.
export class LayerOneConnectionPlugin extends NetworkPlugin {
    readonly provider!: Provider;
// @TODO: Rename to ChainAccess and allow for connecting to any chain
    constructor(provider: Provider) {
        super("org.ethers.plugins.layer-one-connection");
        defineProperties<LayerOneConnectionPlugin>(this, { provider });
    }

    clone(): LayerOneConnectionPlugin {
        return new LayerOneConnectionPlugin(this.provider);
    }
}
*/
const Networks = new Map();
/**
 *  A **Network** provides access to a chain's properties and allows
 *  for plug-ins to extend functionality.
 */
class Network {
    #name;
    #chainId;
    #plugins;
    /**
     *  Creates a new **Network** for %%name%% and %%chainId%%.
     */
    constructor(name, chainId) {
        this.#name = name;
        this.#chainId = getBigInt(chainId);
        this.#plugins = new Map();
    }
    /**
     *  Returns a JSON-compatible representation of a Network.
     */
    toJSON() {
        return { name: this.name, chainId: String(this.chainId) };
    }
    /**
     *  The network common name.
     *
     *  This is the canonical name, as networks migh have multiple
     *  names.
     */
    get name() { return this.#name; }
    set name(value) { this.#name = value; }
    /**
     *  The network chain ID.
     */
    get chainId() { return this.#chainId; }
    set chainId(value) { this.#chainId = getBigInt(value, "chainId"); }
    /**
     *  Returns true if %%other%% matches this network. Any chain ID
     *  must match, and if no chain ID is present, the name must match.
     *
     *  This method does not currently check for additional properties,
     *  such as ENS address or plug-in compatibility.
     */
    matches(other) {
        if (other == null) {
            return false;
        }
        if (typeof (other) === "string") {
            try {
                return (this.chainId === getBigInt(other));
            }
            catch (error) { }
            return (this.name === other);
        }
        if (typeof (other) === "number" || typeof (other) === "bigint") {
            try {
                return (this.chainId === getBigInt(other));
            }
            catch (error) { }
            return false;
        }
        if (typeof (other) === "object") {
            if (other.chainId != null) {
                try {
                    return (this.chainId === getBigInt(other.chainId));
                }
                catch (error) { }
                return false;
            }
            if (other.name != null) {
                return (this.name === other.name);
            }
            return false;
        }
        return false;
    }
    /**
     *  Returns the list of plugins currently attached to this Network.
     */
    get plugins() {
        return Array.from(this.#plugins.values());
    }
    /**
     *  Attach a new %%plugin%% to this Network. The network name
     *  must be unique, excluding any fragment.
     */
    attachPlugin(plugin) {
        if (this.#plugins.get(plugin.name)) {
            throw new Error(`cannot replace existing plugin: ${plugin.name} `);
        }
        this.#plugins.set(plugin.name, plugin.clone());
        return this;
    }
    /**
     *  Return the plugin, if any, matching %%name%% exactly. Plugins
     *  with fragments will not be returned unless %%name%% includes
     *  a fragment.
     */
    getPlugin(name) {
        return (this.#plugins.get(name)) || null;
    }
    /**
     *  Gets a list of all plugins that match %%name%%, with otr without
     *  a fragment.
     */
    getPlugins(basename) {
        return (this.plugins.filter((p) => (p.name.split("#")[0] === basename)));
    }
    /**
     *  Create a copy of this Network.
     */
    clone() {
        const clone = new Network(this.name, this.chainId);
        this.plugins.forEach((plugin) => {
            clone.attachPlugin(plugin.clone());
        });
        return clone;
    }
    /**
     *  Compute the intrinsic gas required for a transaction.
     *
     *  A GasCostPlugin can be attached to override the default
     *  values.
     */
    computeIntrinsicGas(tx) {
        const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || (new GasCostPlugin());
        let gas = costs.txBase;
        if (tx.to == null) {
            gas += costs.txCreate;
        }
        if (tx.data) {
            for (let i = 2; i < tx.data.length; i += 2) {
                if (tx.data.substring(i, i + 2) === "00") {
                    gas += costs.txDataZero;
                }
                else {
                    gas += costs.txDataNonzero;
                }
            }
        }
        if (tx.accessList) {
            const accessList = accessListify(tx.accessList);
            for (const addr in accessList) {
                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
            }
        }
        return gas;
    }
    /**
     *  Returns a new Network for the %%network%% name or chainId.
     */
    static from(network) {
        injectCommonNetworks();
        // Default network
        if (network == null) {
            return Network.from("mainnet");
        }
        // Canonical name or chain ID
        if (typeof (network) === "number") {
            network = BigInt(network);
        }
        if (typeof (network) === "string" || typeof (network) === "bigint") {
            const networkFunc = Networks.get(network);
            if (networkFunc) {
                return networkFunc();
            }
            if (typeof (network) === "bigint") {
                return new Network("unknown", network);
            }
            assertArgument(false, "unknown network", "network", network);
        }
        // Clonable with network-like abilities
        if (typeof (network.clone) === "function") {
            const clone = network.clone();
            //if (typeof(network.name) !== "string" || typeof(network.chainId) !== "number") {
            //}
            return clone;
        }
        // Networkish
        if (typeof (network) === "object") {
            assertArgument(typeof (network.name) === "string" && typeof (network.chainId) === "number", "invalid network object name or chainId", "network", network);
            const custom = new Network((network.name), (network.chainId));
            if (network.ensAddress || network.ensNetwork != null) {
                custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
            }
            //if ((<any>network).layerOneConnection) {
            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));
            //}
            return custom;
        }
        assertArgument(false, "invalid network", "network", network);
    }
    /**
     *  Register %%nameOrChainId%% with a function which returns
     *  an instance of a Network representing that chain.
     */
    static register(nameOrChainId, networkFunc) {
        if (typeof (nameOrChainId) === "number") {
            nameOrChainId = BigInt(nameOrChainId);
        }
        const existing = Networks.get(nameOrChainId);
        if (existing) {
            assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
        }
        Networks.set(nameOrChainId, networkFunc);
    }
}
// We don't want to bring in formatUnits because it is backed by
// FixedNumber and we want to keep Networks tiny. The values
// included by the Gas Stations are also IEEE 754 with lots of
// rounding issues and exceed the strict checks formatUnits has.
function parseUnits(_value, decimals) {
    const value = String(_value);
    if (!value.match(/^[0-9.]+$/)) {
        throw new Error(`invalid gwei value: ${_value}`);
    }
    // Break into [ whole, fraction ]
    const comps = value.split(".");
    if (comps.length === 1) {
        comps.push("");
    }
    // More than 1 decimal point or too many fractional positions
    if (comps.length !== 2) {
        throw new Error(`invalid gwei value: ${_value}`);
    }
    // Pad the fraction to 9 decimalplaces
    while (comps[1].length < decimals) {
        comps[1] += "0";
    }
    // Too many decimals and some non-zero ending, take the ceiling
    if (comps[1].length > 9) {
        let frac = BigInt(comps[1].substring(0, 9));
        if (!comps[1].substring(9).match(/^0+$/)) {
            frac++;
        }
        comps[1] = frac.toString();
    }
    return BigInt(comps[0] + comps[1]);
}
// Used by Polygon to use a gas station for fee data
function getGasStationPlugin(url) {
    return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
        // Prevent Cloudflare from blocking our request in node.js
        request.setHeader("User-Agent", "ethers");
        let response;
        try {
            const [_response, _feeData] = await Promise.all([
                request.send(), fetchFeeData()
            ]);
            response = _response;
            const payload = response.bodyJson.standard;
            const feeData = {
                gasPrice: _feeData.gasPrice,
                maxFeePerGas: parseUnits(payload.maxFee, 9),
                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),
            };
            return feeData;
        }
        catch (error) {
            assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
        }
    });
}
// See: https://chainlist.org
let injected = false;
function injectCommonNetworks() {
    if (injected) {
        return;
    }
    injected = true;
    /// Register popular Ethereum networks
    function registerEth(name, chainId, options) {
        const func = function () {
            const network = new Network(name, chainId);
            // We use 0 to disable ENS
            if (options.ensNetwork != null) {
                network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
            }
            network.attachPlugin(new GasCostPlugin());
            (options.plugins || []).forEach((plugin) => {
                network.attachPlugin(plugin);
            });
            return network;
        };
        // Register the network by name and chain ID
        Network.register(name, func);
        Network.register(chainId, func);
        if (options.altNames) {
            options.altNames.forEach((name) => {
                Network.register(name, func);
            });
        }
    }
    registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
    registerEth("ropsten", 3, { ensNetwork: 3 });
    registerEth("rinkeby", 4, { ensNetwork: 4 });
    registerEth("goerli", 5, { ensNetwork: 5 });
    registerEth("kovan", 42, { ensNetwork: 42 });
    registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
    registerEth("holesky", 17000, { ensNetwork: 17000 });
    registerEth("classic", 61, {});
    registerEth("classicKotti", 6, {});
    registerEth("arbitrum", 42161, {
        ensNetwork: 1,
    });
    registerEth("arbitrum-goerli", 421613, {});
    registerEth("arbitrum-sepolia", 421614, {});
    registerEth("base", 8453, { ensNetwork: 1 });
    registerEth("base-goerli", 84531, {});
    registerEth("base-sepolia", 84532, {});
    registerEth("bnb", 56, { ensNetwork: 1 });
    registerEth("bnbt", 97, {});
    registerEth("linea", 59144, { ensNetwork: 1 });
    registerEth("linea-goerli", 59140, {});
    registerEth("linea-sepolia", 59141, {});
    registerEth("matic", 137, {
        ensNetwork: 1,
        plugins: [
            getGasStationPlugin("https:/\/gasstation.polygon.technology/v2")
        ]
    });
    registerEth("matic-amoy", 80002, {});
    registerEth("matic-mumbai", 80001, {
        altNames: ["maticMumbai", "maticmum"],
        plugins: [
            getGasStationPlugin("https:/\/gasstation-testnet.polygon.technology/v2")
        ]
    });
    registerEth("optimism", 10, {
        ensNetwork: 1,
        plugins: []
    });
    registerEth("optimism-goerli", 420, {});
    registerEth("optimism-sepolia", 11155420, {});
    registerEth("xdai", 100, { ensNetwork: 1 });
}

function copy$2(obj) {
    return JSON.parse(JSON.stringify(obj));
}
// @TODO: refactor this
/**
 *  A **PollingBlockSubscriber** polls at a regular interval for a change
 *  in the block number.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class PollingBlockSubscriber {
    #provider;
    #poller;
    #interval;
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    #blockNumber;
    /**
     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
     */
    constructor(provider) {
        this.#provider = provider;
        this.#poller = null;
        this.#interval = 4000;
        this.#blockNumber = -2;
    }
    /**
     *  The polling interval.
     */
    get pollingInterval() { return this.#interval; }
    set pollingInterval(value) { this.#interval = value; }
    async #poll() {
        try {
            const blockNumber = await this.#provider.getBlockNumber();
            // Bootstrap poll to setup our initial block number
            if (this.#blockNumber === -2) {
                this.#blockNumber = blockNumber;
                return;
            }
            // @TODO: Put a cap on the maximum number of events per loop?
            if (blockNumber !== this.#blockNumber) {
                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {
                    // We have been stopped
                    if (this.#poller == null) {
                        return;
                    }
                    await this.#provider.emit("block", b);
                }
                this.#blockNumber = blockNumber;
            }
        }
        catch (error) {
            // @TODO: Minor bump, add an "error" event to let subscribers
            //        know things went awry.
            //console.log(error);
        }
        // We have been stopped
        if (this.#poller == null) {
            return;
        }
        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    }
    start() {
        if (this.#poller) {
            return;
        }
        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
        this.#poll();
    }
    stop() {
        if (!this.#poller) {
            return;
        }
        this.#provider._clearTimeout(this.#poller);
        this.#poller = null;
    }
    pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
            this.#blockNumber = -2;
        }
    }
    resume() {
        this.start();
    }
}
/**
 *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]
 *  implmentation which will be called on every new block.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class OnBlockSubscriber {
    #provider;
    #poll;
    #running;
    /**
     *  Create a new **OnBlockSubscriber** attached to %%provider%%.
     */
    constructor(provider) {
        this.#provider = provider;
        this.#running = false;
        this.#poll = (blockNumber) => {
            this._poll(blockNumber, this.#provider);
        };
    }
    /**
     *  Called on every new block.
     */
    async _poll(blockNumber, provider) {
        throw new Error("sub-classes must override this");
    }
    start() {
        if (this.#running) {
            return;
        }
        this.#running = true;
        this.#poll(-2);
        this.#provider.on("block", this.#poll);
    }
    stop() {
        if (!this.#running) {
            return;
        }
        this.#running = false;
        this.#provider.off("block", this.#poll);
    }
    pause(dropWhilePaused) { this.stop(); }
    resume() { this.start(); }
}
class PollingBlockTagSubscriber extends OnBlockSubscriber {
    #tag;
    #lastBlock;
    constructor(provider, tag) {
        super(provider);
        this.#tag = tag;
        this.#lastBlock = -2;
    }
    pause(dropWhilePaused) {
        if (dropWhilePaused) {
            this.#lastBlock = -2;
        }
        super.pause(dropWhilePaused);
    }
    async _poll(blockNumber, provider) {
        const block = await provider.getBlock(this.#tag);
        if (block == null) {
            return;
        }
        if (this.#lastBlock === -2) {
            this.#lastBlock = block.number;
        }
        else if (block.number > this.#lastBlock) {
            provider.emit(this.#tag, block.number);
            this.#lastBlock = block.number;
        }
    }
}
/**
 *  @_ignore:
 *
 *  @_docloc: api/providers/abstract-provider
 */
class PollingOrphanSubscriber extends OnBlockSubscriber {
    #filter;
    constructor(provider, filter) {
        super(provider);
        this.#filter = copy$2(filter);
    }
    async _poll(blockNumber, provider) {
        throw new Error("@TODO");
    }
}
/**
 *  A **PollingTransactionSubscriber** will poll for a given transaction
 *  hash for its receipt.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class PollingTransactionSubscriber extends OnBlockSubscriber {
    #hash;
    /**
     *  Create a new **PollingTransactionSubscriber** attached to
     *  %%provider%%, listening for %%hash%%.
     */
    constructor(provider, hash) {
        super(provider);
        this.#hash = hash;
    }
    async _poll(blockNumber, provider) {
        const tx = await provider.getTransactionReceipt(this.#hash);
        if (tx) {
            provider.emit(this.#hash, tx);
        }
    }
}
/**
 *  A **PollingEventSubscriber** will poll for a given filter for its logs.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class PollingEventSubscriber {
    #provider;
    #filter;
    #poller;
    #running;
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    #blockNumber;
    /**
     *  Create a new **PollingTransactionSubscriber** attached to
     *  %%provider%%, listening for %%filter%%.
     */
    constructor(provider, filter) {
        this.#provider = provider;
        this.#filter = copy$2(filter);
        this.#poller = this.#poll.bind(this);
        this.#running = false;
        this.#blockNumber = -2;
    }
    async #poll(blockNumber) {
        // The initial block hasn't been determined yet
        if (this.#blockNumber === -2) {
            return;
        }
        const filter = copy$2(this.#filter);
        filter.fromBlock = this.#blockNumber + 1;
        filter.toBlock = blockNumber;
        const logs = await this.#provider.getLogs(filter);
        // No logs could just mean the node has not indexed them yet,
        // so we keep a sliding window of 60 blocks to keep scanning
        if (logs.length === 0) {
            if (this.#blockNumber < blockNumber - 60) {
                this.#blockNumber = blockNumber - 60;
            }
            return;
        }
        for (const log of logs) {
            this.#provider.emit(this.#filter, log);
            // Only advance the block number when logs were found to
            // account for networks (like BNB and Polygon) which may
            // sacrifice event consistency for block event speed
            this.#blockNumber = log.blockNumber;
        }
    }
    start() {
        if (this.#running) {
            return;
        }
        this.#running = true;
        if (this.#blockNumber === -2) {
            this.#provider.getBlockNumber().then((blockNumber) => {
                this.#blockNumber = blockNumber;
            });
        }
        this.#provider.on("block", this.#poller);
    }
    stop() {
        if (!this.#running) {
            return;
        }
        this.#running = false;
        this.#provider.off("block", this.#poller);
    }
    pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
            this.#blockNumber = -2;
        }
    }
    resume() {
        this.start();
    }
}

/**
 *  The available providers should suffice for most developers purposes,
 *  but the [[AbstractProvider]] class has many features which enable
 *  sub-classing it for specific purposes.
 *
 *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]
 */
// @TODO
// Event coalescence
//   When we register an event with an async value (e.g. address is a Signer
//   or ENS name), we need to add it immeidately for the Event API, but also
//   need time to resolve the address. Upon resolving the address, we need to
//   migrate the listener to the static event. We also need to maintain a map
//   of Signer/ENS name to address so we can sync respond to listenerCount.
// Constants
const BN_2 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
    return (value && typeof (value.then) === "function");
}
function getTag(prefix, value) {
    return prefix + ":" + JSON.stringify(value, (k, v) => {
        if (v == null) {
            return "null";
        }
        if (typeof (v) === "bigint") {
            return `bigint:${v.toString()}`;
        }
        if (typeof (v) === "string") {
            return v.toLowerCase();
        }
        // Sort object keys
        if (typeof (v) === "object" && !Array.isArray(v)) {
            const keys = Object.keys(v);
            keys.sort();
            return keys.reduce((accum, key) => {
                accum[key] = v[key];
                return accum;
            }, {});
        }
        return v;
    });
}
/**
 *  An **UnmanagedSubscriber** is useful for events which do not require
 *  any additional management, such as ``"debug"`` which only requires
 *  emit in synchronous event loop triggered calls.
 */
class UnmanagedSubscriber {
    /**
     *  The name fof the event.
     */
    name;
    /**
     *  Create a new UnmanagedSubscriber with %%name%%.
     */
    constructor(name) { defineProperties(this, { name }); }
    start() { }
    stop() { }
    pause(dropWhilePaused) { }
    resume() { }
}
function copy$1(value) {
    return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
    items = Array.from((new Set(items)).values());
    items.sort();
    return items;
}
async function getSubscription(_event, provider) {
    if (_event == null) {
        throw new Error("invalid event");
    }
    // Normalize topic array info an EventFilter
    if (Array.isArray(_event)) {
        _event = { topics: _event };
    }
    if (typeof (_event) === "string") {
        switch (_event) {
            case "block":
            case "debug":
            case "error":
            case "finalized":
            case "network":
            case "pending":
            case "safe": {
                return { type: _event, tag: _event };
            }
        }
    }
    if (isHexString(_event, 32)) {
        const hash = _event.toLowerCase();
        return { type: "transaction", tag: getTag("tx", { hash }), hash };
    }
    if (_event.orphan) {
        const event = _event;
        // @TODO: Should lowercase and whatnot things here instead of copy...
        return { type: "orphan", tag: getTag("orphan", event), filter: copy$1(event) };
    }
    if ((_event.address || _event.topics)) {
        const event = _event;
        const filter = {
            topics: ((event.topics || []).map((t) => {
                if (t == null) {
                    return null;
                }
                if (Array.isArray(t)) {
                    return concisify(t.map((t) => t.toLowerCase()));
                }
                return t.toLowerCase();
            }))
        };
        if (event.address) {
            const addresses = [];
            const promises = [];
            const addAddress = (addr) => {
                if (isHexString(addr)) {
                    addresses.push(addr);
                }
                else {
                    promises.push((async () => {
                        addresses.push(await resolveAddress(addr, provider));
                    })());
                }
            };
            if (Array.isArray(event.address)) {
                event.address.forEach(addAddress);
            }
            else {
                addAddress(event.address);
            }
            if (promises.length) {
                await Promise.all(promises);
            }
            filter.address = concisify(addresses.map((a) => a.toLowerCase()));
        }
        return { filter, tag: getTag("event", filter), type: "event" };
    }
    assertArgument(false, "unknown ProviderEvent", "event", _event);
}
function getTime() { return (new Date()).getTime(); }
const defaultOptions$1 = {
    cacheTimeout: 250,
    pollingInterval: 4000
};
/**
 *  An **AbstractProvider** provides a base class for other sub-classes to
 *  implement the [[Provider]] API by normalizing input arguments and
 *  formatting output results as well as tracking events for consistent
 *  behaviour on an eventually-consistent network.
 */
class AbstractProvider {
    #subs;
    #plugins;
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    #pausedState;
    #destroyed;
    #networkPromise;
    #anyNetwork;
    #performCache;
    // The most recent block number if running an event or -1 if no "block" event
    #lastBlockNumber;
    #nextTimer;
    #timers;
    #disableCcipRead;
    #options;
    /**
     *  Create a new **AbstractProvider** connected to %%network%%, or
     *  use the various network detection capabilities to discover the
     *  [[Network]] if necessary.
     */
    constructor(_network, options) {
        this.#options = Object.assign({}, defaultOptions$1, options || {});
        if (_network === "any") {
            this.#anyNetwork = true;
            this.#networkPromise = null;
        }
        else if (_network) {
            const network = Network.from(_network);
            this.#anyNetwork = false;
            this.#networkPromise = Promise.resolve(network);
            setTimeout(() => { this.emit("network", network, null); }, 0);
        }
        else {
            this.#anyNetwork = false;
            this.#networkPromise = null;
        }
        this.#lastBlockNumber = -1;
        this.#performCache = new Map();
        this.#subs = new Map();
        this.#plugins = new Map();
        this.#pausedState = null;
        this.#destroyed = false;
        this.#nextTimer = 1;
        this.#timers = new Map();
        this.#disableCcipRead = false;
    }
    get pollingInterval() { return this.#options.pollingInterval; }
    /**
     *  Returns ``this``, to allow an **AbstractProvider** to implement
     *  the [[ContractRunner]] interface.
     */
    get provider() { return this; }
    /**
     *  Returns all the registered plug-ins.
     */
    get plugins() {
        return Array.from(this.#plugins.values());
    }
    /**
     *  Attach a new plug-in.
     */
    attachPlugin(plugin) {
        if (this.#plugins.get(plugin.name)) {
            throw new Error(`cannot replace existing plugin: ${plugin.name} `);
        }
        this.#plugins.set(plugin.name, plugin.connect(this));
        return this;
    }
    /**
     *  Get a plugin by name.
     */
    getPlugin(name) {
        return (this.#plugins.get(name)) || null;
    }
    /**
     *  Prevent any CCIP-read operation, regardless of whether requested
     *  in a [[call]] using ``enableCcipRead``.
     */
    get disableCcipRead() { return this.#disableCcipRead; }
    set disableCcipRead(value) { this.#disableCcipRead = !!value; }
    // Shares multiple identical requests made during the same 250ms
    async #perform(req) {
        const timeout = this.#options.cacheTimeout;
        // Caching disabled
        if (timeout < 0) {
            return await this._perform(req);
        }
        // Create a tag
        const tag = getTag(req.method, req);
        let perform = this.#performCache.get(tag);
        if (!perform) {
            perform = this._perform(req);
            this.#performCache.set(tag, perform);
            setTimeout(() => {
                if (this.#performCache.get(tag) === perform) {
                    this.#performCache.delete(tag);
                }
            }, timeout);
        }
        return await perform;
    }
    /**
     *  Resolves to the data for executing the CCIP-read operations.
     */
    async ccipReadFetch(tx, calldata, urls) {
        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
            return null;
        }
        const sender = tx.to.toLowerCase();
        const data = calldata.toLowerCase();
        const errorMessages = [];
        for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            // URL expansion
            const href = url.replace("{sender}", sender).replace("{data}", data);
            // If no {data} is present, use POST; otherwise GET
            //const json: string | null = (url.indexOf("{data}") >= 0) ? null: JSON.stringify({ data, sender });
            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
            //    value.status = response.statusCode;
            //    return value;
            //});
            const request = new FetchRequest(href);
            if (url.indexOf("{data}") === -1) {
                request.body = { data, sender };
            }
            this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
            let errorMessage = "unknown error";
            // Fetch the resource...
            let resp;
            try {
                resp = await request.send();
            }
            catch (error) {
                // ...low-level fetch error (missing host, bad SSL, etc.),
                // so try next URL
                errorMessages.push(error.message);
                this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error } });
                continue;
            }
            try {
                const result = resp.bodyJson;
                if (result.data) {
                    this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
                    return result.data;
                }
                if (result.message) {
                    errorMessage = result.message;
                }
                this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
            }
            catch (error) { }
            // 4xx indicates the result is not present; stop
            assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
            // 5xx indicates server issue; try the next url
            errorMessages.push(errorMessage);
        }
        assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
            reason: "500_SERVER_ERROR",
            transaction: tx, info: { urls, errorMessages }
        });
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a block before
     *  returning it, to add additional properties or an alternate
     *  sub-class of [[Block]].
     */
    _wrapBlock(value, network) {
        return new Block(formatBlock(value), this);
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a log before
     *  returning it, to add additional properties or an alternate
     *  sub-class of [[Log]].
     */
    _wrapLog(value, network) {
        return new Log(formatLog(value), this);
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a transaction
     *  receipt before returning it, to add additional properties or an
     *  alternate sub-class of [[TransactionReceipt]].
     */
    _wrapTransactionReceipt(value, network) {
        return new TransactionReceipt(formatTransactionReceipt(value), this);
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a transaction
     *  response before returning it, to add additional properties or an
     *  alternate sub-class of [[TransactionResponse]].
     */
    _wrapTransactionResponse(tx, network) {
        return new TransactionResponse(formatTransactionResponse(tx), this);
    }
    /**
     *  Resolves to the Network, forcing a network detection using whatever
     *  technique the sub-class requires.
     *
     *  Sub-classes **must** override this.
     */
    _detectNetwork() {
        assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
            operation: "_detectNetwork"
        });
    }
    /**
     *  Sub-classes should use this to perform all built-in operations. All
     *  methods sanitizes and normalizes the values passed into this.
     *
     *  Sub-classes **must** override this.
     */
    async _perform(req) {
        assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
            operation: req.method,
            info: req
        });
    }
    // State
    async getBlockNumber() {
        const blockNumber = getNumber(await this.#perform({ method: "getBlockNumber" }), "%response");
        if (this.#lastBlockNumber >= 0) {
            this.#lastBlockNumber = blockNumber;
        }
        return blockNumber;
    }
    /**
     *  Returns or resolves to the address for %%address%%, resolving ENS
     *  names and [[Addressable]] objects and returning if already an
     *  address.
     */
    _getAddress(address) {
        return resolveAddress(address, this);
    }
    /**
     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
     *  negative values and returning if already a valid block tag.
     */
    _getBlockTag(blockTag) {
        if (blockTag == null) {
            return "latest";
        }
        switch (blockTag) {
            case "earliest":
                return "0x0";
            case "finalized":
            case "latest":
            case "pending":
            case "safe":
                return blockTag;
        }
        if (isHexString(blockTag)) {
            if (isHexString(blockTag, 32)) {
                return blockTag;
            }
            return toQuantity(blockTag);
        }
        if (typeof (blockTag) === "bigint") {
            blockTag = getNumber(blockTag, "blockTag");
        }
        if (typeof (blockTag) === "number") {
            if (blockTag >= 0) {
                return toQuantity(blockTag);
            }
            if (this.#lastBlockNumber >= 0) {
                return toQuantity(this.#lastBlockNumber + blockTag);
            }
            return this.getBlockNumber().then((b) => toQuantity(b + blockTag));
        }
        assertArgument(false, "invalid blockTag", "blockTag", blockTag);
    }
    /**
     *  Returns or resolves to a filter for %%filter%%, resolving any ENS
     *  names or [[Addressable]] object and returning if already a valid
     *  filter.
     */
    _getFilter(filter) {
        // Create a canonical representation of the topics
        const topics = (filter.topics || []).map((t) => {
            if (t == null) {
                return null;
            }
            if (Array.isArray(t)) {
                return concisify(t.map((t) => t.toLowerCase()));
            }
            return t.toLowerCase();
        });
        const blockHash = ("blockHash" in filter) ? filter.blockHash : undefined;
        const resolve = (_address, fromBlock, toBlock) => {
            let address = undefined;
            switch (_address.length) {
                case 0: break;
                case 1:
                    address = _address[0];
                    break;
                default:
                    _address.sort();
                    address = _address;
            }
            if (blockHash) {
                if (fromBlock != null || toBlock != null) {
                    throw new Error("invalid filter");
                }
            }
            const filter = {};
            if (address) {
                filter.address = address;
            }
            if (topics.length) {
                filter.topics = topics;
            }
            if (fromBlock) {
                filter.fromBlock = fromBlock;
            }
            if (toBlock) {
                filter.toBlock = toBlock;
            }
            if (blockHash) {
                filter.blockHash = blockHash;
            }
            return filter;
        };
        // Addresses could be async (ENS names or Addressables)
        let address = [];
        if (filter.address) {
            if (Array.isArray(filter.address)) {
                for (const addr of filter.address) {
                    address.push(this._getAddress(addr));
                }
            }
            else {
                address.push(this._getAddress(filter.address));
            }
        }
        let fromBlock = undefined;
        if ("fromBlock" in filter) {
            fromBlock = this._getBlockTag(filter.fromBlock);
        }
        let toBlock = undefined;
        if ("toBlock" in filter) {
            toBlock = this._getBlockTag(filter.toBlock);
        }
        if (address.filter((a) => (typeof (a) !== "string")).length ||
            (fromBlock != null && typeof (fromBlock) !== "string") ||
            (toBlock != null && typeof (toBlock) !== "string")) {
            return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
                return resolve(result[0], result[1], result[2]);
            });
        }
        return resolve(address, fromBlock, toBlock);
    }
    /**
     *  Returns or resolves to a transaction for %%request%%, resolving
     *  any ENS names or [[Addressable]] and returning if already a valid
     *  transaction.
     */
    _getTransactionRequest(_request) {
        const request = copyRequest(_request);
        const promises = [];
        ["to", "from"].forEach((key) => {
            if (request[key] == null) {
                return;
            }
            const addr = resolveAddress(request[key], this);
            if (isPromise(addr)) {
                promises.push((async function () { request[key] = await addr; })());
            }
            else {
                request[key] = addr;
            }
        });
        if (request.blockTag != null) {
            const blockTag = this._getBlockTag(request.blockTag);
            if (isPromise(blockTag)) {
                promises.push((async function () { request.blockTag = await blockTag; })());
            }
            else {
                request.blockTag = blockTag;
            }
        }
        if (promises.length) {
            return (async function () {
                await Promise.all(promises);
                return request;
            })();
        }
        return request;
    }
    async getNetwork() {
        // No explicit network was set and this is our first time
        if (this.#networkPromise == null) {
            // Detect the current network (shared with all calls)
            const detectNetwork = (async () => {
                try {
                    const network = await this._detectNetwork();
                    this.emit("network", network, null);
                    return network;
                }
                catch (error) {
                    if (this.#networkPromise === detectNetwork) {
                        this.#networkPromise = null;
                    }
                    throw error;
                }
            })();
            this.#networkPromise = detectNetwork;
            return (await detectNetwork).clone();
        }
        const networkPromise = this.#networkPromise;
        const [expected, actual] = await Promise.all([
            networkPromise,
            this._detectNetwork() // The actual connected network
        ]);
        if (expected.chainId !== actual.chainId) {
            if (this.#anyNetwork) {
                // The "any" network can change, so notify listeners
                this.emit("network", actual, expected);
                // Update the network if something else hasn't already changed it
                if (this.#networkPromise === networkPromise) {
                    this.#networkPromise = Promise.resolve(actual);
                }
            }
            else {
                // Otherwise, we do not allow changes to the underlying network
                assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
                    event: "changed"
                });
            }
        }
        return expected.clone();
    }
    async getFeeData() {
        const network = await this.getNetwork();
        const getFeeDataFunc = async () => {
            const { _block, gasPrice, priorityFee } = await resolveProperties({
                _block: this.#getBlock("latest", false),
                gasPrice: ((async () => {
                    try {
                        const value = await this.#perform({ method: "getGasPrice" });
                        return getBigInt(value, "%response");
                    }
                    catch (error) { }
                    return null;
                })()),
                priorityFee: ((async () => {
                    try {
                        const value = await this.#perform({ method: "getPriorityFee" });
                        return getBigInt(value, "%response");
                    }
                    catch (error) { }
                    return null;
                })())
            });
            let maxFeePerGas = null;
            let maxPriorityFeePerGas = null;
            // These are the recommended EIP-1559 heuristics for fee data
            const block = this._wrapBlock(_block, network);
            if (block && block.baseFeePerGas) {
                maxPriorityFeePerGas = (priorityFee != null) ? priorityFee : BigInt("1000000000");
                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;
            }
            return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
        };
        // Check for a FeeDataNetWorkPlugin
        const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        if (plugin) {
            const req = new FetchRequest(plugin.url);
            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
            return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
        }
        return await getFeeDataFunc();
    }
    async estimateGas(_tx) {
        let tx = this._getTransactionRequest(_tx);
        if (isPromise(tx)) {
            tx = await tx;
        }
        return getBigInt(await this.#perform({
            method: "estimateGas", transaction: tx
        }), "%response");
    }
    async #call(tx, blockTag, attempt) {
        assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
            reason: "TOO_MANY_REDIRECTS",
            transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
        });
        // This came in as a PerformActionTransaction, so to/from are safe; we can cast
        const transaction = copyRequest(tx);
        try {
            return hexlify(await this._perform({ method: "call", transaction, blockTag }));
        }
        catch (error) {
            // CCIP Read OffchainLookup
            if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
                const data = error.data;
                const txSender = await resolveAddress(transaction.to, this);
                // Parse the CCIP Read Arguments
                let ccipArgs;
                try {
                    ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
                }
                catch (error) {
                    assert(false, error.message, "OFFCHAIN_FAULT", {
                        reason: "BAD_DATA", transaction, info: { data }
                    });
                }
                // Check the sender of the OffchainLookup matches the transaction
                assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
                    action: "call",
                    data,
                    reason: "OffchainLookup",
                    transaction: transaction,
                    invocation: null,
                    revert: {
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        name: "OffchainLookup",
                        args: ccipArgs.errorArgs
                    }
                });
                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
                assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
                    reason: "FETCH_FAILED", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs }
                });
                const tx = {
                    to: txSender,
                    data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
                };
                this.emit("debug", { action: "sendCcipReadCall", transaction: tx });
                try {
                    const result = await this.#call(tx, blockTag, attempt + 1);
                    this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx), result });
                    return result;
                }
                catch (error) {
                    this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx), error });
                    throw error;
                }
            }
            throw error;
        }
    }
    async #checkNetwork(promise) {
        const { value } = await resolveProperties({
            network: this.getNetwork(),
            value: promise
        });
        return value;
    }
    async call(_tx) {
        const { tx, blockTag } = await resolveProperties({
            tx: this._getTransactionRequest(_tx),
            blockTag: this._getBlockTag(_tx.blockTag)
        });
        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
    }
    // Account
    async #getAccountValue(request, _address, _blockTag) {
        let address = this._getAddress(_address);
        let blockTag = this._getBlockTag(_blockTag);
        if (typeof (address) !== "string" || typeof (blockTag) !== "string") {
            [address, blockTag] = await Promise.all([address, blockTag]);
        }
        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
    }
    async getBalance(address, blockTag) {
        return getBigInt(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
    }
    async getTransactionCount(address, blockTag) {
        return getNumber(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
    }
    async getCode(address, blockTag) {
        return hexlify(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
    }
    async getStorage(address, _position, blockTag) {
        const position = getBigInt(_position, "position");
        return hexlify(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
    }
    // Write
    async broadcastTransaction(signedTx) {
        const { blockNumber, hash, network } = await resolveProperties({
            blockNumber: this.getBlockNumber(),
            hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: signedTx
            }),
            network: this.getNetwork()
        });
        const tx = Transaction.from(signedTx);
        if (tx.hash !== hash) {
            throw new Error("@TODO: the returned hash did not match");
        }
        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
    }
    async #getBlock(block, includeTransactions) {
        // @TODO: Add CustomBlockPlugin check
        if (isHexString(block, 32)) {
            return await this.#perform({
                method: "getBlock", blockHash: block, includeTransactions
            });
        }
        let blockTag = this._getBlockTag(block);
        if (typeof (blockTag) !== "string") {
            blockTag = await blockTag;
        }
        return await this.#perform({
            method: "getBlock", blockTag, includeTransactions
        });
    }
    // Queries
    async getBlock(block, prefetchTxs) {
        const { network, params } = await resolveProperties({
            network: this.getNetwork(),
            params: this.#getBlock(block, !!prefetchTxs)
        });
        if (params == null) {
            return null;
        }
        return this._wrapBlock(params, network);
    }
    async getTransaction(hash) {
        const { network, params } = await resolveProperties({
            network: this.getNetwork(),
            params: this.#perform({ method: "getTransaction", hash })
        });
        if (params == null) {
            return null;
        }
        return this._wrapTransactionResponse(params, network);
    }
    async getTransactionReceipt(hash) {
        const { network, params } = await resolveProperties({
            network: this.getNetwork(),
            params: this.#perform({ method: "getTransactionReceipt", hash })
        });
        if (params == null) {
            return null;
        }
        // Some backends did not backfill the effectiveGasPrice into old transactions
        // in the receipt, so we look it up manually and inject it.
        if (params.gasPrice == null && params.effectiveGasPrice == null) {
            const tx = await this.#perform({ method: "getTransaction", hash });
            if (tx == null) {
                throw new Error("report this; could not find tx or effectiveGasPrice");
            }
            params.effectiveGasPrice = tx.gasPrice;
        }
        return this._wrapTransactionReceipt(params, network);
    }
    async getTransactionResult(hash) {
        const { result } = await resolveProperties({
            network: this.getNetwork(),
            result: this.#perform({ method: "getTransactionResult", hash })
        });
        if (result == null) {
            return null;
        }
        return hexlify(result);
    }
    // Bloom-filter Queries
    async getLogs(_filter) {
        let filter = this._getFilter(_filter);
        if (isPromise(filter)) {
            filter = await filter;
        }
        const { network, params } = await resolveProperties({
            network: this.getNetwork(),
            params: this.#perform({ method: "getLogs", filter })
        });
        return params.map((p) => this._wrapLog(p, network));
    }
    // ENS
    _getProvider(chainId) {
        assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
            operation: "_getProvider()"
        });
    }
    async getResolver(name) {
        return await EnsResolver.fromName(this, name);
    }
    async getAvatar(name) {
        const resolver = await this.getResolver(name);
        if (resolver) {
            return await resolver.getAvatar();
        }
        return null;
    }
    async resolveName(name) {
        const resolver = await this.getResolver(name);
        if (resolver) {
            return await resolver.getAddress();
        }
        return null;
    }
    async lookupAddress(address) {
        address = getAddress(address);
        const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
        try {
            const ensAddr = await EnsResolver.getEnsAddress(this);
            const ensContract = new Contract(ensAddr, [
                "function resolver(bytes32) view returns (address)"
            ], this);
            const resolver = await ensContract.resolver(node);
            if (resolver == null || resolver === ZeroAddress) {
                return null;
            }
            const resolverContract = new Contract(resolver, [
                "function name(bytes32) view returns (string)"
            ], this);
            const name = await resolverContract.name(node);
            // Failed forward resolution
            const check = await this.resolveName(name);
            if (check !== address) {
                return null;
            }
            return name;
        }
        catch (error) {
            // No data was returned from the resolver
            if (isError(error, "BAD_DATA") && error.value === "0x") {
                return null;
            }
            // Something reerted
            if (isError(error, "CALL_EXCEPTION")) {
                return null;
            }
            throw error;
        }
        return null;
    }
    async waitForTransaction(hash, _confirms, timeout) {
        const confirms = (_confirms != null) ? _confirms : 1;
        if (confirms === 0) {
            return this.getTransactionReceipt(hash);
        }
        return new Promise(async (resolve, reject) => {
            let timer = null;
            const listener = (async (blockNumber) => {
                try {
                    const receipt = await this.getTransactionReceipt(hash);
                    if (receipt != null) {
                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                            resolve(receipt);
                            //this.off("block", listener);
                            if (timer) {
                                clearTimeout(timer);
                                timer = null;
                            }
                            return;
                        }
                    }
                }
                catch (error) {
                    console.log("EEE", error);
                }
                this.once("block", listener);
            });
            if (timeout != null) {
                timer = setTimeout(() => {
                    if (timer == null) {
                        return;
                    }
                    timer = null;
                    this.off("block", listener);
                    reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
                }, timeout);
            }
            listener(await this.getBlockNumber());
        });
    }
    async waitForBlock(blockTag) {
        assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock"
        });
    }
    /**
     *  Clear a timer created using the [[_setTimeout]] method.
     */
    _clearTimeout(timerId) {
        const timer = this.#timers.get(timerId);
        if (!timer) {
            return;
        }
        if (timer.timer) {
            clearTimeout(timer.timer);
        }
        this.#timers.delete(timerId);
    }
    /**
     *  Create a timer that will execute %%func%% after at least %%timeout%%
     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
     *  in the next event loop.
     *
     *  [Pausing](AbstractProvider-paused) the provider will pause any
     *  associated timers.
     */
    _setTimeout(_func, timeout) {
        if (timeout == null) {
            timeout = 0;
        }
        const timerId = this.#nextTimer++;
        const func = () => {
            this.#timers.delete(timerId);
            _func();
        };
        if (this.paused) {
            this.#timers.set(timerId, { timer: null, func, time: timeout });
        }
        else {
            const timer = setTimeout(func, timeout);
            this.#timers.set(timerId, { timer, func, time: getTime() });
        }
        return timerId;
    }
    /**
     *  Perform %%func%% on each subscriber.
     */
    _forEachSubscriber(func) {
        for (const sub of this.#subs.values()) {
            func(sub.subscriber);
        }
    }
    /**
     *  Sub-classes may override this to customize subscription
     *  implementations.
     */
    _getSubscriber(sub) {
        switch (sub.type) {
            case "debug":
            case "error":
            case "network":
                return new UnmanagedSubscriber(sub.type);
            case "block": {
                const subscriber = new PollingBlockSubscriber(this);
                subscriber.pollingInterval = this.pollingInterval;
                return subscriber;
            }
            case "safe":
            case "finalized":
                return new PollingBlockTagSubscriber(this, sub.type);
            case "event":
                return new PollingEventSubscriber(this, sub.filter);
            case "transaction":
                return new PollingTransactionSubscriber(this, sub.hash);
            case "orphan":
                return new PollingOrphanSubscriber(this, sub.filter);
        }
        throw new Error(`unsupported event: ${sub.type}`);
    }
    /**
     *  If a [[Subscriber]] fails and needs to replace itself, this
     *  method may be used.
     *
     *  For example, this is used for providers when using the
     *  ``eth_getFilterChanges`` method, which can return null if state
     *  filters are not supported by the backend, allowing the Subscriber
     *  to swap in a [[PollingEventSubscriber]].
     */
    _recoverSubscriber(oldSub, newSub) {
        for (const sub of this.#subs.values()) {
            if (sub.subscriber === oldSub) {
                if (sub.started) {
                    sub.subscriber.stop();
                }
                sub.subscriber = newSub;
                if (sub.started) {
                    newSub.start();
                }
                if (this.#pausedState != null) {
                    newSub.pause(this.#pausedState);
                }
                break;
            }
        }
    }
    async #hasSub(event, emitArgs) {
        let sub = await getSubscription(event, this);
        // This is a log that is removing an existing log; we actually want
        // to emit an orphan event for the removed log
        if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
            sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
        }
        return this.#subs.get(sub.tag) || null;
    }
    async #getSub(event) {
        const subscription = await getSubscription(event, this);
        // Prevent tampering with our tag in any subclass' _getSubscriber
        const tag = subscription.tag;
        let sub = this.#subs.get(tag);
        if (!sub) {
            const subscriber = this._getSubscriber(subscription);
            const addressableMap = new WeakMap();
            const nameMap = new Map();
            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
            this.#subs.set(tag, sub);
        }
        return sub;
    }
    async on(event, listener) {
        const sub = await this.#getSub(event);
        sub.listeners.push({ listener, once: false });
        if (!sub.started) {
            sub.subscriber.start();
            sub.started = true;
            if (this.#pausedState != null) {
                sub.subscriber.pause(this.#pausedState);
            }
        }
        return this;
    }
    async once(event, listener) {
        const sub = await this.#getSub(event);
        sub.listeners.push({ listener, once: true });
        if (!sub.started) {
            sub.subscriber.start();
            sub.started = true;
            if (this.#pausedState != null) {
                sub.subscriber.pause(this.#pausedState);
            }
        }
        return this;
    }
    async emit(event, ...args) {
        const sub = await this.#hasSub(event, args);
        // If there is not subscription or if a recent emit removed
        // the last of them (which also deleted the sub) do nothing
        if (!sub || sub.listeners.length === 0) {
            return false;
        }
        const count = sub.listeners.length;
        sub.listeners = sub.listeners.filter(({ listener, once }) => {
            const payload = new EventPayload(this, (once ? null : listener), event);
            try {
                listener.call(this, ...args, payload);
            }
            catch (error) { }
            return !once;
        });
        if (sub.listeners.length === 0) {
            if (sub.started) {
                sub.subscriber.stop();
            }
            this.#subs.delete(sub.tag);
        }
        return (count > 0);
    }
    async listenerCount(event) {
        if (event) {
            const sub = await this.#hasSub(event);
            if (!sub) {
                return 0;
            }
            return sub.listeners.length;
        }
        let total = 0;
        for (const { listeners } of this.#subs.values()) {
            total += listeners.length;
        }
        return total;
    }
    async listeners(event) {
        if (event) {
            const sub = await this.#hasSub(event);
            if (!sub) {
                return [];
            }
            return sub.listeners.map(({ listener }) => listener);
        }
        let result = [];
        for (const { listeners } of this.#subs.values()) {
            result = result.concat(listeners.map(({ listener }) => listener));
        }
        return result;
    }
    async off(event, listener) {
        const sub = await this.#hasSub(event);
        if (!sub) {
            return this;
        }
        if (listener) {
            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);
            if (index >= 0) {
                sub.listeners.splice(index, 1);
            }
        }
        if (!listener || sub.listeners.length === 0) {
            if (sub.started) {
                sub.subscriber.stop();
            }
            this.#subs.delete(sub.tag);
        }
        return this;
    }
    async removeAllListeners(event) {
        if (event) {
            const { tag, started, subscriber } = await this.#getSub(event);
            if (started) {
                subscriber.stop();
            }
            this.#subs.delete(tag);
        }
        else {
            for (const [tag, { started, subscriber }] of this.#subs) {
                if (started) {
                    subscriber.stop();
                }
                this.#subs.delete(tag);
            }
        }
        return this;
    }
    // Alias for "on"
    async addListener(event, listener) {
        return await this.on(event, listener);
    }
    // Alias for "off"
    async removeListener(event, listener) {
        return this.off(event, listener);
    }
    /**
     *  If this provider has been destroyed using the [[destroy]] method.
     *
     *  Once destroyed, all resources are reclaimed, internal event loops
     *  and timers are cleaned up and no further requests may be sent to
     *  the provider.
     */
    get destroyed() {
        return this.#destroyed;
    }
    /**
     *  Sub-classes may use this to shutdown any sockets or release their
     *  resources and reject any pending requests.
     *
     *  Sub-classes **must** call ``super.destroy()``.
     */
    destroy() {
        // Stop all listeners
        this.removeAllListeners();
        // Shut down all tiemrs
        for (const timerId of this.#timers.keys()) {
            this._clearTimeout(timerId);
        }
        this.#destroyed = true;
    }
    /**
     *  Whether the provider is currently paused.
     *
     *  A paused provider will not emit any events, and generally should
     *  not make any requests to the network, but that is up to sub-classes
     *  to manage.
     *
     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
     *  which will buffer any events that occur while paused until the
     *  provider is unpaused.
     */
    get paused() { return (this.#pausedState != null); }
    set paused(pause) {
        if (!!pause === this.paused) {
            return;
        }
        if (this.paused) {
            this.resume();
        }
        else {
            this.pause(false);
        }
    }
    /**
     *  Pause the provider. If %%dropWhilePaused%%, any events that occur
     *  while paused are dropped, otherwise all events will be emitted once
     *  the provider is unpaused.
     */
    pause(dropWhilePaused) {
        this.#lastBlockNumber = -1;
        if (this.#pausedState != null) {
            if (this.#pausedState == !!dropWhilePaused) {
                return;
            }
            assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
                operation: "pause"
            });
        }
        this._forEachSubscriber((s) => s.pause(dropWhilePaused));
        this.#pausedState = !!dropWhilePaused;
        for (const timer of this.#timers.values()) {
            // Clear the timer
            if (timer.timer) {
                clearTimeout(timer.timer);
            }
            // Remaining time needed for when we become unpaused
            timer.time = getTime() - timer.time;
        }
    }
    /**
     *  Resume the provider.
     */
    resume() {
        if (this.#pausedState == null) {
            return;
        }
        this._forEachSubscriber((s) => s.resume());
        this.#pausedState = null;
        for (const timer of this.#timers.values()) {
            // Remaining time when we were paused
            let timeout = timer.time;
            if (timeout < 0) {
                timeout = 0;
            }
            // Start time (in cause paused, so we con compute remaininf time)
            timer.time = getTime();
            // Start the timer
            setTimeout(timer.func, timeout);
        }
    }
}
function _parseString(result, start) {
    try {
        const bytes = _parseBytes(result, start);
        if (bytes) {
            return toUtf8String(bytes);
        }
    }
    catch (error) { }
    return null;
}
function _parseBytes(result, start) {
    if (result === "0x") {
        return null;
    }
    try {
        const offset = getNumber(dataSlice(result, start, start + 32));
        const length = getNumber(dataSlice(result, offset, offset + 32));
        return dataSlice(result, offset + 32, offset + 32 + length);
    }
    catch (error) { }
    return null;
}
function numPad(value) {
    const result = toBeArray(value);
    if (result.length > 32) {
        throw new Error("internal; should not happen");
    }
    const padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
}
function bytesPad(value) {
    if ((value.length % 32) === 0) {
        return value;
    }
    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
}
const empty = new Uint8Array([]);
// ABI Encodes a series of (bytes, bytes, ...)
function encodeBytes(datas) {
    const result = [];
    let byteCount = 0;
    // Add place-holders for pointers as we add items
    for (let i = 0; i < datas.length; i++) {
        result.push(empty);
        byteCount += 32;
    }
    for (let i = 0; i < datas.length; i++) {
        const data = getBytes(datas[i]);
        // Update the bytes offset
        result[i] = numPad(byteCount);
        // The length and padded value of data
        result.push(numPad(data.length));
        result.push(bytesPad(data));
        byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return concat(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
    const result = {
        sender: "", urls: [], calldata: "", selector: "", extraData: "", errorArgs: []
    };
    assert(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
        reason: "insufficient OffchainLookup data"
    });
    const sender = dataSlice(data, 0, 32);
    assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup sender"
    });
    result.sender = dataSlice(sender, 12);
    // Read the URLs from the response
    try {
        const urls = [];
        const urlsOffset = getNumber(dataSlice(data, 32, 64));
        const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
        const urlsData = dataSlice(data, urlsOffset + 32);
        for (let u = 0; u < urlsLength; u++) {
            const url = _parseString(urlsData, u * 32);
            if (url == null) {
                throw new Error("abort");
            }
            urls.push(url);
        }
        result.urls = urls;
    }
    catch (error) {
        assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup urls"
        });
    }
    // Get the CCIP calldata to forward
    try {
        const calldata = _parseBytes(data, 64);
        if (calldata == null) {
            throw new Error("abort");
        }
        result.calldata = calldata;
    }
    catch (error) {
        assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup calldata"
        });
    }
    // Get the callbackSelector (bytes4)
    assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup callbaackSelector"
    });
    result.selector = dataSlice(data, 96, 100);
    // Get the extra data to send back to the contract as context
    try {
        const extraData = _parseBytes(data, 128);
        if (extraData == null) {
            throw new Error("abort");
        }
        result.extraData = extraData;
    }
    catch (error) {
        assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup extraData"
        });
    }
    result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
    return result;
}

/**
 *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes
 *  are sufficent for most developers, but this is provided to
 *  fascilitate more complex Signers.
 *
 *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]
 */
function checkProvider(signer, operation) {
    if (signer.provider) {
        return signer.provider;
    }
    assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
    let pop = copyRequest(tx);
    if (pop.to != null) {
        pop.to = resolveAddress(pop.to, signer);
    }
    if (pop.from != null) {
        const from = pop.from;
        pop.from = Promise.all([
            signer.getAddress(),
            resolveAddress(from, signer)
        ]).then(([address, from]) => {
            assertArgument(address.toLowerCase() === from.toLowerCase(), "transaction from mismatch", "tx.from", from);
            return address;
        });
    }
    else {
        pop.from = signer.getAddress();
    }
    return await resolveProperties(pop);
}
/**
 *  An **AbstractSigner** includes most of teh functionality required
 *  to get a [[Signer]] working as expected, but requires a few
 *  Signer-specific methods be overridden.
 *
 */
class AbstractSigner {
    /**
     *  The provider this signer is connected to.
     */
    provider;
    /**
     *  Creates a new Signer connected to %%provider%%.
     */
    constructor(provider) {
        defineProperties(this, { provider: (provider || null) });
    }
    async getNonce(blockTag) {
        return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
    }
    async populateCall(tx) {
        const pop = await populate(this, tx);
        return pop;
    }
    async populateTransaction(tx) {
        const provider = checkProvider(this, "populateTransaction");
        const pop = await populate(this, tx);
        if (pop.nonce == null) {
            pop.nonce = await this.getNonce("pending");
        }
        if (pop.gasLimit == null) {
            pop.gasLimit = await this.estimateGas(pop);
        }
        // Populate the chain ID
        const network = await (this.provider).getNetwork();
        if (pop.chainId != null) {
            const chainId = getBigInt(pop.chainId);
            assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
        }
        else {
            pop.chainId = network.chainId;
        }
        // Do not allow mixing pre-eip-1559 and eip-1559 properties
        const hasEip1559 = (pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null);
        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
            assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
        }
        else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
            assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
        }
        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
            // Fully-formed EIP-1559 transaction (skip getFeeData)
            pop.type = 2;
        }
        else if (pop.type === 0 || pop.type === 1) {
            // Explicit Legacy or EIP-2930 transaction
            // We need to get fee data to determine things
            const feeData = await provider.getFeeData();
            assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                operation: "getGasPrice"
            });
            // Populate missing gasPrice
            if (pop.gasPrice == null) {
                pop.gasPrice = feeData.gasPrice;
            }
        }
        else {
            // We need to get fee data to determine things
            const feeData = await provider.getFeeData();
            if (pop.type == null) {
                // We need to auto-detect the intended type of this transaction...
                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                    // The network supports EIP-1559!
                    // Upgrade transaction from null to eip-1559
                    if (pop.authorizationList && pop.authorizationList.length) {
                        pop.type = 4;
                    }
                    else {
                        pop.type = 2;
                    }
                    if (pop.gasPrice != null) {
                        // Using legacy gasPrice property on an eip-1559 network,
                        // so use gasPrice as both fee properties
                        const gasPrice = pop.gasPrice;
                        delete pop.gasPrice;
                        pop.maxFeePerGas = gasPrice;
                        pop.maxPriorityFeePerGas = gasPrice;
                    }
                    else {
                        // Populate missing fee data
                        if (pop.maxFeePerGas == null) {
                            pop.maxFeePerGas = feeData.maxFeePerGas;
                        }
                        if (pop.maxPriorityFeePerGas == null) {
                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                        }
                    }
                }
                else if (feeData.gasPrice != null) {
                    // Network doesn't support EIP-1559...
                    // ...but they are trying to use EIP-1559 properties
                    assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                        operation: "populateTransaction"
                    });
                    // Populate missing fee data
                    if (pop.gasPrice == null) {
                        pop.gasPrice = feeData.gasPrice;
                    }
                    // Explicitly set untyped transaction to legacy
                    // @TODO: Maybe this shold allow type 1?
                    pop.type = 0;
                }
                else {
                    // getFeeData has failed us.
                    assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                        operation: "signer.getFeeData"
                    });
                }
            }
            else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {
                // Explicitly using EIP-1559 or EIP-4844
                // Populate missing fee data
                if (pop.maxFeePerGas == null) {
                    pop.maxFeePerGas = feeData.maxFeePerGas;
                }
                if (pop.maxPriorityFeePerGas == null) {
                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
            }
        }
        //@TOOD: Don't await all over the place; save them up for
        // the end for better batching
        return await resolveProperties(pop);
    }
    async populateAuthorization(_auth) {
        const auth = Object.assign({}, _auth);
        // Add a chain ID if not explicitly set to 0
        if (auth.chainId == null) {
            auth.chainId = (await checkProvider(this, "getNetwork").getNetwork()).chainId;
        }
        // @TODO: Take chain ID into account when populating noce?
        if (auth.nonce == null) {
            auth.nonce = await this.getNonce();
        }
        return auth;
    }
    async estimateGas(tx) {
        return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
    }
    async call(tx) {
        return checkProvider(this, "call").call(await this.populateCall(tx));
    }
    async resolveName(name) {
        const provider = checkProvider(this, "resolveName");
        return await provider.resolveName(name);
    }
    async sendTransaction(tx) {
        const provider = checkProvider(this, "sendTransaction");
        const pop = await this.populateTransaction(tx);
        delete pop.from;
        const txObj = Transaction.from(pop);
        return await provider.broadcastTransaction(await this.signTransaction(txObj));
    }
    // @TODO: in v7 move this to be abstract
    authorize(authorization) {
        assert(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
    }
}

function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 *  Some backends support subscribing to events using a Filter ID.
 *
 *  When subscribing with this technique, the node issues a unique
 *  //Filter ID//. At this point the node dedicates resources to
 *  the filter, so that periodic calls to follow up on the //Filter ID//
 *  will receive any events since the last call.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class FilterIdSubscriber {
    #provider;
    #filterIdPromise;
    #poller;
    #running;
    #network;
    #hault;
    /**
     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
     *  and [[_emitResults]] to setup the subscription and provide the event
     *  to the %%provider%%.
     */
    constructor(provider) {
        this.#provider = provider;
        this.#filterIdPromise = null;
        this.#poller = this.#poll.bind(this);
        this.#running = false;
        this.#network = null;
        this.#hault = false;
    }
    /**
     *  Sub-classes **must** override this to begin the subscription.
     */
    _subscribe(provider) {
        throw new Error("subclasses must override this");
    }
    /**
     *  Sub-classes **must** override this handle the events.
     */
    _emitResults(provider, result) {
        throw new Error("subclasses must override this");
    }
    /**
     *  Sub-classes **must** override this handle recovery on errors.
     */
    _recover(provider) {
        throw new Error("subclasses must override this");
    }
    async #poll(blockNumber) {
        try {
            // Subscribe if necessary
            if (this.#filterIdPromise == null) {
                this.#filterIdPromise = this._subscribe(this.#provider);
            }
            // Get the Filter ID
            let filterId = null;
            try {
                filterId = await this.#filterIdPromise;
            }
            catch (error) {
                if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
                    throw error;
                }
            }
            // The backend does not support Filter ID; downgrade to
            // polling
            if (filterId == null) {
                this.#filterIdPromise = null;
                this.#provider._recoverSubscriber(this, this._recover(this.#provider));
                return;
            }
            const network = await this.#provider.getNetwork();
            if (!this.#network) {
                this.#network = network;
            }
            if (this.#network.chainId !== network.chainId) {
                throw new Error("chaid changed");
            }
            if (this.#hault) {
                return;
            }
            const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
            await this._emitResults(this.#provider, result);
        }
        catch (error) {
            console.log("@TODO", error);
        }
        this.#provider.once("block", this.#poller);
    }
    #teardown() {
        const filterIdPromise = this.#filterIdPromise;
        if (filterIdPromise) {
            this.#filterIdPromise = null;
            filterIdPromise.then((filterId) => {
                if (this.#provider.destroyed) {
                    return;
                }
                this.#provider.send("eth_uninstallFilter", [filterId]);
            });
        }
    }
    start() {
        if (this.#running) {
            return;
        }
        this.#running = true;
        this.#poll(-2);
    }
    stop() {
        if (!this.#running) {
            return;
        }
        this.#running = false;
        this.#hault = true;
        this.#teardown();
        this.#provider.off("block", this.#poller);
    }
    pause(dropWhilePaused) {
        if (dropWhilePaused) {
            this.#teardown();
        }
        this.#provider.off("block", this.#poller);
    }
    resume() { this.start(); }
}
/**
 *  A **FilterIdSubscriber** for receiving contract events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class FilterIdEventSubscriber extends FilterIdSubscriber {
    #event;
    /**
     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
     *  listening for %%filter%%.
     */
    constructor(provider, filter) {
        super(provider);
        this.#event = copy(filter);
    }
    _recover(provider) {
        return new PollingEventSubscriber(provider, this.#event);
    }
    async _subscribe(provider) {
        const filterId = await provider.send("eth_newFilter", [this.#event]);
        return filterId;
    }
    async _emitResults(provider, results) {
        for (const result of results) {
            provider.emit(this.#event, provider._wrapLog(result, provider._network));
        }
    }
}
/**
 *  A **FilterIdSubscriber** for receiving pending transactions events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class FilterIdPendingSubscriber extends FilterIdSubscriber {
    async _subscribe(provider) {
        return await provider.send("eth_newPendingTransactionFilter", []);
    }
    async _emitResults(provider, results) {
        for (const result of results) {
            provider.emit("pending", result);
        }
    }
}

/**
 *  One of the most common ways to interact with the blockchain is
 *  by a node running a JSON-RPC interface which can be connected to,
 *  based on the transport, using:
 *
 *  - HTTP or HTTPS - [[JsonRpcProvider]]
 *  - WebSocket - [[WebSocketProvider]]
 *  - IPC - [[IpcSocketProvider]]
 *
 * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]
 */
// @TODO:
// - Add the batching API
// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false
const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
//const Methods = "getAddress,then".split(/,/g);
function deepCopy(value) {
    if (value == null || Primitive.indexOf(typeof (value)) >= 0) {
        return value;
    }
    // Keep any Addressable
    if (typeof (value.getAddress) === "function") {
        return value;
    }
    if (Array.isArray(value)) {
        return (value.map(deepCopy));
    }
    if (typeof (value) === "object") {
        return Object.keys(value).reduce((accum, key) => {
            accum[key] = value[key];
            return accum;
        }, {});
    }
    throw new Error(`should not happen: ${value} (${typeof (value)})`);
}
function stall(duration) {
    return new Promise((resolve) => { setTimeout(resolve, duration); });
}
function getLowerCase(value) {
    if (value) {
        return value.toLowerCase();
    }
    return value;
}
function isPollable(value) {
    return (value && typeof (value.pollingInterval) === "number");
}
const defaultOptions = {
    polling: false,
    staticNetwork: null,
    batchStallTime: 10,
    batchMaxSize: (1 << 20),
    batchMaxCount: 100,
    cacheTimeout: 250,
    pollingInterval: 4000
};
// @TODO: Unchecked Signers
class JsonRpcSigner extends AbstractSigner {
    address;
    constructor(provider, address) {
        super(provider);
        address = getAddress(address);
        defineProperties(this, { address });
    }
    connect(provider) {
        assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
            operation: "signer.connect"
        });
    }
    async getAddress() {
        return this.address;
    }
    // JSON-RPC will automatially fill in nonce, etc. so we just check from
    async populateTransaction(tx) {
        return await this.populateCall(tx);
    }
    // Returns just the hash of the transaction after sent, which is what
    // the bare JSON-RPC API does;
    async sendUncheckedTransaction(_tx) {
        const tx = deepCopy(_tx);
        const promises = [];
        // Make sure the from matches the sender
        if (tx.from) {
            const _from = tx.from;
            promises.push((async () => {
                const from = await resolveAddress(_from, this.provider);
                assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
                tx.from = from;
            })());
        }
        else {
            tx.from = this.address;
        }
        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
        // wishes to use this, it is easy to specify explicitly, otherwise
        // we look it up for them.
        if (tx.gasLimit == null) {
            promises.push((async () => {
                tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
            })());
        }
        // The address may be an ENS name or Addressable
        if (tx.to != null) {
            const _to = tx.to;
            promises.push((async () => {
                tx.to = await resolveAddress(_to, this.provider);
            })());
        }
        // Wait until all of our properties are filled in
        if (promises.length) {
            await Promise.all(promises);
        }
        const hexTx = this.provider.getRpcTransaction(tx);
        return this.provider.send("eth_sendTransaction", [hexTx]);
    }
    async sendTransaction(tx) {
        // This cannot be mined any earlier than any recent block
        const blockNumber = await this.provider.getBlockNumber();
        // Send the transaction
        const hash = await this.sendUncheckedTransaction(tx);
        // Unfortunately, JSON-RPC only provides and opaque transaction hash
        // for a response, and we need the actual transaction, so we poll
        // for it; it should show up very quickly
        return await (new Promise((resolve, reject) => {
            const timeouts = [1000, 100];
            let invalids = 0;
            const checkTx = async () => {
                try {
                    // Try getting the transaction
                    const tx = await this.provider.getTransaction(hash);
                    if (tx != null) {
                        resolve(tx.replaceableTransaction(blockNumber));
                        return;
                    }
                }
                catch (error) {
                    // If we were cancelled: stop polling.
                    // If the data is bad: the node returns bad transactions
                    // If the network changed: calling again will also fail
                    // If unsupported: likely destroyed
                    if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") ||
                        isError(error, "NETWORK_ERROR") || isError(error, "UNSUPPORTED_OPERATION")) {
                        if (error.info == null) {
                            error.info = {};
                        }
                        error.info.sendTransactionHash = hash;
                        reject(error);
                        return;
                    }
                    // Stop-gap for misbehaving backends; see #4513
                    if (isError(error, "INVALID_ARGUMENT")) {
                        invalids++;
                        if (error.info == null) {
                            error.info = {};
                        }
                        error.info.sendTransactionHash = hash;
                        if (invalids > 10) {
                            reject(error);
                            return;
                        }
                    }
                    // Notify anyone that cares; but we will try again, since
                    // it is likely an intermittent service error
                    this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
                }
                // Wait another 4 seconds
                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);
            };
            checkTx();
        }));
    }
    async signTransaction(_tx) {
        const tx = deepCopy(_tx);
        // Make sure the from matches the sender
        if (tx.from) {
            const from = await resolveAddress(tx.from, this.provider);
            assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
            tx.from = from;
        }
        else {
            tx.from = this.address;
        }
        const hexTx = this.provider.getRpcTransaction(tx);
        return await this.provider.send("eth_signTransaction", [hexTx]);
    }
    async signMessage(_message) {
        const message = ((typeof (_message) === "string") ? toUtf8Bytes(_message) : _message);
        return await this.provider.send("personal_sign", [
            hexlify(message), this.address.toLowerCase()
        ]);
    }
    async signTypedData(domain, types, _value) {
        const value = deepCopy(_value);
        // Populate any ENS names (in-place)
        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value) => {
            const address = await resolveAddress(value);
            assertArgument(address != null, "TypedData does not support null address", "value", value);
            return address;
        });
        return await this.provider.send("eth_signTypedData_v4", [
            this.address.toLowerCase(),
            JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
    }
    async unlock(password) {
        return this.provider.send("personal_unlockAccount", [
            this.address.toLowerCase(), password, null
        ]);
    }
    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
    async _legacySignMessage(_message) {
        const message = ((typeof (_message) === "string") ? toUtf8Bytes(_message) : _message);
        return await this.provider.send("eth_sign", [
            this.address.toLowerCase(), hexlify(message)
        ]);
    }
}
/**
 *  The JsonRpcApiProvider is an abstract class and **MUST** be
 *  sub-classed.
 *
 *  It provides the base for all JSON-RPC-based Provider interaction.
 *
 *  Sub-classing Notes:
 *  - a sub-class MUST override _send
 *  - a sub-class MUST call the `_start()` method once connected
 */
class JsonRpcApiProvider extends AbstractProvider {
    #options;
    // The next ID to use for the JSON-RPC ID field
    #nextId;
    // Payloads are queued and triggered in batches using the drainTimer
    #payloads;
    #drainTimer;
    #notReady;
    #network;
    #pendingDetectNetwork;
    #scheduleDrain() {
        if (this.#drainTimer) {
            return;
        }
        // If we aren't using batching, no harm in sending it immediately
        const stallTime = (this._getOption("batchMaxCount") === 1) ? 0 : this._getOption("batchStallTime");
        this.#drainTimer = setTimeout(() => {
            this.#drainTimer = null;
            const payloads = this.#payloads;
            this.#payloads = [];
            while (payloads.length) {
                // Create payload batches that satisfy our batch constraints
                const batch = [(payloads.shift())];
                while (payloads.length) {
                    if (batch.length === this.#options.batchMaxCount) {
                        break;
                    }
                    batch.push((payloads.shift()));
                    const bytes = JSON.stringify(batch.map((p) => p.payload));
                    if (bytes.length > this.#options.batchMaxSize) {
                        payloads.unshift((batch.pop()));
                        break;
                    }
                }
                // Process the result to each payload
                (async () => {
                    const payload = ((batch.length === 1) ? batch[0].payload : batch.map((p) => p.payload));
                    this.emit("debug", { action: "sendRpcPayload", payload });
                    try {
                        const result = await this._send(payload);
                        this.emit("debug", { action: "receiveRpcResult", result });
                        // Process results in batch order
                        for (const { resolve, reject, payload } of batch) {
                            if (this.destroyed) {
                                reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
                                continue;
                            }
                            // Find the matching result
                            const resp = result.filter((r) => (r.id === payload.id))[0];
                            // No result; the node failed us in unexpected ways
                            if (resp == null) {
                                const error = makeError("missing response for request", "BAD_DATA", {
                                    value: result, info: { payload }
                                });
                                this.emit("error", error);
                                reject(error);
                                continue;
                            }
                            // The response is an error
                            if ("error" in resp) {
                                reject(this.getRpcError(payload, resp));
                                continue;
                            }
                            // All good; send the result
                            resolve(resp.result);
                        }
                    }
                    catch (error) {
                        this.emit("debug", { action: "receiveRpcError", error });
                        for (const { reject } of batch) {
                            // @TODO: augment the error with the payload
                            reject(error);
                        }
                    }
                })();
            }
        }, stallTime);
    }
    constructor(network, options) {
        super(network, options);
        this.#nextId = 1;
        this.#options = Object.assign({}, defaultOptions, options || {});
        this.#payloads = [];
        this.#drainTimer = null;
        this.#network = null;
        this.#pendingDetectNetwork = null;
        {
            let resolve = null;
            const promise = new Promise((_resolve) => {
                resolve = _resolve;
            });
            this.#notReady = { promise, resolve };
        }
        const staticNetwork = this._getOption("staticNetwork");
        if (typeof (staticNetwork) === "boolean") {
            assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
            if (staticNetwork && network != null) {
                this.#network = Network.from(network);
            }
        }
        else if (staticNetwork) {
            // Make sure any static network is compatbile with the provided netwrok
            assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
            this.#network = staticNetwork;
        }
    }
    /**
     *  Returns the value associated with the option %%key%%.
     *
     *  Sub-classes can use this to inquire about configuration options.
     */
    _getOption(key) {
        return this.#options[key];
    }
    /**
     *  Gets the [[Network]] this provider has committed to. On each call, the network
     *  is detected, and if it has changed, the call will reject.
     */
    get _network() {
        assert(this.#network, "network is not available yet", "NETWORK_ERROR");
        return this.#network;
    }
    /**
     *  Resolves to the non-normalized value by performing %%req%%.
     *
     *  Sub-classes may override this to modify behavior of actions,
     *  and should generally call ``super._perform`` as a fallback.
     */
    async _perform(req) {
        // Legacy networks do not like the type field being passed along (which
        // is fair), so we delete type if it is 0 and a non-EIP-1559 network
        if (req.method === "call" || req.method === "estimateGas") {
            let tx = req.transaction;
            if (tx && tx.type != null && getBigInt(tx.type)) {
                // If there are no EIP-1559 or newer properties, it might be pre-EIP-1559
                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                    const feeData = await this.getFeeData();
                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                        // Network doesn't know about EIP-1559 (and hence type)
                        req = Object.assign({}, req, {
                            transaction: Object.assign({}, tx, { type: undefined })
                        });
                    }
                }
            }
        }
        const request = this.getRpcRequest(req);
        if (request != null) {
            return await this.send(request.method, request.args);
        }
        return super._perform(req);
    }
    /**
     *  Sub-classes may override this; it detects the *actual* network that
     *  we are **currently** connected to.
     *
     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
     *  _send primitive must be used instead.
     */
    async _detectNetwork() {
        const network = this._getOption("staticNetwork");
        if (network) {
            if (network === true) {
                if (this.#network) {
                    return this.#network;
                }
            }
            else {
                return network;
            }
        }
        if (this.#pendingDetectNetwork) {
            return await this.#pendingDetectNetwork;
        }
        // If we are ready, use ``send``, which enabled requests to be batched
        if (this.ready) {
            this.#pendingDetectNetwork = (async () => {
                try {
                    const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
                    this.#pendingDetectNetwork = null;
                    return result;
                }
                catch (error) {
                    this.#pendingDetectNetwork = null;
                    throw error;
                }
            })();
            return await this.#pendingDetectNetwork;
        }
        // We are not ready yet; use the primitive _send
        this.#pendingDetectNetwork = (async () => {
            const payload = {
                id: this.#nextId++, method: "eth_chainId", params: [], jsonrpc: "2.0"
            };
            this.emit("debug", { action: "sendRpcPayload", payload });
            let result;
            try {
                result = (await this._send(payload))[0];
                this.#pendingDetectNetwork = null;
            }
            catch (error) {
                this.#pendingDetectNetwork = null;
                this.emit("debug", { action: "receiveRpcError", error });
                throw error;
            }
            this.emit("debug", { action: "receiveRpcResult", result });
            if ("result" in result) {
                return Network.from(getBigInt(result.result));
            }
            throw this.getRpcError(payload, result);
        })();
        return await this.#pendingDetectNetwork;
    }
    /**
     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
     *  will be passed to [[_send]] from [[send]]. If it is overridden, then
     *  ``super._start()`` **MUST** be called.
     *
     *  Calling it multiple times is safe and has no effect.
     */
    _start() {
        if (this.#notReady == null || this.#notReady.resolve == null) {
            return;
        }
        this.#notReady.resolve();
        this.#notReady = null;
        (async () => {
            // Bootstrap the network
            while (this.#network == null && !this.destroyed) {
                try {
                    this.#network = await this._detectNetwork();
                }
                catch (error) {
                    if (this.destroyed) {
                        break;
                    }
                    console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
                    this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
                    await stall(1000);
                }
            }
            // Start dispatching requests
            this.#scheduleDrain();
        })();
    }
    /**
     *  Resolves once the [[_start]] has been called. This can be used in
     *  sub-classes to defer sending data until the connection has been
     *  established.
     */
    async _waitUntilReady() {
        if (this.#notReady == null) {
            return;
        }
        return await this.#notReady.promise;
    }
    /**
     *  Return a Subscriber that will manage the %%sub%%.
     *
     *  Sub-classes may override this to modify the behavior of
     *  subscription management.
     */
    _getSubscriber(sub) {
        // Pending Filters aren't availble via polling
        if (sub.type === "pending") {
            return new FilterIdPendingSubscriber(this);
        }
        if (sub.type === "event") {
            if (this._getOption("polling")) {
                return new PollingEventSubscriber(this, sub.filter);
            }
            return new FilterIdEventSubscriber(this, sub.filter);
        }
        // Orphaned Logs are handled automatically, by the filter, since
        // logs with removed are emitted by it
        if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
            return new UnmanagedSubscriber("orphan");
        }
        return super._getSubscriber(sub);
    }
    /**
     *  Returns true only if the [[_start]] has been called.
     */
    get ready() { return this.#notReady == null; }
    /**
     *  Returns %%tx%% as a normalized JSON-RPC transaction request,
     *  which has all values hexlified and any numeric values converted
     *  to Quantity values.
     */
    getRpcTransaction(tx) {
        const result = {};
        // JSON-RPC now requires numeric values to be "quantity" values
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
            if (tx[key] == null) {
                return;
            }
            let dstKey = key;
            if (key === "gasLimit") {
                dstKey = "gas";
            }
            result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
        });
        // Make sure addresses and data are lowercase
        ["from", "to", "data"].forEach((key) => {
            if (tx[key] == null) {
                return;
            }
            result[key] = hexlify(tx[key]);
        });
        // Normalize the access list object
        if (tx.accessList) {
            result["accessList"] = accessListify(tx.accessList);
        }
        if (tx.blobVersionedHashes) {
            // @TODO: Remove this <any> case once EIP-4844 added to prepared tx
            result["blobVersionedHashes"] = tx.blobVersionedHashes.map(h => h.toLowerCase());
        }
        if (tx.authorizationList) {
            result["authorizationList"] = tx.authorizationList.map((_a) => {
                const a = authorizationify(_a);
                return {
                    address: a.address,
                    nonce: toQuantity(a.nonce),
                    chainId: toQuantity(a.chainId),
                    yParity: toQuantity(a.signature.yParity),
                    r: toQuantity(a.signature.r),
                    s: toQuantity(a.signature.s),
                };
            });
        }
        // @TODO: blobs should probably also be copied over, optionally
        // accounting for the kzg property to backfill blobVersionedHashes
        // using the commitment. Or should that be left as an exercise to
        // the caller?
        return result;
    }
    /**
     *  Returns the request method and arguments required to perform
     *  %%req%%.
     */
    getRpcRequest(req) {
        switch (req.method) {
            case "chainId":
                return { method: "eth_chainId", args: [] };
            case "getBlockNumber":
                return { method: "eth_blockNumber", args: [] };
            case "getGasPrice":
                return { method: "eth_gasPrice", args: [] };
            case "getPriorityFee":
                return { method: "eth_maxPriorityFeePerGas", args: [] };
            case "getBalance":
                return {
                    method: "eth_getBalance",
                    args: [getLowerCase(req.address), req.blockTag]
                };
            case "getTransactionCount":
                return {
                    method: "eth_getTransactionCount",
                    args: [getLowerCase(req.address), req.blockTag]
                };
            case "getCode":
                return {
                    method: "eth_getCode",
                    args: [getLowerCase(req.address), req.blockTag]
                };
            case "getStorage":
                return {
                    method: "eth_getStorageAt",
                    args: [
                        getLowerCase(req.address),
                        ("0x" + req.position.toString(16)),
                        req.blockTag
                    ]
                };
            case "broadcastTransaction":
                return {
                    method: "eth_sendRawTransaction",
                    args: [req.signedTransaction]
                };
            case "getBlock":
                if ("blockTag" in req) {
                    return {
                        method: "eth_getBlockByNumber",
                        args: [req.blockTag, !!req.includeTransactions]
                    };
                }
                else if ("blockHash" in req) {
                    return {
                        method: "eth_getBlockByHash",
                        args: [req.blockHash, !!req.includeTransactions]
                    };
                }
                break;
            case "getTransaction":
                return {
                    method: "eth_getTransactionByHash",
                    args: [req.hash]
                };
            case "getTransactionReceipt":
                return {
                    method: "eth_getTransactionReceipt",
                    args: [req.hash]
                };
            case "call":
                return {
                    method: "eth_call",
                    args: [this.getRpcTransaction(req.transaction), req.blockTag]
                };
            case "estimateGas": {
                return {
                    method: "eth_estimateGas",
                    args: [this.getRpcTransaction(req.transaction)]
                };
            }
            case "getLogs":
                if (req.filter && req.filter.address != null) {
                    if (Array.isArray(req.filter.address)) {
                        req.filter.address = req.filter.address.map(getLowerCase);
                    }
                    else {
                        req.filter.address = getLowerCase(req.filter.address);
                    }
                }
                return { method: "eth_getLogs", args: [req.filter] };
        }
        return null;
    }
    /**
     *  Returns an ethers-style Error for the given JSON-RPC error
     *  %%payload%%, coalescing the various strings and error shapes
     *  that different nodes return, coercing them into a machine-readable
     *  standardized error.
     */
    getRpcError(payload, _error) {
        const { method } = payload;
        const { error } = _error;
        if (method === "eth_estimateGas" && error.message) {
            const msg = error.message;
            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
                return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
                    transaction: (payload.params[0]),
                    info: { payload, error }
                });
            }
            else if (msg.match(/nonce/i) && msg.match(/too low/i)) {
                return makeError("nonce has already been used", "NONCE_EXPIRED", {
                    transaction: (payload.params[0]),
                    info: { payload, error }
                });
            }
        }
        if (method === "eth_call" || method === "eth_estimateGas") {
            const result = spelunkData(error);
            const e = AbiCoder.getBuiltinCallException((method === "eth_call") ? "call" : "estimateGas", (payload.params[0]), (result ? result.data : null));
            e.info = { error, payload };
            return e;
        }
        // Only estimateGas and call can return arbitrary contract-defined text, so now we
        // we can process text safely.
        const message = JSON.stringify(spelunkMessage(error));
        if (typeof (error.message) === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
            const actionMap = {
                eth_sign: "signMessage",
                personal_sign: "signMessage",
                eth_signTypedData_v4: "signTypedData",
                eth_signTransaction: "signTransaction",
                eth_sendTransaction: "sendTransaction",
                eth_requestAccounts: "requestAccess",
                wallet_requestAccounts: "requestAccess",
            };
            return makeError(`user rejected action`, "ACTION_REJECTED", {
                action: (actionMap[method] || "unknown"),
                reason: "rejected",
                info: { payload, error }
            });
        }
        if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
            const transaction = (payload.params[0]);
            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
                return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                    transaction, info: { error }
                });
            }
            if (message.match(/nonce/i) && message.match(/too low/i)) {
                return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
            }
            // "replacement transaction underpriced"
            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
                return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
            }
            if (message.match(/only replay-protected/i)) {
                return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
                    operation: method, info: { transaction, info: { error } }
                });
            }
        }
        let unsupported = !!message.match(/the method .* does not exist/i);
        if (!unsupported) {
            if (error && error.details && error.details.startsWith("Unauthorized method:")) {
                unsupported = true;
            }
        }
        if (unsupported) {
            return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
                operation: payload.method, info: { error, payload }
            });
        }
        return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
    }
    /**
     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
     *  over the underlying channel. This can be used to call methods
     *  on the backend that do not have a high-level API within the Provider
     *  API.
     *
     *  This method queues requests according to the batch constraints
     *  in the options, assigns the request a unique ID.
     *
     *  **Do NOT override** this method in sub-classes; instead
     *  override [[_send]] or force the options values in the
     *  call to the constructor to modify this method's behavior.
     */
    send(method, params) {
        // @TODO: cache chainId?? purge on switch_networks
        // We have been destroyed; no operations are supported anymore
        if (this.destroyed) {
            return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
        }
        const id = this.#nextId++;
        const promise = new Promise((resolve, reject) => {
            this.#payloads.push({
                resolve, reject,
                payload: { method, params, id, jsonrpc: "2.0" }
            });
        });
        // If there is not a pending drainTimer, set one
        this.#scheduleDrain();
        return promise;
    }
    /**
     *  Resolves to the [[Signer]] account for  %%address%% managed by
     *  the client.
     *
     *  If the %%address%% is a number, it is used as an index in the
     *  the accounts from [[listAccounts]].
     *
     *  This can only be used on clients which manage accounts (such as
     *  Geth with imported account or MetaMask).
     *
     *  Throws if the account doesn't exist.
     */
    async getSigner(address) {
        if (address == null) {
            address = 0;
        }
        const accountsPromise = this.send("eth_accounts", []);
        // Account index
        if (typeof (address) === "number") {
            const accounts = (await accountsPromise);
            if (address >= accounts.length) {
                throw new Error("no such account");
            }
            return new JsonRpcSigner(this, accounts[address]);
        }
        const { accounts } = await resolveProperties({
            network: this.getNetwork(),
            accounts: accountsPromise
        });
        // Account address
        address = getAddress(address);
        for (const account of accounts) {
            if (getAddress(account) === address) {
                return new JsonRpcSigner(this, address);
            }
        }
        throw new Error("invalid account");
    }
    async listAccounts() {
        const accounts = await this.send("eth_accounts", []);
        return accounts.map((a) => new JsonRpcSigner(this, a));
    }
    destroy() {
        // Stop processing requests
        if (this.#drainTimer) {
            clearTimeout(this.#drainTimer);
            this.#drainTimer = null;
        }
        // Cancel all pending requests
        for (const { payload, reject } of this.#payloads) {
            reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
        }
        this.#payloads = [];
        // Parent clean-up
        super.destroy();
    }
}
// @TODO: remove this in v7, it is not exported because this functionality
// is exposed in the JsonRpcApiProvider by setting polling to true. It should
// be safe to remove regardless, because it isn't reachable, but just in case.
/**
 *  @_ignore:
 */
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
    #pollingInterval;
    constructor(network, options) {
        super(network, options);
        let pollingInterval = this._getOption("pollingInterval");
        if (pollingInterval == null) {
            pollingInterval = defaultOptions.pollingInterval;
        }
        this.#pollingInterval = pollingInterval;
    }
    _getSubscriber(sub) {
        const subscriber = super._getSubscriber(sub);
        if (isPollable(subscriber)) {
            subscriber.pollingInterval = this.#pollingInterval;
        }
        return subscriber;
    }
    /**
     *  The polling interval (default: 4000 ms)
     */
    get pollingInterval() { return this.#pollingInterval; }
    set pollingInterval(value) {
        if (!Number.isInteger(value) || value < 0) {
            throw new Error("invalid interval");
        }
        this.#pollingInterval = value;
        this._forEachSubscriber((sub) => {
            if (isPollable(sub)) {
                sub.pollingInterval = this.#pollingInterval;
            }
        });
    }
}
/**
 *  The JsonRpcProvider is one of the most common Providers,
 *  which performs all operations over HTTP (or HTTPS) requests.
 *
 *  Events are processed by polling the backend for the current block
 *  number; when it advances, all block-base events are then checked
 *  for updates.
 */
class JsonRpcProvider extends JsonRpcApiPollingProvider {
    #connect;
    constructor(url, network, options) {
        if (url == null) {
            url = "http:/\/localhost:8545";
        }
        super(network, options);
        if (typeof (url) === "string") {
            this.#connect = new FetchRequest(url);
        }
        else {
            this.#connect = url.clone();
        }
    }
    _getConnection() {
        return this.#connect.clone();
    }
    async send(method, params) {
        // All requests are over HTTP, so we can just start handling requests
        // We do this here rather than the constructor so that we don't send any
        // requests to the network (i.e. eth_chainId) until we absolutely have to.
        await this._start();
        return await super.send(method, params);
    }
    async _send(payload) {
        // Configure a POST connection for the requested method
        const request = this._getConnection();
        request.body = JSON.stringify(payload);
        request.setHeader("content-type", "application/json");
        const response = await request.send();
        response.assertOk();
        let resp = response.bodyJson;
        if (!Array.isArray(resp)) {
            resp = [resp];
        }
        return resp;
    }
}
function spelunkData(value) {
    if (value == null) {
        return null;
    }
    // These *are* the droids we're looking for.
    if (typeof (value.message) === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
        return { message: value.message, data: value.data };
    }
    // Spelunk further...
    if (typeof (value) === "object") {
        for (const key in value) {
            const result = spelunkData(value[key]);
            if (result) {
                return result;
            }
        }
        return null;
    }
    // Might be a JSON string we can further descend...
    if (typeof (value) === "string") {
        try {
            return spelunkData(JSON.parse(value));
        }
        catch (error) { }
    }
    return null;
}
function _spelunkMessage(value, result) {
    if (value == null) {
        return;
    }
    // These *are* the droids we're looking for.
    if (typeof (value.message) === "string") {
        result.push(value.message);
    }
    // Spelunk further...
    if (typeof (value) === "object") {
        for (const key in value) {
            _spelunkMessage(value[key], result);
        }
    }
    // Might be a JSON string we can further descend...
    if (typeof (value) === "string") {
        try {
            return _spelunkMessage(JSON.parse(value), result);
        }
        catch (error) { }
    }
}
function spelunkMessage(value) {
    const result = [];
    _spelunkMessage(value, result);
    return result;
}

var stream;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;

	const { Duplex } = require$$0;

	/**
	 * Emits the `'close'` event on a stream.
	 *
	 * @param {Duplex} stream The stream.
	 * @private
	 */
	function emitClose(stream) {
	  stream.emit('close');
	}

	/**
	 * The listener of the `'end'` event.
	 *
	 * @private
	 */
	function duplexOnEnd() {
	  if (!this.destroyed && this._writableState.finished) {
	    this.destroy();
	  }
	}

	/**
	 * The listener of the `'error'` event.
	 *
	 * @param {Error} err The error
	 * @private
	 */
	function duplexOnError(err) {
	  this.removeListener('error', duplexOnError);
	  this.destroy();
	  if (this.listenerCount('error') === 0) {
	    // Do not suppress the throwing behavior.
	    this.emit('error', err);
	  }
	}

	/**
	 * Wraps a `WebSocket` in a duplex stream.
	 *
	 * @param {WebSocket} ws The `WebSocket` to wrap
	 * @param {Object} [options] The options for the `Duplex` constructor
	 * @return {Duplex} The duplex stream
	 * @public
	 */
	function createWebSocketStream(ws, options) {
	  let terminateOnDestroy = true;

	  const duplex = new Duplex({
	    ...options,
	    autoDestroy: false,
	    emitClose: false,
	    objectMode: false,
	    writableObjectMode: false
	  });

	  ws.on('message', function message(msg, isBinary) {
	    const data =
	      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

	    if (!duplex.push(data)) ws.pause();
	  });

	  ws.once('error', function error(err) {
	    if (duplex.destroyed) return;

	    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
	    //
	    // - If the `'error'` event is emitted before the `'open'` event, then
	    //   `ws.terminate()` is a noop as no socket is assigned.
	    // - Otherwise, the error is re-emitted by the listener of the `'error'`
	    //   event of the `Receiver` object. The listener already closes the
	    //   connection by calling `ws.close()`. This allows a close frame to be
	    //   sent to the other peer. If `ws.terminate()` is called right after this,
	    //   then the close frame might not be sent.
	    terminateOnDestroy = false;
	    duplex.destroy(err);
	  });

	  ws.once('close', function close() {
	    if (duplex.destroyed) return;

	    duplex.push(null);
	  });

	  duplex._destroy = function (err, callback) {
	    if (ws.readyState === ws.CLOSED) {
	      callback(err);
	      process.nextTick(emitClose, duplex);
	      return;
	    }

	    let called = false;

	    ws.once('error', function error(err) {
	      called = true;
	      callback(err);
	    });

	    ws.once('close', function close() {
	      if (!called) callback(err);
	      process.nextTick(emitClose, duplex);
	    });

	    if (terminateOnDestroy) ws.terminate();
	  };

	  duplex._final = function (callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._final(callback);
	      });
	      return;
	    }

	    // If the value of the `_socket` property is `null` it means that `ws` is a
	    // client websocket and the handshake failed. In fact, when this happens, a
	    // socket is never assigned to the websocket. Wait for the `'error'` event
	    // that will be emitted by the websocket.
	    if (ws._socket === null) return;

	    if (ws._socket._writableState.finished) {
	      callback();
	      if (duplex._readableState.endEmitted) duplex.destroy();
	    } else {
	      ws._socket.once('finish', function finish() {
	        // `duplex` is not destroyed here because the `'end'` event will be
	        // emitted on `duplex` after this `'finish'` event. The EOF signaling
	        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
	        callback();
	      });
	      ws.close();
	    }
	  };

	  duplex._read = function () {
	    if (ws.isPaused) ws.resume();
	  };

	  duplex._write = function (chunk, encoding, callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._write(chunk, encoding, callback);
	      });
	      return;
	    }

	    ws.send(chunk, callback);
	  };

	  duplex.on('end', duplexOnEnd);
	  duplex.on('error', duplexOnError);
	  return duplex;
	}

	stream = createWebSocketStream;
	return stream;
}

requireStream();

var bufferUtil = {exports: {}};

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	constants = {
	  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
	  EMPTY_BUFFER: Buffer.alloc(0),
	  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
	  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
	  kListener: Symbol('kListener'),
	  kStatusCode: Symbol('status-code'),
	  kWebSocket: Symbol('websocket'),
	  NOOP: () => {}
	};
	return constants;
}

var hasRequiredBufferUtil;

function requireBufferUtil () {
	if (hasRequiredBufferUtil) return bufferUtil.exports;
	hasRequiredBufferUtil = 1;

	const { EMPTY_BUFFER } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];

	/**
	 * Merges an array of buffers into a new buffer.
	 *
	 * @param {Buffer[]} list The array of buffers to concat
	 * @param {Number} totalLength The total length of buffers in the list
	 * @return {Buffer} The resulting buffer
	 * @public
	 */
	function concat(list, totalLength) {
	  if (list.length === 0) return EMPTY_BUFFER;
	  if (list.length === 1) return list[0];

	  const target = Buffer.allocUnsafe(totalLength);
	  let offset = 0;

	  for (let i = 0; i < list.length; i++) {
	    const buf = list[i];
	    target.set(buf, offset);
	    offset += buf.length;
	  }

	  if (offset < totalLength) {
	    return new FastBuffer(target.buffer, target.byteOffset, offset);
	  }

	  return target;
	}

	/**
	 * Masks a buffer using the given mask.
	 *
	 * @param {Buffer} source The buffer to mask
	 * @param {Buffer} mask The mask to use
	 * @param {Buffer} output The buffer where to store the result
	 * @param {Number} offset The offset at which to start writing
	 * @param {Number} length The number of bytes to mask.
	 * @public
	 */
	function _mask(source, mask, output, offset, length) {
	  for (let i = 0; i < length; i++) {
	    output[offset + i] = source[i] ^ mask[i & 3];
	  }
	}

	/**
	 * Unmasks a buffer using the given mask.
	 *
	 * @param {Buffer} buffer The buffer to unmask
	 * @param {Buffer} mask The mask to use
	 * @public
	 */
	function _unmask(buffer, mask) {
	  for (let i = 0; i < buffer.length; i++) {
	    buffer[i] ^= mask[i & 3];
	  }
	}

	/**
	 * Converts a buffer to an `ArrayBuffer`.
	 *
	 * @param {Buffer} buf The buffer to convert
	 * @return {ArrayBuffer} Converted buffer
	 * @public
	 */
	function toArrayBuffer(buf) {
	  if (buf.length === buf.buffer.byteLength) {
	    return buf.buffer;
	  }

	  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}

	/**
	 * Converts `data` to a `Buffer`.
	 *
	 * @param {*} data The data to convert
	 * @return {Buffer} The buffer
	 * @throws {TypeError}
	 * @public
	 */
	function toBuffer(data) {
	  toBuffer.readOnly = true;

	  if (Buffer.isBuffer(data)) return data;

	  let buf;

	  if (data instanceof ArrayBuffer) {
	    buf = new FastBuffer(data);
	  } else if (ArrayBuffer.isView(data)) {
	    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
	  } else {
	    buf = Buffer.from(data);
	    toBuffer.readOnly = false;
	  }

	  return buf;
	}

	bufferUtil.exports = {
	  concat,
	  mask: _mask,
	  toArrayBuffer,
	  toBuffer,
	  unmask: _unmask
	};

	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) {
	  try {
	    const bufferUtil$1 = require('bufferutil');

	    bufferUtil.exports.mask = function (source, mask, output, offset, length) {
	      if (length < 48) _mask(source, mask, output, offset, length);
	      else bufferUtil$1.mask(source, mask, output, offset, length);
	    };

	    bufferUtil.exports.unmask = function (buffer, mask) {
	      if (buffer.length < 32) _unmask(buffer, mask);
	      else bufferUtil$1.unmask(buffer, mask);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return bufferUtil.exports;
}

var limiter;
var hasRequiredLimiter;

function requireLimiter () {
	if (hasRequiredLimiter) return limiter;
	hasRequiredLimiter = 1;

	const kDone = Symbol('kDone');
	const kRun = Symbol('kRun');

	/**
	 * A very simple job queue with adjustable concurrency. Adapted from
	 * https://github.com/STRML/async-limiter
	 */
	class Limiter {
	  /**
	   * Creates a new `Limiter`.
	   *
	   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
	   *     to run concurrently
	   */
	  constructor(concurrency) {
	    this[kDone] = () => {
	      this.pending--;
	      this[kRun]();
	    };
	    this.concurrency = concurrency || Infinity;
	    this.jobs = [];
	    this.pending = 0;
	  }

	  /**
	   * Adds a job to the queue.
	   *
	   * @param {Function} job The job to run
	   * @public
	   */
	  add(job) {
	    this.jobs.push(job);
	    this[kRun]();
	  }

	  /**
	   * Removes a job from the queue and runs it if possible.
	   *
	   * @private
	   */
	  [kRun]() {
	    if (this.pending === this.concurrency) return;

	    if (this.jobs.length) {
	      const job = this.jobs.shift();

	      this.pending++;
	      job(this[kDone]);
	    }
	  }
	}

	limiter = Limiter;
	return limiter;
}

var permessageDeflate;
var hasRequiredPermessageDeflate;

function requirePermessageDeflate () {
	if (hasRequiredPermessageDeflate) return permessageDeflate;
	hasRequiredPermessageDeflate = 1;

	const zlib = require$$0$1;

	const bufferUtil = requireBufferUtil();
	const Limiter = requireLimiter();
	const { kStatusCode } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
	const kPerMessageDeflate = Symbol('permessage-deflate');
	const kTotalLength = Symbol('total-length');
	const kCallback = Symbol('callback');
	const kBuffers = Symbol('buffers');
	const kError = Symbol('error');

	//
	// We limit zlib concurrency, which prevents severe memory fragmentation
	// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
	// and https://github.com/websockets/ws/issues/1202
	//
	// Intentionally global; it's the global thread pool that's an issue.
	//
	let zlibLimiter;

	/**
	 * permessage-deflate implementation.
	 */
	class PerMessageDeflate {
	  /**
	   * Creates a PerMessageDeflate instance.
	   *
	   * @param {Object} [options] Configuration options
	   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
	   *     for, or request, a custom client window size
	   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
	   *     acknowledge disabling of client context takeover
	   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
	   *     calls to zlib
	   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
	   *     use of a custom server window size
	   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
	   *     disabling of server context takeover
	   * @param {Number} [options.threshold=1024] Size (in bytes) below which
	   *     messages should not be compressed if context takeover is disabled
	   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
	   *     deflate
	   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
	   *     inflate
	   * @param {Boolean} [isServer=false] Create the instance in either server or
	   *     client mode
	   * @param {Number} [maxPayload=0] The maximum allowed message length
	   */
	  constructor(options, isServer, maxPayload) {
	    this._maxPayload = maxPayload | 0;
	    this._options = options || {};
	    this._threshold =
	      this._options.threshold !== undefined ? this._options.threshold : 1024;
	    this._isServer = !!isServer;
	    this._deflate = null;
	    this._inflate = null;

	    this.params = null;

	    if (!zlibLimiter) {
	      const concurrency =
	        this._options.concurrencyLimit !== undefined
	          ? this._options.concurrencyLimit
	          : 10;
	      zlibLimiter = new Limiter(concurrency);
	    }
	  }

	  /**
	   * @type {String}
	   */
	  static get extensionName() {
	    return 'permessage-deflate';
	  }

	  /**
	   * Create an extension negotiation offer.
	   *
	   * @return {Object} Extension parameters
	   * @public
	   */
	  offer() {
	    const params = {};

	    if (this._options.serverNoContextTakeover) {
	      params.server_no_context_takeover = true;
	    }
	    if (this._options.clientNoContextTakeover) {
	      params.client_no_context_takeover = true;
	    }
	    if (this._options.serverMaxWindowBits) {
	      params.server_max_window_bits = this._options.serverMaxWindowBits;
	    }
	    if (this._options.clientMaxWindowBits) {
	      params.client_max_window_bits = this._options.clientMaxWindowBits;
	    } else if (this._options.clientMaxWindowBits == null) {
	      params.client_max_window_bits = true;
	    }

	    return params;
	  }

	  /**
	   * Accept an extension negotiation offer/response.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Object} Accepted configuration
	   * @public
	   */
	  accept(configurations) {
	    configurations = this.normalizeParams(configurations);

	    this.params = this._isServer
	      ? this.acceptAsServer(configurations)
	      : this.acceptAsClient(configurations);

	    return this.params;
	  }

	  /**
	   * Releases all resources used by the extension.
	   *
	   * @public
	   */
	  cleanup() {
	    if (this._inflate) {
	      this._inflate.close();
	      this._inflate = null;
	    }

	    if (this._deflate) {
	      const callback = this._deflate[kCallback];

	      this._deflate.close();
	      this._deflate = null;

	      if (callback) {
	        callback(
	          new Error(
	            'The deflate stream was closed while data was being processed'
	          )
	        );
	      }
	    }
	  }

	  /**
	   *  Accept an extension negotiation offer.
	   *
	   * @param {Array} offers The extension negotiation offers
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsServer(offers) {
	    const opts = this._options;
	    const accepted = offers.find((params) => {
	      if (
	        (opts.serverNoContextTakeover === false &&
	          params.server_no_context_takeover) ||
	        (params.server_max_window_bits &&
	          (opts.serverMaxWindowBits === false ||
	            (typeof opts.serverMaxWindowBits === 'number' &&
	              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
	        (typeof opts.clientMaxWindowBits === 'number' &&
	          !params.client_max_window_bits)
	      ) {
	        return false;
	      }

	      return true;
	    });

	    if (!accepted) {
	      throw new Error('None of the extension offers can be accepted');
	    }

	    if (opts.serverNoContextTakeover) {
	      accepted.server_no_context_takeover = true;
	    }
	    if (opts.clientNoContextTakeover) {
	      accepted.client_no_context_takeover = true;
	    }
	    if (typeof opts.serverMaxWindowBits === 'number') {
	      accepted.server_max_window_bits = opts.serverMaxWindowBits;
	    }
	    if (typeof opts.clientMaxWindowBits === 'number') {
	      accepted.client_max_window_bits = opts.clientMaxWindowBits;
	    } else if (
	      accepted.client_max_window_bits === true ||
	      opts.clientMaxWindowBits === false
	    ) {
	      delete accepted.client_max_window_bits;
	    }

	    return accepted;
	  }

	  /**
	   * Accept the extension negotiation response.
	   *
	   * @param {Array} response The extension negotiation response
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsClient(response) {
	    const params = response[0];

	    if (
	      this._options.clientNoContextTakeover === false &&
	      params.client_no_context_takeover
	    ) {
	      throw new Error('Unexpected parameter "client_no_context_takeover"');
	    }

	    if (!params.client_max_window_bits) {
	      if (typeof this._options.clientMaxWindowBits === 'number') {
	        params.client_max_window_bits = this._options.clientMaxWindowBits;
	      }
	    } else if (
	      this._options.clientMaxWindowBits === false ||
	      (typeof this._options.clientMaxWindowBits === 'number' &&
	        params.client_max_window_bits > this._options.clientMaxWindowBits)
	    ) {
	      throw new Error(
	        'Unexpected or invalid parameter "client_max_window_bits"'
	      );
	    }

	    return params;
	  }

	  /**
	   * Normalize parameters.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Array} The offers/response with normalized parameters
	   * @private
	   */
	  normalizeParams(configurations) {
	    configurations.forEach((params) => {
	      Object.keys(params).forEach((key) => {
	        let value = params[key];

	        if (value.length > 1) {
	          throw new Error(`Parameter "${key}" must have only a single value`);
	        }

	        value = value[0];

	        if (key === 'client_max_window_bits') {
	          if (value !== true) {
	            const num = +value;
	            if (!Number.isInteger(num) || num < 8 || num > 15) {
	              throw new TypeError(
	                `Invalid value for parameter "${key}": ${value}`
	              );
	            }
	            value = num;
	          } else if (!this._isServer) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else if (key === 'server_max_window_bits') {
	          const num = +value;
	          if (!Number.isInteger(num) || num < 8 || num > 15) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	          value = num;
	        } else if (
	          key === 'client_no_context_takeover' ||
	          key === 'server_no_context_takeover'
	        ) {
	          if (value !== true) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else {
	          throw new Error(`Unknown parameter "${key}"`);
	        }

	        params[key] = value;
	      });
	    });

	    return configurations;
	  }

	  /**
	   * Decompress data. Concurrency limited.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  decompress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._decompress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Compress data. Concurrency limited.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  compress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._compress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Decompress data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _decompress(data, fin, callback) {
	    const endpoint = this._isServer ? 'client' : 'server';

	    if (!this._inflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._inflate = zlib.createInflateRaw({
	        ...this._options.zlibInflateOptions,
	        windowBits
	      });
	      this._inflate[kPerMessageDeflate] = this;
	      this._inflate[kTotalLength] = 0;
	      this._inflate[kBuffers] = [];
	      this._inflate.on('error', inflateOnError);
	      this._inflate.on('data', inflateOnData);
	    }

	    this._inflate[kCallback] = callback;

	    this._inflate.write(data);
	    if (fin) this._inflate.write(TRAILER);

	    this._inflate.flush(() => {
	      const err = this._inflate[kError];

	      if (err) {
	        this._inflate.close();
	        this._inflate = null;
	        callback(err);
	        return;
	      }

	      const data = bufferUtil.concat(
	        this._inflate[kBuffers],
	        this._inflate[kTotalLength]
	      );

	      if (this._inflate._readableState.endEmitted) {
	        this._inflate.close();
	        this._inflate = null;
	      } else {
	        this._inflate[kTotalLength] = 0;
	        this._inflate[kBuffers] = [];

	        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	          this._inflate.reset();
	        }
	      }

	      callback(null, data);
	    });
	  }

	  /**
	   * Compress data.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _compress(data, fin, callback) {
	    const endpoint = this._isServer ? 'server' : 'client';

	    if (!this._deflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._deflate = zlib.createDeflateRaw({
	        ...this._options.zlibDeflateOptions,
	        windowBits
	      });

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      this._deflate.on('data', deflateOnData);
	    }

	    this._deflate[kCallback] = callback;

	    this._deflate.write(data);
	    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
	      if (!this._deflate) {
	        //
	        // The deflate stream was closed while data was being processed.
	        //
	        return;
	      }

	      let data = bufferUtil.concat(
	        this._deflate[kBuffers],
	        this._deflate[kTotalLength]
	      );

	      if (fin) {
	        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
	      }

	      //
	      // Ensure that the callback will not be called again in
	      // `PerMessageDeflate#cleanup()`.
	      //
	      this._deflate[kCallback] = null;

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	        this._deflate.reset();
	      }

	      callback(null, data);
	    });
	  }
	}

	permessageDeflate = PerMessageDeflate;

	/**
	 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function deflateOnData(chunk) {
	  this[kBuffers].push(chunk);
	  this[kTotalLength] += chunk.length;
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function inflateOnData(chunk) {
	  this[kTotalLength] += chunk.length;

	  if (
	    this[kPerMessageDeflate]._maxPayload < 1 ||
	    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
	  ) {
	    this[kBuffers].push(chunk);
	    return;
	  }

	  this[kError] = new RangeError('Max payload size exceeded');
	  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
	  this[kError][kStatusCode] = 1009;
	  this.removeListener('data', inflateOnData);
	  this.reset();
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'error'` event.
	 *
	 * @param {Error} err The emitted error
	 * @private
	 */
	function inflateOnError(err) {
	  //
	  // There is no need to call `Zlib#close()` as the handle is automatically
	  // closed when an error is emitted.
	  //
	  this[kPerMessageDeflate]._inflate = null;
	  err[kStatusCode] = 1007;
	  this[kCallback](err);
	}
	return permessageDeflate;
}

var validation$1 = {exports: {}};

var hasRequiredValidation$1;

function requireValidation$1 () {
	if (hasRequiredValidation$1) return validation$1.exports;
	hasRequiredValidation$1 = 1;

	const { isUtf8 } = require$$0$2;

	//
	// Allowed token characters:
	//
	// '!', '#', '$', '%', '&', ''', '*', '+', '-',
	// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
	//
	// tokenChars[32] === 0 // ' '
	// tokenChars[33] === 1 // '!'
	// tokenChars[34] === 0 // '"'
	// ...
	//
	// prettier-ignore
	const tokenChars = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
	  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
	];

	/**
	 * Checks if a status code is allowed in a close frame.
	 *
	 * @param {Number} code The status code
	 * @return {Boolean} `true` if the status code is valid, else `false`
	 * @public
	 */
	function isValidStatusCode(code) {
	  return (
	    (code >= 1000 &&
	      code <= 1014 &&
	      code !== 1004 &&
	      code !== 1005 &&
	      code !== 1006) ||
	    (code >= 3000 && code <= 4999)
	  );
	}

	/**
	 * Checks if a given buffer contains only correct UTF-8.
	 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	 * Markus Kuhn.
	 *
	 * @param {Buffer} buf The buffer to check
	 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	 * @public
	 */
	function _isValidUTF8(buf) {
	  const len = buf.length;
	  let i = 0;

	  while (i < len) {
	    if ((buf[i] & 0x80) === 0) {
	      // 0xxxxxxx
	      i++;
	    } else if ((buf[i] & 0xe0) === 0xc0) {
	      // 110xxxxx 10xxxxxx
	      if (
	        i + 1 === len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i] & 0xfe) === 0xc0 // Overlong
	      ) {
	        return false;
	      }

	      i += 2;
	    } else if ((buf[i] & 0xf0) === 0xe0) {
	      // 1110xxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 2 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
	        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
	      ) {
	        return false;
	      }

	      i += 3;
	    } else if ((buf[i] & 0xf8) === 0xf0) {
	      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 3 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i + 3] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
	        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
	        buf[i] > 0xf4 // > U+10FFFF
	      ) {
	        return false;
	      }

	      i += 4;
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	validation$1.exports = {
	  isValidStatusCode,
	  isValidUTF8: _isValidUTF8,
	  tokenChars
	};

	if (isUtf8) {
	  validation$1.exports.isValidUTF8 = function (buf) {
	    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	  };
	} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
	  try {
	    const isValidUTF8 = require('utf-8-validate');

	    validation$1.exports.isValidUTF8 = function (buf) {
	      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return validation$1.exports;
}

var receiver;
var hasRequiredReceiver;

function requireReceiver () {
	if (hasRequiredReceiver) return receiver;
	hasRequiredReceiver = 1;

	const { Writable } = require$$0;

	const PerMessageDeflate = requirePermessageDeflate();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  kStatusCode,
	  kWebSocket
	} = requireConstants();
	const { concat, toArrayBuffer, unmask } = requireBufferUtil();
	const { isValidStatusCode, isValidUTF8 } = requireValidation$1();

	const FastBuffer = Buffer[Symbol.species];

	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;

	/**
	 * HyBi Receiver implementation.
	 *
	 * @extends Writable
	 */
	class Receiver extends Writable {
	  /**
	   * Creates a Receiver instance.
	   *
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {String} [options.binaryType=nodebuffer] The type for binary data
	   * @param {Object} [options.extensions] An object containing the negotiated
	   *     extensions
	   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
	   *     client or server mode
	   * @param {Number} [options.maxPayload=0] The maximum allowed message length
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   */
	  constructor(options = {}) {
	    super();

	    this._allowSynchronousEvents =
	      options.allowSynchronousEvents !== undefined
	        ? options.allowSynchronousEvents
	        : true;
	    this._binaryType = options.binaryType || BINARY_TYPES[0];
	    this._extensions = options.extensions || {};
	    this._isServer = !!options.isServer;
	    this._maxPayload = options.maxPayload | 0;
	    this._skipUTF8Validation = !!options.skipUTF8Validation;
	    this[kWebSocket] = undefined;

	    this._bufferedBytes = 0;
	    this._buffers = [];

	    this._compressed = false;
	    this._payloadLength = 0;
	    this._mask = undefined;
	    this._fragmented = 0;
	    this._masked = false;
	    this._fin = false;
	    this._opcode = 0;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragments = [];

	    this._errored = false;
	    this._loop = false;
	    this._state = GET_INFO;
	  }

	  /**
	   * Implements `Writable.prototype._write()`.
	   *
	   * @param {Buffer} chunk The chunk of data to write
	   * @param {String} encoding The character encoding of `chunk`
	   * @param {Function} cb Callback
	   * @private
	   */
	  _write(chunk, encoding, cb) {
	    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

	    this._bufferedBytes += chunk.length;
	    this._buffers.push(chunk);
	    this.startLoop(cb);
	  }

	  /**
	   * Consumes `n` bytes from the buffered data.
	   *
	   * @param {Number} n The number of bytes to consume
	   * @return {Buffer} The consumed bytes
	   * @private
	   */
	  consume(n) {
	    this._bufferedBytes -= n;

	    if (n === this._buffers[0].length) return this._buffers.shift();

	    if (n < this._buffers[0].length) {
	      const buf = this._buffers[0];
	      this._buffers[0] = new FastBuffer(
	        buf.buffer,
	        buf.byteOffset + n,
	        buf.length - n
	      );

	      return new FastBuffer(buf.buffer, buf.byteOffset, n);
	    }

	    const dst = Buffer.allocUnsafe(n);

	    do {
	      const buf = this._buffers[0];
	      const offset = dst.length - n;

	      if (n >= buf.length) {
	        dst.set(this._buffers.shift(), offset);
	      } else {
	        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
	        this._buffers[0] = new FastBuffer(
	          buf.buffer,
	          buf.byteOffset + n,
	          buf.length - n
	        );
	      }

	      n -= buf.length;
	    } while (n > 0);

	    return dst;
	  }

	  /**
	   * Starts the parsing loop.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  startLoop(cb) {
	    this._loop = true;

	    do {
	      switch (this._state) {
	        case GET_INFO:
	          this.getInfo(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_16:
	          this.getPayloadLength16(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_64:
	          this.getPayloadLength64(cb);
	          break;
	        case GET_MASK:
	          this.getMask();
	          break;
	        case GET_DATA:
	          this.getData(cb);
	          break;
	        case INFLATING:
	        case DEFER_EVENT:
	          this._loop = false;
	          return;
	      }
	    } while (this._loop);

	    if (!this._errored) cb();
	  }

	  /**
	   * Reads the first two bytes of a frame.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getInfo(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(2);

	    if ((buf[0] & 0x30) !== 0x00) {
	      const error = this.createError(
	        RangeError,
	        'RSV2 and RSV3 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_2_3'
	      );

	      cb(error);
	      return;
	    }

	    const compressed = (buf[0] & 0x40) === 0x40;

	    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
	      const error = this.createError(
	        RangeError,
	        'RSV1 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_1'
	      );

	      cb(error);
	      return;
	    }

	    this._fin = (buf[0] & 0x80) === 0x80;
	    this._opcode = buf[0] & 0x0f;
	    this._payloadLength = buf[1] & 0x7f;

	    if (this._opcode === 0x00) {
	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (!this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          'invalid opcode 0',
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._opcode = this._fragmented;
	    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
	      if (this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          `invalid opcode ${this._opcode}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._compressed = compressed;
	    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
	      if (!this._fin) {
	        const error = this.createError(
	          RangeError,
	          'FIN must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_FIN'
	        );

	        cb(error);
	        return;
	      }

	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (
	        this._payloadLength > 0x7d ||
	        (this._opcode === 0x08 && this._payloadLength === 1)
	      ) {
	        const error = this.createError(
	          RangeError,
	          `invalid payload length ${this._payloadLength}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    } else {
	      const error = this.createError(
	        RangeError,
	        `invalid opcode ${this._opcode}`,
	        true,
	        1002,
	        'WS_ERR_INVALID_OPCODE'
	      );

	      cb(error);
	      return;
	    }

	    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
	    this._masked = (buf[1] & 0x80) === 0x80;

	    if (this._isServer) {
	      if (!this._masked) {
	        const error = this.createError(
	          RangeError,
	          'MASK must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_MASK'
	        );

	        cb(error);
	        return;
	      }
	    } else if (this._masked) {
	      const error = this.createError(
	        RangeError,
	        'MASK must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_MASK'
	      );

	      cb(error);
	      return;
	    }

	    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
	    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
	    else this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+16).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength16(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    this._payloadLength = this.consume(2).readUInt16BE(0);
	    this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+64).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength64(cb) {
	    if (this._bufferedBytes < 8) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(8);
	    const num = buf.readUInt32BE(0);

	    //
	    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
	    // if payload length is greater than this number.
	    //
	    if (num > Math.pow(2, 53 - 32) - 1) {
	      const error = this.createError(
	        RangeError,
	        'Unsupported WebSocket frame: payload length > 2^53 - 1',
	        false,
	        1009,
	        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
	      );

	      cb(error);
	      return;
	    }

	    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
	    this.haveLength(cb);
	  }

	  /**
	   * Payload length has been read.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  haveLength(cb) {
	    if (this._payloadLength && this._opcode < 0x08) {
	      this._totalPayloadLength += this._payloadLength;
	      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
	        const error = this.createError(
	          RangeError,
	          'Max payload size exceeded',
	          false,
	          1009,
	          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    }

	    if (this._masked) this._state = GET_MASK;
	    else this._state = GET_DATA;
	  }

	  /**
	   * Reads mask bytes.
	   *
	   * @private
	   */
	  getMask() {
	    if (this._bufferedBytes < 4) {
	      this._loop = false;
	      return;
	    }

	    this._mask = this.consume(4);
	    this._state = GET_DATA;
	  }

	  /**
	   * Reads data bytes.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getData(cb) {
	    let data = EMPTY_BUFFER;

	    if (this._payloadLength) {
	      if (this._bufferedBytes < this._payloadLength) {
	        this._loop = false;
	        return;
	      }

	      data = this.consume(this._payloadLength);

	      if (
	        this._masked &&
	        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
	      ) {
	        unmask(data, this._mask);
	      }
	    }

	    if (this._opcode > 0x07) {
	      this.controlMessage(data, cb);
	      return;
	    }

	    if (this._compressed) {
	      this._state = INFLATING;
	      this.decompress(data, cb);
	      return;
	    }

	    if (data.length) {
	      //
	      // This message is not compressed so its length is the sum of the payload
	      // length of all fragments.
	      //
	      this._messageLength = this._totalPayloadLength;
	      this._fragments.push(data);
	    }

	    this.dataMessage(cb);
	  }

	  /**
	   * Decompresses data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Function} cb Callback
	   * @private
	   */
	  decompress(data, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
	      if (err) return cb(err);

	      if (buf.length) {
	        this._messageLength += buf.length;
	        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
	          const error = this.createError(
	            RangeError,
	            'Max payload size exceeded',
	            false,
	            1009,
	            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	          );

	          cb(error);
	          return;
	        }

	        this._fragments.push(buf);
	      }

	      this.dataMessage(cb);
	      if (this._state === GET_INFO) this.startLoop(cb);
	    });
	  }

	  /**
	   * Handles a data message.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  dataMessage(cb) {
	    if (!this._fin) {
	      this._state = GET_INFO;
	      return;
	    }

	    const messageLength = this._messageLength;
	    const fragments = this._fragments;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragmented = 0;
	    this._fragments = [];

	    if (this._opcode === 2) {
	      let data;

	      if (this._binaryType === 'nodebuffer') {
	        data = concat(fragments, messageLength);
	      } else if (this._binaryType === 'arraybuffer') {
	        data = toArrayBuffer(concat(fragments, messageLength));
	      } else {
	        data = fragments;
	      }

	      if (this._allowSynchronousEvents) {
	        this.emit('message', data, true);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', data, true);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    } else {
	      const buf = concat(fragments, messageLength);

	      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	        const error = this.createError(
	          Error,
	          'invalid UTF-8 sequence',
	          true,
	          1007,
	          'WS_ERR_INVALID_UTF8'
	        );

	        cb(error);
	        return;
	      }

	      if (this._state === INFLATING || this._allowSynchronousEvents) {
	        this.emit('message', buf, false);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', buf, false);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    }
	  }

	  /**
	   * Handles a control message.
	   *
	   * @param {Buffer} data Data to handle
	   * @return {(Error|RangeError|undefined)} A possible error
	   * @private
	   */
	  controlMessage(data, cb) {
	    if (this._opcode === 0x08) {
	      if (data.length === 0) {
	        this._loop = false;
	        this.emit('conclude', 1005, EMPTY_BUFFER);
	        this.end();
	      } else {
	        const code = data.readUInt16BE(0);

	        if (!isValidStatusCode(code)) {
	          const error = this.createError(
	            RangeError,
	            `invalid status code ${code}`,
	            true,
	            1002,
	            'WS_ERR_INVALID_CLOSE_CODE'
	          );

	          cb(error);
	          return;
	        }

	        const buf = new FastBuffer(
	          data.buffer,
	          data.byteOffset + 2,
	          data.length - 2
	        );

	        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	          const error = this.createError(
	            Error,
	            'invalid UTF-8 sequence',
	            true,
	            1007,
	            'WS_ERR_INVALID_UTF8'
	          );

	          cb(error);
	          return;
	        }

	        this._loop = false;
	        this.emit('conclude', code, buf);
	        this.end();
	      }

	      this._state = GET_INFO;
	      return;
	    }

	    if (this._allowSynchronousEvents) {
	      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	      this._state = GET_INFO;
	    } else {
	      this._state = DEFER_EVENT;
	      setImmediate(() => {
	        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	        this._state = GET_INFO;
	        this.startLoop(cb);
	      });
	    }
	  }

	  /**
	   * Builds an error object.
	   *
	   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
	   * @param {String} message The error message
	   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
	   *     `message`
	   * @param {Number} statusCode The status code
	   * @param {String} errorCode The exposed error code
	   * @return {(Error|RangeError)} The error
	   * @private
	   */
	  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
	    this._loop = false;
	    this._errored = true;

	    const err = new ErrorCtor(
	      prefix ? `Invalid WebSocket frame: ${message}` : message
	    );

	    Error.captureStackTrace(err, this.createError);
	    err.code = errorCode;
	    err[kStatusCode] = statusCode;
	    return err;
	  }
	}

	receiver = Receiver;
	return receiver;
}

requireReceiver();

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */

var sender;
var hasRequiredSender;

function requireSender () {
	if (hasRequiredSender) return sender;
	hasRequiredSender = 1;

	const { Duplex } = require$$0;
	const { randomFillSync } = require$$1;

	const PerMessageDeflate = requirePermessageDeflate();
	const { EMPTY_BUFFER } = requireConstants();
	const { isValidStatusCode } = requireValidation$1();
	const { mask: applyMask, toBuffer } = requireBufferUtil();

	const kByteLength = Symbol('kByteLength');
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;

	/**
	 * HyBi Sender implementation.
	 */
	class Sender {
	  /**
	   * Creates a Sender instance.
	   *
	   * @param {Duplex} socket The connection socket
	   * @param {Object} [extensions] An object containing the negotiated extensions
	   * @param {Function} [generateMask] The function used to generate the masking
	   *     key
	   */
	  constructor(socket, extensions, generateMask) {
	    this._extensions = extensions || {};

	    if (generateMask) {
	      this._generateMask = generateMask;
	      this._maskBuffer = Buffer.alloc(4);
	    }

	    this._socket = socket;

	    this._firstFragment = true;
	    this._compress = false;

	    this._bufferedBytes = 0;
	    this._deflating = false;
	    this._queue = [];
	  }

	  /**
	   * Frames a piece of data according to the HyBi WebSocket protocol.
	   *
	   * @param {(Buffer|String)} data The data to frame
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @return {(Buffer|String)[]} The framed data
	   * @public
	   */
	  static frame(data, options) {
	    let mask;
	    let merge = false;
	    let offset = 2;
	    let skipMasking = false;

	    if (options.mask) {
	      mask = options.maskBuffer || maskBuffer;

	      if (options.generateMask) {
	        options.generateMask(mask);
	      } else {
	        if (randomPoolPointer === RANDOM_POOL_SIZE) {
	          /* istanbul ignore else  */
	          if (randomPool === undefined) {
	            //
	            // This is lazily initialized because server-sent frames must not
	            // be masked so it may never be used.
	            //
	            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
	          }

	          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
	          randomPoolPointer = 0;
	        }

	        mask[0] = randomPool[randomPoolPointer++];
	        mask[1] = randomPool[randomPoolPointer++];
	        mask[2] = randomPool[randomPoolPointer++];
	        mask[3] = randomPool[randomPoolPointer++];
	      }

	      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
	      offset = 6;
	    }

	    let dataLength;

	    if (typeof data === 'string') {
	      if (
	        (!options.mask || skipMasking) &&
	        options[kByteLength] !== undefined
	      ) {
	        dataLength = options[kByteLength];
	      } else {
	        data = Buffer.from(data);
	        dataLength = data.length;
	      }
	    } else {
	      dataLength = data.length;
	      merge = options.mask && options.readOnly && !skipMasking;
	    }

	    let payloadLength = dataLength;

	    if (dataLength >= 65536) {
	      offset += 8;
	      payloadLength = 127;
	    } else if (dataLength > 125) {
	      offset += 2;
	      payloadLength = 126;
	    }

	    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

	    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
	    if (options.rsv1) target[0] |= 0x40;

	    target[1] = payloadLength;

	    if (payloadLength === 126) {
	      target.writeUInt16BE(dataLength, 2);
	    } else if (payloadLength === 127) {
	      target[2] = target[3] = 0;
	      target.writeUIntBE(dataLength, 4, 6);
	    }

	    if (!options.mask) return [target, data];

	    target[1] |= 0x80;
	    target[offset - 4] = mask[0];
	    target[offset - 3] = mask[1];
	    target[offset - 2] = mask[2];
	    target[offset - 1] = mask[3];

	    if (skipMasking) return [target, data];

	    if (merge) {
	      applyMask(data, mask, target, offset, dataLength);
	      return [target];
	    }

	    applyMask(data, mask, data, 0, dataLength);
	    return [target, data];
	  }

	  /**
	   * Sends a close message to the other peer.
	   *
	   * @param {Number} [code] The status code component of the body
	   * @param {(String|Buffer)} [data] The message component of the body
	   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  close(code, data, mask, cb) {
	    let buf;

	    if (code === undefined) {
	      buf = EMPTY_BUFFER;
	    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
	      throw new TypeError('First argument must be a valid error code number');
	    } else if (data === undefined || !data.length) {
	      buf = Buffer.allocUnsafe(2);
	      buf.writeUInt16BE(code, 0);
	    } else {
	      const length = Buffer.byteLength(data);

	      if (length > 123) {
	        throw new RangeError('The message must not be greater than 123 bytes');
	      }

	      buf = Buffer.allocUnsafe(2 + length);
	      buf.writeUInt16BE(code, 0);

	      if (typeof data === 'string') {
	        buf.write(data, 2);
	      } else {
	        buf.set(data, 2);
	      }
	    }

	    const options = {
	      [kByteLength]: buf.length,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x08,
	      readOnly: false,
	      rsv1: false
	    };

	    if (this._deflating) {
	      this.enqueue([this.dispatch, buf, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(buf, options), cb);
	    }
	  }

	  /**
	   * Sends a ping message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  ping(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x09,
	      readOnly,
	      rsv1: false
	    };

	    if (this._deflating) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a pong message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  pong(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x0a,
	      readOnly,
	      rsv1: false
	    };

	    if (this._deflating) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a data message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Object} options Options object
	   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
	   *     or text
	   * @param {Boolean} [options.compress=false] Specifies whether or not to
	   *     compress `data`
	   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  send(data, options, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    let opcode = options.binary ? 2 : 1;
	    let rsv1 = options.compress;

	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (this._firstFragment) {
	      this._firstFragment = false;
	      if (
	        rsv1 &&
	        perMessageDeflate &&
	        perMessageDeflate.params[
	          perMessageDeflate._isServer
	            ? 'server_no_context_takeover'
	            : 'client_no_context_takeover'
	        ]
	      ) {
	        rsv1 = byteLength >= perMessageDeflate._threshold;
	      }
	      this._compress = rsv1;
	    } else {
	      rsv1 = false;
	      opcode = 0;
	    }

	    if (options.fin) this._firstFragment = true;

	    if (perMessageDeflate) {
	      const opts = {
	        [kByteLength]: byteLength,
	        fin: options.fin,
	        generateMask: this._generateMask,
	        mask: options.mask,
	        maskBuffer: this._maskBuffer,
	        opcode,
	        readOnly,
	        rsv1
	      };

	      if (this._deflating) {
	        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
	      } else {
	        this.dispatch(data, this._compress, opts, cb);
	      }
	    } else {
	      this.sendFrame(
	        Sender.frame(data, {
	          [kByteLength]: byteLength,
	          fin: options.fin,
	          generateMask: this._generateMask,
	          mask: options.mask,
	          maskBuffer: this._maskBuffer,
	          opcode,
	          readOnly,
	          rsv1: false
	        }),
	        cb
	      );
	    }
	  }

	  /**
	   * Dispatches a message.
	   *
	   * @param {(Buffer|String)} data The message to send
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     `data`
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  dispatch(data, compress, options, cb) {
	    if (!compress) {
	      this.sendFrame(Sender.frame(data, options), cb);
	      return;
	    }

	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    this._bufferedBytes += options[kByteLength];
	    this._deflating = true;
	    perMessageDeflate.compress(data, options.fin, (_, buf) => {
	      if (this._socket.destroyed) {
	        const err = new Error(
	          'The socket was closed while data was being compressed'
	        );

	        if (typeof cb === 'function') cb(err);

	        for (let i = 0; i < this._queue.length; i++) {
	          const params = this._queue[i];
	          const callback = params[params.length - 1];

	          if (typeof callback === 'function') callback(err);
	        }

	        return;
	      }

	      this._bufferedBytes -= options[kByteLength];
	      this._deflating = false;
	      options.readOnly = false;
	      this.sendFrame(Sender.frame(buf, options), cb);
	      this.dequeue();
	    });
	  }

	  /**
	   * Executes queued send operations.
	   *
	   * @private
	   */
	  dequeue() {
	    while (!this._deflating && this._queue.length) {
	      const params = this._queue.shift();

	      this._bufferedBytes -= params[3][kByteLength];
	      Reflect.apply(params[0], this, params.slice(1));
	    }
	  }

	  /**
	   * Enqueues a send operation.
	   *
	   * @param {Array} params Send operation parameters.
	   * @private
	   */
	  enqueue(params) {
	    this._bufferedBytes += params[3][kByteLength];
	    this._queue.push(params);
	  }

	  /**
	   * Sends a frame.
	   *
	   * @param {Buffer[]} list The frame to send
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  sendFrame(list, cb) {
	    if (list.length === 2) {
	      this._socket.cork();
	      this._socket.write(list[0]);
	      this._socket.write(list[1], cb);
	      this._socket.uncork();
	    } else {
	      this._socket.write(list[0], cb);
	    }
	  }
	}

	sender = Sender;
	return sender;
}

requireSender();

var eventTarget;
var hasRequiredEventTarget;

function requireEventTarget () {
	if (hasRequiredEventTarget) return eventTarget;
	hasRequiredEventTarget = 1;

	const { kForOnEventAttribute, kListener } = requireConstants();

	const kCode = Symbol('kCode');
	const kData = Symbol('kData');
	const kError = Symbol('kError');
	const kMessage = Symbol('kMessage');
	const kReason = Symbol('kReason');
	const kTarget = Symbol('kTarget');
	const kType = Symbol('kType');
	const kWasClean = Symbol('kWasClean');

	/**
	 * Class representing an event.
	 */
	class Event {
	  /**
	   * Create a new `Event`.
	   *
	   * @param {String} type The name of the event
	   * @throws {TypeError} If the `type` argument is not specified
	   */
	  constructor(type) {
	    this[kTarget] = null;
	    this[kType] = type;
	  }

	  /**
	   * @type {*}
	   */
	  get target() {
	    return this[kTarget];
	  }

	  /**
	   * @type {String}
	   */
	  get type() {
	    return this[kType];
	  }
	}

	Object.defineProperty(Event.prototype, 'target', { enumerable: true });
	Object.defineProperty(Event.prototype, 'type', { enumerable: true });

	/**
	 * Class representing a close event.
	 *
	 * @extends Event
	 */
	class CloseEvent extends Event {
	  /**
	   * Create a new `CloseEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {Number} [options.code=0] The status code explaining why the
	   *     connection was closed
	   * @param {String} [options.reason=''] A human-readable string explaining why
	   *     the connection was closed
	   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
	   *     connection was cleanly closed
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kCode] = options.code === undefined ? 0 : options.code;
	    this[kReason] = options.reason === undefined ? '' : options.reason;
	    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
	  }

	  /**
	   * @type {Number}
	   */
	  get code() {
	    return this[kCode];
	  }

	  /**
	   * @type {String}
	   */
	  get reason() {
	    return this[kReason];
	  }

	  /**
	   * @type {Boolean}
	   */
	  get wasClean() {
	    return this[kWasClean];
	  }
	}

	Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

	/**
	 * Class representing an error event.
	 *
	 * @extends Event
	 */
	class ErrorEvent extends Event {
	  /**
	   * Create a new `ErrorEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.error=null] The error that generated this event
	   * @param {String} [options.message=''] The error message
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kError] = options.error === undefined ? null : options.error;
	    this[kMessage] = options.message === undefined ? '' : options.message;
	  }

	  /**
	   * @type {*}
	   */
	  get error() {
	    return this[kError];
	  }

	  /**
	   * @type {String}
	   */
	  get message() {
	    return this[kMessage];
	  }
	}

	Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

	/**
	 * Class representing a message event.
	 *
	 * @extends Event
	 */
	class MessageEvent extends Event {
	  /**
	   * Create a new `MessageEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.data=null] The message content
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kData] = options.data === undefined ? null : options.data;
	  }

	  /**
	   * @type {*}
	   */
	  get data() {
	    return this[kData];
	  }
	}

	Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

	/**
	 * This provides methods for emulating the `EventTarget` interface. It's not
	 * meant to be used directly.
	 *
	 * @mixin
	 */
	const EventTarget = {
	  /**
	   * Register an event listener.
	   *
	   * @param {String} type A string representing the event type to listen for
	   * @param {(Function|Object)} handler The listener to add
	   * @param {Object} [options] An options object specifies characteristics about
	   *     the event listener
	   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
	   *     listener should be invoked at most once after being added. If `true`,
	   *     the listener would be automatically removed when invoked.
	   * @public
	   */
	  addEventListener(type, handler, options = {}) {
	    for (const listener of this.listeners(type)) {
	      if (
	        !options[kForOnEventAttribute] &&
	        listener[kListener] === handler &&
	        !listener[kForOnEventAttribute]
	      ) {
	        return;
	      }
	    }

	    let wrapper;

	    if (type === 'message') {
	      wrapper = function onMessage(data, isBinary) {
	        const event = new MessageEvent('message', {
	          data: isBinary ? data : data.toString()
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'close') {
	      wrapper = function onClose(code, message) {
	        const event = new CloseEvent('close', {
	          code,
	          reason: message.toString(),
	          wasClean: this._closeFrameReceived && this._closeFrameSent
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'error') {
	      wrapper = function onError(error) {
	        const event = new ErrorEvent('error', {
	          error,
	          message: error.message
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'open') {
	      wrapper = function onOpen() {
	        const event = new Event('open');

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else {
	      return;
	    }

	    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
	    wrapper[kListener] = handler;

	    if (options.once) {
	      this.once(type, wrapper);
	    } else {
	      this.on(type, wrapper);
	    }
	  },

	  /**
	   * Remove an event listener.
	   *
	   * @param {String} type A string representing the event type to remove
	   * @param {(Function|Object)} handler The listener to remove
	   * @public
	   */
	  removeEventListener(type, handler) {
	    for (const listener of this.listeners(type)) {
	      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
	        this.removeListener(type, listener);
	        break;
	      }
	    }
	  }
	};

	eventTarget = {
	  CloseEvent,
	  ErrorEvent,
	  Event,
	  EventTarget,
	  MessageEvent
	};

	/**
	 * Call an event listener
	 *
	 * @param {(Function|Object)} listener The listener to call
	 * @param {*} thisArg The value to use as `this`` when calling the listener
	 * @param {Event} event The event to pass to the listener
	 * @private
	 */
	function callListener(listener, thisArg, event) {
	  if (typeof listener === 'object' && listener.handleEvent) {
	    listener.handleEvent.call(listener, event);
	  } else {
	    listener.call(thisArg, event);
	  }
	}
	return eventTarget;
}

var extension;
var hasRequiredExtension;

function requireExtension () {
	if (hasRequiredExtension) return extension;
	hasRequiredExtension = 1;

	const { tokenChars } = requireValidation$1();

	/**
	 * Adds an offer to the map of extension offers or a parameter to the map of
	 * parameters.
	 *
	 * @param {Object} dest The map of extension offers or parameters
	 * @param {String} name The extension or parameter name
	 * @param {(Object|Boolean|String)} elem The extension parameters or the
	 *     parameter value
	 * @private
	 */
	function push(dest, name, elem) {
	  if (dest[name] === undefined) dest[name] = [elem];
	  else dest[name].push(elem);
	}

	/**
	 * Parses the `Sec-WebSocket-Extensions` header into an object.
	 *
	 * @param {String} header The field value of the header
	 * @return {Object} The parsed object
	 * @public
	 */
	function parse(header) {
	  const offers = Object.create(null);
	  let params = Object.create(null);
	  let mustUnescape = false;
	  let isEscaping = false;
	  let inQuotes = false;
	  let extensionName;
	  let paramName;
	  let start = -1;
	  let code = -1;
	  let end = -1;
	  let i = 0;

	  for (; i < header.length; i++) {
	    code = header.charCodeAt(i);

	    if (extensionName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (
	        i !== 0 &&
	        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	      ) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        const name = header.slice(start, end);
	        if (code === 0x2c) {
	          push(offers, name, params);
	          params = Object.create(null);
	        } else {
	          extensionName = name;
	        }

	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else if (paramName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (code === 0x20 || code === 0x09) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        push(params, header.slice(start, end), true);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        start = end = -1;
	      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
	        paramName = header.slice(start, i);
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else {
	      //
	      // The value of a quoted-string after unescaping must conform to the
	      // token ABNF, so only token characters are valid.
	      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
	      //
	      if (isEscaping) {
	        if (tokenChars[code] !== 1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (start === -1) start = i;
	        else if (!mustUnescape) mustUnescape = true;
	        isEscaping = false;
	      } else if (inQuotes) {
	        if (tokenChars[code] === 1) {
	          if (start === -1) start = i;
	        } else if (code === 0x22 /* '"' */ && start !== -1) {
	          inQuotes = false;
	          end = i;
	        } else if (code === 0x5c /* '\' */) {
	          isEscaping = true;
	        } else {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
	        inQuotes = true;
	      } else if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
	        if (end === -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        let value = header.slice(start, end);
	        if (mustUnescape) {
	          value = value.replace(/\\/g, '');
	          mustUnescape = false;
	        }
	        push(params, paramName, value);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        paramName = undefined;
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    }
	  }

	  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  if (end === -1) end = i;
	  const token = header.slice(start, end);
	  if (extensionName === undefined) {
	    push(offers, token, params);
	  } else {
	    if (paramName === undefined) {
	      push(params, token, true);
	    } else if (mustUnescape) {
	      push(params, paramName, token.replace(/\\/g, ''));
	    } else {
	      push(params, paramName, token);
	    }
	    push(offers, extensionName, params);
	  }

	  return offers;
	}

	/**
	 * Builds the `Sec-WebSocket-Extensions` header field value.
	 *
	 * @param {Object} extensions The map of extensions and parameters to format
	 * @return {String} A string representing the given object
	 * @public
	 */
	function format(extensions) {
	  return Object.keys(extensions)
	    .map((extension) => {
	      let configurations = extensions[extension];
	      if (!Array.isArray(configurations)) configurations = [configurations];
	      return configurations
	        .map((params) => {
	          return [extension]
	            .concat(
	              Object.keys(params).map((k) => {
	                let values = params[k];
	                if (!Array.isArray(values)) values = [values];
	                return values
	                  .map((v) => (v === true ? k : `${k}=${v}`))
	                  .join('; ');
	              })
	            )
	            .join('; ');
	        })
	        .join(', ');
	    })
	    .join(', ');
	}

	extension = { format, parse };
	return extension;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */

var websocket;
var hasRequiredWebsocket;

function requireWebsocket () {
	if (hasRequiredWebsocket) return websocket;
	hasRequiredWebsocket = 1;

	const EventEmitter = require$$0$3;
	const https$1 = https;
	const http$1 = http;
	const net = require$$3$1;
	const tls = require$$4;
	const { randomBytes, createHash } = require$$1;
	const { Duplex, Readable } = require$$0;
	const { URL } = require$$7;

	const PerMessageDeflate = requirePermessageDeflate();
	const Receiver = requireReceiver();
	const Sender = requireSender();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  GUID,
	  kForOnEventAttribute,
	  kListener,
	  kStatusCode,
	  kWebSocket,
	  NOOP
	} = requireConstants();
	const {
	  EventTarget: { addEventListener, removeEventListener }
	} = requireEventTarget();
	const { format, parse } = requireExtension();
	const { toBuffer } = requireBufferUtil();

	const closeTimeout = 30 * 1000;
	const kAborted = Symbol('kAborted');
	const protocolVersions = [8, 13];
	const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

	/**
	 * Class representing a WebSocket.
	 *
	 * @extends EventEmitter
	 */
	class WebSocket extends EventEmitter {
	  /**
	   * Create a new `WebSocket`.
	   *
	   * @param {(String|URL)} address The URL to which to connect
	   * @param {(String|String[])} [protocols] The subprotocols
	   * @param {Object} [options] Connection options
	   */
	  constructor(address, protocols, options) {
	    super();

	    this._binaryType = BINARY_TYPES[0];
	    this._closeCode = 1006;
	    this._closeFrameReceived = false;
	    this._closeFrameSent = false;
	    this._closeMessage = EMPTY_BUFFER;
	    this._closeTimer = null;
	    this._extensions = {};
	    this._paused = false;
	    this._protocol = '';
	    this._readyState = WebSocket.CONNECTING;
	    this._receiver = null;
	    this._sender = null;
	    this._socket = null;

	    if (address !== null) {
	      this._bufferedAmount = 0;
	      this._isServer = false;
	      this._redirects = 0;

	      if (protocols === undefined) {
	        protocols = [];
	      } else if (!Array.isArray(protocols)) {
	        if (typeof protocols === 'object' && protocols !== null) {
	          options = protocols;
	          protocols = [];
	        } else {
	          protocols = [protocols];
	        }
	      }

	      initAsClient(this, address, protocols, options);
	    } else {
	      this._autoPong = options.autoPong;
	      this._isServer = true;
	    }
	  }

	  /**
	   * This deviates from the WHATWG interface since ws doesn't support the
	   * required default "blob" type (instead we define a custom "nodebuffer"
	   * type).
	   *
	   * @type {String}
	   */
	  get binaryType() {
	    return this._binaryType;
	  }

	  set binaryType(type) {
	    if (!BINARY_TYPES.includes(type)) return;

	    this._binaryType = type;

	    //
	    // Allow to change `binaryType` on the fly.
	    //
	    if (this._receiver) this._receiver._binaryType = type;
	  }

	  /**
	   * @type {Number}
	   */
	  get bufferedAmount() {
	    if (!this._socket) return this._bufferedAmount;

	    return this._socket._writableState.length + this._sender._bufferedBytes;
	  }

	  /**
	   * @type {String}
	   */
	  get extensions() {
	    return Object.keys(this._extensions).join();
	  }

	  /**
	   * @type {Boolean}
	   */
	  get isPaused() {
	    return this._paused;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onclose() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onerror() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onopen() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onmessage() {
	    return null;
	  }

	  /**
	   * @type {String}
	   */
	  get protocol() {
	    return this._protocol;
	  }

	  /**
	   * @type {Number}
	   */
	  get readyState() {
	    return this._readyState;
	  }

	  /**
	   * @type {String}
	   */
	  get url() {
	    return this._url;
	  }

	  /**
	   * Set up the socket and the internal resources.
	   *
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Object} options Options object
	   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Number} [options.maxPayload=0] The maximum allowed message size
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @private
	   */
	  setSocket(socket, head, options) {
	    const receiver = new Receiver({
	      allowSynchronousEvents: options.allowSynchronousEvents,
	      binaryType: this.binaryType,
	      extensions: this._extensions,
	      isServer: this._isServer,
	      maxPayload: options.maxPayload,
	      skipUTF8Validation: options.skipUTF8Validation
	    });

	    this._sender = new Sender(socket, this._extensions, options.generateMask);
	    this._receiver = receiver;
	    this._socket = socket;

	    receiver[kWebSocket] = this;
	    socket[kWebSocket] = this;

	    receiver.on('conclude', receiverOnConclude);
	    receiver.on('drain', receiverOnDrain);
	    receiver.on('error', receiverOnError);
	    receiver.on('message', receiverOnMessage);
	    receiver.on('ping', receiverOnPing);
	    receiver.on('pong', receiverOnPong);

	    //
	    // These methods may not be available if `socket` is just a `Duplex`.
	    //
	    if (socket.setTimeout) socket.setTimeout(0);
	    if (socket.setNoDelay) socket.setNoDelay();

	    if (head.length > 0) socket.unshift(head);

	    socket.on('close', socketOnClose);
	    socket.on('data', socketOnData);
	    socket.on('end', socketOnEnd);
	    socket.on('error', socketOnError);

	    this._readyState = WebSocket.OPEN;
	    this.emit('open');
	  }

	  /**
	   * Emit the `'close'` event.
	   *
	   * @private
	   */
	  emitClose() {
	    if (!this._socket) {
	      this._readyState = WebSocket.CLOSED;
	      this.emit('close', this._closeCode, this._closeMessage);
	      return;
	    }

	    if (this._extensions[PerMessageDeflate.extensionName]) {
	      this._extensions[PerMessageDeflate.extensionName].cleanup();
	    }

	    this._receiver.removeAllListeners();
	    this._readyState = WebSocket.CLOSED;
	    this.emit('close', this._closeCode, this._closeMessage);
	  }

	  /**
	   * Start a closing handshake.
	   *
	   *          +----------+   +-----------+   +----------+
	   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
	   *    |     +----------+   +-----------+   +----------+     |
	   *          +----------+   +-----------+         |
	   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
	   *          +----------+   +-----------+   |
	   *    |           |                        |   +---+        |
	   *                +------------------------+-->|fin| - - - -
	   *    |         +---+                      |   +---+
	   *     - - - - -|fin|<---------------------+
	   *              +---+
	   *
	   * @param {Number} [code] Status code explaining why the connection is closing
	   * @param {(String|Buffer)} [data] The reason why the connection is
	   *     closing
	   * @public
	   */
	  close(code, data) {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this.readyState === WebSocket.CLOSING) {
	      if (
	        this._closeFrameSent &&
	        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
	      ) {
	        this._socket.end();
	      }

	      return;
	    }

	    this._readyState = WebSocket.CLOSING;
	    this._sender.close(code, data, !this._isServer, (err) => {
	      //
	      // This error is handled by the `'error'` listener on the socket. We only
	      // want to know if the close frame has been sent here.
	      //
	      if (err) return;

	      this._closeFrameSent = true;

	      if (
	        this._closeFrameReceived ||
	        this._receiver._writableState.errorEmitted
	      ) {
	        this._socket.end();
	      }
	    });

	    //
	    // Specify a timeout for the closing handshake to complete.
	    //
	    this._closeTimer = setTimeout(
	      this._socket.destroy.bind(this._socket),
	      closeTimeout
	    );
	  }

	  /**
	   * Pause the socket.
	   *
	   * @public
	   */
	  pause() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = true;
	    this._socket.pause();
	  }

	  /**
	   * Send a ping.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the ping is sent
	   * @public
	   */
	  ping(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Send a pong.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the pong is sent
	   * @public
	   */
	  pong(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Resume the socket.
	   *
	   * @public
	   */
	  resume() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = false;
	    if (!this._receiver._writableState.needDrain) this._socket.resume();
	  }

	  /**
	   * Send a data message.
	   *
	   * @param {*} data The message to send
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
	   *     text
	   * @param {Boolean} [options.compress] Specifies whether or not to compress
	   *     `data`
	   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when data is written out
	   * @public
	   */
	  send(data, options, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof options === 'function') {
	      cb = options;
	      options = {};
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    const opts = {
	      binary: typeof data !== 'string',
	      mask: !this._isServer,
	      compress: true,
	      fin: true,
	      ...options
	    };

	    if (!this._extensions[PerMessageDeflate.extensionName]) {
	      opts.compress = false;
	    }

	    this._sender.send(data || EMPTY_BUFFER, opts, cb);
	  }

	  /**
	   * Forcibly close the connection.
	   *
	   * @public
	   */
	  terminate() {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this._socket) {
	      this._readyState = WebSocket.CLOSING;
	      this._socket.destroy();
	    }
	  }
	}

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	[
	  'binaryType',
	  'bufferedAmount',
	  'extensions',
	  'isPaused',
	  'protocol',
	  'readyState',
	  'url'
	].forEach((property) => {
	  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});

	//
	// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
	// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
	//
	['open', 'error', 'close', 'message'].forEach((method) => {
	  Object.defineProperty(WebSocket.prototype, `on${method}`, {
	    enumerable: true,
	    get() {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) return listener[kListener];
	      }

	      return null;
	    },
	    set(handler) {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) {
	          this.removeListener(method, listener);
	          break;
	        }
	      }

	      if (typeof handler !== 'function') return;

	      this.addEventListener(method, handler, {
	        [kForOnEventAttribute]: true
	      });
	    }
	  });
	});

	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;

	websocket = WebSocket;

	/**
	 * Initialize a WebSocket client.
	 *
	 * @param {WebSocket} websocket The client to initialize
	 * @param {(String|URL)} address The URL to which to connect
	 * @param {Array} protocols The subprotocols
	 * @param {Object} [options] Connection options
	 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	 *     times in the same tick
	 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	 *     automatically send a pong in response to a ping
	 * @param {Function} [options.finishRequest] A function which can be used to
	 *     customize the headers of each http request before it is sent
	 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
	 *     redirects
	 * @param {Function} [options.generateMask] The function used to generate the
	 *     masking key
	 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	 *     handshake request
	 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	 *     size
	 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
	 *     allowed
	 * @param {String} [options.origin] Value of the `Origin` or
	 *     `Sec-WebSocket-Origin` header
	 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	 *     permessage-deflate
	 * @param {Number} [options.protocolVersion=13] Value of the
	 *     `Sec-WebSocket-Version` header
	 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	 *     not to skip UTF-8 validation for text and close messages
	 * @private
	 */
	function initAsClient(websocket, address, protocols, options) {
	  const opts = {
	    allowSynchronousEvents: true,
	    autoPong: true,
	    protocolVersion: protocolVersions[1],
	    maxPayload: 100 * 1024 * 1024,
	    skipUTF8Validation: false,
	    perMessageDeflate: true,
	    followRedirects: false,
	    maxRedirects: 10,
	    ...options,
	    socketPath: undefined,
	    hostname: undefined,
	    protocol: undefined,
	    timeout: undefined,
	    method: 'GET',
	    host: undefined,
	    path: undefined,
	    port: undefined
	  };

	  websocket._autoPong = opts.autoPong;

	  if (!protocolVersions.includes(opts.protocolVersion)) {
	    throw new RangeError(
	      `Unsupported protocol version: ${opts.protocolVersion} ` +
	        `(supported versions: ${protocolVersions.join(', ')})`
	    );
	  }

	  let parsedUrl;

	  if (address instanceof URL) {
	    parsedUrl = address;
	  } else {
	    try {
	      parsedUrl = new URL(address);
	    } catch (e) {
	      throw new SyntaxError(`Invalid URL: ${address}`);
	    }
	  }

	  if (parsedUrl.protocol === 'http:') {
	    parsedUrl.protocol = 'ws:';
	  } else if (parsedUrl.protocol === 'https:') {
	    parsedUrl.protocol = 'wss:';
	  }

	  websocket._url = parsedUrl.href;

	  const isSecure = parsedUrl.protocol === 'wss:';
	  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
	  let invalidUrlMessage;

	  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
	    invalidUrlMessage =
	      'The URL\'s protocol must be one of "ws:", "wss:", ' +
	      '"http:", "https", or "ws+unix:"';
	  } else if (isIpcUrl && !parsedUrl.pathname) {
	    invalidUrlMessage = "The URL's pathname is empty";
	  } else if (parsedUrl.hash) {
	    invalidUrlMessage = 'The URL contains a fragment identifier';
	  }

	  if (invalidUrlMessage) {
	    const err = new SyntaxError(invalidUrlMessage);

	    if (websocket._redirects === 0) {
	      throw err;
	    } else {
	      emitErrorAndClose(websocket, err);
	      return;
	    }
	  }

	  const defaultPort = isSecure ? 443 : 80;
	  const key = randomBytes(16).toString('base64');
	  const request = isSecure ? https$1.request : http$1.request;
	  const protocolSet = new Set();
	  let perMessageDeflate;

	  opts.createConnection =
	    opts.createConnection || (isSecure ? tlsConnect : netConnect);
	  opts.defaultPort = opts.defaultPort || defaultPort;
	  opts.port = parsedUrl.port || defaultPort;
	  opts.host = parsedUrl.hostname.startsWith('[')
	    ? parsedUrl.hostname.slice(1, -1)
	    : parsedUrl.hostname;
	  opts.headers = {
	    ...opts.headers,
	    'Sec-WebSocket-Version': opts.protocolVersion,
	    'Sec-WebSocket-Key': key,
	    Connection: 'Upgrade',
	    Upgrade: 'websocket'
	  };
	  opts.path = parsedUrl.pathname + parsedUrl.search;
	  opts.timeout = opts.handshakeTimeout;

	  if (opts.perMessageDeflate) {
	    perMessageDeflate = new PerMessageDeflate(
	      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
	      false,
	      opts.maxPayload
	    );
	    opts.headers['Sec-WebSocket-Extensions'] = format({
	      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
	    });
	  }
	  if (protocols.length) {
	    for (const protocol of protocols) {
	      if (
	        typeof protocol !== 'string' ||
	        !subprotocolRegex.test(protocol) ||
	        protocolSet.has(protocol)
	      ) {
	        throw new SyntaxError(
	          'An invalid or duplicated subprotocol was specified'
	        );
	      }

	      protocolSet.add(protocol);
	    }

	    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
	  }
	  if (opts.origin) {
	    if (opts.protocolVersion < 13) {
	      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
	    } else {
	      opts.headers.Origin = opts.origin;
	    }
	  }
	  if (parsedUrl.username || parsedUrl.password) {
	    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
	  }

	  if (isIpcUrl) {
	    const parts = opts.path.split(':');

	    opts.socketPath = parts[0];
	    opts.path = parts[1];
	  }

	  let req;

	  if (opts.followRedirects) {
	    if (websocket._redirects === 0) {
	      websocket._originalIpc = isIpcUrl;
	      websocket._originalSecure = isSecure;
	      websocket._originalHostOrSocketPath = isIpcUrl
	        ? opts.socketPath
	        : parsedUrl.host;

	      const headers = options && options.headers;

	      //
	      // Shallow copy the user provided options so that headers can be changed
	      // without mutating the original object.
	      //
	      options = { ...options, headers: {} };

	      if (headers) {
	        for (const [key, value] of Object.entries(headers)) {
	          options.headers[key.toLowerCase()] = value;
	        }
	      }
	    } else if (websocket.listenerCount('redirect') === 0) {
	      const isSameHost = isIpcUrl
	        ? websocket._originalIpc
	          ? opts.socketPath === websocket._originalHostOrSocketPath
	          : false
	        : websocket._originalIpc
	          ? false
	          : parsedUrl.host === websocket._originalHostOrSocketPath;

	      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
	        //
	        // Match curl 7.77.0 behavior and drop the following headers. These
	        // headers are also dropped when following a redirect to a subdomain.
	        //
	        delete opts.headers.authorization;
	        delete opts.headers.cookie;

	        if (!isSameHost) delete opts.headers.host;

	        opts.auth = undefined;
	      }
	    }

	    //
	    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
	    // If the `Authorization` header is set, then there is nothing to do as it
	    // will take precedence.
	    //
	    if (opts.auth && !options.headers.authorization) {
	      options.headers.authorization =
	        'Basic ' + Buffer.from(opts.auth).toString('base64');
	    }

	    req = websocket._req = request(opts);

	    if (websocket._redirects) {
	      //
	      // Unlike what is done for the `'upgrade'` event, no early exit is
	      // triggered here if the user calls `websocket.close()` or
	      // `websocket.terminate()` from a listener of the `'redirect'` event. This
	      // is because the user can also call `request.destroy()` with an error
	      // before calling `websocket.close()` or `websocket.terminate()` and this
	      // would result in an error being emitted on the `request` object with no
	      // `'error'` event listeners attached.
	      //
	      websocket.emit('redirect', websocket.url, req);
	    }
	  } else {
	    req = websocket._req = request(opts);
	  }

	  if (opts.timeout) {
	    req.on('timeout', () => {
	      abortHandshake(websocket, req, 'Opening handshake has timed out');
	    });
	  }

	  req.on('error', (err) => {
	    if (req === null || req[kAborted]) return;

	    req = websocket._req = null;
	    emitErrorAndClose(websocket, err);
	  });

	  req.on('response', (res) => {
	    const location = res.headers.location;
	    const statusCode = res.statusCode;

	    if (
	      location &&
	      opts.followRedirects &&
	      statusCode >= 300 &&
	      statusCode < 400
	    ) {
	      if (++websocket._redirects > opts.maxRedirects) {
	        abortHandshake(websocket, req, 'Maximum redirects exceeded');
	        return;
	      }

	      req.abort();

	      let addr;

	      try {
	        addr = new URL(location, address);
	      } catch (e) {
	        const err = new SyntaxError(`Invalid URL: ${location}`);
	        emitErrorAndClose(websocket, err);
	        return;
	      }

	      initAsClient(websocket, addr, protocols, options);
	    } else if (!websocket.emit('unexpected-response', req, res)) {
	      abortHandshake(
	        websocket,
	        req,
	        `Unexpected server response: ${res.statusCode}`
	      );
	    }
	  });

	  req.on('upgrade', (res, socket, head) => {
	    websocket.emit('upgrade', res);

	    //
	    // The user may have closed the connection from a listener of the
	    // `'upgrade'` event.
	    //
	    if (websocket.readyState !== WebSocket.CONNECTING) return;

	    req = websocket._req = null;

	    const upgrade = res.headers.upgrade;

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      abortHandshake(websocket, socket, 'Invalid Upgrade header');
	      return;
	    }

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    if (res.headers['sec-websocket-accept'] !== digest) {
	      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
	      return;
	    }

	    const serverProt = res.headers['sec-websocket-protocol'];
	    let protError;

	    if (serverProt !== undefined) {
	      if (!protocolSet.size) {
	        protError = 'Server sent a subprotocol but none was requested';
	      } else if (!protocolSet.has(serverProt)) {
	        protError = 'Server sent an invalid subprotocol';
	      }
	    } else if (protocolSet.size) {
	      protError = 'Server sent no subprotocol';
	    }

	    if (protError) {
	      abortHandshake(websocket, socket, protError);
	      return;
	    }

	    if (serverProt) websocket._protocol = serverProt;

	    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

	    if (secWebSocketExtensions !== undefined) {
	      if (!perMessageDeflate) {
	        const message =
	          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
	          'was requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      let extensions;

	      try {
	        extensions = parse(secWebSocketExtensions);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      const extensionNames = Object.keys(extensions);

	      if (
	        extensionNames.length !== 1 ||
	        extensionNames[0] !== PerMessageDeflate.extensionName
	      ) {
	        const message = 'Server indicated an extension that was not requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      try {
	        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      websocket._extensions[PerMessageDeflate.extensionName] =
	        perMessageDeflate;
	    }

	    websocket.setSocket(socket, head, {
	      allowSynchronousEvents: opts.allowSynchronousEvents,
	      generateMask: opts.generateMask,
	      maxPayload: opts.maxPayload,
	      skipUTF8Validation: opts.skipUTF8Validation
	    });
	  });

	  if (opts.finishRequest) {
	    opts.finishRequest(req, websocket);
	  } else {
	    req.end();
	  }
	}

	/**
	 * Emit the `'error'` and `'close'` events.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {Error} The error to emit
	 * @private
	 */
	function emitErrorAndClose(websocket, err) {
	  websocket._readyState = WebSocket.CLOSING;
	  websocket.emit('error', err);
	  websocket.emitClose();
	}

	/**
	 * Create a `net.Socket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {net.Socket} The newly created socket used to start the connection
	 * @private
	 */
	function netConnect(options) {
	  options.path = options.socketPath;
	  return net.connect(options);
	}

	/**
	 * Create a `tls.TLSSocket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {tls.TLSSocket} The newly created socket used to start the connection
	 * @private
	 */
	function tlsConnect(options) {
	  options.path = undefined;

	  if (!options.servername && options.servername !== '') {
	    options.servername = net.isIP(options.host) ? '' : options.host;
	  }

	  return tls.connect(options);
	}

	/**
	 * Abort the handshake and emit an error.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	 *     abort or the socket to destroy
	 * @param {String} message The error message
	 * @private
	 */
	function abortHandshake(websocket, stream, message) {
	  websocket._readyState = WebSocket.CLOSING;

	  const err = new Error(message);
	  Error.captureStackTrace(err, abortHandshake);

	  if (stream.setHeader) {
	    stream[kAborted] = true;
	    stream.abort();

	    if (stream.socket && !stream.socket.destroyed) {
	      //
	      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
	      // called after the request completed. See
	      // https://github.com/websockets/ws/issues/1869.
	      //
	      stream.socket.destroy();
	    }

	    process.nextTick(emitErrorAndClose, websocket, err);
	  } else {
	    stream.destroy(err);
	    stream.once('error', websocket.emit.bind(websocket, 'error'));
	    stream.once('close', websocket.emitClose.bind(websocket));
	  }
	}

	/**
	 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {*} [data] The data to send
	 * @param {Function} [cb] Callback
	 * @private
	 */
	function sendAfterClose(websocket, data, cb) {
	  if (data) {
	    const length = toBuffer(data).length;

	    //
	    // The `_bufferedAmount` property is used only when the peer is a client and
	    // the opening handshake fails. Under these circumstances, in fact, the
	    // `setSocket()` method is not called, so the `_socket` and `_sender`
	    // properties are set to `null`.
	    //
	    if (websocket._socket) websocket._sender._bufferedBytes += length;
	    else websocket._bufferedAmount += length;
	  }

	  if (cb) {
	    const err = new Error(
	      `WebSocket is not open: readyState ${websocket.readyState} ` +
	        `(${readyStates[websocket.readyState]})`
	    );
	    process.nextTick(cb, err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'conclude'` event.
	 *
	 * @param {Number} code The status code
	 * @param {Buffer} reason The reason for closing
	 * @private
	 */
	function receiverOnConclude(code, reason) {
	  const websocket = this[kWebSocket];

	  websocket._closeFrameReceived = true;
	  websocket._closeMessage = reason;
	  websocket._closeCode = code;

	  if (websocket._socket[kWebSocket] === undefined) return;

	  websocket._socket.removeListener('data', socketOnData);
	  process.nextTick(resume, websocket._socket);

	  if (code === 1005) websocket.close();
	  else websocket.close(code, reason);
	}

	/**
	 * The listener of the `Receiver` `'drain'` event.
	 *
	 * @private
	 */
	function receiverOnDrain() {
	  const websocket = this[kWebSocket];

	  if (!websocket.isPaused) websocket._socket.resume();
	}

	/**
	 * The listener of the `Receiver` `'error'` event.
	 *
	 * @param {(RangeError|Error)} err The emitted error
	 * @private
	 */
	function receiverOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket._socket[kWebSocket] !== undefined) {
	    websocket._socket.removeListener('data', socketOnData);

	    //
	    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
	    // https://github.com/websockets/ws/issues/1940.
	    //
	    process.nextTick(resume, websocket._socket);

	    websocket.close(err[kStatusCode]);
	  }

	  websocket.emit('error', err);
	}

	/**
	 * The listener of the `Receiver` `'finish'` event.
	 *
	 * @private
	 */
	function receiverOnFinish() {
	  this[kWebSocket].emitClose();
	}

	/**
	 * The listener of the `Receiver` `'message'` event.
	 *
	 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
	 * @param {Boolean} isBinary Specifies whether the message is binary or not
	 * @private
	 */
	function receiverOnMessage(data, isBinary) {
	  this[kWebSocket].emit('message', data, isBinary);
	}

	/**
	 * The listener of the `Receiver` `'ping'` event.
	 *
	 * @param {Buffer} data The data included in the ping frame
	 * @private
	 */
	function receiverOnPing(data) {
	  const websocket = this[kWebSocket];

	  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
	  websocket.emit('ping', data);
	}

	/**
	 * The listener of the `Receiver` `'pong'` event.
	 *
	 * @param {Buffer} data The data included in the pong frame
	 * @private
	 */
	function receiverOnPong(data) {
	  this[kWebSocket].emit('pong', data);
	}

	/**
	 * Resume a readable stream
	 *
	 * @param {Readable} stream The readable stream
	 * @private
	 */
	function resume(stream) {
	  stream.resume();
	}

	/**
	 * The listener of the socket `'close'` event.
	 *
	 * @private
	 */
	function socketOnClose() {
	  const websocket = this[kWebSocket];

	  this.removeListener('close', socketOnClose);
	  this.removeListener('data', socketOnData);
	  this.removeListener('end', socketOnEnd);

	  websocket._readyState = WebSocket.CLOSING;

	  let chunk;

	  //
	  // The close frame might not have been received or the `'end'` event emitted,
	  // for example, if the socket was destroyed due to an error. Ensure that the
	  // `receiver` stream is closed after writing any remaining buffered data to
	  // it. If the readable side of the socket is in flowing mode then there is no
	  // buffered data as everything has been already written and `readable.read()`
	  // will return `null`. If instead, the socket is paused, any possible buffered
	  // data will be read as a single chunk.
	  //
	  if (
	    !this._readableState.endEmitted &&
	    !websocket._closeFrameReceived &&
	    !websocket._receiver._writableState.errorEmitted &&
	    (chunk = websocket._socket.read()) !== null
	  ) {
	    websocket._receiver.write(chunk);
	  }

	  websocket._receiver.end();

	  this[kWebSocket] = undefined;

	  clearTimeout(websocket._closeTimer);

	  if (
	    websocket._receiver._writableState.finished ||
	    websocket._receiver._writableState.errorEmitted
	  ) {
	    websocket.emitClose();
	  } else {
	    websocket._receiver.on('error', receiverOnFinish);
	    websocket._receiver.on('finish', receiverOnFinish);
	  }
	}

	/**
	 * The listener of the socket `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function socketOnData(chunk) {
	  if (!this[kWebSocket]._receiver.write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * The listener of the socket `'end'` event.
	 *
	 * @private
	 */
	function socketOnEnd() {
	  const websocket = this[kWebSocket];

	  websocket._readyState = WebSocket.CLOSING;
	  websocket._receiver.end();
	  this.end();
	}

	/**
	 * The listener of the socket `'error'` event.
	 *
	 * @private
	 */
	function socketOnError() {
	  const websocket = this[kWebSocket];

	  this.removeListener('error', socketOnError);
	  this.on('error', NOOP);

	  if (websocket) {
	    websocket._readyState = WebSocket.CLOSING;
	    this.destroy();
	  }
	}
	return websocket;
}

requireWebsocket();

var subprotocol;
var hasRequiredSubprotocol;

function requireSubprotocol () {
	if (hasRequiredSubprotocol) return subprotocol;
	hasRequiredSubprotocol = 1;

	const { tokenChars } = requireValidation$1();

	/**
	 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	 *
	 * @param {String} header The field value of the header
	 * @return {Set} The subprotocol names
	 * @public
	 */
	function parse(header) {
	  const protocols = new Set();
	  let start = -1;
	  let end = -1;
	  let i = 0;

	  for (i; i < header.length; i++) {
	    const code = header.charCodeAt(i);

	    if (end === -1 && tokenChars[code] === 1) {
	      if (start === -1) start = i;
	    } else if (
	      i !== 0 &&
	      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	    ) {
	      if (end === -1 && start !== -1) end = i;
	    } else if (code === 0x2c /* ',' */) {
	      if (start === -1) {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }

	      if (end === -1) end = i;

	      const protocol = header.slice(start, end);

	      if (protocols.has(protocol)) {
	        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	      }

	      protocols.add(protocol);
	      start = end = -1;
	    } else {
	      throw new SyntaxError(`Unexpected character at index ${i}`);
	    }
	  }

	  if (start === -1 || end !== -1) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  const protocol = header.slice(start, i);

	  if (protocols.has(protocol)) {
	    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	  }

	  protocols.add(protocol);
	  return protocols;
	}

	subprotocol = { parse };
	return subprotocol;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */

var websocketServer;
var hasRequiredWebsocketServer;

function requireWebsocketServer () {
	if (hasRequiredWebsocketServer) return websocketServer;
	hasRequiredWebsocketServer = 1;

	const EventEmitter = require$$0$3;
	const http$1 = http;
	const { Duplex } = require$$0;
	const { createHash } = require$$1;

	const extension = requireExtension();
	const PerMessageDeflate = requirePermessageDeflate();
	const subprotocol = requireSubprotocol();
	const WebSocket = requireWebsocket();
	const { GUID, kWebSocket } = requireConstants();

	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;

	/**
	 * Class representing a WebSocket server.
	 *
	 * @extends EventEmitter
	 */
	class WebSocketServer extends EventEmitter {
	  /**
	   * Create a `WebSocketServer` instance.
	   *
	   * @param {Object} options Configuration options
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	   *     automatically send a pong in response to a ping
	   * @param {Number} [options.backlog=511] The maximum length of the queue of
	   *     pending connections
	   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
	   *     track clients
	   * @param {Function} [options.handleProtocols] A hook to handle protocols
	   * @param {String} [options.host] The hostname where to bind the server
	   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	   *     size
	   * @param {Boolean} [options.noServer=false] Enable no server mode
	   * @param {String} [options.path] Accept only connections matching this path
	   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
	   *     permessage-deflate
	   * @param {Number} [options.port] The port where to bind the server
	   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
	   *     server to use
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @param {Function} [options.verifyClient] A hook to reject connections
	   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
	   *     class to use. It must be the `WebSocket` class or class that extends it
	   * @param {Function} [callback] A listener for the `listening` event
	   */
	  constructor(options, callback) {
	    super();

	    options = {
	      allowSynchronousEvents: true,
	      autoPong: true,
	      maxPayload: 100 * 1024 * 1024,
	      skipUTF8Validation: false,
	      perMessageDeflate: false,
	      handleProtocols: null,
	      clientTracking: true,
	      verifyClient: null,
	      noServer: false,
	      backlog: null, // use default (511 as implemented in net.js)
	      server: null,
	      host: null,
	      path: null,
	      port: null,
	      WebSocket,
	      ...options
	    };

	    if (
	      (options.port == null && !options.server && !options.noServer) ||
	      (options.port != null && (options.server || options.noServer)) ||
	      (options.server && options.noServer)
	    ) {
	      throw new TypeError(
	        'One and only one of the "port", "server", or "noServer" options ' +
	          'must be specified'
	      );
	    }

	    if (options.port != null) {
	      this._server = http$1.createServer((req, res) => {
	        const body = http$1.STATUS_CODES[426];

	        res.writeHead(426, {
	          'Content-Length': body.length,
	          'Content-Type': 'text/plain'
	        });
	        res.end(body);
	      });
	      this._server.listen(
	        options.port,
	        options.host,
	        options.backlog,
	        callback
	      );
	    } else if (options.server) {
	      this._server = options.server;
	    }

	    if (this._server) {
	      const emitConnection = this.emit.bind(this, 'connection');

	      this._removeListeners = addListeners(this._server, {
	        listening: this.emit.bind(this, 'listening'),
	        error: this.emit.bind(this, 'error'),
	        upgrade: (req, socket, head) => {
	          this.handleUpgrade(req, socket, head, emitConnection);
	        }
	      });
	    }

	    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
	    if (options.clientTracking) {
	      this.clients = new Set();
	      this._shouldEmitClose = false;
	    }

	    this.options = options;
	    this._state = RUNNING;
	  }

	  /**
	   * Returns the bound address, the address family name, and port of the server
	   * as reported by the operating system if listening on an IP socket.
	   * If the server is listening on a pipe or UNIX domain socket, the name is
	   * returned as a string.
	   *
	   * @return {(Object|String|null)} The address of the server
	   * @public
	   */
	  address() {
	    if (this.options.noServer) {
	      throw new Error('The server is operating in "noServer" mode');
	    }

	    if (!this._server) return null;
	    return this._server.address();
	  }

	  /**
	   * Stop the server from accepting new connections and emit the `'close'` event
	   * when all existing connections are closed.
	   *
	   * @param {Function} [cb] A one-time listener for the `'close'` event
	   * @public
	   */
	  close(cb) {
	    if (this._state === CLOSED) {
	      if (cb) {
	        this.once('close', () => {
	          cb(new Error('The server is not running'));
	        });
	      }

	      process.nextTick(emitClose, this);
	      return;
	    }

	    if (cb) this.once('close', cb);

	    if (this._state === CLOSING) return;
	    this._state = CLOSING;

	    if (this.options.noServer || this.options.server) {
	      if (this._server) {
	        this._removeListeners();
	        this._removeListeners = this._server = null;
	      }

	      if (this.clients) {
	        if (!this.clients.size) {
	          process.nextTick(emitClose, this);
	        } else {
	          this._shouldEmitClose = true;
	        }
	      } else {
	        process.nextTick(emitClose, this);
	      }
	    } else {
	      const server = this._server;

	      this._removeListeners();
	      this._removeListeners = this._server = null;

	      //
	      // The HTTP/S server was created internally. Close it, and rely on its
	      // `'close'` event.
	      //
	      server.close(() => {
	        emitClose(this);
	      });
	    }
	  }

	  /**
	   * See if a given request should be handled by this server instance.
	   *
	   * @param {http.IncomingMessage} req Request object to inspect
	   * @return {Boolean} `true` if the request is valid, else `false`
	   * @public
	   */
	  shouldHandle(req) {
	    if (this.options.path) {
	      const index = req.url.indexOf('?');
	      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

	      if (pathname !== this.options.path) return false;
	    }

	    return true;
	  }

	  /**
	   * Handle a HTTP Upgrade request.
	   *
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @public
	   */
	  handleUpgrade(req, socket, head, cb) {
	    socket.on('error', socketOnError);

	    const key = req.headers['sec-websocket-key'];
	    const upgrade = req.headers.upgrade;
	    const version = +req.headers['sec-websocket-version'];

	    if (req.method !== 'GET') {
	      const message = 'Invalid HTTP method';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
	      return;
	    }

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      const message = 'Invalid Upgrade header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (key === undefined || !keyRegex.test(key)) {
	      const message = 'Missing or invalid Sec-WebSocket-Key header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (version !== 8 && version !== 13) {
	      const message = 'Missing or invalid Sec-WebSocket-Version header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (!this.shouldHandle(req)) {
	      abortHandshake(socket, 400);
	      return;
	    }

	    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
	    let protocols = new Set();

	    if (secWebSocketProtocol !== undefined) {
	      try {
	        protocols = subprotocol.parse(secWebSocketProtocol);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Protocol header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
	    const extensions = {};

	    if (
	      this.options.perMessageDeflate &&
	      secWebSocketExtensions !== undefined
	    ) {
	      const perMessageDeflate = new PerMessageDeflate(
	        this.options.perMessageDeflate,
	        true,
	        this.options.maxPayload
	      );

	      try {
	        const offers = extension.parse(secWebSocketExtensions);

	        if (offers[PerMessageDeflate.extensionName]) {
	          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
	          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
	        }
	      } catch (err) {
	        const message =
	          'Invalid or unacceptable Sec-WebSocket-Extensions header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    //
	    // Optionally call external client verification handler.
	    //
	    if (this.options.verifyClient) {
	      const info = {
	        origin:
	          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
	        secure: !!(req.socket.authorized || req.socket.encrypted),
	        req
	      };

	      if (this.options.verifyClient.length === 2) {
	        this.options.verifyClient(info, (verified, code, message, headers) => {
	          if (!verified) {
	            return abortHandshake(socket, code || 401, message, headers);
	          }

	          this.completeUpgrade(
	            extensions,
	            key,
	            protocols,
	            req,
	            socket,
	            head,
	            cb
	          );
	        });
	        return;
	      }

	      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
	    }

	    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
	  }

	  /**
	   * Upgrade the connection to WebSocket.
	   *
	   * @param {Object} extensions The accepted extensions
	   * @param {String} key The value of the `Sec-WebSocket-Key` header
	   * @param {Set} protocols The subprotocols
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @throws {Error} If called more than once with the same socket
	   * @private
	   */
	  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
	    //
	    // Destroy the socket if the client has already sent a FIN packet.
	    //
	    if (!socket.readable || !socket.writable) return socket.destroy();

	    if (socket[kWebSocket]) {
	      throw new Error(
	        'server.handleUpgrade() was called more than once with the same ' +
	          'socket, possibly due to a misconfiguration'
	      );
	    }

	    if (this._state > RUNNING) return abortHandshake(socket, 503);

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    const headers = [
	      'HTTP/1.1 101 Switching Protocols',
	      'Upgrade: websocket',
	      'Connection: Upgrade',
	      `Sec-WebSocket-Accept: ${digest}`
	    ];

	    const ws = new this.options.WebSocket(null, undefined, this.options);

	    if (protocols.size) {
	      //
	      // Optionally call external protocol selection handler.
	      //
	      const protocol = this.options.handleProtocols
	        ? this.options.handleProtocols(protocols, req)
	        : protocols.values().next().value;

	      if (protocol) {
	        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
	        ws._protocol = protocol;
	      }
	    }

	    if (extensions[PerMessageDeflate.extensionName]) {
	      const params = extensions[PerMessageDeflate.extensionName].params;
	      const value = extension.format({
	        [PerMessageDeflate.extensionName]: [params]
	      });
	      headers.push(`Sec-WebSocket-Extensions: ${value}`);
	      ws._extensions = extensions;
	    }

	    //
	    // Allow external modification/inspection of handshake headers.
	    //
	    this.emit('headers', headers, req);

	    socket.write(headers.concat('\r\n').join('\r\n'));
	    socket.removeListener('error', socketOnError);

	    ws.setSocket(socket, head, {
	      allowSynchronousEvents: this.options.allowSynchronousEvents,
	      maxPayload: this.options.maxPayload,
	      skipUTF8Validation: this.options.skipUTF8Validation
	    });

	    if (this.clients) {
	      this.clients.add(ws);
	      ws.on('close', () => {
	        this.clients.delete(ws);

	        if (this._shouldEmitClose && !this.clients.size) {
	          process.nextTick(emitClose, this);
	        }
	      });
	    }

	    cb(ws, req);
	  }
	}

	websocketServer = WebSocketServer;

	/**
	 * Add event listeners on an `EventEmitter` using a map of <event, listener>
	 * pairs.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @param {Object.<String, Function>} map The listeners to add
	 * @return {Function} A function that will remove the added listeners when
	 *     called
	 * @private
	 */
	function addListeners(server, map) {
	  for (const event of Object.keys(map)) server.on(event, map[event]);

	  return function removeListeners() {
	    for (const event of Object.keys(map)) {
	      server.removeListener(event, map[event]);
	    }
	  };
	}

	/**
	 * Emit a `'close'` event on an `EventEmitter`.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @private
	 */
	function emitClose(server) {
	  server._state = CLOSED;
	  server.emit('close');
	}

	/**
	 * Handle socket errors.
	 *
	 * @private
	 */
	function socketOnError() {
	  this.destroy();
	}

	/**
	 * Close the connection when preconditions are not fulfilled.
	 *
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} [message] The HTTP response body
	 * @param {Object} [headers] Additional HTTP response headers
	 * @private
	 */
	function abortHandshake(socket, code, message, headers) {
	  //
	  // The socket is writable unless the user destroyed or ended it before calling
	  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
	  // error. Handling this does not make much sense as the worst that can happen
	  // is that some of the data written by the user might be discarded due to the
	  // call to `socket.end()` below, which triggers an `'error'` event that in
	  // turn causes the socket to be destroyed.
	  //
	  message = message || http$1.STATUS_CODES[code];
	  headers = {
	    Connection: 'close',
	    'Content-Type': 'text/html',
	    'Content-Length': Buffer.byteLength(message),
	    ...headers
	  };

	  socket.once('finish', socket.destroy);

	  socket.end(
	    `HTTP/1.1 ${code} ${http$1.STATUS_CODES[code]}\r\n` +
	      Object.keys(headers)
	        .map((h) => `${h}: ${headers[h]}`)
	        .join('\r\n') +
	      '\r\n\r\n' +
	      message
	  );
	}

	/**
	 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	 * one listener for it, otherwise call `abortHandshake()`.
	 *
	 * @param {WebSocketServer} server The WebSocket server
	 * @param {http.IncomingMessage} req The request object
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} message The HTTP response body
	 * @private
	 */
	function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
	  if (server.listenerCount('wsClientError')) {
	    const err = new Error(message);
	    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

	    server.emit('wsClientError', err, socket, req);
	  } else {
	    abortHandshake(socket, code, message);
	  }
	}
	return websocketServer;
}

requireWebsocketServer();

/**
 *  A **FallbackProvider** provides resilience, security and performance
 *  in a way that is customizable and configurable.
 *
 *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]
 */
BigInt("1");
BigInt("2");

const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
const Word = /^[a-z]*$/i;
function unfold(words, sep) {
    let initial = 97;
    return words.reduce((accum, word) => {
        if (word === sep) {
            initial++;
        }
        else if (word.match(Word)) {
            accum.push(String.fromCharCode(initial) + word);
        }
        else {
            initial = 97;
            accum.push(word);
        }
        return accum;
    }, []);
}
/**
 *  @_ignore
 */
function decode(data, subs) {
    // Replace all the substitutions with their expanded form
    for (let i = subsChrs.length - 1; i >= 0; i--) {
        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
    }
    // Get all tle clumps; each suffix, first-increment and second-increment
    const clumps = [];
    const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
        if (semi) {
            for (let i = parseInt(semi); i >= 0; i--) {
                clumps.push(";");
            }
        }
        else {
            clumps.push(item.toLowerCase());
        }
        return "";
    });
    /* c8 ignore start */
    if (leftover) {
        throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
    }
    /* c8 ignore stop */
    return unfold(unfold(clumps, ";"), ":");
}
/**
 *  @_ignore
 */
function decodeOwl(data) {
    assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}

/**
 *  A Wordlist represents a collection of language-specific
 *  words used to encode and devoce [[link-bip-39]] encoded data
 *  by mapping words to 11-bit values and vice versa.
 */
class Wordlist {
    locale;
    /**
     *  Creates a new Wordlist instance.
     *
     *  Sub-classes MUST call this if they provide their own constructor,
     *  passing in the locale string of the language.
     *
     *  Generally there is no need to create instances of a Wordlist,
     *  since each language-specific Wordlist creates an instance and
     *  there is no state kept internally, so they are safe to share.
     */
    constructor(locale) {
        defineProperties(this, { locale });
    }
    /**
     *  Sub-classes may override this to provide a language-specific
     *  method for spliting %%phrase%% into individual words.
     *
     *  By default, %%phrase%% is split using any sequences of
     *  white-space as defined by regular expressions (i.e. ``/\s+/``).
     */
    split(phrase) {
        return phrase.toLowerCase().split(/\s+/g);
    }
    /**
     *  Sub-classes may override this to provider a language-specific
     *  method for joining %%words%% into a phrase.
     *
     *  By default, %%words%% are joined by a single space.
     */
    join(words) {
        return words.join(" ");
    }
}

// Use the encode-latin.js script to create the necessary
// data files to be consumed by this class
/**
 *  An OWL format Wordlist is an encoding method that exploits
 *  the general locality of alphabetically sorted words to
 *  achieve a simple but effective means of compression.
 *
 *  This class is generally not useful to most developers as
 *  it is used mainly internally to keep Wordlists for languages
 *  based on ASCII-7 small.
 *
 *  If necessary, there are tools within the ``generation/`` folder
 *  to create the necessary data.
 */
class WordlistOwl extends Wordlist {
    #data;
    #checksum;
    /**
     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
     *  and validated against the %%checksum%%.
     */
    constructor(locale, data, checksum) {
        super(locale);
        this.#data = data;
        this.#checksum = checksum;
        this.#words = null;
    }
    /**
     *  The OWL-encoded data.
     */
    get _data() { return this.#data; }
    /**
     *  Decode all the words for the wordlist.
     */
    _decodeWords() {
        return decodeOwl(this.#data);
    }
    #words;
    #loadWords() {
        if (this.#words == null) {
            const words = this._decodeWords();
            // Verify the computed list matches the official list
            const checksum = id$1(words.join("\n") + "\n");
            /* c8 ignore start */
            if (checksum !== this.#checksum) {
                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
            }
            /* c8 ignore stop */
            this.#words = words;
        }
        return this.#words;
    }
    getWord(index) {
        const words = this.#loadWords();
        assertArgument(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
        return words[index];
    }
    getWordIndex(word) {
        return this.#loadWords().indexOf(word);
    }
}

const words$5 = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
const checksum$5 = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
let wordlist$7 = null;
/**
 *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangEn extends WordlistOwl {
    /**
     *  Creates a new instance of the English language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langEn]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("en", words$5, checksum$5); }
    /**
     *  Returns a singleton instance of a ``LangEn``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist$7 == null) {
            wordlist$7 = new LangEn();
        }
        return wordlist$7;
    }
}

/**
 *  Explain HD Wallets..
 *
 *  @_subsection: api/wallet:HD Wallets  [hd-wallets]
 */
BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");

const Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
/**
 *  @_ignore
 */
function decodeBits(width, data) {
    const maxValue = (1 << width) - 1;
    const result = [];
    let accum = 0, bits = 0, flood = 0;
    for (let i = 0; i < data.length; i++) {
        // Accumulate 6 bits of data
        accum = ((accum << 6) | Base64.indexOf(data[i]));
        bits += 6;
        // While we have enough for a word...
        while (bits >= width) {
            // ...read the word
            const value = (accum >> (bits - width));
            accum &= (1 << (bits - width)) - 1;
            bits -= width;
            // A value of 0 indicates we exceeded maxValue, it
            // floods over into the next value
            if (value === 0) {
                flood += maxValue;
            }
            else {
                result.push(value + flood);
                flood = 0;
            }
        }
    }
    return result;
}

/**
 *  @_ignore
 */
function decodeOwlA(data, accents) {
    let words = decodeOwl(data).join(",");
    // Inject the accents
    accents.split(/,/g).forEach((accent) => {
        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
        assertArgument(match !== null, "internal error parsing accents", "accents", accents);
        let posOffset = 0;
        const positions = decodeBits(parseInt(match[3]), match[4]);
        const charCode = parseInt(match[2]);
        const regex = new RegExp(`([${match[1]}])`, "g");
        words = words.replace(regex, (all, letter) => {
            const rem = --positions[posOffset];
            if (rem === 0) {
                letter = String.fromCharCode(letter.charCodeAt(0), charCode);
                posOffset++;
            }
            return letter;
        });
    });
    return words.split(",");
}

/**
 *  An OWL-A format Wordlist extends the OWL format to add an
 *  overlay onto an OWL format Wordlist to support diacritic
 *  marks.
 *
 *  This class is generally not useful to most developers as
 *  it is used mainly internally to keep Wordlists for languages
 *  based on latin-1 small.
 *
 *  If necessary, there are tools within the ``generation/`` folder
 *  to create the necessary data.
 */
class WordlistOwlA extends WordlistOwl {
    #accent;
    /**
     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
     *  and %%accent%% data and validated against the %%checksum%%.
     */
    constructor(locale, data, accent, checksum) {
        super(locale, data, checksum);
        this.#accent = accent;
    }
    /**
     *  The OWLA-encoded accent data.
     */
    get _accent() { return this.#accent; }
    /**
     *  Decode all the words for the wordlist.
     */
    _decodeWords() {
        return decodeOwlA(this._data, this._accent);
    }
}

const words$4 = "0itatkastcenaovo$taouleraeki&chor*teci%enbalodaeladet'!Chn=0Di#%E%^1Resa2Rese3CeT'#0EjKohol0Pu)%0A&sDul#Ekdo)Ke)Ti#Ul|3}aOgan%0FaltI$@tPi,%TmaTronom0LasL{i#Ol0Tobus4Yl:B#}<CilCul#D!_Ge)GrHnoKterieLa^L{#LkonLon-LvanLzaMbusNkom!R[rR{RmanRokoRvaTer#TohVl&Zal#Zili#Zu#3D&RanSe^StieTonZin#ZmocZ)k3CyklD]Ft-KinyLan%Og,fO]gTvaZon2AhobytAt*/E/aEdu+EskIk!Iz&Ok|Oud Ud2B-BrDl.D~H!(JkotJ|K<ysLe$R>R'?TaUb_U/!U^U+Ur!Xer2A^v#Ambo,An#AtrEp)Ike)KoLohOnzOskevUn{#Usin#Z^Zy2Bl.Bn|})D _D#D'aF{Jar(Kv?LdokLvaN^NkrRzaTikVolZola3D+tL.T'#0Ukot:PartRev&3DrDu+J/JnLaLerLkemLn?N.Nn(N'#NtrumNz<StopisT#2AlupaAp`]Ar aA)E/t!EmieI/otIrurgL`Le[Lub M_Mu,ObotO/olOd[O+,Om=Op Oro[OvRapotRl RtRupTiv(Ud.Utn!V!Vil#V(Y[Y$!Yt 0Bu+Gare)H_&HlaNkotRkusSter&Ta%TrusZin>Z(2O&2KolivUv!4It_N(0Dn(Ke)KrPot0Ak~AlIkRkot2Kli$a:L-oRe[T_Tum1E,1B!a}'#Cib_Fic Fla%KlKr{Mokr!PreseRbyS#T-tiv3Kob,zKt|O^P]mSkSp+jV`]Vo/2AhaOuhoUhopis1Es0BroByt-C@t}ut DnesH+dHo^H,JemJn?Kl`KolaKt<Kum@tLarLevaL.MaM.ntMluv M'Nut P`PisPln PosudPr'odPu$ Raz R(RtSahSl'St!-SudSy)TazT-Tk~Uf!Utn!Voz%Z`uZn!Z<%2Aho)AkAm!ikAv>AzeDolObn(OgerieOzdSn(T Z(2B@}'noD-HaH'#S SnoT(0Oj?Or>2Nam :9O]gOnomie0EktronIpsa0AilIseO%P!ie2Izo^O/aOpejOs2EjEn%K<)Kymo0Ike)0F<ie0Olu%1Eku%KurzePed?P]zeP<tT,kt:C#Jf#Kul)N!ikN)zieRmacieV< Zo+3De,%J{onN#3Al#Gu,ntLozofLtrNan%N)Xa%0Ord1An_IrtOtila2NdSf<T[lT#Ton2Ak%Es#On)2KarNk%3Zi#:LejeRant3N{i#O]g3Lot.2Azu,Ejt2LemLfi$aTi#2AfAmofonAnu+EpIlOgOtes#2Ma:D?DrLaL@#N[NopisRfaRpu&V,n3Bk(J#lJnoJtmanK)rLmaM!omR>R&S]Zky3St<ik2Ad'#AsivkyAvaEd!EnO^v>OhOup(T!Ub.U/o)0AtO)Yz0IsOjivoOut0Bl.Boj}DinyDl!Dno)D|Jn(KejLin#L#LubMo+N [No,%RalR^RizontRkoRliv>RmonRn.RoskopR$voSpo^St.T'(U[UfUp!Us#V<2Ad[An?Av(Az^Bo+kD.D]D(N-Ob#Oma^OtOu^Oz@St#Ub(Yz!2B@(B~D[KotMrS aSto)0Ozd2Bn(D,ntGie&M&Sterik:2Yl#3Ned2O&0Uze0Un a0F-%Fla%KasoOva%Sp-%Tern{Vali^Ve$<Zer%3Onie:Blko})Ho^Kmi+K(L'>N)rRmarkRoSanSnoT#V<Zyk3Din>D+Dn!_HlanKotL@L oMn(NomP?S{erV Zd>Zero3NakNdyNo/Sk,Sto)Trn?Zva3En|1Gurt5R):Bar{B_Bin{}&D{Did]HanJakJu)KaoKtusLam aLhotyLibrLn(Me,MkolivM&Ni[lNoeNt<Pal.P_aP olaP#P+Po)PrPu$aPy[,Ram_Rot#RtonSaTa]gTed,U%UzaVa+cZaj#Ze)Ziv(2EkolivEsi0Dlub@MpRami#3No2A%kAdivoAmApotAsi#AunEcEn[Ep!Es~IdImaIs&Ob*kO#nOpaOubUb'&Us!Uzk(0EnIt!Otr0IhaOt0Al?Ber>B#BlihaBylaC*rH=J@>KosKtejlLapsLe^LizeLoMandoMe)MikMn!aMo,MpasMun aN!N%ptNd?N>NfeseNgresN.NkursN)ktNzervaPan>PieP~Pr'#Rb_R-t<Rmid]RoptevRpusRu&RytoRz{S!>St#T_T+)T*lUk!Up_&Us-Uz]VbojZaZ<oh2Ab?A/Aj.Al|AsopisAv!aEd EjcarEs[Eve)Ik{ItikIzeKav>Me+cMivoOcanOkOni#Op OupaOv#T-Uh`]Up?Ut(Vin#Y/+Yp)Y$alYt2Dlan#FrJn(KlaLaj^Li/L#Lom{Ltu,NaPodivuRtRz<Til0Al aAsin#E$<2No]gS_.Ta,T?T#T'>V`]:B,d<})nDn(IkKom>M_aMpaN'#S?SoStu,Tin#V.3B#CkdyD@Dn?D'#Dv.G@^GieG,%H%Hk(H~KtvarNo/odNtil#P@#Pid]T`]T>TmoTokruhVhartV a%Vobok3B,}ot#DojedDsk(H'.Jav>L-M{#NieN#No+umStop`T.T|5Bi$aDivodGi#GopedKal aK{Mc|P!aPu/RdSosTrU^lUhU#Usk!V>3Tiv(1Cer&CiferMpSkSt,%0I%2RaRi#S.:DamD]Gi$rHagonJ{-J _J< aKakK'?Kr_aL[L.L|Lv?Min#Nd+NkoRn(SakrSkotSopu$T?Tri#Tur aZan>ZivoZl Zur#2Lo[0}anikD a%D'.LasaL*nNtol#TlaTo^TrZe,3G,%H~Hu+K.KrofonL@>Lim{rL(Mi#Nc'&Ni[rNom{Nul(S#StrX|2Ad(HaH'.OkS!Uv 1I/Ohem0BilCn(D_#Dl [HylaKroL-ulaM@t#Nar/aNoklN$rumNt|NzunSazSkytStTiva%T<#Ty#U/aUdr(Zai#Z-Zol2Am<Av@>KevTvolaZ{Zut(0T _1DrcF]nL!MieN?S{Ta%ZeumZi#nt3Sliv>0Da:B*r!}yt!Da%Dbyt-DhozDobroDpisHlasHn!Hodi+H,d Iv aJedn*Ji$oJm=K]n Kon>Krm LevoMaz!Mluv Nom{rOkoOpakO$roP`!PevnoPln P~Pos+dPr(oRod RubyRy/]S` S-!S+poSt!TolikV@-Vr/Vzd<yZv!3Be}!CkyDa+koDb!DuhGa%H{Ho^J@JprveKlidLib(Mil(MocO/o)On#PokojR(RvSmyslS*l`Tv<UronV.Zvyk+3Co)JakKamKdyKlKte,kTro5C+hHav?M.%RaR-S _Sn(UzeVinyVo)Zd,5DaD+G{T Tn(Trie3Mfa:0AlArv AvaDivEcEhn!Ejm=Ez aHajo[Iln?Jasn J-tK]p La$L-Li[LohaLu^NosOh! Oj-OutRaz>R&Ru[RysSahSluhaS)r!UvVazVin VodVyk+Yv!_Z<0AsElEn Hl` Ho)H,&It~0BojByt}odCiz Ebr!Esl!Evzd!EzvaH`%Hod J{JinudKazK*p LivLu#Ml#Oln(P`PisPl=P<Pu$ Pyk!Raz#S*d StupSunTokTudVahaVe)Vol!V,%tZ&k1I&Sajd1LasNiskoRa^Roz Ryz-2ApEn?Li#NoOuzl OvyRasaResRs-RuhUpantUr#Us 0Ejn.Iz|0AkE+)Ez L`.L*v!LuvaYl0Ehdy1Ak|As-E,%I%Il(Is|O,Oz?RavduRoti1B al}e$rGieL?LojT_0A^}~I#IvoLavaLep Ln L' N'aO[Ol Pa+cT@T,haTu^Ty/Voj 0Epl IskOpRh!Rl(RokRubyV<1A~ArEsLivn O%1Id1Do[:}!_Ci@tD*/H<-KtLan^L>LivoLu[Mf+tMls-N@#Ni#N&N|N$voNtof+Pri#Rke)RodieR)Ru#Ry[Se#Siv aSt_#T@tTro&V*kZnehtZ*r-3C#DagogJs-K]LotonNal)Ndr-NzeRiskopRoStr(Tar^T?Tro+jVn.Xeso3Ani$aHaJav?K+KnikL.Ln(Lul#Nze)Pe)S!_Sto+Tev&Vn?V'ar2A%n)Ak!Am@Ane)A$i#At Avid]AzE/Em@oEn)EsEtivoEv_Iv!N NoO/aOd.Om[OutUkYn2Bav Byt}odC Ctiv>D!D%n Deps!Dh+dDiv Dkl`Dman DnikDo[Dpo,D,zD$!aDvodDzimEzieHan#Hnut#H'<HromaHybIn)Ji$#Jm=Kaz K+sKojKrokKu)KynLedneLib-Lk~LohaLynomMaluMi~Ml#MocM$aMys+tNe/!N<#Nur(P`!P_Pis-Pla/Pros Ps!PudR`%R%RodRu/aRyvS` SedSilaSkokSlan>S*d SpoluS)vaSud-SypTahT#nT+skTom-T,vaTupaTvo,U#zUtoUzdroVahaVidlaVlakVozVr/V$!VykVzde/Zd,vZem-Zn!-Z<Zv!2Ac|Ah<yAkti#A+sAot>Ap<-AseAv^IncipKnoObud O%ntoOdejOfeseOh,Oj-tO]m Omi+Onik!Op`OrokOs[OtonOut-OvazS#v#St@Udk(UtV-Voh<y0An>OvodTruh0Actvo0Ber)}DlKav>Kl.Kr+LtMpaNcP@SaSin#St.T|Ty#3Rami^SkT_::C-}otDia%Dn?DonFtGbyKe)K'.M@oMp*/NdeRa/R aS'&StrTo+$Zan%Zid]3Ag|Ak%CeptDakt<Fer@tF+xJnokKlamaK<dKrutKt<Pu)%VizeVmaVolverZerva3Sk|Ziko5Boti#Dokm@H'#K+KokoMan{oP'odPu/aRejsSolStl.Tmi$rTopedTun^Ub@#U/oUpU,V.Vn?Zb<Z/odZd!Zezn!Zhod%Zin#ZjezdZ#zZ]haZmarZp`Zru/ZsahZtokZumZvod5Bri#}`]Kav?Kopis3BaBol'}l(D]P`]T.Z(:Di$aH!KoM>Mizd!Mo)N #Rdin#San#T_ Z[Z@?0Or0H|1B,n#CeseD`]Dim@tD]Hn!Jm=Ke,K)Kun^KvojeM@oNoRvisS` Sho,SkokSl!St,SuvSyp!T[T.Tk!T~Trv!VerZ&m2O^R~0FonLn?R#Rot-RupTua%1AfandrAliskoAnz@AutEptikIcaL`[L@?LoLuzO[O#nOroRip)RzUp.V(Vr&0Abi#Adid]An.A$Avn(Ed|Ep>EvaEz.IbI&Izn?OnOup-OvoU/UhaUn%Up#Za0A,gdE)&Il$voL*vaOgR`RkRt#Ut-Ysl0AdAhaOb0Bo)}aD'#KolP#TvaUbojUc Ud%UhlasUl`Um,kUp,vaUsedUtokUvis{0Al'&As _IsLavOd-Oj@>OluOnz<Orn(Ou$aR/aU$ 1An^AzD%NaN>Ovn!P@StUb1An?Ar(aAti#Av[EhnoEz#OdolaO+kOpaOrnoOup!Ra/ResRh~RomRu&Ud&Upn?VolYk0Bj-tBtropy}arD(KnoNd!N=Rik!aR'.0AhAl$voEtrAt[Az-Is+It-Obo^Odid]Or#Rab2Kav#KotN-N'>P!Pk(R'(S_T(:B+t#Bu+H*nJemnoJfunJgaJ Jn(Kti#Mh+MponNc|N>NkerPe)V@.Z!_3}ni#HdyKut.LefonMno)Nd@%Ni$aN<P])P&PrveRapieRmos#Xtil3}oSkopisTu+k1Ad+cAn.0Ap#Esk!UkotUpa0El1A+)Pin#PolRzoUhaU+c2Ad?Akt<AmpAsaAverzaEf E$Ez<Hav.Hl.O/uOj?Os#Ou[P%P _Pk(Ub>U/l Uhl?UsV!2DyH~H(Nd,Ri$aR&jZemsko0ArohOr[Rd(Rz2GrKev:0Oh(OzeR!R*s-RusYt'&0HoTiv(0Iv 3R` 1Edn!I$ M=0Az!_Lidn Lon Otv Roj 0I%I)Ov 0Yv`]0Av If<maIk~1Ad~L!n Ly~Out!Rav 1AnAz 0Ed~Il|Mrt N`n N=Oud Tl!Tr~0Ah|K!Lum O~Op@>R*s 1Al Oln Oz'#3D,v ElEn.L.N!:GonL/aL*nNaN^lNil#RanRhanyR|1ElkuHod0Ova0DroGe)%J%Lbl*dL{rhL _LmocLry[Nk'Ran^RzeS_#SkrzeSn?SpoduS)Ter.Ver#3B,%}rDeoh,D.D+LaN?S{Tal aZeZ #0Ezd0L`Us0Aj#AkAs>EvoHk(IvN'#Oup!1Uc|Uk0DaDiv(Doz&kD$voJ@skyJ&JskoLantL[L LnoSk'#Zid]Z'&0Ravo1Ab>A%tAhA)Ba}o+kH!StvaTu+0Ad T*p Tup0Ip4Bav Br!}|D!D,Fot H+d!H~Hod H,d Hub Jasn J{Jm=K]p Kon!L-!Maz!Mez Miz{Mys+tNe/!Nik!Nut P`!Pl! P,v Pu$ Raz R'n!Rv!Sl' SokoS)v Su~Syp!Tas Tes!Tr! Vi~Vol!Vrh_Zdob Zn!0AduBud }op D<Du/Dy/!E$upH+demKazLyk!NikOr-P*,TahT-::993Lofon::Br!Byd+t}|DarmoDus F*k!Hlt Hod H,^Hy~J!>J{Ji$ K+p!K*p Lep Mez Mot!Mys+tNe/!Nik!Pl! Poj Ps!Raz S)v Su~Taj Temn Tk~Ujm=Val Ve+tVin Vol!Vrt!Zvon 0Av RusuUd|Yt-1A+#ArmaAtn(IvoOb RojVihYm`]0L@.ManM.Pt!Z`uZdola2At Lt~Lubo#Ot' Ru[0MaMn?0Emn 0Lam!Oum!R!#Umav#0AtoEh#O[OmO$Ozvyk0Ap|ArAt-IjeIz{Ocn Odr!Rzl.Ut|0AkAl(Am@!Ovu0B,z Tav Ub-Ufa+0Lod Omal RavaR( Rud#Rvu1A^An C`]N (NoOv&Y/l Zav(1I/aR! 0B'.Br0Ed~EnkuEs_aOnR!Uk'odYk";
const checksum$4 = "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a";
let wordlist$6 = null;
/**
 *  The [[link-bip39-cz]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangCz extends WordlistOwl {
    /**
     *  Creates a new instance of the Czech language Wordlist.
     *
     *  Using the constructor should be unnecessary, instead use the
     *  [[wordlist]] singleton method.
     *
     *  @_ignore:
     */
    constructor() { super("cz", words$4, checksum$4); }
    /**
     *  Returns a singleton instance of a ``LangCz``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist$6 == null) {
            wordlist$6 = new LangCz();
        }
        return wordlist$6;
    }
}

const words$3 = "0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&";
const accents$1 = "aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M";
const checksum$3 = "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300";
let wordlist$5 = null;
/**
 *  The [[link-bip39-es]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangEs extends WordlistOwlA {
    /**
     *  Creates a new instance of the Spanish language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langEs]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("es", words$3, accents$1, checksum$3); }
    /**
     *  Returns a singleton instance of a ``LangEs``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist$5 == null) {
            wordlist$5 = new LangEs();
        }
        return wordlist$5;
    }
}

const words$2 = "0erreleontiteurinueiriet cegeanseali medenel q)eniluxaus ch0Ais}And$Diqu E`#Ol*Ord Ou%rOy RasifReuv Ri,Rog RuptS_-SoluS'@UsifYss=0A@m+AjouAr+nCab]Cep,Clam Cola@Cro~eCu}ErbeHatHe,Idu]I Omp&Qu *R$y?Te'TifT)l0Ep&EquatHesifJec%fJug Mett!M* Op,Or Ouc*Res<RoitUl&V be0R R$ef0Fai!Fec,Fi~eF!{Fub]0Ac Enc I#I,Raf Reab#Ru?1D Gu`#L>Mab#S/-0Ou,Us,1Arm Chim+Er&Geb!G)I_ I?ntLeg Lia.Lou Lum O'd*PagaTes<Veo#0A&'BiguB!Enag Ertu?Id$Ir=Orc O'Ovib#Phib+P#'Us/t0Aly<Apho!Ar~+Atom+C+nE/%rG#Gois<Gu#{Im=Nex N$-N)lOd(Om=+Ony?Orm=T_[Tido&X+{1Ai}Eri%fL/*Olog+Pa!`Pe]Por,Puy 0UariumUeduc0Bit!Bus&De'Doi<G_tLequ(Matu!Me?ntMoi!Mu!P_,Ra~ Riv Ro}S_icT +lTic#0PectPh=&P* S|tS v*S+t&Soc>S' TicotT!Tu-0El>O?RiumRo-Ta^T_%fT* Trap 0Ba(eB .Da-Dib#G' Ro!Tom[Tru~e0A]Anc Ari-En*Er<Eug#Ia&'I@I$I}O(eOu R`1I=Io?:D.Fou Ga.G)t&Igna@L/c Lc$Le(eLisa.Mb(Ncai!Nda.Nl+)Nn>eNqu>Rb>R`R$R^Rra.Ss(S%$Ta`#Te|T,+Udr>Vard 3Let&L>Lo&Nefi-R-|Rg Rl(eRmudaSa-Sog[Ta`Ur!3B $Cyc#Du#JouL/L(g)LlardNai!Olog+Ops+OtypeScuitS$Sto'iTu?Zar!2AfardAg)An~*Ess/tInd OndOqu Ous$2BardB(eI!I}Li@Nb$Nd*Nhe'Nif>NusRdu!R[T&Uc#Ue{Ug+Ul$Uqu(Ur<Usso#U%^Xe'2An~eAs>AveEbisE~eEuva.Ico]Iga@Ill/tIo~eI^O~u!Od Onz Ous<Oye'U?Us^Ut=Uy/t2Ff#Iss$L#%nRe|R(S% T( To*Vab#Vet&:B/$B(eChet&De|D!Fe(eIllouIss$Lcu]Lep(Lib!Lm Lomn+Lvai!Mara@M aMi$Mpag[N=Net$N$N%[NularPab#Por=Pri-Psu#P,Pu~eRab(eRb$eRes}RibouRna.Rot&R!|Rt$Sca@S>S^Ssu!U}U%$V=>V [Viar3D`#Intu!Les&Llu#Ndr>Ns' Ntr=Rc#Rebr=Ri<Rn Rve|S}2Agr(Ai<A#'Amb!An-Apit!Arb$As<'At$Auss$Av* Emi<En`#Equ>Er~ Ev=I_Iff!Ign$Im eIotLoru!OcolatOis*O<O)t&Ro?U&0Ga!Gog[M_,NemaNtr Rcu]R R^T [Toy_Tr$V`2A*$A?'Aqu As<Av>I_tIgn ImatIva.O~eOna.Opor&2B=tBraCas<Co% D Dif>Ff!Gn Hesi$Iff Inc L eLibriLl(eLma,L$elMbatMed+Mm/@MpactNc tNdui!Nf>N.]Nno,Ns$[NtactNvexePa(P+Ra`Rbe|Rda.Rni~eRpusR!ctR&.Smi^Stu?T$U@Upu!Ura.U&|Uvr*Yo&2AbeA(&Ava&Ay$Eatu!Edi,E?{Eu}Evet&Ib]I Ist=I,eOi!Oqu Ota#Uci=UelYp,2Bi^E`l*Il]eIs(eIv!Lm( L%v Mu]Pi@Ra%fR<'3Anu!C#L(d!Ni^:Ign M>Ng N<'Uph(3Batt!Bi,Bord Brid But/tC= Cemb!Ch* Cid Clar Cor Cri!Cup]Da#Duc%fEs<F_sifFi]Fray Gag Givr Glu%rGraf Jeun Li-Log M/d Me' Mol*Ni~ Nou N&l#Nud PartP_}Pha}Plac Po}R/g Rob Sast!S-n&S tSign Sobe*Ss( Str>Ta~ Tes,To' T!s<V/c V_*V( Vo*3Ab#Alog)Am/tC,Ff  G  Git=G[Lu M/~eM(u Oxy@Rec%fRig Scu,Spo}Ssip St/-V %rVi}5Ci#C&'G?IgtMa(eMici#Mp,Na&'Nj$Nn Pam(eRto*Ru!Sa.Se'Ss>Ta%$U/>Ub#U-'U,Y_2Ag$Ap Es}Ibb]Oitu!2P +P#xeRab#Rc*3Nas%e:0Lou*0Ar,HarpeHel#La* Lip<Lo!Lu<O#Onom+Or-Ou,Ra}Rem Riva(RouU?U!u`0If>Uqu 1Fac Fec%fFig+FortFray Fusi$0Ali}Ar 2Ec,1Abor Arg*Ectr$Eg/tEph/tEveIgib#I%s?O.Ucid Ud 0B=]Bell*Bry$Er|@Issi$M_ O%$Ouvo*P e'Ploy Por,Pri<Ulsi$0Cadr Ch eClaveCo~eDigu Dos}DroitDui!Erg+F/-F m Fou*Gag G(Glob Ig?Jamb JeuLev NemiNuye{Ri~*Roba.Seig[Tas}T_d!T>To' Trav Um  Vah*Viab#Voy Zy?0L+n0Aiss*Arg[At/tAu#Ic +I@m+I Ilog)I[Iso@ItapheO^ReuveRouv Uis/t0U !Uipe0Ig Osi$Re'Up%$0C=>Pad$Pe-P+g#Po*PritQuiv Say S_-S+uSor Ti?TomacTra@0Ag eA]An~eA%^E(d!Endo*Er[lH/olHi^Hn+Ir Off Oi#Onn/tO'd*R/.RoitU@0Phor+0Alu Asi$Enta`I@n-I,Olu%fOqu 1ActAg  Auc Cel]Cit/tClusifCu<Ecu,Emp#Erc H= Hor,I.n-I]Is,O%^Ped>Plor Po}Prim QuisT_sifTrai!Ul,:B#Bu#{Cet&Ci#Ctu!Ibl*Lai<Me{M`#R-'RfeluR(eRou~eSc( T=Tig)Uc$U%fVe'Vori3Bri#C$d D  L(M?M'Ndo*Od=Rm Ro-Rve'S%v=U`#Ut!Vr>3AscoCe]C%fDe#Gu!Latu!Leta.L>eL#ulLm LouLtr N/c N*O#R?Ssu!X 2A* Am?As^At&'E|E~eE'Exi$Oc$O!Uctu Ui@Uvi=2L+Nd +Ngib#Nta(eRc Rg $Rmu]Rtu[Ssi#Ud!Ug eU`]Ulu!Urmi2Agi#Ai<An~*App Aye'Ega&E( El$Em*E[s+E!Iab#Ic%$Iss$Ivo#OidOma.Ont=Ot,Uit2Gi%fI&Re'R+{R%fSi$T':Gn Lax+L +Mbad R/%rRd+nRn*Rrig)Zel#Z$3AntLa%[Lu#Ndar?N =N+NouN%lOlog+O?t!R/iumR?St)lY}3B>C]RafeV!2A-AiveIs}ObeOi!Or+{2Lfe'M?Nf]R.R`#Udr$Uff!UlotUp`#Urm/dUt&2Ad)lAffi%A(eAndApp(AtuitAv*EnatIffu!Il]Imp Ogn Ond Ot&OupeUg U% Uy e2EpardErr>I@Im|veIta!Sta%f3Mnas&Rostat:Bitu@Cho*L&Me|NgarN[t$RicotRm$+Rp$Sard3LiumMato?RbeRiss$Rm(eR$Si,U!{3B n BouLar/tStoi!V 5MardMma.Mo.[N['Nor N&{R@Riz$Rlo.Rm$eRrib#U#{Us<5BlotI#{Ma(Mb#Mi@Mo'R]3Dro?lG+[M[Pno<:2Yl#2Nor U/e4Lici&Lusi$0A.Bib I,M_<Mobi#Muab#PactP i=Plor Po}Prim Pu,0Carn C_d+Ci@ntCl( Colo!Dex Di-Duc%fEditEp%eExactF(iFlig Form Fusi$G  H= Hib Jec,Ju!No-ntOcu]Ond Scri!Sec&Sig[Soli&Sp* S%nctSul,TactT_<Ti?Trig)Tui%fU%#Vasi$V_,Vi,Voqu 3Oni^Rad>ReelRi,0O]2Oi!Res<:GuarIll*MbeNv>Rd(Ug U[Velot3Tab#T$UdiU[s<9Ind!N~ Ng]Ue'UissifUrn=Vi=Y|Ye{5Bi]Ge?ntNiorP$Ris&S%-Te{V_i#:Yak7M$oOs^:BelBi=Bo' C  Cto<Gu[I[Is}I% Mbe|Mel#MpeN-'Nga.N,[P(R.'R?Ur>VaboVo*3Ctu!G=G Gu?SsiveTt!V>Xi^Zard3As<B  B!C_-Cor[E.Ev!Gatu!Go,G)M Mi&M$a@Mpi@Neai!NgotOn-|Qui@S>eS,ThiumTi.Ttor=V!'5Gi^Inta(Is*MbricT +U UrdUt!UveY=5B+Ci@Cra%fE'Gub!Is/tM>eNai!NdiR$T,X){:Ch(eGas(G_taGi^Ig!Ill$In%_Ir+Is$Jor Lax Lefi-Lhe'Li-L#t&MmouthNda,Niab#Nqu/tN&|N)lRath$Rb!R~/dRdiRi%?R^'Rr$R&]Scot&SsifT +lT>eTra^Udi!Ussa@UveXim=3Ch/tC$nuDa`#Dec(Di,Du<Il#'L/.Lod+Mb!Moi!Nac N Nh*Ns$.NtorRc!diRi&R#Ssag Su!T=Teo!Tho@T>Ub#3Au]CrobeEt&Gn$Gr L+uLli$Mi^N-N =Nim=Nor Nu&Rac#Roi,Ssi#X&5Bi#D [El#{Ndi=Ni&'Nna+Not$eNst!Ntag[Nu?ntQ)'R-|Rsu!R% Te'TifU~eUf#Ul(Uss$Ut$Uv/t5L%p#Ni%$Ra`#Re[Rmu!Sc#SeumSic+nTa%$T T)l3Ria@R%l#S,eThi^:Ge'PpeRquoisRr Ta%$Ti$Tu!Ufra.U%^Vi!3Bu#{CtarFas&Ga%$Glig Goc>I.Rve{Ttoy Ur$eUtr$Veu3CheCkelTra&Ve|5B#CifCt'[Ir-'I<t&Ma@Mb!{Mm Rma%fTab#Tif>Toi!Urr*Uve|Va&'Vemb!Vi-5A.Anc I!Isib#M oP%=Q)Tri%f:0E*Jec%fLig Sc'S v Stac#T_*T' 0Casi$Cup E/Tob!Troy Tup]Ulai!0E'Or/t1F_}Fic>Fr*0Ive1Se|S`l$2Fac%fIv>0Bra.Ett!0Ct){Du]E!{Iri^1A#A^Er Ini$PortunPrim T Ti^1A.{An.Bi&D$n E`#G/eG)`Ifi-Ne?ntQ)T+0C`]Mo<Satu!0Ar+0Rag/Rs$T`Trag Vra.0A%$1Y@Y.[1O[:Isib#La-Lma!sLo'@Lp Na~eNdaNgol(Niqu N[|NoramaNt=$PayeP>Po,PyrusRadoxeR-l#Res<Rfum R]Ro#Rra(R<m Rtag Ru!Rv_*Ssi$S&^T [lT+n-Tr$V`l$Voi}Y Ysa.3Ig[Int!La.Lic/L#Lou<Lu~eNdu#Netr Nib#NsifN'+Pi&PlumRdrixRfor Rio@Rmu,Rp#xeRs`R&S Ta#TitTr*Up#2Ara$Ob+O^Ot$Ra<Ysi^0AnoCt'=E-Er!Euv!Lo&N-|Pet&Qu Rog)Sc(eSt$Vo,XelZza2AcardAf$dAis*An A^Astr$A&|E' ExusIa.OmbOng U+Uma.2Chet&Es+E&In&Ir>Iss$Iv!Lai!Lic>L#nLyg$eMma@Mp>Nct)lNd  NeyR%^Si%$S<d Stu!Tag Te|Ti$U-Ula(Um$Urp!Uss(Uvo*2A*+A%^Ec+{Edi!EfixeElu@EnomE<n-E&x&Evo*Imi%fIn-Is$Iv Ob#?O-d Odi.Of$dOg!sO+Oje,Olog)O?n Op!Osp eO&g O)s<Ov beU@n-U[|0Y~o<1BlicC $I}LpeLsarNai<Ni%fPit!Rif>Zz#3Rami@:99AsarE!l#Es%$Ietu@It,O%_t:C(eC$,D+{G$d(I@'Is(L_%rLl$.Mas}Pi@Sa.Tis}Vag V(Y$n 3Ac%fAg*Ali}Anim Cevo*Ci,Clam Col,Cru,Cu]Cyc]Dig Dou,Fai!F#xeForm Fra(Fu.G=+nGi$Gla.Gul>I, Je,Jou La%fLev L+fMar^Me@Mi<M$,Mpl*Mu NardNfortNif]N$c Ntr NvoiPl>Por,Pri<P%#Qu(S veS(e{Soud!SpectS,SultatTabl*T_*Ticu#Tomb Trac Uni$Uss*V/~eViv!Vol&Vulsif3Ches<De|E'Gi@Go]Nc Pos,Sib#S^T)lV=V>e5Che{M/-Mp!N-Nd(Se|S>Ta%fTorTu#U.U`#U#|U%[Y|?5B/BisCheEl#G){In Is<|S S%^3Th?:B]Bo,B!Co~eFariGes<Is*La@LiveL$Lu MediNc%$Ngl>Rcas?Rd(eT' Ug!nuUm$U,Uva.V/tV$n 1AlpelAnda#E]atEnarioEpt!HemaI_-Ind O!Ru%nUlp,1An-Cab#Ch Cou C!,Da%fDui!Ig['Jo'Lec%fMa(eMb]M_-M(=Na&'Nsib#N&n-Par Q)n-Re(R.ntR+{Rru!RumRvi-Sa?V*Vra.Xtup#3D =Ec#Eg Ff]G#Gn=L_-LiciumMp#Nc eNist!Ph$RopSmi^Tu 1I 3Ci=C#DiumIg[{LdatLe`Litu@Lub#Mb!M?`Mno]N@N.'N[t&No!Rc>R%rS+T%<Uc+{Udu!Uff#U#v UpapeUr-U%r Uv_*0Ac+{A%=Eci=H eIr=3Ab#A%$ErnumImulusIpu]RictUd+{Upe'Ylis&0Bli?BstratB%lBv_*C-sC!FfixeGg  Ive'Lfa&P bePpl>Rfa-Rica&R?n Rpri<Rs|tRv+Spect3LlabeMbo#Metr+Nap<NtaxeS&?:BacBl>C%#Il]L_tLism/L$n Mbo'Mi}Ngib#PisQu( Rd RifR%[S<TamiToua.UpeU!|X 3Mo(Mpo!lNa`#Nd!Ne'N*Nsi$Rm( R[Rrib#T(eX&2E?Eor+Erap+Orax0BiaE@Mi@Reli!Ro*SsuT/eT!Tub 5Bogg/L /tMa&Ni^N[|P$y?R~eRd!Rna@Rp`#R!ntR<Rt)TemU~ Urna.Us}X(e2Ac%$AficAgi^Ah*A(An~ Ava`Ef#Emp EsorEu`Ia.Ibun=Ico,Ilog+IompheIp]It' Ivi=Omb$eOncOpic=Oupe|2I#LipeMul&N[lRb(eTe'Toy Y|3Mp/Ph$Pi^R/:0Ues^9Ti?Tras$1Ani?If>I$I^Itai!Iv s3AniumBa(Tic/t0A.I[UelU!0I#Op+:Car?Cc(Gab$dG)Ill/tInc!Is<|Lab#Li<Ll$LveMpi!N`#Pe'R>Se{Ss=S&3C&'Det&Get=Hicu#InardLo-Nd!diN  Ng Ni?{Ntou<Rdu!R(Rn*RrouR}RtuSt$T /Tus&X/tX 3AducAn@Ctoi!D/.DeoG[t&G)'La(Lla.Naig!Ol$P eRe?ntRtuo<RusSa.Se'Si$S^{S)lT=Tes<Tico#Tr(eVa-Vipa!5Ca%$Gu I#Is(Itu!La`#Lc/L%g Lu?Ra-R&xT Ulo*Ya.Yel#:G$:3N$:Cht:3B!NithS&9Olog+";
const accents = "e7693&)U*o&)Ry^)*)W))))#X^))))@@)#Wf)m%)#!))AG)&IIAQIIIBIIHJNAgBIILIDJGo)))HIQIIIIA(IGgJHH(BIIxX#)Ou)@*IAAPIIIJHQJ)&QIQPYI(HYAQC%)!))QHJJ@)#)^f*^AXCJ))$%CP))%&m)u)@e^A#G#))W@!(IKK%!(I%))O@QA))@GG#e))))WHJIWh))my@IIBT^)!)HAYGETHI*))!QnUDG)))nBoKAC*HwyQh))$&)G&)UGO)G)))(BX#v**)%O,e7686)I))@)&)gdMP()))ud)p#L))I^FIHYdWG))D@DFV)QA)o%MyTh%*)Z)%)n(XANc^R)YS";
const checksum$2 = "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045";
let wordlist$4 = null;
/**
 *  The [[link-bip39-fr]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangFr extends WordlistOwlA {
    /**
     *  Creates a new instance of the French language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langFr]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("fr", words$2, accents, checksum$2); }
    /**
     *  Returns a singleton instance of a ``LangFr``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist$4 == null) {
            wordlist$4 = new LangFr();
        }
        return wordlist$4;
    }
}

const data$2 = [
    // 4-kana words
    "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
    // 5-kana words
    "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
    // 6-kana words
    "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
    // 7-kana words
    "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
    // 8-kana words
    "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
    // 9-kana words
    "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
    // 10-kana words
    "IJBEJqXZJ"
];
// Maps each character into its kana value (the index)
const mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
let _wordlist$2 = null;
function hex(word) {
    return hexlify(toUtf8Bytes(word));
}
const KiYoKu = "0xe3818de38284e3818f";
const KyoKu = "0xe3818de38283e3818f";
function toString(data) {
    return toUtf8String(new Uint8Array(data));
}
function loadWords$2() {
    if (_wordlist$2 !== null) {
        return _wordlist$2;
    }
    const wordlist = [];
    // Transforms for normalizing (sort is a not quite UTF-8)
    const transform = {};
    // Delete the diacritic marks
    transform[toString([227, 130, 154])] = false;
    transform[toString([227, 130, 153])] = false;
    // Some simple transforms that sort out most of the order
    transform[toString([227, 130, 133])] = toString([227, 130, 134]);
    transform[toString([227, 129, 163])] = toString([227, 129, 164]);
    transform[toString([227, 130, 131])] = toString([227, 130, 132]);
    transform[toString([227, 130, 135])] = toString([227, 130, 136]);
    // Normalize words using the transform
    function normalize(word) {
        let result = "";
        for (let i = 0; i < word.length; i++) {
            let kana = word[i];
            const target = transform[kana];
            if (target === false) {
                continue;
            }
            if (target) {
                kana = target;
            }
            result += kana;
        }
        return result;
    }
    // Sort how the Japanese list is sorted
    function sortJapanese(a, b) {
        a = normalize(a);
        b = normalize(b);
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    }
    // Load all the words
    for (let length = 3; length <= 9; length++) {
        const d = data$2[length - 3];
        for (let offset = 0; offset < d.length; offset += length) {
            const word = [];
            for (let i = 0; i < length; i++) {
                const k = mapping.indexOf(d[offset + i]);
                word.push(227);
                word.push((k & 0x40) ? 130 : 129);
                word.push((k & 0x3f) + 128);
            }
            wordlist.push(toString(word));
        }
    }
    wordlist.sort(sortJapanese);
    // For some reason kyoku and kiyoku are flipped in node (!!).
    // The order SHOULD be:
    //   - kyoku
    //   - kiyoku
    // This should ignore "if", but that doesn't work here??
    /* c8 ignore start */
    if (hex(wordlist[442]) === KiYoKu && hex(wordlist[443]) === KyoKu) {
        const tmp = wordlist[442];
        wordlist[442] = wordlist[443];
        wordlist[443] = tmp;
    }
    /* c8 ignore stop */
    // Verify the computed list matches the official list
    /* istanbul ignore if */
    const checksum = id$1(wordlist.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
        throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
    }
    /* c8 ignore stop */
    _wordlist$2 = wordlist;
    return wordlist;
}
let wordlist$3 = null;
/**
 *  The [[link-bip39-ja]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangJa extends Wordlist {
    /**
     *  Creates a new instance of the Japanese language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langJa]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("ja"); }
    getWord(index) {
        const words = loadWords$2();
        assertArgument(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
        return words[index];
    }
    getWordIndex(word) {
        return loadWords$2().indexOf(word);
    }
    split(phrase) {
        //logger.assertNormalize();
        return phrase.split(/(?:\u3000| )+/g);
    }
    join(words) {
        return words.join("\u3000");
    }
    /**
     *  Returns a singleton instance of a ``LangJa``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist$3 == null) {
            wordlist$3 = new LangJa();
        }
        return wordlist$3;
    }
}

const data$1 = [
    "OYAa",
    "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8",
    "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
    "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
    "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
    "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
    "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
    "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
];
const codes$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
function getHangul(code) {
    if (code >= 40) {
        code = code + 168 - 40;
    }
    else if (code >= 19) {
        code = code + 97 - 19;
    }
    return toUtf8String(new Uint8Array([225, (code >> 6) + 132, (code & 0x3f) + 128]));
}
let _wordlist$1 = null;
function loadWords$1() {
    if (_wordlist$1 != null) {
        return _wordlist$1;
    }
    const wordlist = [];
    data$1.forEach((data, length) => {
        length += 4;
        for (let i = 0; i < data.length; i += length) {
            let word = "";
            for (let j = 0; j < length; j++) {
                word += getHangul(codes$1.indexOf(data[i + j]));
            }
            wordlist.push(word);
        }
    });
    wordlist.sort();
    // Verify the computed list matches the official list
    /* istanbul ignore if */
    const checksum = id$1(wordlist.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
        throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
    }
    /* c8 ignore stop */
    _wordlist$1 = wordlist;
    return wordlist;
}
let wordlist$2 = null;
/**
 *  The [[link-bip39-ko]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangKo extends Wordlist {
    /**
     *  Creates a new instance of the Korean language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langKo]] should suffice.
     *
     *  @_ignore:
     */
    constructor() {
        super("ko");
    }
    getWord(index) {
        const words = loadWords$1();
        assertArgument(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
        return words[index];
    }
    getWordIndex(word) {
        return loadWords$1().indexOf(word);
    }
    /**
     *  Returns a singleton instance of a ``LangKo``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist$2 == null) {
            wordlist$2 = new LangKo();
        }
        return wordlist$2;
    }
}

const words$1 = "0torea noica!iosorolotaleratelanena%oiadoencotivomai t ca%a0A]Bagl'Bin#E.Is(Oli!Rasi_Rog#0Cade!C[$Cus#E <Hil,I@QuaReRil>Roba+U 0Ag'Deb{DomeEgu#Eri!IpeOtt&Ul&1Fabi,Fe|Fis(F-n Oris`O(R~$0AveEn.E_,Ganc'I!It&OnismoR>*Rume Uzzo4AbardaA Bat)Ber#BoBumeCeCol>E|<FaGeb-Ian.IbiIm[ Lag#Leg)Lie_Lo@/Lusi_Me$Oge$Pa}Pest!Ta,=Ter$T%c'T)veUn$Veo*Z&0Alga`Ani+A!=B{Br#EbaEr~E^s+I]Mas(M[daMir&Mon{O!P'Pli&U, 0A}r@Ag-feAlis+Arch?At-CaCel/Co-D&D!aEl*Ge*Gol&Gus I`Neg&Nid#NoNunc'OnimoT%ipoZi1At>Ertu-OdePari!Pe^ Pogg'P)@Pun Ri,1Ab~AchideAgos+Ald~Anc'Atu-AzzoBit)Chiv'D{Eni,G[ Gi<Gu IaMon?NeseRed#RingaRos S[>SoTef%eZil*0Ciu|Col EpsiEtt>Fal I$O/Pir#P)Sagg'SeSolu Sur@TaT[u T%eT-|0Av>EismoOm>O$TesaTiv&Tor$Tr{Tua,0Sil'Str?Tis+To$moTun$0Anz#E!V[i!Vi(Volge!3Io<O ZimoZur):Be,C}$Ci$CoDessaDi/+Gn#I+L]<L@Le=L/+Lza$Mbi$Ndi!RaondaRba)R}R{$RlumeRoc]Sil>S(Tos+Ttu U,VaVosa3C]FfaLg'LvaNdaNe_,Nig$Nzi=ReRli=Ta3Bi+CiDo<Fi@GaLanc?MboNo]*O*goPedePol&Rban.R-S]|Ses S$n$Son.SturiZzar)2An@At+2Ll{Nif>R@S]Tan>T^$Zzo*2Acc'AdipoA`An}Avu-E.l/Eve|EzzaIgl?Il/n.Ind&Oc]*O@Onzi=Ul*U$2Bbo<CaDi$Ffo<IoLboO$R*<R-s}S(/S+:De|Du]La`)L]*LesseLib)LmoLor?MbusaMe-+M%?Mmi$Mo/Mpa,NapaNde/NeNi$No|N^=PacePel*P{*Pogi)Ppe)P-Psu/RapaceR}ssaR@Ris`Rova=R!|R li=Sacc'S}+Ser`SoS(<S.l*Sua,Tas+Te=T-meU Vil*3Dibi,D-+Fa*Leb!Llul&NaNo<N.simoRam~Rc&R RumeRvel*So?SpoTo2E/Ia)Ic}Iede!Ime-I=IrurgoI+r-0AoClismoFr&G$Lind)O|*R}R)siTr>T+di$UffoVet+Vi,2Ass>In~O)2C]Dar@D%eE!n.G$meLl&Lm#Lo!Lpo(L^v#LzaMaMe+M`n@Mo@Mpu.rMu<Nci(Ndur!Nfer`Ngel&NiugeN<s(Nosce!NsumoN^nuoNveg$Per P'<Pp?Pr~poRazzaRda+R%#Rn%eRol/RpoR!@Rs?R.seSm>S+n.Ttu-V#2A.!Avat+E#Ede!Emo(Esci+E+Ice I=,IsiIt>OceO=}Os++Uc?,Us}2Ci!Cu*Gi$Ll#Po/R#!R(!R_Sci$S de:DoI$L`+Meri$Nie/N$(Nz&T#Van^Vve)3Bu|C[n'Ci(Cli$Col*C! D%#Fin{FormeG$Leg&Lfi$Lir'L+M[zaNot#Nt)Pos{Rapa+Riv&RogaScri|Ser Sider'Sume!Tersi_Vo 3Amet)Cemb!Ed)Fe(Ffu(Geri!Gi+,Luv'Nam>N=nziPin P*`Po*Rad&ReRo|RupoSag'Sc! Sf&Sge*Spos S+nzaSu`$ToVa$Vel Vide!Vor#5B*<C[.Ga=,G`LceM#M[~Min&N@*NoRmi!TeT !Vu Zzi=2AgoUi@2Bb'Bit&Ca,NaOmoPl%eRatu):0A$0Ces(CoLissiO$m?0E-I]/I,I r?Uc&2Emon?LiOismoReg'4Abor#Argi!Egan.Enc#E|Ev&F>I}MoSaU(0An#B,`Es(I)O^_Oz'<Pir>U*0Dem>Du)Erg?FasiO.}Tr&Zi`1A^.I*goI(d'O},Pu!0U#!0Ar'BaBo(EdeEmi+Ige!Met>OeOsi_Ran.0Ago$AmeAnimeAudi!CaEmp'Erc{Ib{Ig[.Is.!I OfagoOrt#O(Pan(P!s(S[zaSoTe(Tim&Ton?T)(Ult&0Il>N>Rus]To0ClideoRopa0A(Id[zaIt#Olu Viva:Bbr~Cc[daChi)L]Migl?Na,Nfa-NgoN+s`ReRfal/Ri$(R`]Sc?S (Sul*T%&ToVo*(3Bb!Co/DeG#LpaLt)Mmi=Nde!Nome$Rm[ R)R^,Ssu-S^_T+U@3AbaDuc?FaGur#LoNanzaNest-Ni!O!S},S>Ume2A]<Am[]EboEm`Ori@U[.Uo)2B>Cacc?Co(Der#Gl'La+Lc*!Lgo!Nd[.Net>N?N+=Rb{Rchet+Res+Rm~R='RoR.zzaRz&Sf#S(2A}s(A=Assi$A.l*Eccet+E=+Es]IgoOlli$OndeUga,Ut+2Ci/+Cs?Gg[.Lmi<L_Man.Me|Mo(NeNz'<O]RboRgo<Ro!SoTi,:Bb?$FfeLa.oLli=LoppoMbe)M`Ranz?RboRofa$Rzo<S@|Sol'Str>T Ud'ZeboZzel/3CoLa^=L(Mel*Mm#NeN{!N='No^poRgo2Epar@Iacc'Isa0Al*LdaNep)Oc&Oiel*Or$OveR#Ro<T++Udiz'Ur#Us 2Obu*U^<1Omo0BbaLfM{Mmo<Nf'N=Ver$2Aci,A@Af>AmmoAndeAtt&A_(Az?E}EggeIfo<Ig'InzaOt+Uppo2Adag$A'An Ard&FoId&::0Ern#0O=0Ent>Ill'O*RaR>Roge$2Ie<Na)Nor#4A!Le(Log>Lude!0Bal*Bevu Boc]Bu Ma<Mer(Mol#Pac]Pe PiegoPor P)n+0Al&Arc&At^_Can C[d'Chi$Cisi_Clu(Cont)C)c'CuboDagi<D?Do,Ed{Fat^Fil&Fli|Gagg'Geg$G,seGor@G)s(Nes]O@!Oltr&Ond#Sa$Se|SiemeSonn?Suli=Tas#Te)To=]Tu{Umidi!Vali@VeceV{1Erbo,Not>O.siP~1IdeLandaOn>Rig#Ror&0Ol#O poTer>Titu Tr%e0Al?Er&:::Bb)Birin C}Cer#Cri`Cu=D@veGoMpoNcet+N.r=R@(RgaRingeSt-T[zaTi$TtugaVag=Vo)3Ga,Gge)MboN.zzaNzaO<P!Si_Ss#S T.-,VaVig#3Be)DoEv{L/Matu-Mit&Mpi@Ne&NguaQui@RaR~S}TeTig'V!a5CandaDeG~Mb&Nd-Nge_QuaceR[zoToT.r?5CeCid#Ma}Mi$(NgoPoPpo*SingaS(T :Cab)Cchi=Ce)Cin#Da`G>Gl?G<.G)Iol~LafedeLg-@Lin.(Lsa$L Lumo!NaNc?N@r/Ngi&Nifes N=)Nov-NsardaN^deNubr'PpaR#=Rci!Ret+RmoRsup'Sche-Ssa?S^$Te-s(Tr>/T <Tu)Zur}3And)C}n>Ce=.DesimoDit&GaLassaLisLod?NingeNoN(/Rcur'R[daR*Schi$SeSse!S *Tal*To@T.!3Agol&CaCel'Che,C)boDol*E,Gl'!La$Li.MosaNe-,NiNo!Ri$R^l*Sce/SsivaS Sur&TezzaTig&T-T.n.4Emon>0Del*Dif~Du*Ga$G'LeLos(Nas.)N]Ndi=Ne+r'Ni,No $N(<Nt#Nvi(RaRde!Rs%#St)Tiv#TosegaT V[zaVim[ Zzo5C}CosaFfaGhe|G='La|Li<l*L^p*Mm?N Ove!Ra,SaS]*S~Te_,To:BabboF+Nomet)Rci(R%eRr#Sce!Str&Tu-,Ut~Vigl'3Bu*saC)siGa^_Goz'Mme$Ofi+Re|R_Ssu$Ttu$Ut-,VeV)t>3Cch?NfaTi@5Bi,Ci_DoMeMi=Rd>R`,RvegeseSt-$T&Tiz?Ttur$Vel/5C,oL/Me)O_Tri!Vo/Z?,:Si0Bedi!BligoElis]L'O*So, 0Cas'<Ch'Cid[.Cor!!Cult&RaUl#0Ier$Or&1Fer+Fri!Fusc#0Ge|GiNu$4AndeseFa|I#IvaOg-m`T!0Agg'Bel>B-EgaIss'<0Do(E!IceNi_)O!_,Ta1Er#In'<Pos 1A]*AfoDi<Ecchi$Ef%eFa$Gan>Igi<Izzon.MaMegg'Na^_O*g'R[@Ribi,T[s?T~Za+Zo0A!Cur&MosiPeda,Pi.SaSid&Ta]*Te0I.ReTago$TimoTob!1A,EstI$Ipa)Oc{UnqueVi&3Io:Cche|CeCif>Del/D)<EseGaGi=Lazzi=Les&Lli@LoLudeN@)N<l*O*O=zzoPr~Rabo/Rcel/Re!Rgo*RiRl#Ro/R^!Rv[zaRz?,Ssi_St%}Tac}To*g?TtumeVo<3Cc#Dal&Do=,Gg'Lo(N&Nd%eNi(/Nnu Nomb-Ns&N /PePi+Rbe<R]r(R@n#Rfor&Rgame=R'@Rmes(R$Rp,s(Rsua(Rtug'Rva(S#!Sis+SoS^fe)Ta*T^<Tu/n.Zzo3Ace!An+At^$Cci$CozzaEgaEt-Ffe)G?`Gol'G)LaLife)L*/Lo+Mpan.Ne+N=No*Ogg?OmboRamideRet>Ri.RolisiTo<Zz>2AceboAn&As`A+$E=r'2ChezzaDe)(DismoEs?Ggi&L[+Ligo$Ll%eLmoni.Lpet+L(Lt)=Lve!M%eMo@)N.Po*(Rfi@Ro(Rpo-R!R++SaSi^_Sses(Stul#Tass'Te!2AnzoAssiAt~Eclu(Ed~Efis(Egi#Elie_Eme!E$t&Epar#Es[zaE.s Eval(I`IncipeIv#Ob,`Ocu-Odur!OfumoOge|OlungaOmessaO$meOpos+O)gaO.(OvaUd[.Ug=Ur{0Iche1Bbl>D~Gil#G$LceL{Lsan.Nt&PazzoPil/Ro:99Ad)Al]saAsiE!/O+:C]l D@pp'D~,Dun#Ff~GazzoG'<G$Mar)MingoMoNdag'N l&P#Pi=Pp!(Satu-Schi#S[.Sseg=St!l*TaVvedu 3A,Cepi!Cin Clu+Cond{Cupe)Dd{Dime!Gal#Gist)Go/G!s(Laz'<M&Mo N=Pl~Prime!Put&SaSid[.Spon(S+u)TeTi=Tor~T^f~Voc#3Assun Badi!Bel,B!zzoCar~C]Ceve!C%l#Cor@C!du D>*Dur!Fas&F,s(For`Fug'G&Gett#Ghel*Lass#Lev#Ma<!MbalzoMed'Morch'Nasci+N})NforzoN$_Nom#Nsav{N c]Nunc?Nv[i!Par#Petu Pie$Port&P!saPuli!Sa+Sch'ServaSibi,SoSpe|S )Sult#S_l Tar@Teg$Tm>T)_Un'<VaVer(Vinci+Vol Zo`5BaBot>Bus Cc?CoDagg'De!D{!G{Ll'Mant>Mpe!Nz'Sol&SpoTan.Ton@Tu/Vesc'5BizzoBr~GaLli$Mi<Mo)(O*PeSs&St>:B#Bbi&Bot#Go`Las(Ldatu-Lgem`Liv&Lmo<Lo<Lt&Lu L_Pe!Pi@Por{Race$R}smoR S((Telli.Ti-Tol*Tur$Va=V'Zi#0Adigl'AlzoAnc#Ar-At.!Av&End&Irci&Locc#Occi#Rin&Ruffo<Uff&0Ab)(Ad[zaA/Ambi&Anda*Apo/Ar(A.n&Av#El En>Ett)HedaHie=IarpaI[zaInde!IppoI)ppoI_*Ler&Odel/Olp{Ompar Onfor Opri!Or+Os(<OzzeseRibaRoll&Ru^n'Uder?Ul !Uo/U)Us&0Ebit&Ogan&0C}tu-Con@Da$Gg'/G=l#G!g#Gu{Lci#Let^_L/Lvagg'Mafo)Mbr&MeMin#Mp!N(N^!Pol Qu[zaRa+Rb#Re$R'Rp[.R-gl'Rvi!S^=To/T^`=0Ace*Ald&Am#Arzo(At%#E-IdaIl#IngeOc#Oder&OgoOl^!Orz#Ra|Rutt#Ugg{Um&U(0Abel*Arb#Onfi&Orb'Rass#Uar@1Bi*C]meEr-G/G$!L[z'L/baMbo*Mpat>Mul#Nfon?Ngo*Nist)NoN.siNu(idePar'S`S ,Tu#2It+Ogatu-Ove$0Arr{Emor#En^ E-l@IlzoOnt&Ott#Uss#0Elli!Erv#O@0BbalzoBr'C]r(C?,Da,Ffi|G$Ld#L[<Li@L/zzoLoLubi,Lv[.Mat>M`NdaNe|Nnife)Pi!Ppe(P-Rge!Rpas(Rri(R(R.gg'R_l#Spi)S+T^,0AdaAl/Arge!A /Av[ Azzo/EcieEdi!Eg<!E/tu-E-nzaEs(!Ett-,Ezz#IaIgo*(Ill#I$(I-,L[di@Or^_O(RangaRec&Ron#RuzzoUn^$0Uil*0Ad%&O l#1Abi,Ac]AffaAgn&Amp#Ant'Arnu Ase-Atu E*EppaErzoI,|I`IrpeIva,Izzo(On#Or>RappoReg#Ridu*Rozz&Ru|Ucc&UfoUp[@0B[t)C](Do!Gger{GoL+$On&PerboPpor Rgel#R)g#Ssur)Tu-0Ag&EdeseEgl'El&Enu Ez?IluppoIs+Izze-Ol+Uot&:Bac]Bul#Cci&Citur$LeLis`$Mpo<Nni$RaRdi_Rg#RiffaRp&R+rugaS Tt>Ver=Vo/+Zza3CaCn>Lefo$Me-r'MpoMu N@<Ne)Ns'<N+]*O!`RmeR-zzoRze|SiSser#St#T)T ?3F&Gel/Mb)N P>Pog-foRagg'RoTan'To*Tuban.Z'Zzo<5Cc&L,r&L Mbo/MoNfoNsil/Paz'Po*g?PpaRbaRn&R)<R -S}$Ssi!S+tu-Ta$2Aboc]AcheaAfi/Aged?Alc'Amon Ans{Apa$Ar!As*]Att#AveEcc?Emol'Espo*Ibu Iche]Ifogl'Il*InceaIoIs.zzaItur#Ivel/OmbaO$OppoO|/Ov&Ucc#2Batu-Ff#Lipa$Mul Nis?Rb&Rchi$TaTe/:0Ic#0Cel*Ci(!0I!I^_1FaF%'0Ua,4IsseTim#0A$I,Orismo0Ci<|Ge!Ghe!seI]r$If%#I($I+r'Te0Vo0Upa1Aga$G[zaLo0AnzaA C{Ig$*U-'0Ensi,IlizzoOp?:Can.Ccin#Gabon@Gli#LangaLgoL>L,t+Lo)(Lut&L_/Mpa+Ng&N{(NoN+gg'Nve-Po!Ra$Rc#R?n.S}3Det+DovaDu Ge+,I]*Lc)Li=Llu LoceN#Ndemm?N RaceRba,Rgog=Rif~RoRru}Rt~,Sc~Ssil*S+,Te-$Tri=Tus 3Andan.B-n.C[daChingoCi=nzaDim&Gil?G< Go!LeL/$MiniNc{!O/Pe-Rgo/Ro*goRu,n S](S'<SpoSsu Su-TaTel*T^`VandaVi@Zi&5CeGaLa^,Le!LpeRagi<5L}$::::Mpog=N=Pp#T.-Vor-3Fi)Lan.LoNze)Rbi$3Be|N]R]<T 5L/T>5Cche)Fo*LuPpa";
const checksum$1 = "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620";
let wordlist$1 = null;
/**
 *  The [[link-bip39-it]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangIt extends WordlistOwl {
    /**
     *  Creates a new instance of the Italian language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langIt]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("it", words$1, checksum$1); }
    /**
     *  Returns a singleton instance of a ``LangIt``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist$1 == null) {
            wordlist$1 = new LangIt();
        }
        return wordlist$1;
    }
}

const words = "0arad!ototealirertainrasoent hoandoaR#riareha!aroele'oronul0Aca%AixoAl A%rDuz'El]Er$IsmoO$ R<g(Revi Rig Rup$S*$Solu$Sur=Ut[0Ab#Alm Amp Anh A,Ei.El( En ErvoEss E$naHa.IdezImaI}#Irr Lam LiveOlhidaOmod Opl Ord Um~ Us?0Ap.EgaEnt_Ep$Equ Er-%EsivoEusI<%ItivoJetivoJun$M' Or Qu''UboV(,Vog#0R}ave0As.Er'EtivoIn?Iv` Li$Lu-%R}.0Ach Arr As&/Enci Iliz Io)It#O+R! Res%Rup U d Ul]2O`h Ud Us.1AmedaArmeAstr Av<caB(gueB*oCat+De@EcrimEgr@Er.FaceF*e%GumHeioI Ica%I- Inh Ivi Mof^Oc Pis%T( TitudeUc* Ug UnoUsivoVo0Aci A=rA[loAss BasBi-%EixaEniz I=Is$,Iz!eOl?On$ O_,Ost+P  Pli Pola0Ag+maAlis Arqu@A$m@DaimeElExoG~ Im JoOm&@Ot#Sio,T(i|Uid!eUnci Zol1Ag?Alp Anh#EgoEli=Ert^Es Eti%I$Lau,Lic^OioOn.Os)R-dizRov 0Uec(0AmeAn]A+C^D-%E@Ej Eni$Es)Gilo,GolaMaQuivoRai&Reba%Risc Rob>um S-&T(i&TigoVo[=0F&.Il#P' S?S* So&/Sun$Tr&0Ac#Adu+Al/A[f E End(Er_EuIng'Ir?IvoOl{oRac Revi=RizU&Um0Di$rM-.R>o+TismoT|@Tu 0Ali An%Ar@Ent&Es,I?Is Ul,1Ila1Ar E=Ei%Ulejo:B BosaC&]uCh `C@GagemI<oIl I}e)Ir_Ixis)J~ Le@LizaLsaN&Nd{aN/N'Nque%Ra$Rb#R}es>+c>~/Se#S)n%Ta)Te=rTidaTomTuc Unil]3B(IjoIr^IsebolLd!eLezaLgaLisc Ndi$Ng&aNz(RimbauRl*d>_Sou_XigaZ(_3CoCu=En&Foc&Furc G|naLhe%Mest[Mo$rOlog@OmboOsf(aPol Rr-$Scoi$Sne$SpoSsex$TolaZ _2Ind#OcoOque 2A$BagemC#CejoChec]Ico.L^LetimL]LoMb{oNdeNecoNi)Rb~h>d>e&R+c]V*oXe?2AncoAsaAvezaEuIgaIl/Inc OaOchu+Onze O$Uxo2C]DismoF LeRacoScaS$Z*a:B<aB`oBideBoBri$CauCet^C/r_CiqueDast_De#Fez&IaqueIp'aIxo%J#JuLafrioLc~ Ld{aLibr Lm<%Lo)M^Mbis)MisaMomilaMp<]Mufl Navi&Nc` Ne)NguruN/$Nive%NoaNs#N.Nu=Pac/P`aP* Po.Pric/Pt?PuzRacolRb}oRde&Rec>imb Rn{oRpe%R['>)zRv&/SacoScaSeb[S%loS~oT a)Tiv UleUs?U%l V&oV(na3BolaDil]G}]Lebr L~ Nou+N,N%ioRc Rr#R%'oRvejaTimV^2Aco)Al{aAm#Ap^ArmeAticeAveEfeEg^E'oEqueIco%If[In`oOc&/Ov(UmboU.Uva0CatrizCl}eD!eD['aEn%G<aM-$N$Nz><d>cui$Rurg@T 2A[zaE_Ic OneUbe2A=Ag'Ba@B($rBr C^El/Ent_E,Gum`oIb'IfaIo%L L{aLh(Lid'Lme@L}oLunaM<=Mb* M-.MitivaMov(MplexoMumNc]N=rNec.Nfu,Ng` Nhec(Njug Nsum'Nt+$Nvi%Op( P{oPi?PoQue%lRagemRdi&Rne)R}h>p|&R[ioR%joRuj>voSs-oS%laT}e%U_UveVilZ*]2A%+AvoEcheE=rEmeErEspoI^Im*&Io~oIseItic Os)UaUz{o2B<oEcaId#JoLat+Lm* Lp Ltu+Mpr'Nh#Pi=RativoRr&Rs R$Sp'S% T`o:MascoT 3Ba%rBi.BocheB~h C&queCim&CliveCo%C[.D&Dic#Duz'FesaFum G`oG+uGus.It#Ix La$rLeg#L*e L}gaM<daMit'Moli=Ntis)P-#Pil PoisP[ssaPur Riv>+m SafioSbo.Sc<,S-/Sfi#Sgas%Sigu&SlizeSmam SovaSpesaS)queSvi T&h T-$rT} Tri$UsaV(Vi=Vot#Z-a3Ag+maAle$Da)Fu,Gi.Lat#Lu-%M*u'Nast@Nh{oOceseRe$Sc[)Sf ceSp oSque%Ssip S)n%T?UrnoV(,Vi,rV~g Z(5Br?L|i=M?M*#NativoNz`>m-%Rs&SagemUr#U$r2EnagemIbleOg @2El EndeE$PloQues><%Vi=,:1Lod'O Olog@0Ific It&Uc#1Ei$Etiv 3E.1Ab| Eg(Ei$rEncoEv?Im* Ogi 0B goBol#Br~/Buti=EndaErg'Is,rPat@P-/P*#Polg P[goPurr Ul?0CaixeC-#Ch-%C}t_Deus Doss Faix Fei%FimGaj#G-/Glob Gom#G+x Gu@Jo La.Qu<$Raiz Rol#Rug SaioSe^S*oSop#T<$Te#Tid!eT|.Tr^T~/V(g Vi#Volv(XameX($Xof[Xu$1Id(me0Uip 0E$Gui=Ra)VaVil]0B<j B`$CamaColaCri)Cu)F*geFol F[g Fum#GrimaM&%P<$P`/PigaP}jaP[i)Pum Qu(daTacaT{aTic Tof#T[laTu=Vazi 0AnolIque)0F|i>opeu0Acu Ap| AsivoEntu&Id-%Olu'1Ag(oAl Am* A$Aus$Ces,Ci.Clam Ecu.EmploIb'Ig-%On( P<d'P`'P' Pl< Pos$P[s,P~s T(noT*$T+$:Bric B~o,Ce)Ci&DaDigaIxaL L)Mili Nd<goNf +N$cheRd#R`oR*h>of>p>tu+T@T|V|i)X*aZ-da3Ch#Ijo^I+n%L*oM**oNdaNoR>i#RrugemRv(S%j T&Ud&3ApoB_seC Ch{oGur#L{aL/LmeLtr RmezaSg^Ssu+TaV`aX?Xo2AcidezAm*goAn`aEch^O+Utu Uxo2C&C*/Foc GoGue%IceLg#Lhe$Rj Rmig>noR%ScoSsa2Aga)AldaAngoAscoA%rnoE'aEn%E.IezaI,Itu+On]Ustr U%'a2G'L<oLigemNd NgoNilR?Rio,Tebol:B i$B*e%DoIa$IolaIvo)LegaL/L*]Loc]Nh RagemRfoRg&oRimpoRoup>+faSodu$S$TaTil/Ve)Z`a3L#Le@LoM^M(Mi=N(o,NgivaNi&NomaN_Ologi>?Rm* S,S$r3Nas)Nc<aNg#Raf>*o2Aci&IcoseOb&Orio,2ElaIabaLfeLpe Rdu+Rje)R_S$,T{aV(n 2AcejoAdu&Afi%Al]AmpoAn^Atui$Ave$AxaEgoElh EveIloIs&/I.@Os,O%scoUd#Unhi=U)2AcheA+niAx*imEr[ I Inc/Is#LaLo,Ru:Bi.Rm}@S%V(3C.eRd Res@Si.3A$B(n D+.EnaNoPismoPnosePo%ca5JeLofo%MemNes$Nr#Rm}&Sped 5M|#:Te2E@O,2N|#RejaU<a4E,HaUdi=Um* Ustr 0AgemEd@$En,ErsivoIn-%It?Ort&Pac$Ped'Pl<%P|Pr-saPuneUniz 0Al?Ap$AtivoC-,Ch Cid'Clu'Col|Deci,D'e$Du$rEficazEr-%F<tilFes.F*i$Flam F|m&F+$rG('Ibi=Ici&ImigoJe.Oc-%O=_Ov?OxQuie$Scri$Se$Sist'Spe$rSt& S~$Tac$Tegr&Tim Toc#TrigaVa,rV(noVic$Voc 0Gur%2Ani<oOniz Re&Rit#0CaEn$Ol#Qu{o0Ali<o:N{oNg^N)R ac>dimR_SmimToV&iZida3Jum9An*]Elh^G?I>n&Rr Vem5BaDeuDocaIzLg?L/R#Ris)RoS)::B edaB|&C[C)n%Dril/G )GoaJeMb(M-.M* MpejoNchePid P,R<j>{>gu+S<]St_T(&Ti=V<daVou+Vr?X<%Z(3Ald!eB[G#G-d Gis)IgoIlo Itu+Mb[%MeNh?Ntil]OaSmaS%TivoT['oV VezaVi.3B(&Bi=D( G G{oMi.Mo{oMp?NdaNe N]gemQuidezS)gemSu+T|&V_XaX{a5C?Cu$rJis)MboNaNgeNt+RdeT#T(@Ucu+UsaUv 5ArCidezC_Ne)St[T?Va:CacoCe%Ch#CioD{aDr*]Gna)G[zaI|IsL<d_L]Lo%LucoMiloMo{oMu%N^Nc]Nda$NequimN/,Niv`aNobr NsaN%rNuse Pe#Qu* Rc?Resi>fimRgemR*/Rmi)Ro$RquiseR[coR%loRujoSco%Sm|+SsagemStig Tag&T(noT*&Tu.Xil 3D&]DidaDusaGaf}eIgaL<c@L/rMb_M|i&N*oNosNsagemNt&Rec(Rg~/S^Scl SmoSqui)St[T!eTeo_T+gemX(Xic<o3C_G&]Gr Lag[L- Lh M#N( N/caNist_N|@OloR<%RtiloStur 5Cid!eD(noD~ EdaErIn/I)Ldu+LezaL/L*e%LuscoN)n]Quec><goRcegoR=moR-aSaicoSque%S.daT`TimToTriz5DaI$La)Lh(L.Ndi&Ni=R&h>c/Sc~ SeuSic&:Ci}&D?JaMo_R*>r#Sc(TivaTu[zaV&]Veg Vio3Bl*aB~o,GativaGoci Gri$Rvo,TaUr&VascaVo{o3N N/TidezV` 5B[zaI%IvaMe M*&Rdes%R% T Tici TurnoV`oVil/Vo5Bl#DezM(&Pci&Tr'Vem:0Cec#Edec(JetivoRig#Scu_S%t+T(Tur 0Id-%Io,Orr(Ulis)Up#2Eg<%EnsivaEr-daIc*aUsc#0Iva4Ar@Eo,H Iv{a0B_Ele%Is,It'0D~#E_,Tem1Ci}&Er?On-%OrtunoOs$1ArBi.DemD*&F<a$GasmoG~/I-t&IgemIun=LaTo=xoV&/0Cil S^SoT-.0Imismo0S!@T}oTub_Vi=0El]Ul 1Id Ig- :Ca$Ci-%Co%Ctu D @Dr*/G GodeIn`Ir IsagemLav+Lest+Lhe)Li$Lm^Lpi.Nc^N`aNfle$NquecaN)n&PagaioP`^P'oRaf*>ci&Rd&RedeRtidaSmoSs#S%lTam T-%T* T_noUl^Us 3C~i D& Dest[D@t+D+G^I$r&IxeLeLic<oNcaNdur N{aN]scoNs?N%Rceb(Rfei$Rgun)Ri$Rmit'Rn>plexoRsi<>%nceRucaSc#SquisaS,aTisc 3AdaC#Ed!eGm-$Last+Lh#Lo.M-)Nc`NguimN]No%N.On{oPocaQue%R<h>esRue)Sc S$laT<gaVe%2An)Aque)At*aEbeuUmagemUvi&1Eu0DaE'aEtisaLeg^Lici Lu-%Lvil/M MbaNd( N.@P~o,R)Ssu'St&TeUp U,Vo 2A@Anc]A$AxeEceEd?Efei$Emi Ens Ep  Esil]E%x$Ev-'Ez Ima)IncesaIsmaIv#Oces,Odu$Ofe)Oibi=Oje$Ome%rOpag OsaO%$rOv?2Blic DimL Lm} Ls{aNh&N'PiloRezaX?:99Ad+Ant@Ar$AseEbr EdaEijoEn%Eri=Im}oInaIosque:B<^BiscoCh Ci} Di&I In]IoIvaJ^L#M&Ng(Nhu+P!u+P`PidezPosaQue%Rid!eS<%Scun/Sg Sp?S%'aSur Taz<aTo{a3AlezaAnim Av(Baix B`deBol C#C-%CheioCiboC|d Cru.Cu DeDim'D}daDuzidaEnvioF* Flet'Fog F[scoFugi G&@GimeG+In#I$rJei.LativoM?M-=M|,Nov#P oP`'Ple$Pol/P[saPudi Qu((S-]Sfri Sga.Sid'Solv(Spei$SsacaS)n%Sum'T&/T(T' Tom^T+.V` Vi,rVol)3Ac/CaGidezGo_,M NgueS^ScoS}/5B&oChe=D^DeioDov@E=rLe)M<oNc S#S{aS$TaT{oT*aT~ UcoUpaXo5B_Gi=Go,IvoMoPest[S,:B|Ci ColaCud'DioF'aGaGr^Ib_L^L{oLg#LivaLpic Lsic]L.Lv?Mb Mu+iN Nf}aNgueNid!ePa$Rd>g-$Rje)Tur Ud!eXof}eZ}&3C C~ DaD-$Di#Do,Du$rGm-$G[=Gun=IvaLe$LvagemM<&M-%N?N/rNsu&Nt#P #Rei>*g>+RvoTemb_T|3GiloLhue)Lic}eMetr@Mpat@M~ N&Nc(oNg~ NopseN$ni>-eRiTu#5B(<oB+C|_G_JaLdaLetr L%'oMbrioNa)Nd Neg Nh?NoP+noQue%Rr'R%ioSsegoTaqueT(r V#Z*/5Aviz BidaBm(,B,loBt+'Ca)Ces,CoDes%FixoG?G('Jei$Lfa$M'OrP(i|Plic Pos$Prim'Rd*>fis)Rp[s>[&Rt'Sp'oS%n$:B`aBle%Bu^C/G `aLh(LoLvezM</Mb|imMpaNg-%N$P Pioc>dioRef>j>+xaTuagemUr*oXativoXis)3Atr&C(Ci=Cl#Dio,IaIm Lef}eLh#Mp(oN-%N,rN.Rm&RnoRr-oSeSou+St#ToXtu+Xugo3A+G`aJoloMbr MidezNgi=N%'oRagemT~ 5Al]C]L( LiceM^Mil/N`Ntu+Pe%R>ci=RneioRqueRr!>$S.UcaUp{aX*a2Ab&/Acej Adu$rAfeg Aje$AmaAnc ApoAs{oAt?Av E*oEm(Epid EvoIagemIboIcicloId-%Ilog@Ind!eIploItur Iunf&Oc Ombe)OvaUnfoUque2B~ C<oDoLipaPiRboRm>quesaT` T|i&:7V 3Bigo0HaId!eIf|me3Olog@SoTigaUbu0A=InaUfru':C*aDi G o,I=,LaL-%Lid!eLo[sN)gemQu{oR<d>e)Rr(Sc~ Sil]S,u+Z Zio3A=D Ge.Ic~ L{oLhiceLu=Nce=rNdav&N( Nt[Rb&Rd!eRe?Rg}h>m`/RnizRs R%n%SpaSti=T|i&3Adu$AgemAj Atu+Br?D{aDr @ElaGaG-%Gi G| L ejoNcoNhe)NilOle)R!>tudeSi.S$Tr&V{oZ*/5A=rArG&L<%LeibolL)gemLumo,Nt!e5L$Vuz`a::D[zRope3QueRe.Rife3Ng ::Ng#Rp 3BuL?9Mb Olog@5Mbi=";
const checksum = "0x2219000926df7b50d8aa0a3d495826b988287df4657fbd100e6fe596c8f737ac";
let wordlist = null;
/**
 *  The [[link-bip39-pt]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangPt extends WordlistOwl {
    /**
     *  Creates a new instance of the Portuguese language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langPt]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("pt", words, checksum); }
    /**
     *  Returns a singleton instance of a ``LangPt``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist == null) {
            wordlist = new LangPt();
        }
        return wordlist;
    }
}

const data = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
const deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
const _wordlist = {
    zh_cn: null,
    zh_tw: null
};
const Checks = {
    zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
    zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
};
const codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
function loadWords(locale) {
    if (_wordlist[locale] != null) {
        return _wordlist[locale];
    }
    const wordlist = [];
    let deltaOffset = 0;
    for (let i = 0; i < 2048; i++) {
        const s = style.indexOf(data[i * 3]);
        const bytes = [
            228 + (s >> 2),
            128 + codes.indexOf(data[i * 3 + 1]),
            128 + codes.indexOf(data[i * 3 + 2]),
        ];
        if (locale === "zh_tw") {
            const common = s % 4;
            for (let i = common; i < 3; i++) {
                bytes[i] = codes.indexOf(deltaData[deltaOffset++]) + ((i == 0) ? 228 : 128);
            }
        }
        wordlist.push(toUtf8String(new Uint8Array(bytes)));
    }
    // Verify the computed list matches the official list
    const checksum = id$1(wordlist.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== Checks[locale]) {
        throw new Error(`BIP39 Wordlist for ${locale} (Chinese) FAILED`);
    }
    /* c8 ignore stop */
    _wordlist[locale] = wordlist;
    return wordlist;
}
const wordlists = {};
/**
 *  The [[link-bip39-zh_cn]] and [[link-bip39-zh_tw]] for
 *  [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangZh extends Wordlist {
    /**
     *  Creates a new instance of the Chinese language Wordlist for
     *  the %%dialect%%, either ``"cn"`` or ``"tw"`` for simplified
     *  or traditional, respectively.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langZhCn]] and [[langZhTw]] should suffice.
     *
     *  @_ignore:
     */
    constructor(dialect) { super("zh_" + dialect); }
    getWord(index) {
        const words = loadWords(this.locale);
        assertArgument(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
        return words[index];
    }
    getWordIndex(word) {
        return loadWords(this.locale).indexOf(word);
    }
    split(phrase) {
        phrase = phrase.replace(/(?:\u3000| )+/g, "");
        return phrase.split("");
    }
    /**
     *  Returns a singleton instance of a ``LangZh`` for %%dialect%%,
     *  creating it if this is the first time being called.
     *
     *  Use the %%dialect%% ``"cn"`` or ``"tw"`` for simplified or
     *  traditional, respectively.
     */
    static wordlist(dialect) {
        if (wordlists[dialect] == null) {
            wordlists[dialect] = new LangZh(dialect);
        }
        return wordlists[dialect];
    }
}

/**
 *  The available Wordlists by their
 *  [ISO 639-1 Language Code](link-wiki-iso639).
 *
 *  (**i.e.** [cz](LangCz), [en](LangEn), [es](LangEs), [fr](LangFr),
 *  [ja](LangJa), [ko](LangKo), [it](LangIt), [pt](LangPt),
 *  [zh_cn](LangZh), [zh_tw](LangZh))
 *
 *  The dist files (in the ``/dist`` folder) have had all languages
 *  except English stripped out, which reduces the library size by
 *  about 80kb. If required, they are available by importing the
 *  included ``wordlists-extra.min.js`` file.
 */
({
    cz: LangCz.wordlist(),
    en: LangEn.wordlist(),
    es: LangEs.wordlist(),
    fr: LangFr.wordlist(),
    it: LangIt.wordlist(),
    pt: LangPt.wordlist(),
    ja: LangJa.wordlist(),
    ko: LangKo.wordlist(),
    zh_cn: LangZh.wordlist("cn"),
    zh_tw: LangZh.wordlist("tw"),
});

var dist$1 = {};

var dist = {};

var decoder = {};

var verbatimString = {};

var hasRequiredVerbatimString;

function requireVerbatimString () {
	if (hasRequiredVerbatimString) return verbatimString;
	hasRequiredVerbatimString = 1;
	Object.defineProperty(verbatimString, "__esModule", { value: true });
	verbatimString.VerbatimString = void 0;
	class VerbatimString extends String {
	    format;
	    constructor(format, value) {
	        super(value);
	        this.format = format;
	    }
	}
	verbatimString.VerbatimString = VerbatimString;
	
	return verbatimString;
}

var errors$1 = {};

var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;
	Object.defineProperty(errors$1, "__esModule", { value: true });
	errors$1.MultiErrorReply = errors$1.TimeoutError = errors$1.BlobError = errors$1.SimpleError = errors$1.ErrorReply = errors$1.ReconnectStrategyError = errors$1.RootNodesUnavailableError = errors$1.SocketClosedUnexpectedlyError = errors$1.DisconnectsClientError = errors$1.ClientOfflineError = errors$1.ClientClosedError = errors$1.SocketTimeoutError = errors$1.ConnectionTimeoutError = errors$1.WatchError = errors$1.AbortError = void 0;
	class AbortError extends Error {
	    constructor() {
	        super('The command was aborted');
	    }
	}
	errors$1.AbortError = AbortError;
	class WatchError extends Error {
	    constructor(message = 'One (or more) of the watched keys has been changed') {
	        super(message);
	    }
	}
	errors$1.WatchError = WatchError;
	class ConnectionTimeoutError extends Error {
	    constructor() {
	        super('Connection timeout');
	    }
	}
	errors$1.ConnectionTimeoutError = ConnectionTimeoutError;
	class SocketTimeoutError extends Error {
	    constructor(timeout) {
	        super(`Socket timeout timeout. Expecting data, but didn't receive any in ${timeout}ms.`);
	    }
	}
	errors$1.SocketTimeoutError = SocketTimeoutError;
	class ClientClosedError extends Error {
	    constructor() {
	        super('The client is closed');
	    }
	}
	errors$1.ClientClosedError = ClientClosedError;
	class ClientOfflineError extends Error {
	    constructor() {
	        super('The client is offline');
	    }
	}
	errors$1.ClientOfflineError = ClientOfflineError;
	class DisconnectsClientError extends Error {
	    constructor() {
	        super('Disconnects client');
	    }
	}
	errors$1.DisconnectsClientError = DisconnectsClientError;
	class SocketClosedUnexpectedlyError extends Error {
	    constructor() {
	        super('Socket closed unexpectedly');
	    }
	}
	errors$1.SocketClosedUnexpectedlyError = SocketClosedUnexpectedlyError;
	class RootNodesUnavailableError extends Error {
	    constructor() {
	        super('All the root nodes are unavailable');
	    }
	}
	errors$1.RootNodesUnavailableError = RootNodesUnavailableError;
	class ReconnectStrategyError extends Error {
	    originalError;
	    socketError;
	    constructor(originalError, socketError) {
	        super(originalError.message);
	        this.originalError = originalError;
	        this.socketError = socketError;
	    }
	}
	errors$1.ReconnectStrategyError = ReconnectStrategyError;
	class ErrorReply extends Error {
	    constructor(message) {
	        super(message);
	        this.stack = undefined;
	    }
	}
	errors$1.ErrorReply = ErrorReply;
	class SimpleError extends ErrorReply {
	}
	errors$1.SimpleError = SimpleError;
	class BlobError extends ErrorReply {
	}
	errors$1.BlobError = BlobError;
	class TimeoutError extends Error {
	}
	errors$1.TimeoutError = TimeoutError;
	class MultiErrorReply extends ErrorReply {
	    replies;
	    errorIndexes;
	    constructor(replies, errorIndexes) {
	        super(`${errorIndexes.length} commands failed, see .replies and .errorIndexes for more information`);
	        this.replies = replies;
	        this.errorIndexes = errorIndexes;
	    }
	    *errors() {
	        for (const index of this.errorIndexes) {
	            yield this.replies[index];
	        }
	    }
	}
	errors$1.MultiErrorReply = MultiErrorReply;
	
	return errors$1;
}

var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return decoder;
	hasRequiredDecoder = 1;
	(function (exports) {
		var _a;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Decoder = exports.PUSH_TYPE_MAPPING = exports.RESP_TYPES = void 0;
		// @ts-nocheck
		const verbatim_string_1 = requireVerbatimString();
		const errors_1 = requireErrors$1();
		// https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md
		exports.RESP_TYPES = {
		    NULL: 95, // _
		    BOOLEAN: 35, // #
		    NUMBER: 58, // :
		    BIG_NUMBER: 40, // (
		    DOUBLE: 44, // ,
		    SIMPLE_STRING: 43, // +
		    BLOB_STRING: 36, // $
		    VERBATIM_STRING: 61, // =
		    SIMPLE_ERROR: 45, // -
		    BLOB_ERROR: 33, // !
		    ARRAY: 42, // *
		    SET: 126, // ~
		    MAP: 37, // %
		    PUSH: 62 // >
		};
		const ASCII = {
		    '\r': 13,
		    't': 116,
		    '+': 43,
		    '-': 45,
		    '0': 48,
		    '.': 46,
		    'i': 105,
		    'n': 110,
		    'E': 69,
		    'e': 101
		};
		exports.PUSH_TYPE_MAPPING = {
		    [exports.RESP_TYPES.BLOB_STRING]: Buffer
		};
		class Decoder {
		    onReply;
		    onErrorReply;
		    onPush;
		    getTypeMapping;
		    #cursor = 0;
		    #next;
		    constructor(config) {
		        this.onReply = config.onReply;
		        this.onErrorReply = config.onErrorReply;
		        this.onPush = config.onPush;
		        this.getTypeMapping = config.getTypeMapping;
		    }
		    reset() {
		        this.#cursor = 0;
		        this.#next = undefined;
		    }
		    write(chunk) {
		        if (this.#cursor >= chunk.length) {
		            this.#cursor -= chunk.length;
		            return;
		        }
		        if (this.#next) {
		            if (this.#next(chunk) || this.#cursor >= chunk.length) {
		                this.#cursor -= chunk.length;
		                return;
		            }
		        }
		        do {
		            const type = chunk[this.#cursor];
		            if (++this.#cursor === chunk.length) {
		                this.#next = this.#continueDecodeTypeValue.bind(this, type);
		                break;
		            }
		            if (this.#decodeTypeValue(type, chunk)) {
		                break;
		            }
		        } while (this.#cursor < chunk.length);
		        this.#cursor -= chunk.length;
		    }
		    #continueDecodeTypeValue(type, chunk) {
		        this.#next = undefined;
		        return this.#decodeTypeValue(type, chunk);
		    }
		    #decodeTypeValue(type, chunk) {
		        switch (type) {
		            case exports.RESP_TYPES.NULL:
		                this.onReply(this.#decodeNull());
		                return false;
		            case exports.RESP_TYPES.BOOLEAN:
		                return this.#handleDecodedValue(this.onReply, this.#decodeBoolean(chunk));
		            case exports.RESP_TYPES.NUMBER:
		                return this.#handleDecodedValue(this.onReply, this.#decodeNumber(this.getTypeMapping()[exports.RESP_TYPES.NUMBER], chunk));
		            case exports.RESP_TYPES.BIG_NUMBER:
		                return this.#handleDecodedValue(this.onReply, this.#decodeBigNumber(this.getTypeMapping()[exports.RESP_TYPES.BIG_NUMBER], chunk));
		            case exports.RESP_TYPES.DOUBLE:
		                return this.#handleDecodedValue(this.onReply, this.#decodeDouble(this.getTypeMapping()[exports.RESP_TYPES.DOUBLE], chunk));
		            case exports.RESP_TYPES.SIMPLE_STRING:
		                return this.#handleDecodedValue(this.onReply, this.#decodeSimpleString(this.getTypeMapping()[exports.RESP_TYPES.SIMPLE_STRING], chunk));
		            case exports.RESP_TYPES.BLOB_STRING:
		                return this.#handleDecodedValue(this.onReply, this.#decodeBlobString(this.getTypeMapping()[exports.RESP_TYPES.BLOB_STRING], chunk));
		            case exports.RESP_TYPES.VERBATIM_STRING:
		                return this.#handleDecodedValue(this.onReply, this.#decodeVerbatimString(this.getTypeMapping()[exports.RESP_TYPES.VERBATIM_STRING], chunk));
		            case exports.RESP_TYPES.SIMPLE_ERROR:
		                return this.#handleDecodedValue(this.onErrorReply, this.#decodeSimpleError(chunk));
		            case exports.RESP_TYPES.BLOB_ERROR:
		                return this.#handleDecodedValue(this.onErrorReply, this.#decodeBlobError(chunk));
		            case exports.RESP_TYPES.ARRAY:
		                return this.#handleDecodedValue(this.onReply, this.#decodeArray(this.getTypeMapping(), chunk));
		            case exports.RESP_TYPES.SET:
		                return this.#handleDecodedValue(this.onReply, this.#decodeSet(this.getTypeMapping(), chunk));
		            case exports.RESP_TYPES.MAP:
		                return this.#handleDecodedValue(this.onReply, this.#decodeMap(this.getTypeMapping(), chunk));
		            case exports.RESP_TYPES.PUSH:
		                return this.#handleDecodedValue(this.onPush, this.#decodeArray(exports.PUSH_TYPE_MAPPING, chunk));
		            default:
		                throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
		        }
		    }
		    #handleDecodedValue(cb, value) {
		        if (typeof value === 'function') {
		            this.#next = this.#continueDecodeValue.bind(this, cb, value);
		            return true;
		        }
		        cb(value);
		        return false;
		    }
		    #continueDecodeValue(cb, next, chunk) {
		        this.#next = undefined;
		        return this.#handleDecodedValue(cb, next(chunk));
		    }
		    #decodeNull() {
		        this.#cursor += 2; // skip \r\n
		        return null;
		    }
		    #decodeBoolean(chunk) {
		        const boolean = chunk[this.#cursor] === ASCII.t;
		        this.#cursor += 3; // skip {t | f}\r\n
		        return boolean;
		    }
		    #decodeNumber(type, chunk) {
		        if (type === String) {
		            return this.#decodeSimpleString(String, chunk);
		        }
		        switch (chunk[this.#cursor]) {
		            case ASCII['+']:
		                return this.#maybeDecodeNumberValue(false, chunk);
		            case ASCII['-']:
		                return this.#maybeDecodeNumberValue(true, chunk);
		            default:
		                return this.#decodeNumberValue(false, this.#decodeUnsingedNumber.bind(this, 0), chunk);
		        }
		    }
		    #maybeDecodeNumberValue(isNegative, chunk) {
		        const cb = this.#decodeUnsingedNumber.bind(this, 0);
		        return ++this.#cursor === chunk.length ?
		            this.#decodeNumberValue.bind(this, isNegative, cb) :
		            this.#decodeNumberValue(isNegative, cb, chunk);
		    }
		    #decodeNumberValue(isNegative, numberCb, chunk) {
		        const number = numberCb(chunk);
		        return typeof number === 'function' ?
		            this.#decodeNumberValue.bind(this, isNegative, number) :
		            isNegative ? -number : number;
		    }
		    #decodeUnsingedNumber(number, chunk) {
		        let cursor = this.#cursor;
		        do {
		            const byte = chunk[cursor];
		            if (byte === ASCII['\r']) {
		                this.#cursor = cursor + 2; // skip \r\n
		                return number;
		            }
		            number = number * 10 + byte - ASCII['0'];
		        } while (++cursor < chunk.length);
		        this.#cursor = cursor;
		        return this.#decodeUnsingedNumber.bind(this, number);
		    }
		    #decodeBigNumber(type, chunk) {
		        if (type === String) {
		            return this.#decodeSimpleString(String, chunk);
		        }
		        switch (chunk[this.#cursor]) {
		            case ASCII['+']:
		                return this.#maybeDecodeBigNumberValue(false, chunk);
		            case ASCII['-']:
		                return this.#maybeDecodeBigNumberValue(true, chunk);
		            default:
		                return this.#decodeBigNumberValue(false, this.#decodeUnsingedBigNumber.bind(this, 0n), chunk);
		        }
		    }
		    #maybeDecodeBigNumberValue(isNegative, chunk) {
		        const cb = this.#decodeUnsingedBigNumber.bind(this, 0n);
		        return ++this.#cursor === chunk.length ?
		            this.#decodeBigNumberValue.bind(this, isNegative, cb) :
		            this.#decodeBigNumberValue(isNegative, cb, chunk);
		    }
		    #decodeBigNumberValue(isNegative, bigNumberCb, chunk) {
		        const bigNumber = bigNumberCb(chunk);
		        return typeof bigNumber === 'function' ?
		            this.#decodeBigNumberValue.bind(this, isNegative, bigNumber) :
		            isNegative ? -bigNumber : bigNumber;
		    }
		    #decodeUnsingedBigNumber(bigNumber, chunk) {
		        let cursor = this.#cursor;
		        do {
		            const byte = chunk[cursor];
		            if (byte === ASCII['\r']) {
		                this.#cursor = cursor + 2; // skip \r\n
		                return bigNumber;
		            }
		            bigNumber = bigNumber * 10n + BigInt(byte - ASCII['0']);
		        } while (++cursor < chunk.length);
		        this.#cursor = cursor;
		        return this.#decodeUnsingedBigNumber.bind(this, bigNumber);
		    }
		    #decodeDouble(type, chunk) {
		        if (type === String) {
		            return this.#decodeSimpleString(String, chunk);
		        }
		        switch (chunk[this.#cursor]) {
		            case ASCII.n:
		                this.#cursor += 5; // skip nan\r\n
		                return NaN;
		            case ASCII['+']:
		                return this.#maybeDecodeDoubleInteger(false, chunk);
		            case ASCII['-']:
		                return this.#maybeDecodeDoubleInteger(true, chunk);
		            default:
		                return this.#decodeDoubleInteger(false, 0, chunk);
		        }
		    }
		    #maybeDecodeDoubleInteger(isNegative, chunk) {
		        return ++this.#cursor === chunk.length ?
		            this.#decodeDoubleInteger.bind(this, isNegative, 0) :
		            this.#decodeDoubleInteger(isNegative, 0, chunk);
		    }
		    #decodeDoubleInteger(isNegative, integer, chunk) {
		        if (chunk[this.#cursor] === ASCII.i) {
		            this.#cursor += 5; // skip inf\r\n
		            return isNegative ? -Infinity : Infinity;
		        }
		        return this.#continueDecodeDoubleInteger(isNegative, integer, chunk);
		    }
		    #continueDecodeDoubleInteger(isNegative, integer, chunk) {
		        let cursor = this.#cursor;
		        do {
		            const byte = chunk[cursor];
		            switch (byte) {
		                case ASCII['.']:
		                    this.#cursor = cursor + 1; // skip .
		                    return this.#cursor < chunk.length ?
		                        this.#decodeDoubleDecimal(isNegative, 0, integer, chunk) :
		                        this.#decodeDoubleDecimal.bind(this, isNegative, 0, integer);
		                case ASCII.E:
		                case ASCII.e:
		                    this.#cursor = cursor + 1; // skip E/e
		                    const i = isNegative ? -integer : integer;
		                    return this.#cursor < chunk.length ?
		                        this.#decodeDoubleExponent(i, chunk) :
		                        this.#decodeDoubleExponent.bind(this, i);
		                case ASCII['\r']:
		                    this.#cursor = cursor + 2; // skip \r\n
		                    return isNegative ? -integer : integer;
		                default:
		                    integer = integer * 10 + byte - ASCII['0'];
		            }
		        } while (++cursor < chunk.length);
		        this.#cursor = cursor;
		        return this.#continueDecodeDoubleInteger.bind(this, isNegative, integer);
		    }
		    // Precalculated multipliers for decimal points to improve performance
		    // "... about 15 to 17 decimal places ..."
		    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#:~:text=about%2015%20to%2017%20decimal%20places
		    static #DOUBLE_DECIMAL_MULTIPLIERS = [
		        1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6,
		        1e-7, 1e-8, 1e-9, 1e-10, 1e-11, 1e-12,
		        1e-13, 1e-14, 1e-15, 1e-16, 1e-17
		    ];
		    #decodeDoubleDecimal(isNegative, decimalIndex, double, chunk) {
		        let cursor = this.#cursor;
		        do {
		            const byte = chunk[cursor];
		            switch (byte) {
		                case ASCII.E:
		                case ASCII.e:
		                    this.#cursor = cursor + 1; // skip E/e
		                    const d = isNegative ? -double : double;
		                    return this.#cursor === chunk.length ?
		                        this.#decodeDoubleExponent.bind(this, d) :
		                        this.#decodeDoubleExponent(d, chunk);
		                case ASCII['\r']:
		                    this.#cursor = cursor + 2; // skip \r\n
		                    return isNegative ? -double : double;
		            }
		            if (decimalIndex < _a.#DOUBLE_DECIMAL_MULTIPLIERS.length) {
		                double += (byte - ASCII['0']) * _a.#DOUBLE_DECIMAL_MULTIPLIERS[decimalIndex++];
		            }
		        } while (++cursor < chunk.length);
		        this.#cursor = cursor;
		        return this.#decodeDoubleDecimal.bind(this, isNegative, decimalIndex, double);
		    }
		    #decodeDoubleExponent(double, chunk) {
		        switch (chunk[this.#cursor]) {
		            case ASCII['+']:
		                return ++this.#cursor === chunk.length ?
		                    this.#continueDecodeDoubleExponent.bind(this, false, double, 0) :
		                    this.#continueDecodeDoubleExponent(false, double, 0, chunk);
		            case ASCII['-']:
		                return ++this.#cursor === chunk.length ?
		                    this.#continueDecodeDoubleExponent.bind(this, true, double, 0) :
		                    this.#continueDecodeDoubleExponent(true, double, 0, chunk);
		        }
		        return this.#continueDecodeDoubleExponent(false, double, 0, chunk);
		    }
		    #continueDecodeDoubleExponent(isNegative, double, exponent, chunk) {
		        let cursor = this.#cursor;
		        do {
		            const byte = chunk[cursor];
		            if (byte === ASCII['\r']) {
		                this.#cursor = cursor + 2; // skip \r\n
		                return double * 10 ** (isNegative ? -exponent : exponent);
		            }
		            exponent = exponent * 10 + byte - ASCII['0'];
		        } while (++cursor < chunk.length);
		        this.#cursor = cursor;
		        return this.#continueDecodeDoubleExponent.bind(this, isNegative, double, exponent);
		    }
		    #findCRLF(chunk, cursor) {
		        while (chunk[cursor] !== ASCII['\r']) {
		            if (++cursor === chunk.length) {
		                this.#cursor = chunk.length;
		                return -1;
		            }
		        }
		        this.#cursor = cursor + 2; // skip \r\n
		        return cursor;
		    }
		    #decodeSimpleString(type, chunk) {
		        const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
		        if (crlfIndex === -1) {
		            return this.#continueDecodeSimpleString.bind(this, [chunk.subarray(start)], type);
		        }
		        const slice = chunk.subarray(start, crlfIndex);
		        return type === Buffer ?
		            slice :
		            slice.toString();
		    }
		    #continueDecodeSimpleString(chunks, type, chunk) {
		        const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
		        if (crlfIndex === -1) {
		            chunks.push(chunk.subarray(start));
		            return this.#continueDecodeSimpleString.bind(this, chunks, type);
		        }
		        chunks.push(chunk.subarray(start, crlfIndex));
		        return type === Buffer ?
		            Buffer.concat(chunks) :
		            chunks.join('');
		    }
		    #decodeBlobString(type, chunk) {
		        // RESP 2 bulk string null
		        // https://github.com/redis/redis-specifications/blob/master/protocol/RESP2.md#resp-bulk-strings
		        if (chunk[this.#cursor] === ASCII['-']) {
		            this.#cursor += 4; // skip -1\r\n
		            return null;
		        }
		        const length = this.#decodeUnsingedNumber(0, chunk);
		        if (typeof length === 'function') {
		            return this.#continueDecodeBlobStringLength.bind(this, length, type);
		        }
		        else if (this.#cursor >= chunk.length) {
		            return this.#decodeBlobStringWithLength.bind(this, length, type);
		        }
		        return this.#decodeBlobStringWithLength(length, type, chunk);
		    }
		    #continueDecodeBlobStringLength(lengthCb, type, chunk) {
		        const length = lengthCb(chunk);
		        if (typeof length === 'function') {
		            return this.#continueDecodeBlobStringLength.bind(this, length, type);
		        }
		        else if (this.#cursor >= chunk.length) {
		            return this.#decodeBlobStringWithLength.bind(this, length, type);
		        }
		        return this.#decodeBlobStringWithLength(length, type, chunk);
		    }
		    #decodeStringWithLength(length, skip, type, chunk) {
		        const end = this.#cursor + length;
		        if (end >= chunk.length) {
		            const slice = chunk.subarray(this.#cursor);
		            this.#cursor = chunk.length;
		            return this.#continueDecodeStringWithLength.bind(this, length - slice.length, [slice], skip, type);
		        }
		        const slice = chunk.subarray(this.#cursor, end);
		        this.#cursor = end + skip;
		        return type === Buffer ?
		            slice :
		            slice.toString();
		    }
		    #continueDecodeStringWithLength(length, chunks, skip, type, chunk) {
		        const end = this.#cursor + length;
		        if (end >= chunk.length) {
		            const slice = chunk.subarray(this.#cursor);
		            chunks.push(slice);
		            this.#cursor = chunk.length;
		            return this.#continueDecodeStringWithLength.bind(this, length - slice.length, chunks, skip, type);
		        }
		        chunks.push(chunk.subarray(this.#cursor, end));
		        this.#cursor = end + skip;
		        return type === Buffer ?
		            Buffer.concat(chunks) :
		            chunks.join('');
		    }
		    #decodeBlobStringWithLength(length, type, chunk) {
		        return this.#decodeStringWithLength(length, 2, type, chunk);
		    }
		    #decodeVerbatimString(type, chunk) {
		        return this.#continueDecodeVerbatimStringLength(this.#decodeUnsingedNumber.bind(this, 0), type, chunk);
		    }
		    #continueDecodeVerbatimStringLength(lengthCb, type, chunk) {
		        const length = lengthCb(chunk);
		        return typeof length === 'function' ?
		            this.#continueDecodeVerbatimStringLength.bind(this, length, type) :
		            this.#decodeVerbatimStringWithLength(length, type, chunk);
		    }
		    #decodeVerbatimStringWithLength(length, type, chunk) {
		        const stringLength = length - 4; // skip <format>:
		        if (type === verbatim_string_1.VerbatimString) {
		            return this.#decodeVerbatimStringFormat(stringLength, chunk);
		        }
		        this.#cursor += 4; // skip <format>:
		        return this.#cursor >= chunk.length ?
		            this.#decodeBlobStringWithLength.bind(this, stringLength, type) :
		            this.#decodeBlobStringWithLength(stringLength, type, chunk);
		    }
		    #decodeVerbatimStringFormat(stringLength, chunk) {
		        const formatCb = this.#decodeStringWithLength.bind(this, 3, 1, String);
		        return this.#cursor >= chunk.length ?
		            this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, formatCb) :
		            this.#continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk);
		    }
		    #continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk) {
		        const format = formatCb(chunk);
		        return typeof format === 'function' ?
		            this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, format) :
		            this.#decodeVerbatimStringWithFormat(stringLength, format, chunk);
		    }
		    #decodeVerbatimStringWithFormat(stringLength, format, chunk) {
		        return this.#continueDecodeVerbatimStringWithFormat(format, this.#decodeBlobStringWithLength.bind(this, stringLength, String), chunk);
		    }
		    #continueDecodeVerbatimStringWithFormat(format, stringCb, chunk) {
		        const string = stringCb(chunk);
		        return typeof string === 'function' ?
		            this.#continueDecodeVerbatimStringWithFormat.bind(this, format, string) :
		            new verbatim_string_1.VerbatimString(format, string);
		    }
		    #decodeSimpleError(chunk) {
		        const string = this.#decodeSimpleString(String, chunk);
		        return typeof string === 'function' ?
		            this.#continueDecodeSimpleError.bind(this, string) :
		            new errors_1.SimpleError(string);
		    }
		    #continueDecodeSimpleError(stringCb, chunk) {
		        const string = stringCb(chunk);
		        return typeof string === 'function' ?
		            this.#continueDecodeSimpleError.bind(this, string) :
		            new errors_1.SimpleError(string);
		    }
		    #decodeBlobError(chunk) {
		        const string = this.#decodeBlobString(String, chunk);
		        return typeof string === 'function' ?
		            this.#continueDecodeBlobError.bind(this, string) :
		            new errors_1.BlobError(string);
		    }
		    #continueDecodeBlobError(stringCb, chunk) {
		        const string = stringCb(chunk);
		        return typeof string === 'function' ?
		            this.#continueDecodeBlobError.bind(this, string) :
		            new errors_1.BlobError(string);
		    }
		    #decodeNestedType(typeMapping, chunk) {
		        const type = chunk[this.#cursor];
		        return ++this.#cursor === chunk.length ?
		            this.#decodeNestedTypeValue.bind(this, type, typeMapping) :
		            this.#decodeNestedTypeValue(type, typeMapping, chunk);
		    }
		    #decodeNestedTypeValue(type, typeMapping, chunk) {
		        switch (type) {
		            case exports.RESP_TYPES.NULL:
		                return this.#decodeNull();
		            case exports.RESP_TYPES.BOOLEAN:
		                return this.#decodeBoolean(chunk);
		            case exports.RESP_TYPES.NUMBER:
		                return this.#decodeNumber(typeMapping[exports.RESP_TYPES.NUMBER], chunk);
		            case exports.RESP_TYPES.BIG_NUMBER:
		                return this.#decodeBigNumber(typeMapping[exports.RESP_TYPES.BIG_NUMBER], chunk);
		            case exports.RESP_TYPES.DOUBLE:
		                return this.#decodeDouble(typeMapping[exports.RESP_TYPES.DOUBLE], chunk);
		            case exports.RESP_TYPES.SIMPLE_STRING:
		                return this.#decodeSimpleString(typeMapping[exports.RESP_TYPES.SIMPLE_STRING], chunk);
		            case exports.RESP_TYPES.BLOB_STRING:
		                return this.#decodeBlobString(typeMapping[exports.RESP_TYPES.BLOB_STRING], chunk);
		            case exports.RESP_TYPES.VERBATIM_STRING:
		                return this.#decodeVerbatimString(typeMapping[exports.RESP_TYPES.VERBATIM_STRING], chunk);
		            case exports.RESP_TYPES.SIMPLE_ERROR:
		                return this.#decodeSimpleError(chunk);
		            case exports.RESP_TYPES.BLOB_ERROR:
		                return this.#decodeBlobError(chunk);
		            case exports.RESP_TYPES.ARRAY:
		                return this.#decodeArray(typeMapping, chunk);
		            case exports.RESP_TYPES.SET:
		                return this.#decodeSet(typeMapping, chunk);
		            case exports.RESP_TYPES.MAP:
		                return this.#decodeMap(typeMapping, chunk);
		            default:
		                throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
		        }
		    }
		    #decodeArray(typeMapping, chunk) {
		        // RESP 2 null
		        // https://github.com/redis/redis-specifications/blob/master/protocol/RESP2.md#resp-arrays
		        if (chunk[this.#cursor] === ASCII['-']) {
		            this.#cursor += 4; // skip -1\r\n
		            return null;
		        }
		        return this.#decodeArrayWithLength(this.#decodeUnsingedNumber(0, chunk), typeMapping, chunk);
		    }
		    #decodeArrayWithLength(length, typeMapping, chunk) {
		        return typeof length === 'function' ?
		            this.#continueDecodeArrayLength.bind(this, length, typeMapping) :
		            this.#decodeArrayItems(new Array(length), 0, typeMapping, chunk);
		    }
		    #continueDecodeArrayLength(lengthCb, typeMapping, chunk) {
		        return this.#decodeArrayWithLength(lengthCb(chunk), typeMapping, chunk);
		    }
		    #decodeArrayItems(array, filled, typeMapping, chunk) {
		        for (let i = filled; i < array.length; i++) {
		            if (this.#cursor >= chunk.length) {
		                return this.#decodeArrayItems.bind(this, array, i, typeMapping);
		            }
		            const item = this.#decodeNestedType(typeMapping, chunk);
		            if (typeof item === 'function') {
		                return this.#continueDecodeArrayItems.bind(this, array, i, item, typeMapping);
		            }
		            array[i] = item;
		        }
		        return array;
		    }
		    #continueDecodeArrayItems(array, filled, itemCb, typeMapping, chunk) {
		        const item = itemCb(chunk);
		        if (typeof item === 'function') {
		            return this.#continueDecodeArrayItems.bind(this, array, filled, item, typeMapping);
		        }
		        array[filled++] = item;
		        return this.#decodeArrayItems(array, filled, typeMapping, chunk);
		    }
		    #decodeSet(typeMapping, chunk) {
		        const length = this.#decodeUnsingedNumber(0, chunk);
		        if (typeof length === 'function') {
		            return this.#continueDecodeSetLength.bind(this, length, typeMapping);
		        }
		        return this.#decodeSetItems(length, typeMapping, chunk);
		    }
		    #continueDecodeSetLength(lengthCb, typeMapping, chunk) {
		        const length = lengthCb(chunk);
		        return typeof length === 'function' ?
		            this.#continueDecodeSetLength.bind(this, length, typeMapping) :
		            this.#decodeSetItems(length, typeMapping, chunk);
		    }
		    #decodeSetItems(length, typeMapping, chunk) {
		        return typeMapping[exports.RESP_TYPES.SET] === Set ?
		            this.#decodeSetAsSet(new Set(), length, typeMapping, chunk) :
		            this.#decodeArrayItems(new Array(length), 0, typeMapping, chunk);
		    }
		    #decodeSetAsSet(set, remaining, typeMapping, chunk) {
		        // using `remaining` instead of `length` & `set.size` to make it work even if the set contains duplicates
		        while (remaining > 0) {
		            if (this.#cursor >= chunk.length) {
		                return this.#decodeSetAsSet.bind(this, set, remaining, typeMapping);
		            }
		            const item = this.#decodeNestedType(typeMapping, chunk);
		            if (typeof item === 'function') {
		                return this.#continueDecodeSetAsSet.bind(this, set, remaining, item, typeMapping);
		            }
		            set.add(item);
		            --remaining;
		        }
		        return set;
		    }
		    #continueDecodeSetAsSet(set, remaining, itemCb, typeMapping, chunk) {
		        const item = itemCb(chunk);
		        if (typeof item === 'function') {
		            return this.#continueDecodeSetAsSet.bind(this, set, remaining, item, typeMapping);
		        }
		        set.add(item);
		        return this.#decodeSetAsSet(set, remaining - 1, typeMapping, chunk);
		    }
		    #decodeMap(typeMapping, chunk) {
		        const length = this.#decodeUnsingedNumber(0, chunk);
		        if (typeof length === 'function') {
		            return this.#continueDecodeMapLength.bind(this, length, typeMapping);
		        }
		        return this.#decodeMapItems(length, typeMapping, chunk);
		    }
		    #continueDecodeMapLength(lengthCb, typeMapping, chunk) {
		        const length = lengthCb(chunk);
		        return typeof length === 'function' ?
		            this.#continueDecodeMapLength.bind(this, length, typeMapping) :
		            this.#decodeMapItems(length, typeMapping, chunk);
		    }
		    #decodeMapItems(length, typeMapping, chunk) {
		        switch (typeMapping[exports.RESP_TYPES.MAP]) {
		            case Map:
		                return this.#decodeMapAsMap(new Map(), length, typeMapping, chunk);
		            case Array:
		                return this.#decodeArrayItems(new Array(length * 2), 0, typeMapping, chunk);
		            default:
		                return this.#decodeMapAsObject(Object.create(null), length, typeMapping, chunk);
		        }
		    }
		    #decodeMapAsMap(map, remaining, typeMapping, chunk) {
		        // using `remaining` instead of `length` & `map.size` to make it work even if the map contains duplicate keys
		        while (remaining > 0) {
		            if (this.#cursor >= chunk.length) {
		                return this.#decodeMapAsMap.bind(this, map, remaining, typeMapping);
		            }
		            const key = this.#decodeMapKey(typeMapping, chunk);
		            if (typeof key === 'function') {
		                return this.#continueDecodeMapKey.bind(this, map, remaining, key, typeMapping);
		            }
		            if (this.#cursor >= chunk.length) {
		                return this.#continueDecodeMapValue.bind(this, map, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
		            }
		            const value = this.#decodeNestedType(typeMapping, chunk);
		            if (typeof value === 'function') {
		                return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
		            }
		            map.set(key, value);
		            --remaining;
		        }
		        return map;
		    }
		    #decodeMapKey(typeMapping, chunk) {
		        const type = chunk[this.#cursor];
		        return ++this.#cursor === chunk.length ?
		            this.#decodeMapKeyValue.bind(this, type, typeMapping) :
		            this.#decodeMapKeyValue(type, typeMapping, chunk);
		    }
		    #decodeMapKeyValue(type, typeMapping, chunk) {
		        switch (type) {
		            // decode simple string map key as string (and not as buffer)
		            case exports.RESP_TYPES.SIMPLE_STRING:
		                return this.#decodeSimpleString(String, chunk);
		            // decode blob string map key as string (and not as buffer)
		            case exports.RESP_TYPES.BLOB_STRING:
		                return this.#decodeBlobString(String, chunk);
		            default:
		                return this.#decodeNestedTypeValue(type, typeMapping, chunk);
		        }
		    }
		    #continueDecodeMapKey(map, remaining, keyCb, typeMapping, chunk) {
		        const key = keyCb(chunk);
		        if (typeof key === 'function') {
		            return this.#continueDecodeMapKey.bind(this, map, remaining, key, typeMapping);
		        }
		        if (this.#cursor >= chunk.length) {
		            return this.#continueDecodeMapValue.bind(this, map, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
		        }
		        const value = this.#decodeNestedType(typeMapping, chunk);
		        if (typeof value === 'function') {
		            return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
		        }
		        map.set(key, value);
		        return this.#decodeMapAsMap(map, remaining - 1, typeMapping, chunk);
		    }
		    #continueDecodeMapValue(map, remaining, key, valueCb, typeMapping, chunk) {
		        const value = valueCb(chunk);
		        if (typeof value === 'function') {
		            return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
		        }
		        map.set(key, value);
		        return this.#decodeMapAsMap(map, remaining - 1, typeMapping, chunk);
		    }
		    #decodeMapAsObject(object, remaining, typeMapping, chunk) {
		        while (remaining > 0) {
		            if (this.#cursor >= chunk.length) {
		                return this.#decodeMapAsObject.bind(this, object, remaining, typeMapping);
		            }
		            const key = this.#decodeMapKey(typeMapping, chunk);
		            if (typeof key === 'function') {
		                return this.#continueDecodeMapAsObjectKey.bind(this, object, remaining, key, typeMapping);
		            }
		            if (this.#cursor >= chunk.length) {
		                return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
		            }
		            const value = this.#decodeNestedType(typeMapping, chunk);
		            if (typeof value === 'function') {
		                return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
		            }
		            object[key] = value;
		            --remaining;
		        }
		        return object;
		    }
		    #continueDecodeMapAsObjectKey(object, remaining, keyCb, typeMapping, chunk) {
		        const key = keyCb(chunk);
		        if (typeof key === 'function') {
		            return this.#continueDecodeMapAsObjectKey.bind(this, object, remaining, key, typeMapping);
		        }
		        if (this.#cursor >= chunk.length) {
		            return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
		        }
		        const value = this.#decodeNestedType(typeMapping, chunk);
		        if (typeof value === 'function') {
		            return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
		        }
		        object[key] = value;
		        return this.#decodeMapAsObject(object, remaining - 1, typeMapping, chunk);
		    }
		    #continueDecodeMapAsObjectValue(object, remaining, key, valueCb, typeMapping, chunk) {
		        const value = valueCb(chunk);
		        if (typeof value === 'function') {
		            return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
		        }
		        object[key] = value;
		        return this.#decodeMapAsObject(object, remaining - 1, typeMapping, chunk);
		    }
		}
		exports.Decoder = Decoder;
		_a = Decoder;
		
	} (decoder));
	return decoder;
}

var luaScript = {};

var hasRequiredLuaScript;

function requireLuaScript () {
	if (hasRequiredLuaScript) return luaScript;
	hasRequiredLuaScript = 1;
	Object.defineProperty(luaScript, "__esModule", { value: true });
	luaScript.scriptSha1 = luaScript.defineScript = void 0;
	const node_crypto_1 = require$$0$4;
	function defineScript(script) {
	    return {
	        ...script,
	        SHA1: scriptSha1(script.SCRIPT)
	    };
	}
	luaScript.defineScript = defineScript;
	function scriptSha1(script) {
	    return (0, node_crypto_1.createHash)('sha1').update(script).digest('hex');
	}
	luaScript.scriptSha1 = scriptSha1;
	
	return luaScript;
}

var client = {};

var commands$5 = {};

var ACL_CAT = {};

var hasRequiredACL_CAT;

function requireACL_CAT () {
	if (hasRequiredACL_CAT) return ACL_CAT;
	hasRequiredACL_CAT = 1;
	Object.defineProperty(ACL_CAT, "__esModule", { value: true });
	ACL_CAT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Lists ACL categories or commands in a category
	     * @param parser - The Redis command parser
	     * @param categoryName - Optional category name to filter commands
	     */
	    parseCommand(parser, categoryName) {
	        parser.push('ACL', 'CAT');
	        if (categoryName) {
	            parser.push(categoryName);
	        }
	    },
	    transformReply: undefined
	};
	
	return ACL_CAT;
}

var ACL_DELUSER = {};

var hasRequiredACL_DELUSER;

function requireACL_DELUSER () {
	if (hasRequiredACL_DELUSER) return ACL_DELUSER;
	hasRequiredACL_DELUSER = 1;
	Object.defineProperty(ACL_DELUSER, "__esModule", { value: true });
	ACL_DELUSER.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Deletes one or more users from the ACL
	     * @param parser - The Redis command parser
	     * @param username - Username(s) to delete
	     */
	    parseCommand(parser, username) {
	        parser.push('ACL', 'DELUSER');
	        parser.pushVariadic(username);
	    },
	    transformReply: undefined
	};
	
	return ACL_DELUSER;
}

var ACL_DRYRUN = {};

var hasRequiredACL_DRYRUN;

function requireACL_DRYRUN () {
	if (hasRequiredACL_DRYRUN) return ACL_DRYRUN;
	hasRequiredACL_DRYRUN = 1;
	Object.defineProperty(ACL_DRYRUN, "__esModule", { value: true });
	ACL_DRYRUN.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Simulates ACL operations without executing them
	     * @param parser - The Redis command parser
	     * @param username - Username to simulate ACL operations for
	     * @param command - Command arguments to simulate
	     */
	    parseCommand(parser, username, command) {
	        parser.push('ACL', 'DRYRUN', username, ...command);
	    },
	    transformReply: undefined
	};
	
	return ACL_DRYRUN;
}

var ACL_GENPASS = {};

var hasRequiredACL_GENPASS;

function requireACL_GENPASS () {
	if (hasRequiredACL_GENPASS) return ACL_GENPASS;
	hasRequiredACL_GENPASS = 1;
	Object.defineProperty(ACL_GENPASS, "__esModule", { value: true });
	ACL_GENPASS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Generates a secure password for ACL users
	     * @param parser - The Redis command parser
	     * @param bits - Optional number of bits for password entropy
	     */
	    parseCommand(parser, bits) {
	        parser.push('ACL', 'GENPASS');
	        if (bits) {
	            parser.push(bits.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return ACL_GENPASS;
}

var ACL_GETUSER = {};

var hasRequiredACL_GETUSER;

function requireACL_GETUSER () {
	if (hasRequiredACL_GETUSER) return ACL_GETUSER;
	hasRequiredACL_GETUSER = 1;
	Object.defineProperty(ACL_GETUSER, "__esModule", { value: true });
	ACL_GETUSER.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns ACL information about a specific user
	     * @param parser - The Redis command parser
	     * @param username - Username to get information for
	     */
	    parseCommand(parser, username) {
	        parser.push('ACL', 'GETUSER', username);
	    },
	    transformReply: {
	        2: (reply) => ({
	            flags: reply[1],
	            passwords: reply[3],
	            commands: reply[5],
	            keys: reply[7],
	            channels: reply[9],
	            selectors: reply[11]?.map(selector => {
	                const inferred = selector;
	                return {
	                    commands: inferred[1],
	                    keys: inferred[3],
	                    channels: inferred[5]
	                };
	            })
	        }),
	        3: undefined
	    }
	};
	
	return ACL_GETUSER;
}

var ACL_LIST = {};

var hasRequiredACL_LIST;

function requireACL_LIST () {
	if (hasRequiredACL_LIST) return ACL_LIST;
	hasRequiredACL_LIST = 1;
	Object.defineProperty(ACL_LIST, "__esModule", { value: true });
	ACL_LIST.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns all configured ACL users and their permissions
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('ACL', 'LIST');
	    },
	    transformReply: undefined
	};
	
	return ACL_LIST;
}

var ACL_LOAD = {};

var hasRequiredACL_LOAD;

function requireACL_LOAD () {
	if (hasRequiredACL_LOAD) return ACL_LOAD;
	hasRequiredACL_LOAD = 1;
	Object.defineProperty(ACL_LOAD, "__esModule", { value: true });
	ACL_LOAD.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Reloads ACL configuration from the ACL file
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('ACL', 'LOAD');
	    },
	    transformReply: undefined
	};
	
	return ACL_LOAD;
}

var ACL_LOG_RESET = {};

var ACL_LOG = {};

var genericTransformers = {};

var parser = {};

var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser;
	hasRequiredParser = 1;
	Object.defineProperty(parser, "__esModule", { value: true });
	parser.BasicCommandParser = void 0;
	class BasicCommandParser {
	    #redisArgs = [];
	    #keys = [];
	    preserve;
	    get redisArgs() {
	        return this.#redisArgs;
	    }
	    get keys() {
	        return this.#keys;
	    }
	    get firstKey() {
	        return this.#keys[0];
	    }
	    get cacheKey() {
	        const tmp = new Array(this.#redisArgs.length * 2);
	        for (let i = 0; i < this.#redisArgs.length; i++) {
	            tmp[i] = this.#redisArgs[i].length;
	            tmp[i + this.#redisArgs.length] = this.#redisArgs[i];
	        }
	        return tmp.join('_');
	    }
	    push(...arg) {
	        this.#redisArgs.push(...arg);
	    }
	    ;
	    pushVariadic(vals) {
	        if (Array.isArray(vals)) {
	            for (const val of vals) {
	                this.push(val);
	            }
	        }
	        else {
	            this.push(vals);
	        }
	    }
	    pushVariadicWithLength(vals) {
	        if (Array.isArray(vals)) {
	            this.#redisArgs.push(vals.length.toString());
	        }
	        else {
	            this.#redisArgs.push('1');
	        }
	        this.pushVariadic(vals);
	    }
	    pushVariadicNumber(vals) {
	        if (Array.isArray(vals)) {
	            for (const val of vals) {
	                this.push(val.toString());
	            }
	        }
	        else {
	            this.push(vals.toString());
	        }
	    }
	    pushKey(key) {
	        this.#keys.push(key);
	        this.#redisArgs.push(key);
	    }
	    pushKeysLength(keys) {
	        if (Array.isArray(keys)) {
	            this.#redisArgs.push(keys.length.toString());
	        }
	        else {
	            this.#redisArgs.push('1');
	        }
	        this.pushKeys(keys);
	    }
	    pushKeys(keys) {
	        if (Array.isArray(keys)) {
	            this.#keys.push(...keys);
	            this.#redisArgs.push(...keys);
	        }
	        else {
	            this.#keys.push(keys);
	            this.#redisArgs.push(keys);
	        }
	    }
	}
	parser.BasicCommandParser = BasicCommandParser;
	
	return parser;
}

var hasRequiredGenericTransformers;

function requireGenericTransformers () {
	if (hasRequiredGenericTransformers) return genericTransformers;
	hasRequiredGenericTransformers = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = exports.transformStreamsMessagesReplyResp3 = exports.transformStreamsMessagesReplyResp2 = exports.transformStreamMessagesReply = exports.transformStreamMessageNullReply = exports.transformStreamMessageReply = exports.parseArgs = exports.parseZKeysArguments = exports.transformRangeReply = exports.parseSlotRangesArguments = exports.transformFunctionListItemReply = exports.RedisFunctionFlags = exports.transformCommandReply = exports.CommandCategories = exports.CommandFlags = exports.parseOptionalVariadicArgument = exports.pushVariadicArgument = exports.pushVariadicNumberArguments = exports.pushVariadicArguments = exports.pushEvalArguments = exports.evalFirstKeyIndex = exports.transformPXAT = exports.transformEXAT = exports.transformSortedSetReply = exports.transformTuplesReply = exports.createTransformTuplesReplyFunc = exports.transformTuplesToMap = exports.transformNullableDoubleReply = exports.createTransformNullableDoubleReplyResp2Func = exports.transformDoubleArrayReply = exports.createTransformDoubleReplyResp2Func = exports.transformDoubleReply = exports.transformStringDoubleArgument = exports.transformDoubleArgument = exports.transformBooleanArrayReply = exports.transformBooleanReply = exports.isArrayReply = exports.isNullReply = void 0;
		const parser_1 = requireParser();
		const decoder_1 = requireDecoder();
		function isNullReply(reply) {
		    return reply === null;
		}
		exports.isNullReply = isNullReply;
		function isArrayReply(reply) {
		    return Array.isArray(reply);
		}
		exports.isArrayReply = isArrayReply;
		exports.transformBooleanReply = {
		    2: (reply) => reply === 1,
		    3: undefined
		};
		exports.transformBooleanArrayReply = {
		    2: (reply) => {
		        return reply.map(exports.transformBooleanReply[2]);
		    },
		    3: undefined
		};
		function transformDoubleArgument(num) {
		    switch (num) {
		        case Infinity:
		            return '+inf';
		        case -Infinity:
		            return '-inf';
		        default:
		            return num.toString();
		    }
		}
		exports.transformDoubleArgument = transformDoubleArgument;
		function transformStringDoubleArgument(num) {
		    if (typeof num !== 'number')
		        return num;
		    return transformDoubleArgument(num);
		}
		exports.transformStringDoubleArgument = transformStringDoubleArgument;
		exports.transformDoubleReply = {
		    2: (reply, preserve, typeMapping) => {
		        const double = typeMapping ? typeMapping[decoder_1.RESP_TYPES.DOUBLE] : undefined;
		        switch (double) {
		            case String: {
		                return reply;
		            }
		            default: {
		                let ret;
		                switch (reply.toString()) {
		                    case 'inf':
		                    case '+inf':
		                        ret = Infinity;
		                    case '-inf':
		                        ret = -Infinity;
		                    case 'nan':
		                        ret = NaN;
		                    default:
		                        ret = Number(reply);
		                }
		                return ret;
		            }
		        }
		    },
		    3: undefined
		};
		function createTransformDoubleReplyResp2Func(preserve, typeMapping) {
		    return (reply) => {
		        return exports.transformDoubleReply[2](reply, preserve, typeMapping);
		    };
		}
		exports.createTransformDoubleReplyResp2Func = createTransformDoubleReplyResp2Func;
		exports.transformDoubleArrayReply = {
		    2: (reply, preserve, typeMapping) => {
		        return reply.map(createTransformDoubleReplyResp2Func(preserve, typeMapping));
		    },
		    3: undefined
		};
		function createTransformNullableDoubleReplyResp2Func(preserve, typeMapping) {
		    return (reply) => {
		        return exports.transformNullableDoubleReply[2](reply, preserve, typeMapping);
		    };
		}
		exports.createTransformNullableDoubleReplyResp2Func = createTransformNullableDoubleReplyResp2Func;
		exports.transformNullableDoubleReply = {
		    2: (reply, preserve, typeMapping) => {
		        if (reply === null)
		            return null;
		        return exports.transformDoubleReply[2](reply, preserve, typeMapping);
		    },
		    3: undefined
		};
		function transformTuplesToMap(reply, func) {
		    const message = Object.create(null);
		    for (let i = 0; i < reply.length; i += 2) {
		        message[reply[i].toString()] = func(reply[i + 1]);
		    }
		    return message;
		}
		exports.transformTuplesToMap = transformTuplesToMap;
		function createTransformTuplesReplyFunc(preserve, typeMapping) {
		    return (reply) => {
		        return transformTuplesReply(reply, preserve, typeMapping);
		    };
		}
		exports.createTransformTuplesReplyFunc = createTransformTuplesReplyFunc;
		function transformTuplesReply(reply, preserve, typeMapping) {
		    const mapType = typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : undefined;
		    const inferred = reply;
		    switch (mapType) {
		        case Array: {
		            return reply;
		        }
		        case Map: {
		            const ret = new Map;
		            for (let i = 0; i < inferred.length; i += 2) {
		                ret.set(inferred[i].toString(), inferred[i + 1]);
		            }
		            return ret;
		        }
		        default: {
		            const ret = Object.create(null);
		            for (let i = 0; i < inferred.length; i += 2) {
		                ret[inferred[i].toString()] = inferred[i + 1];
		            }
		            return ret;
		        }
		    }
		}
		exports.transformTuplesReply = transformTuplesReply;
		exports.transformSortedSetReply = {
		    2: (reply, preserve, typeMapping) => {
		        const inferred = reply, members = [];
		        for (let i = 0; i < inferred.length; i += 2) {
		            members.push({
		                value: inferred[i],
		                score: exports.transformDoubleReply[2](inferred[i + 1], preserve, typeMapping)
		            });
		        }
		        return members;
		    },
		    3: (reply) => {
		        return reply.map(member => {
		            const [value, score] = member;
		            return {
		                value,
		                score
		            };
		        });
		    }
		};
		function transformEXAT(EXAT) {
		    return (typeof EXAT === 'number' ? EXAT : Math.floor(EXAT.getTime() / 1000)).toString();
		}
		exports.transformEXAT = transformEXAT;
		function transformPXAT(PXAT) {
		    return (typeof PXAT === 'number' ? PXAT : PXAT.getTime()).toString();
		}
		exports.transformPXAT = transformPXAT;
		function evalFirstKeyIndex(options) {
		    return options?.keys?.[0];
		}
		exports.evalFirstKeyIndex = evalFirstKeyIndex;
		function pushEvalArguments(args, options) {
		    if (options?.keys) {
		        args.push(options.keys.length.toString(), ...options.keys);
		    }
		    else {
		        args.push('0');
		    }
		    if (options?.arguments) {
		        args.push(...options.arguments);
		    }
		    return args;
		}
		exports.pushEvalArguments = pushEvalArguments;
		function pushVariadicArguments(args, value) {
		    if (Array.isArray(value)) {
		        // https://github.com/redis/node-redis/pull/2160
		        args = args.concat(value);
		    }
		    else {
		        args.push(value);
		    }
		    return args;
		}
		exports.pushVariadicArguments = pushVariadicArguments;
		function pushVariadicNumberArguments(args, value) {
		    if (Array.isArray(value)) {
		        for (const item of value) {
		            args.push(item.toString());
		        }
		    }
		    else {
		        args.push(value.toString());
		    }
		    return args;
		}
		exports.pushVariadicNumberArguments = pushVariadicNumberArguments;
		function pushVariadicArgument(args, value) {
		    if (Array.isArray(value)) {
		        args.push(value.length.toString(), ...value);
		    }
		    else {
		        args.push('1', value);
		    }
		    return args;
		}
		exports.pushVariadicArgument = pushVariadicArgument;
		function parseOptionalVariadicArgument(parser, name, value) {
		    if (value === undefined)
		        return;
		    parser.push(name);
		    parser.pushVariadicWithLength(value);
		}
		exports.parseOptionalVariadicArgument = parseOptionalVariadicArgument;
		var CommandFlags;
		(function (CommandFlags) {
		    CommandFlags["WRITE"] = "write";
		    CommandFlags["READONLY"] = "readonly";
		    CommandFlags["DENYOOM"] = "denyoom";
		    CommandFlags["ADMIN"] = "admin";
		    CommandFlags["PUBSUB"] = "pubsub";
		    CommandFlags["NOSCRIPT"] = "noscript";
		    CommandFlags["RANDOM"] = "random";
		    CommandFlags["SORT_FOR_SCRIPT"] = "sort_for_script";
		    CommandFlags["LOADING"] = "loading";
		    CommandFlags["STALE"] = "stale";
		    CommandFlags["SKIP_MONITOR"] = "skip_monitor";
		    CommandFlags["ASKING"] = "asking";
		    CommandFlags["FAST"] = "fast";
		    CommandFlags["MOVABLEKEYS"] = "movablekeys"; // keys have no pre-determined position. You must discover keys yourself.
		})(CommandFlags || (exports.CommandFlags = CommandFlags = {}));
		var CommandCategories;
		(function (CommandCategories) {
		    CommandCategories["KEYSPACE"] = "@keyspace";
		    CommandCategories["READ"] = "@read";
		    CommandCategories["WRITE"] = "@write";
		    CommandCategories["SET"] = "@set";
		    CommandCategories["SORTEDSET"] = "@sortedset";
		    CommandCategories["LIST"] = "@list";
		    CommandCategories["HASH"] = "@hash";
		    CommandCategories["STRING"] = "@string";
		    CommandCategories["BITMAP"] = "@bitmap";
		    CommandCategories["HYPERLOGLOG"] = "@hyperloglog";
		    CommandCategories["GEO"] = "@geo";
		    CommandCategories["STREAM"] = "@stream";
		    CommandCategories["PUBSUB"] = "@pubsub";
		    CommandCategories["ADMIN"] = "@admin";
		    CommandCategories["FAST"] = "@fast";
		    CommandCategories["SLOW"] = "@slow";
		    CommandCategories["BLOCKING"] = "@blocking";
		    CommandCategories["DANGEROUS"] = "@dangerous";
		    CommandCategories["CONNECTION"] = "@connection";
		    CommandCategories["TRANSACTION"] = "@transaction";
		    CommandCategories["SCRIPTING"] = "@scripting";
		})(CommandCategories || (exports.CommandCategories = CommandCategories = {}));
		function transformCommandReply([name, arity, flags, firstKeyIndex, lastKeyIndex, step, categories]) {
		    return {
		        name,
		        arity,
		        flags: new Set(flags),
		        firstKeyIndex,
		        lastKeyIndex,
		        step,
		        categories: new Set(categories)
		    };
		}
		exports.transformCommandReply = transformCommandReply;
		var RedisFunctionFlags;
		(function (RedisFunctionFlags) {
		    RedisFunctionFlags["NO_WRITES"] = "no-writes";
		    RedisFunctionFlags["ALLOW_OOM"] = "allow-oom";
		    RedisFunctionFlags["ALLOW_STALE"] = "allow-stale";
		    RedisFunctionFlags["NO_CLUSTER"] = "no-cluster";
		})(RedisFunctionFlags || (exports.RedisFunctionFlags = RedisFunctionFlags = {}));
		function transformFunctionListItemReply(reply) {
		    return {
		        libraryName: reply[1],
		        engine: reply[3],
		        functions: reply[5].map(fn => ({
		            name: fn[1],
		            description: fn[3],
		            flags: fn[5]
		        }))
		    };
		}
		exports.transformFunctionListItemReply = transformFunctionListItemReply;
		function parseSlotRangeArguments(parser, range) {
		    parser.push(range.start.toString(), range.end.toString());
		}
		function parseSlotRangesArguments(parser, ranges) {
		    if (Array.isArray(ranges)) {
		        for (const range of ranges) {
		            parseSlotRangeArguments(parser, range);
		        }
		    }
		    else {
		        parseSlotRangeArguments(parser, ranges);
		    }
		}
		exports.parseSlotRangesArguments = parseSlotRangesArguments;
		function transformRangeReply([start, end]) {
		    return {
		        start,
		        end
		    };
		}
		exports.transformRangeReply = transformRangeReply;
		function parseZKeysArguments(parser, keys) {
		    if (Array.isArray(keys)) {
		        parser.push(keys.length.toString());
		        if (keys.length) {
		            if (isPlainKeys(keys)) {
		                parser.pushKeys(keys);
		            }
		            else {
		                for (let i = 0; i < keys.length; i++) {
		                    parser.pushKey(keys[i].key);
		                }
		                parser.push('WEIGHTS');
		                for (let i = 0; i < keys.length; i++) {
		                    parser.push(transformDoubleArgument(keys[i].weight));
		                }
		            }
		        }
		    }
		    else {
		        parser.push('1');
		        if (isPlainKey(keys)) {
		            parser.pushKey(keys);
		        }
		        else {
		            parser.pushKey(keys.key);
		            parser.push('WEIGHTS', transformDoubleArgument(keys.weight));
		        }
		    }
		}
		exports.parseZKeysArguments = parseZKeysArguments;
		function isPlainKey(key) {
		    return typeof key === 'string' || key instanceof Buffer;
		}
		function isPlainKeys(keys) {
		    return isPlainKey(keys[0]);
		}
		/**
		 * @deprecated
		 */
		function parseArgs(command, ...args) {
		    const parser = new parser_1.BasicCommandParser();
		    command.parseCommand(parser, ...args);
		    const redisArgs = parser.redisArgs;
		    if (parser.preserve) {
		        redisArgs.preserve = parser.preserve;
		    }
		    return redisArgs;
		}
		exports.parseArgs = parseArgs;
		function transformStreamMessageReply(typeMapping, reply) {
		    const [id, message] = reply;
		    return {
		        id: id,
		        message: transformTuplesReply(message, undefined, typeMapping)
		    };
		}
		exports.transformStreamMessageReply = transformStreamMessageReply;
		function transformStreamMessageNullReply(typeMapping, reply) {
		    return isNullReply(reply) ? reply : transformStreamMessageReply(typeMapping, reply);
		}
		exports.transformStreamMessageNullReply = transformStreamMessageNullReply;
		function transformStreamMessagesReply(r, typeMapping) {
		    const reply = r;
		    return reply.map(transformStreamMessageReply.bind(undefined, typeMapping));
		}
		exports.transformStreamMessagesReply = transformStreamMessagesReply;
		function transformStreamsMessagesReplyResp2(reply, preserve, typeMapping) {
		    // FUTURE: resposne type if resp3 was working, reverting to old v4 for now
		    //: MapReply<BlobStringReply | string, StreamMessagesReply> | NullReply {
		    if (reply === null)
		        return null;
		    switch (typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : undefined) {
		        /* FUTURE: a response type for when resp3 is working properly
		            case Map: {
		              const ret = new Map<string, StreamMessagesReply>();
		        
		              for (let i=0; i < reply.length; i++) {
		                const stream = reply[i] as unknown as UnwrapReply<StreamMessagesRawReply>;
		            
		                const name = stream[0];
		                const rawMessages = stream[1];
		            
		                ret.set(name.toString(), transformStreamMessagesReply(rawMessages, typeMapping));
		              }
		            
		              return ret as unknown as MapReply<string, StreamMessagesReply>;
		            }
		            case Array: {
		              const ret: Array<BlobStringReply | StreamMessagesReply> = [];
		        
		              for (let i=0; i < reply.length; i++) {
		                const stream = reply[i] as unknown as UnwrapReply<StreamMessagesRawReply>;
		            
		                const name = stream[0];
		                const rawMessages = stream[1];
		            
		                ret.push(name);
		                ret.push(transformStreamMessagesReply(rawMessages, typeMapping));
		              }
		        
		              return ret as unknown as MapReply<string, StreamMessagesReply>;
		            }
		            default: {
		              const ret: Record<string, StreamMessagesReply> = Object.create(null);
		        
		              for (let i=0; i < reply.length; i++) {
		                const stream = reply[i] as unknown as UnwrapReply<StreamMessagesRawReply>;
		            
		                const name = stream[0] as unknown as UnwrapReply<BlobStringReply>;
		                const rawMessages = stream[1];
		            
		                ret[name.toString()] = transformStreamMessagesReply(rawMessages);
		              }
		            
		              return ret as unknown as MapReply<string, StreamMessagesReply>;
		            }
		        */
		        // V4 compatible response type
		        default: {
		            const ret = [];
		            for (let i = 0; i < reply.length; i++) {
		                const stream = reply[i];
		                ret.push({
		                    name: stream[0],
		                    messages: transformStreamMessagesReply(stream[1])
		                });
		            }
		            return ret;
		        }
		    }
		}
		exports.transformStreamsMessagesReplyResp2 = transformStreamsMessagesReplyResp2;
		function transformStreamsMessagesReplyResp3(reply) {
		    if (reply === null)
		        return null;
		    if (reply instanceof Map) {
		        const ret = new Map();
		        for (const [n, rawMessages] of reply) {
		            const name = n;
		            ret.set(name.toString(), transformStreamMessagesReply(rawMessages));
		        }
		        return ret;
		    }
		    else if (reply instanceof Array) {
		        const ret = [];
		        for (let i = 0; i < reply.length; i += 2) {
		            const name = reply[i];
		            const rawMessages = reply[i + 1];
		            ret.push(name);
		            ret.push(transformStreamMessagesReply(rawMessages));
		        }
		        return ret;
		    }
		    else {
		        const ret = Object.create(null);
		        for (const [name, rawMessages] of Object.entries(reply)) {
		            ret[name] = transformStreamMessagesReply(rawMessages);
		        }
		        return ret;
		    }
		}
		exports.transformStreamsMessagesReplyResp3 = transformStreamsMessagesReplyResp3;
		function transformRedisJsonArgument(json) {
		    return JSON.stringify(json);
		}
		exports.transformRedisJsonArgument = transformRedisJsonArgument;
		function transformRedisJsonReply(json) {
		    const res = JSON.parse(json.toString());
		    return res;
		}
		exports.transformRedisJsonReply = transformRedisJsonReply;
		function transformRedisJsonNullReply(json) {
		    return isNullReply(json) ? json : transformRedisJsonReply(json);
		}
		exports.transformRedisJsonNullReply = transformRedisJsonNullReply;
		
	} (genericTransformers));
	return genericTransformers;
}

var hasRequiredACL_LOG;

function requireACL_LOG () {
	if (hasRequiredACL_LOG) return ACL_LOG;
	hasRequiredACL_LOG = 1;
	Object.defineProperty(ACL_LOG, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ACL_LOG.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns ACL security events log entries
	     * @param parser - The Redis command parser
	     * @param count - Optional maximum number of entries to return
	     */
	    parseCommand(parser, count) {
	        parser.push('ACL', 'LOG');
	        if (count != undefined) {
	            parser.push(count.toString());
	        }
	    },
	    transformReply: {
	        2: (reply, preserve, typeMapping) => {
	            return reply.map(item => {
	                const inferred = item;
	                return {
	                    count: inferred[1],
	                    reason: inferred[3],
	                    context: inferred[5],
	                    object: inferred[7],
	                    username: inferred[9],
	                    'age-seconds': generic_transformers_1.transformDoubleReply[2](inferred[11], preserve, typeMapping),
	                    'client-info': inferred[13],
	                    'entry-id': inferred[15],
	                    'timestamp-created': inferred[17],
	                    'timestamp-last-updated': inferred[19]
	                };
	            });
	        },
	        3: undefined
	    }
	};
	
	return ACL_LOG;
}

var hasRequiredACL_LOG_RESET;

function requireACL_LOG_RESET () {
	if (hasRequiredACL_LOG_RESET) return ACL_LOG_RESET;
	hasRequiredACL_LOG_RESET = 1;
	var __importDefault = (ACL_LOG_RESET && ACL_LOG_RESET.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ACL_LOG_RESET, "__esModule", { value: true });
	const ACL_LOG_1 = __importDefault(requireACL_LOG());
	ACL_LOG_RESET.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: ACL_LOG_1.default.IS_READ_ONLY,
	    /**
	     * Clears the ACL security events log
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('ACL', 'LOG', 'RESET');
	    },
	    transformReply: undefined
	};
	
	return ACL_LOG_RESET;
}

var ACL_SAVE = {};

var hasRequiredACL_SAVE;

function requireACL_SAVE () {
	if (hasRequiredACL_SAVE) return ACL_SAVE;
	hasRequiredACL_SAVE = 1;
	Object.defineProperty(ACL_SAVE, "__esModule", { value: true });
	ACL_SAVE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Saves the current ACL configuration to the ACL file
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('ACL', 'SAVE');
	    },
	    transformReply: undefined
	};
	
	return ACL_SAVE;
}

var ACL_SETUSER = {};

var hasRequiredACL_SETUSER;

function requireACL_SETUSER () {
	if (hasRequiredACL_SETUSER) return ACL_SETUSER;
	hasRequiredACL_SETUSER = 1;
	Object.defineProperty(ACL_SETUSER, "__esModule", { value: true });
	ACL_SETUSER.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Creates or modifies ACL user with specified rules
	     * @param parser - The Redis command parser
	     * @param username - Username to create or modify
	     * @param rule - ACL rule(s) to apply to the user
	     */
	    parseCommand(parser, username, rule) {
	        parser.push('ACL', 'SETUSER', username);
	        parser.pushVariadic(rule);
	    },
	    transformReply: undefined
	};
	
	return ACL_SETUSER;
}

var ACL_USERS = {};

var hasRequiredACL_USERS;

function requireACL_USERS () {
	if (hasRequiredACL_USERS) return ACL_USERS;
	hasRequiredACL_USERS = 1;
	Object.defineProperty(ACL_USERS, "__esModule", { value: true });
	ACL_USERS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns a list of all configured ACL usernames
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('ACL', 'USERS');
	    },
	    transformReply: undefined
	};
	
	return ACL_USERS;
}

var ACL_WHOAMI = {};

var hasRequiredACL_WHOAMI;

function requireACL_WHOAMI () {
	if (hasRequiredACL_WHOAMI) return ACL_WHOAMI;
	hasRequiredACL_WHOAMI = 1;
	Object.defineProperty(ACL_WHOAMI, "__esModule", { value: true });
	ACL_WHOAMI.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the username of the current connection
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('ACL', 'WHOAMI');
	    },
	    transformReply: undefined
	};
	
	return ACL_WHOAMI;
}

var APPEND = {};

var hasRequiredAPPEND;

function requireAPPEND () {
	if (hasRequiredAPPEND) return APPEND;
	hasRequiredAPPEND = 1;
	Object.defineProperty(APPEND, "__esModule", { value: true });
	APPEND.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Appends a value to a string key
	     * @param parser - The Redis command parser
	     * @param key - The key to append to
	     * @param value - The value to append
	     */
	    parseCommand(parser, key, value) {
	        parser.push('APPEND', key, value);
	    },
	    transformReply: undefined
	};
	
	return APPEND;
}

var ASKING = {};

var hasRequiredASKING;

function requireASKING () {
	if (hasRequiredASKING) return ASKING;
	hasRequiredASKING = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ASKING_CMD = void 0;
		exports.ASKING_CMD = 'ASKING';
		exports.default = {
		    NOT_KEYED_COMMAND: true,
		    IS_READ_ONLY: true,
		    /**
		     * Tells a Redis cluster node that the client is ok receiving such redirects
		     * @param parser - The Redis command parser
		     */
		    parseCommand(parser) {
		        parser.push(exports.ASKING_CMD);
		    },
		    transformReply: undefined
		};
		
	} (ASKING));
	return ASKING;
}

var AUTH = {};

var hasRequiredAUTH;

function requireAUTH () {
	if (hasRequiredAUTH) return AUTH;
	hasRequiredAUTH = 1;
	Object.defineProperty(AUTH, "__esModule", { value: true });
	AUTH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Authenticates the connection using a password or username and password
	     * @param parser - The Redis command parser
	     * @param options - Authentication options containing username and/or password
	     * @param options.username - Optional username for authentication
	     * @param options.password - Password for authentication
	     */
	    parseCommand(parser, { username, password }) {
	        parser.push('AUTH');
	        if (username !== undefined) {
	            parser.push(username);
	        }
	        parser.push(password);
	    },
	    transformReply: undefined
	};
	
	return AUTH;
}

var BGREWRITEAOF = {};

var hasRequiredBGREWRITEAOF;

function requireBGREWRITEAOF () {
	if (hasRequiredBGREWRITEAOF) return BGREWRITEAOF;
	hasRequiredBGREWRITEAOF = 1;
	Object.defineProperty(BGREWRITEAOF, "__esModule", { value: true });
	BGREWRITEAOF.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Asynchronously rewrites the append-only file
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('BGREWRITEAOF');
	    },
	    transformReply: undefined
	};
	
	return BGREWRITEAOF;
}

var BGSAVE = {};

var hasRequiredBGSAVE;

function requireBGSAVE () {
	if (hasRequiredBGSAVE) return BGSAVE;
	hasRequiredBGSAVE = 1;
	Object.defineProperty(BGSAVE, "__esModule", { value: true });
	BGSAVE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Asynchronously saves the dataset to disk
	     * @param parser - The Redis command parser
	     * @param options - Optional configuration
	     * @param options.SCHEDULE - Schedule a BGSAVE operation when no BGSAVE is already in progress
	     */
	    parseCommand(parser, options) {
	        parser.push('BGSAVE');
	        if (options?.SCHEDULE) {
	            parser.push('SCHEDULE');
	        }
	    },
	    transformReply: undefined
	};
	
	return BGSAVE;
}

var BITCOUNT = {};

var hasRequiredBITCOUNT;

function requireBITCOUNT () {
	if (hasRequiredBITCOUNT) return BITCOUNT;
	hasRequiredBITCOUNT = 1;
	Object.defineProperty(BITCOUNT, "__esModule", { value: true });
	BITCOUNT.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the count of set bits in a string key
	     * @param parser - The Redis command parser
	     * @param key - The key to count bits in
	     * @param range - Optional range specification
	     * @param range.start - Start offset in bytes/bits
	     * @param range.end - End offset in bytes/bits
	     * @param range.mode - Optional counting mode: BYTE or BIT
	     */
	    parseCommand(parser, key, range) {
	        parser.push('BITCOUNT');
	        parser.pushKey(key);
	        if (range) {
	            parser.push(range.start.toString());
	            parser.push(range.end.toString());
	            if (range.mode) {
	                parser.push(range.mode);
	            }
	        }
	    },
	    transformReply: undefined
	};
	
	return BITCOUNT;
}

var BITFIELD_RO = {};

var hasRequiredBITFIELD_RO;

function requireBITFIELD_RO () {
	if (hasRequiredBITFIELD_RO) return BITFIELD_RO;
	hasRequiredBITFIELD_RO = 1;
	Object.defineProperty(BITFIELD_RO, "__esModule", { value: true });
	BITFIELD_RO.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Performs read-only bitfield integer operations on strings
	     * @param parser - The Redis command parser
	     * @param key - The key holding the string
	     * @param operations - Array of GET operations to perform on the bitfield
	     */
	    parseCommand(parser, key, operations) {
	        parser.push('BITFIELD_RO');
	        parser.pushKey(key);
	        for (const operation of operations) {
	            parser.push('GET');
	            parser.push(operation.encoding);
	            parser.push(operation.offset.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return BITFIELD_RO;
}

var BITFIELD = {};

var hasRequiredBITFIELD;

function requireBITFIELD () {
	if (hasRequiredBITFIELD) return BITFIELD;
	hasRequiredBITFIELD = 1;
	Object.defineProperty(BITFIELD, "__esModule", { value: true });
	BITFIELD.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Performs arbitrary bitfield integer operations on strings
	     * @param parser - The Redis command parser
	     * @param key - The key holding the string
	     * @param operations - Array of bitfield operations to perform: GET, SET, INCRBY or OVERFLOW
	     */
	    parseCommand(parser, key, operations) {
	        parser.push('BITFIELD');
	        parser.pushKey(key);
	        for (const options of operations) {
	            switch (options.operation) {
	                case 'GET':
	                    parser.push('GET', options.encoding, options.offset.toString());
	                    break;
	                case 'SET':
	                    parser.push('SET', options.encoding, options.offset.toString(), options.value.toString());
	                    break;
	                case 'INCRBY':
	                    parser.push('INCRBY', options.encoding, options.offset.toString(), options.increment.toString());
	                    break;
	                case 'OVERFLOW':
	                    parser.push('OVERFLOW', options.behavior);
	                    break;
	            }
	        }
	    },
	    transformReply: undefined
	};
	
	return BITFIELD;
}

var BITOP = {};

var hasRequiredBITOP;

function requireBITOP () {
	if (hasRequiredBITOP) return BITOP;
	hasRequiredBITOP = 1;
	Object.defineProperty(BITOP, "__esModule", { value: true });
	BITOP.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Performs bitwise operations between strings
	     * @param parser - The Redis command parser
	     * @param operation - Bitwise operation to perform: AND, OR, XOR, NOT, DIFF, DIFF1, ANDOR, ONE
	     * @param destKey - Destination key to store the result
	     * @param key - Source key(s) to perform operation on
	     */
	    parseCommand(parser, operation, destKey, key) {
	        parser.push('BITOP', operation);
	        parser.pushKey(destKey);
	        parser.pushKeys(key);
	    },
	    transformReply: undefined
	};
	
	return BITOP;
}

var BITPOS = {};

var hasRequiredBITPOS;

function requireBITPOS () {
	if (hasRequiredBITPOS) return BITPOS;
	hasRequiredBITPOS = 1;
	Object.defineProperty(BITPOS, "__esModule", { value: true });
	BITPOS.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the position of first bit set to 0 or 1 in a string
	     * @param parser - The Redis command parser
	     * @param key - The key holding the string
	     * @param bit - The bit value to look for (0 or 1)
	     * @param start - Optional starting position in bytes/bits
	     * @param end - Optional ending position in bytes/bits
	     * @param mode - Optional counting mode: BYTE or BIT
	     */
	    parseCommand(parser, key, bit, start, end, mode) {
	        parser.push('BITPOS');
	        parser.pushKey(key);
	        parser.push(bit.toString());
	        if (start !== undefined) {
	            parser.push(start.toString());
	        }
	        if (end !== undefined) {
	            parser.push(end.toString());
	        }
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return BITPOS;
}

var BLMOVE = {};

var hasRequiredBLMOVE;

function requireBLMOVE () {
	if (hasRequiredBLMOVE) return BLMOVE;
	hasRequiredBLMOVE = 1;
	Object.defineProperty(BLMOVE, "__esModule", { value: true });
	BLMOVE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Pop an element from a list, push it to another list and return it; or block until one is available
	     * @param parser - The Redis command parser
	     * @param source - Key of the source list
	     * @param destination - Key of the destination list
	     * @param sourceSide - Side of source list to pop from (LEFT or RIGHT)
	     * @param destinationSide - Side of destination list to push to (LEFT or RIGHT)
	     * @param timeout - Timeout in seconds, 0 to block indefinitely
	     */
	    parseCommand(parser, source, destination, sourceSide, destinationSide, timeout) {
	        parser.push('BLMOVE');
	        parser.pushKeys([source, destination]);
	        parser.push(sourceSide, destinationSide, timeout.toString());
	    },
	    transformReply: undefined
	};
	
	return BLMOVE;
}

var BLMPOP = {};

var LMPOP = {};

var hasRequiredLMPOP;

function requireLMPOP () {
	if (hasRequiredLMPOP) return LMPOP;
	hasRequiredLMPOP = 1;
	Object.defineProperty(LMPOP, "__esModule", { value: true });
	LMPOP.parseLMPopArguments = void 0;
	function parseLMPopArguments(parser, keys, side, options) {
	    parser.pushKeysLength(keys);
	    parser.push(side);
	    if (options?.COUNT !== undefined) {
	        parser.push('COUNT', options.COUNT.toString());
	    }
	}
	LMPOP.parseLMPopArguments = parseLMPopArguments;
	LMPOP.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the LMPOP command
	     *
	     * @param parser - The command parser
	     * @param args - Arguments including keys, side (LEFT or RIGHT), and options
	     * @see https://redis.io/commands/lmpop/
	     */
	    parseCommand(parser, ...args) {
	        parser.push('LMPOP');
	        parseLMPopArguments(parser, ...args);
	    },
	    transformReply: undefined
	};
	
	return LMPOP;
}

var hasRequiredBLMPOP;

function requireBLMPOP () {
	if (hasRequiredBLMPOP) return BLMPOP;
	hasRequiredBLMPOP = 1;
	var __createBinding = (BLMPOP && BLMPOP.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (BLMPOP && BLMPOP.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (BLMPOP && BLMPOP.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(BLMPOP, "__esModule", { value: true });
	const LMPOP_1 = __importStar(requireLMPOP());
	BLMPOP.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Pops elements from multiple lists; blocks until elements are available
	     * @param parser - The Redis command parser
	     * @param timeout - Timeout in seconds, 0 to block indefinitely
	     * @param args - Additional arguments for LMPOP command
	     */
	    parseCommand(parser, timeout, ...args) {
	        parser.push('BLMPOP', timeout.toString());
	        (0, LMPOP_1.parseLMPopArguments)(parser, ...args);
	    },
	    transformReply: LMPOP_1.default.transformReply
	};
	
	return BLMPOP;
}

var BLPOP = {};

var hasRequiredBLPOP;

function requireBLPOP () {
	if (hasRequiredBLPOP) return BLPOP;
	hasRequiredBLPOP = 1;
	Object.defineProperty(BLPOP, "__esModule", { value: true });
	BLPOP.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Removes and returns the first element in a list, or blocks until one is available
	     * @param parser - The Redis command parser
	     * @param key - Key of the list to pop from, or array of keys to try sequentially
	     * @param timeout - Maximum seconds to block, 0 to block indefinitely
	     */
	    parseCommand(parser, key, timeout) {
	        parser.push('BLPOP');
	        parser.pushKeys(key);
	        parser.push(timeout.toString());
	    },
	    transformReply(reply) {
	        if (reply === null)
	            return null;
	        return {
	            key: reply[0],
	            element: reply[1]
	        };
	    }
	};
	
	return BLPOP;
}

var BRPOP = {};

var hasRequiredBRPOP;

function requireBRPOP () {
	if (hasRequiredBRPOP) return BRPOP;
	hasRequiredBRPOP = 1;
	var __importDefault = (BRPOP && BRPOP.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(BRPOP, "__esModule", { value: true });
	const BLPOP_1 = __importDefault(requireBLPOP());
	BRPOP.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Removes and returns the last element in a list, or blocks until one is available
	     * @param parser - The Redis command parser
	     * @param key - Key of the list to pop from, or array of keys to try sequentially
	     * @param timeout - Maximum seconds to block, 0 to block indefinitely
	     */
	    parseCommand(parser, key, timeout) {
	        parser.push('BRPOP');
	        parser.pushKeys(key);
	        parser.push(timeout.toString());
	    },
	    transformReply: BLPOP_1.default.transformReply
	};
	
	return BRPOP;
}

var BRPOPLPUSH = {};

var hasRequiredBRPOPLPUSH;

function requireBRPOPLPUSH () {
	if (hasRequiredBRPOPLPUSH) return BRPOPLPUSH;
	hasRequiredBRPOPLPUSH = 1;
	Object.defineProperty(BRPOPLPUSH, "__esModule", { value: true });
	BRPOPLPUSH.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Pops an element from a list, pushes it to another list and returns it; blocks until element is available
	     * @param parser - The Redis command parser
	     * @param source - Key of the source list to pop from
	     * @param destination - Key of the destination list to push to
	     * @param timeout - Maximum seconds to block, 0 to block indefinitely
	     */
	    parseCommand(parser, source, destination, timeout) {
	        parser.push('BRPOPLPUSH');
	        parser.pushKeys([source, destination]);
	        parser.push(timeout.toString());
	    },
	    transformReply: undefined
	};
	
	return BRPOPLPUSH;
}

var BZMPOP = {};

var ZMPOP = {};

var hasRequiredZMPOP;

function requireZMPOP () {
	if (hasRequiredZMPOP) return ZMPOP;
	hasRequiredZMPOP = 1;
	Object.defineProperty(ZMPOP, "__esModule", { value: true });
	ZMPOP.parseZMPopArguments = void 0;
	const generic_transformers_1 = requireGenericTransformers();
	function parseZMPopArguments(parser, keys, side, options) {
	    parser.pushKeysLength(keys);
	    parser.push(side);
	    if (options?.COUNT) {
	        parser.push('COUNT', options.COUNT.toString());
	    }
	}
	ZMPOP.parseZMPopArguments = parseZMPopArguments;
	ZMPOP.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes and returns up to count members with the highest/lowest scores from the first non-empty sorted set.
	     * @param parser - The Redis command parser.
	     * @param keys - Keys of the sorted sets to pop from.
	     * @param side - Side to pop from (MIN or MAX).
	     * @param options - Optional parameters including COUNT.
	     */
	    parseCommand(parser, keys, side, options) {
	        parser.push('ZMPOP');
	        parseZMPopArguments(parser, keys, side, options);
	    },
	    transformReply: {
	        2(reply, preserve, typeMapping) {
	            return reply === null ? null : {
	                key: reply[0],
	                members: reply[1].map(member => {
	                    const [value, score] = member;
	                    return {
	                        value,
	                        score: generic_transformers_1.transformDoubleReply[2](score, preserve, typeMapping)
	                    };
	                })
	            };
	        },
	        3(reply) {
	            return reply === null ? null : {
	                key: reply[0],
	                members: generic_transformers_1.transformSortedSetReply[3](reply[1])
	            };
	        }
	    }
	};
	
	return ZMPOP;
}

var hasRequiredBZMPOP;

function requireBZMPOP () {
	if (hasRequiredBZMPOP) return BZMPOP;
	hasRequiredBZMPOP = 1;
	var __createBinding = (BZMPOP && BZMPOP.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (BZMPOP && BZMPOP.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (BZMPOP && BZMPOP.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(BZMPOP, "__esModule", { value: true });
	const ZMPOP_1 = __importStar(requireZMPOP());
	BZMPOP.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes and returns members from one or more sorted sets in the specified order; blocks until elements are available
	     * @param parser - The Redis command parser
	     * @param timeout - Maximum seconds to block, 0 to block indefinitely
	     * @param args - Additional arguments specifying the keys, min/max count, and order (MIN/MAX)
	     */
	    parseCommand(parser, timeout, ...args) {
	        parser.push('BZMPOP', timeout.toString());
	        (0, ZMPOP_1.parseZMPopArguments)(parser, ...args);
	    },
	    transformReply: ZMPOP_1.default.transformReply
	};
	
	return BZMPOP;
}

var BZPOPMAX = {};

var hasRequiredBZPOPMAX;

function requireBZPOPMAX () {
	if (hasRequiredBZPOPMAX) return BZPOPMAX;
	hasRequiredBZPOPMAX = 1;
	Object.defineProperty(BZPOPMAX, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	BZPOPMAX.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes and returns the member with the highest score in a sorted set, or blocks until one is available
	     * @param parser - The Redis command parser
	     * @param keys - Key of the sorted set, or array of keys to try sequentially
	     * @param timeout - Maximum seconds to block, 0 to block indefinitely
	     */
	    parseCommand(parser, keys, timeout) {
	        parser.push('BZPOPMAX');
	        parser.pushKeys(keys);
	        parser.push(timeout.toString());
	    },
	    transformReply: {
	        2(reply, preserve, typeMapping) {
	            return reply === null ? null : {
	                key: reply[0],
	                value: reply[1],
	                score: generic_transformers_1.transformDoubleReply[2](reply[2], preserve, typeMapping)
	            };
	        },
	        3(reply) {
	            return reply === null ? null : {
	                key: reply[0],
	                value: reply[1],
	                score: reply[2]
	            };
	        }
	    }
	};
	
	return BZPOPMAX;
}

var BZPOPMIN = {};

var hasRequiredBZPOPMIN;

function requireBZPOPMIN () {
	if (hasRequiredBZPOPMIN) return BZPOPMIN;
	hasRequiredBZPOPMIN = 1;
	var __importDefault = (BZPOPMIN && BZPOPMIN.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(BZPOPMIN, "__esModule", { value: true });
	const BZPOPMAX_1 = __importDefault(requireBZPOPMAX());
	BZPOPMIN.default = {
	    IS_READ_ONLY: BZPOPMAX_1.default.IS_READ_ONLY,
	    /**
	     * Removes and returns the member with the lowest score in a sorted set, or blocks until one is available
	     * @param parser - The Redis command parser
	     * @param keys - Key of the sorted set, or array of keys to try sequentially
	     * @param timeout - Maximum seconds to block, 0 to block indefinitely
	     */
	    parseCommand(parser, keys, timeout) {
	        parser.push('BZPOPMIN');
	        parser.pushKeys(keys);
	        parser.push(timeout.toString());
	    },
	    transformReply: BZPOPMAX_1.default.transformReply
	};
	
	return BZPOPMIN;
}

var CLIENT_CACHING = {};

var hasRequiredCLIENT_CACHING;

function requireCLIENT_CACHING () {
	if (hasRequiredCLIENT_CACHING) return CLIENT_CACHING;
	hasRequiredCLIENT_CACHING = 1;
	Object.defineProperty(CLIENT_CACHING, "__esModule", { value: true });
	CLIENT_CACHING.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Instructs the server about tracking or not keys in the next request
	     * @param parser - The Redis command parser
	     * @param value - Whether to enable (true) or disable (false) tracking
	     */
	    parseCommand(parser, value) {
	        parser.push('CLIENT', 'CACHING', value ? 'YES' : 'NO');
	    },
	    transformReply: undefined
	};
	
	return CLIENT_CACHING;
}

var CLIENT_GETNAME = {};

var hasRequiredCLIENT_GETNAME;

function requireCLIENT_GETNAME () {
	if (hasRequiredCLIENT_GETNAME) return CLIENT_GETNAME;
	hasRequiredCLIENT_GETNAME = 1;
	Object.defineProperty(CLIENT_GETNAME, "__esModule", { value: true });
	CLIENT_GETNAME.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the name of the current connection
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLIENT', 'GETNAME');
	    },
	    transformReply: undefined
	};
	
	return CLIENT_GETNAME;
}

var CLIENT_GETREDIR = {};

var hasRequiredCLIENT_GETREDIR;

function requireCLIENT_GETREDIR () {
	if (hasRequiredCLIENT_GETREDIR) return CLIENT_GETREDIR;
	hasRequiredCLIENT_GETREDIR = 1;
	Object.defineProperty(CLIENT_GETREDIR, "__esModule", { value: true });
	CLIENT_GETREDIR.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the ID of the client to which the current client is redirecting tracking notifications
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLIENT', 'GETREDIR');
	    },
	    transformReply: undefined
	};
	
	return CLIENT_GETREDIR;
}

var CLIENT_ID = {};

var hasRequiredCLIENT_ID;

function requireCLIENT_ID () {
	if (hasRequiredCLIENT_ID) return CLIENT_ID;
	hasRequiredCLIENT_ID = 1;
	Object.defineProperty(CLIENT_ID, "__esModule", { value: true });
	CLIENT_ID.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the client ID for the current connection
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLIENT', 'ID');
	    },
	    transformReply: undefined
	};
	
	return CLIENT_ID;
}

var CLIENT_INFO = {};

var hasRequiredCLIENT_INFO;

function requireCLIENT_INFO () {
	if (hasRequiredCLIENT_INFO) return CLIENT_INFO;
	hasRequiredCLIENT_INFO = 1;
	Object.defineProperty(CLIENT_INFO, "__esModule", { value: true });
	const CLIENT_INFO_REGEX = /([^\s=]+)=([^\s]*)/g;
	CLIENT_INFO.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns information and statistics about the current client connection
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLIENT', 'INFO');
	    },
	    transformReply(rawReply) {
	        const map = {};
	        for (const item of rawReply.toString().matchAll(CLIENT_INFO_REGEX)) {
	            map[item[1]] = item[2];
	        }
	        const reply = {
	            id: Number(map.id),
	            addr: map.addr,
	            fd: Number(map.fd),
	            name: map.name,
	            age: Number(map.age),
	            idle: Number(map.idle),
	            flags: map.flags,
	            db: Number(map.db),
	            sub: Number(map.sub),
	            psub: Number(map.psub),
	            multi: Number(map.multi),
	            qbuf: Number(map.qbuf),
	            qbufFree: Number(map['qbuf-free']),
	            argvMem: Number(map['argv-mem']),
	            obl: Number(map.obl),
	            oll: Number(map.oll),
	            omem: Number(map.omem),
	            totMem: Number(map['tot-mem']),
	            events: map.events,
	            cmd: map.cmd,
	            user: map.user,
	            libName: map['lib-name'],
	            libVer: map['lib-ver']
	        };
	        if (map.laddr !== undefined) {
	            reply.laddr = map.laddr;
	        }
	        if (map.redir !== undefined) {
	            reply.redir = Number(map.redir);
	        }
	        if (map.ssub !== undefined) {
	            reply.ssub = Number(map.ssub);
	        }
	        if (map['multi-mem'] !== undefined) {
	            reply.multiMem = Number(map['multi-mem']);
	        }
	        if (map.resp !== undefined) {
	            reply.resp = Number(map.resp);
	        }
	        return reply;
	    }
	};
	
	return CLIENT_INFO;
}

var CLIENT_KILL = {};

var hasRequiredCLIENT_KILL;

function requireCLIENT_KILL () {
	if (hasRequiredCLIENT_KILL) return CLIENT_KILL;
	hasRequiredCLIENT_KILL = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CLIENT_KILL_FILTERS = void 0;
		exports.CLIENT_KILL_FILTERS = {
		    ADDRESS: 'ADDR',
		    LOCAL_ADDRESS: 'LADDR',
		    ID: 'ID',
		    TYPE: 'TYPE',
		    USER: 'USER',
		    SKIP_ME: 'SKIPME',
		    MAXAGE: 'MAXAGE'
		};
		exports.default = {
		    NOT_KEYED_COMMAND: true,
		    IS_READ_ONLY: true,
		    /**
		     * Closes client connections matching the specified filters
		     * @param parser - The Redis command parser
		     * @param filters - One or more filters to match client connections to kill
		     */
		    parseCommand(parser, filters) {
		        parser.push('CLIENT', 'KILL');
		        if (Array.isArray(filters)) {
		            for (const filter of filters) {
		                pushFilter(parser, filter);
		            }
		        }
		        else {
		            pushFilter(parser, filters);
		        }
		    },
		    transformReply: undefined
		};
		function pushFilter(parser, filter) {
		    if (filter === exports.CLIENT_KILL_FILTERS.SKIP_ME) {
		        parser.push('SKIPME');
		        return;
		    }
		    parser.push(filter.filter);
		    switch (filter.filter) {
		        case exports.CLIENT_KILL_FILTERS.ADDRESS:
		            parser.push(filter.address);
		            break;
		        case exports.CLIENT_KILL_FILTERS.LOCAL_ADDRESS:
		            parser.push(filter.localAddress);
		            break;
		        case exports.CLIENT_KILL_FILTERS.ID:
		            parser.push(typeof filter.id === 'number' ?
		                filter.id.toString() :
		                filter.id);
		            break;
		        case exports.CLIENT_KILL_FILTERS.TYPE:
		            parser.push(filter.type);
		            break;
		        case exports.CLIENT_KILL_FILTERS.USER:
		            parser.push(filter.username);
		            break;
		        case exports.CLIENT_KILL_FILTERS.SKIP_ME:
		            parser.push(filter.skipMe ? 'yes' : 'no');
		            break;
		        case exports.CLIENT_KILL_FILTERS.MAXAGE:
		            parser.push(filter.maxAge.toString());
		            break;
		    }
		}
		
	} (CLIENT_KILL));
	return CLIENT_KILL;
}

var CLIENT_LIST = {};

var hasRequiredCLIENT_LIST;

function requireCLIENT_LIST () {
	if (hasRequiredCLIENT_LIST) return CLIENT_LIST;
	hasRequiredCLIENT_LIST = 1;
	var __importDefault = (CLIENT_LIST && CLIENT_LIST.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(CLIENT_LIST, "__esModule", { value: true });
	const CLIENT_INFO_1 = __importDefault(requireCLIENT_INFO());
	CLIENT_LIST.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns information about all client connections. Can be filtered by type or ID
	     * @param parser - The Redis command parser
	     * @param filter - Optional filter to return only specific client types or IDs
	     */
	    parseCommand(parser, filter) {
	        parser.push('CLIENT', 'LIST');
	        if (filter) {
	            if (filter.TYPE !== undefined) {
	                parser.push('TYPE', filter.TYPE);
	            }
	            else {
	                parser.push('ID');
	                parser.pushVariadic(filter.ID);
	            }
	        }
	    },
	    transformReply(rawReply) {
	        const split = rawReply.toString().split('\n'), length = split.length - 1, reply = [];
	        for (let i = 0; i < length; i++) {
	            reply.push(CLIENT_INFO_1.default.transformReply(split[i]));
	        }
	        return reply;
	    }
	};
	
	return CLIENT_LIST;
}

var CLIENT_NOEVICT = {};

var hasRequiredCLIENT_NOEVICT;

function requireCLIENT_NOEVICT () {
	if (hasRequiredCLIENT_NOEVICT) return CLIENT_NOEVICT;
	hasRequiredCLIENT_NOEVICT = 1;
	Object.defineProperty(CLIENT_NOEVICT, "__esModule", { value: true });
	CLIENT_NOEVICT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Controls whether to prevent the client's connections from being evicted
	     * @param parser - The Redis command parser
	     * @param value - Whether to enable (true) or disable (false) the no-evict mode
	     */
	    parseCommand(parser, value) {
	        parser.push('CLIENT', 'NO-EVICT', value ? 'ON' : 'OFF');
	    },
	    transformReply: undefined
	};
	
	return CLIENT_NOEVICT;
}

var CLIENT_NOTOUCH = {};

var hasRequiredCLIENT_NOTOUCH;

function requireCLIENT_NOTOUCH () {
	if (hasRequiredCLIENT_NOTOUCH) return CLIENT_NOTOUCH;
	hasRequiredCLIENT_NOTOUCH = 1;
	Object.defineProperty(CLIENT_NOTOUCH, "__esModule", { value: true });
	CLIENT_NOTOUCH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Controls whether to prevent the client from touching the LRU/LFU of keys
	     * @param parser - The Redis command parser
	     * @param value - Whether to enable (true) or disable (false) the no-touch mode
	     */
	    parseCommand(parser, value) {
	        parser.push('CLIENT', 'NO-TOUCH', value ? 'ON' : 'OFF');
	    },
	    transformReply: undefined
	};
	
	return CLIENT_NOTOUCH;
}

var CLIENT_PAUSE = {};

var hasRequiredCLIENT_PAUSE;

function requireCLIENT_PAUSE () {
	if (hasRequiredCLIENT_PAUSE) return CLIENT_PAUSE;
	hasRequiredCLIENT_PAUSE = 1;
	Object.defineProperty(CLIENT_PAUSE, "__esModule", { value: true });
	CLIENT_PAUSE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Stops the server from processing client commands for the specified duration
	     * @param parser - The Redis command parser
	     * @param timeout - Time in milliseconds to pause command processing
	     * @param mode - Optional mode: 'WRITE' to pause only write commands, 'ALL' to pause all commands
	     */
	    parseCommand(parser, timeout, mode) {
	        parser.push('CLIENT', 'PAUSE', timeout.toString());
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return CLIENT_PAUSE;
}

var CLIENT_SETNAME = {};

var hasRequiredCLIENT_SETNAME;

function requireCLIENT_SETNAME () {
	if (hasRequiredCLIENT_SETNAME) return CLIENT_SETNAME;
	hasRequiredCLIENT_SETNAME = 1;
	Object.defineProperty(CLIENT_SETNAME, "__esModule", { value: true });
	CLIENT_SETNAME.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Assigns a name to the current connection
	     * @param parser - The Redis command parser
	     * @param name - The name to assign to the connection
	     */
	    parseCommand(parser, name) {
	        parser.push('CLIENT', 'SETNAME', name);
	    },
	    transformReply: undefined
	};
	
	return CLIENT_SETNAME;
}

var CLIENT_TRACKING = {};

var hasRequiredCLIENT_TRACKING;

function requireCLIENT_TRACKING () {
	if (hasRequiredCLIENT_TRACKING) return CLIENT_TRACKING;
	hasRequiredCLIENT_TRACKING = 1;
	Object.defineProperty(CLIENT_TRACKING, "__esModule", { value: true });
	CLIENT_TRACKING.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Controls server-assisted client side caching for the current connection
	     * @param parser - The Redis command parser
	     * @param mode - Whether to enable (true) or disable (false) tracking
	     * @param options - Optional configuration including REDIRECT, BCAST, PREFIX, OPTIN, OPTOUT, and NOLOOP options
	     */
	    parseCommand(parser, mode, options) {
	        parser.push('CLIENT', 'TRACKING', mode ? 'ON' : 'OFF');
	        if (mode) {
	            if (options?.REDIRECT) {
	                parser.push('REDIRECT', options.REDIRECT.toString());
	            }
	            if (isBroadcast(options)) {
	                parser.push('BCAST');
	                if (options?.PREFIX) {
	                    if (Array.isArray(options.PREFIX)) {
	                        for (const prefix of options.PREFIX) {
	                            parser.push('PREFIX', prefix);
	                        }
	                    }
	                    else {
	                        parser.push('PREFIX', options.PREFIX);
	                    }
	                }
	            }
	            else if (isOptIn(options)) {
	                parser.push('OPTIN');
	            }
	            else if (isOptOut(options)) {
	                parser.push('OPTOUT');
	            }
	            if (options?.NOLOOP) {
	                parser.push('NOLOOP');
	            }
	        }
	    },
	    transformReply: undefined
	};
	function isBroadcast(options) {
	    return options?.BCAST === true;
	}
	function isOptIn(options) {
	    return options?.OPTIN === true;
	}
	function isOptOut(options) {
	    return options?.OPTOUT === true;
	}
	
	return CLIENT_TRACKING;
}

var CLIENT_TRACKINGINFO = {};

var hasRequiredCLIENT_TRACKINGINFO;

function requireCLIENT_TRACKINGINFO () {
	if (hasRequiredCLIENT_TRACKINGINFO) return CLIENT_TRACKINGINFO;
	hasRequiredCLIENT_TRACKINGINFO = 1;
	Object.defineProperty(CLIENT_TRACKINGINFO, "__esModule", { value: true });
	CLIENT_TRACKINGINFO.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns information about the current connection's key tracking state
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLIENT', 'TRACKINGINFO');
	    },
	    transformReply: {
	        2: (reply) => ({
	            flags: reply[1],
	            redirect: reply[3],
	            prefixes: reply[5]
	        }),
	        3: undefined
	    }
	};
	
	return CLIENT_TRACKINGINFO;
}

var CLIENT_UNPAUSE = {};

var hasRequiredCLIENT_UNPAUSE;

function requireCLIENT_UNPAUSE () {
	if (hasRequiredCLIENT_UNPAUSE) return CLIENT_UNPAUSE;
	hasRequiredCLIENT_UNPAUSE = 1;
	Object.defineProperty(CLIENT_UNPAUSE, "__esModule", { value: true });
	CLIENT_UNPAUSE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Resumes processing of client commands after a CLIENT PAUSE
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLIENT', 'UNPAUSE');
	    },
	    transformReply: undefined
	};
	
	return CLIENT_UNPAUSE;
}

var CLUSTER_ADDSLOTS = {};

var hasRequiredCLUSTER_ADDSLOTS;

function requireCLUSTER_ADDSLOTS () {
	if (hasRequiredCLUSTER_ADDSLOTS) return CLUSTER_ADDSLOTS;
	hasRequiredCLUSTER_ADDSLOTS = 1;
	Object.defineProperty(CLUSTER_ADDSLOTS, "__esModule", { value: true });
	CLUSTER_ADDSLOTS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Assigns hash slots to the current node in a Redis Cluster
	     * @param parser - The Redis command parser
	     * @param slots - One or more hash slots to be assigned
	     */
	    parseCommand(parser, slots) {
	        parser.push('CLUSTER', 'ADDSLOTS');
	        parser.pushVariadicNumber(slots);
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_ADDSLOTS;
}

var CLUSTER_ADDSLOTSRANGE = {};

var hasRequiredCLUSTER_ADDSLOTSRANGE;

function requireCLUSTER_ADDSLOTSRANGE () {
	if (hasRequiredCLUSTER_ADDSLOTSRANGE) return CLUSTER_ADDSLOTSRANGE;
	hasRequiredCLUSTER_ADDSLOTSRANGE = 1;
	Object.defineProperty(CLUSTER_ADDSLOTSRANGE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	CLUSTER_ADDSLOTSRANGE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Assigns hash slot ranges to the current node in a Redis Cluster
	     * @param parser - The Redis command parser
	     * @param ranges - One or more slot ranges to be assigned, each specified as [start, end]
	     */
	    parseCommand(parser, ranges) {
	        parser.push('CLUSTER', 'ADDSLOTSRANGE');
	        (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_ADDSLOTSRANGE;
}

var CLUSTER_BUMPEPOCH = {};

var hasRequiredCLUSTER_BUMPEPOCH;

function requireCLUSTER_BUMPEPOCH () {
	if (hasRequiredCLUSTER_BUMPEPOCH) return CLUSTER_BUMPEPOCH;
	hasRequiredCLUSTER_BUMPEPOCH = 1;
	Object.defineProperty(CLUSTER_BUMPEPOCH, "__esModule", { value: true });
	CLUSTER_BUMPEPOCH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Advances the cluster config epoch
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLUSTER', 'BUMPEPOCH');
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_BUMPEPOCH;
}

var CLUSTER_COUNTFAILUREREPORTS = {};

var hasRequiredCLUSTER_COUNTFAILUREREPORTS;

function requireCLUSTER_COUNTFAILUREREPORTS () {
	if (hasRequiredCLUSTER_COUNTFAILUREREPORTS) return CLUSTER_COUNTFAILUREREPORTS;
	hasRequiredCLUSTER_COUNTFAILUREREPORTS = 1;
	Object.defineProperty(CLUSTER_COUNTFAILUREREPORTS, "__esModule", { value: true });
	CLUSTER_COUNTFAILUREREPORTS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the number of failure reports for a given node
	     * @param parser - The Redis command parser
	     * @param nodeId - The ID of the node to check
	     */
	    parseCommand(parser, nodeId) {
	        parser.push('CLUSTER', 'COUNT-FAILURE-REPORTS', nodeId);
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_COUNTFAILUREREPORTS;
}

var CLUSTER_COUNTKEYSINSLOT = {};

var hasRequiredCLUSTER_COUNTKEYSINSLOT;

function requireCLUSTER_COUNTKEYSINSLOT () {
	if (hasRequiredCLUSTER_COUNTKEYSINSLOT) return CLUSTER_COUNTKEYSINSLOT;
	hasRequiredCLUSTER_COUNTKEYSINSLOT = 1;
	Object.defineProperty(CLUSTER_COUNTKEYSINSLOT, "__esModule", { value: true });
	CLUSTER_COUNTKEYSINSLOT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the number of keys in the specified hash slot
	     * @param parser - The Redis command parser
	     * @param slot - The hash slot to check
	     */
	    parseCommand(parser, slot) {
	        parser.push('CLUSTER', 'COUNTKEYSINSLOT', slot.toString());
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_COUNTKEYSINSLOT;
}

var CLUSTER_DELSLOTS = {};

var hasRequiredCLUSTER_DELSLOTS;

function requireCLUSTER_DELSLOTS () {
	if (hasRequiredCLUSTER_DELSLOTS) return CLUSTER_DELSLOTS;
	hasRequiredCLUSTER_DELSLOTS = 1;
	Object.defineProperty(CLUSTER_DELSLOTS, "__esModule", { value: true });
	CLUSTER_DELSLOTS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Removes hash slots from the current node in a Redis Cluster
	     * @param parser - The Redis command parser
	     * @param slots - One or more hash slots to be removed
	     */
	    parseCommand(parser, slots) {
	        parser.push('CLUSTER', 'DELSLOTS');
	        parser.pushVariadicNumber(slots);
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_DELSLOTS;
}

var CLUSTER_DELSLOTSRANGE = {};

var hasRequiredCLUSTER_DELSLOTSRANGE;

function requireCLUSTER_DELSLOTSRANGE () {
	if (hasRequiredCLUSTER_DELSLOTSRANGE) return CLUSTER_DELSLOTSRANGE;
	hasRequiredCLUSTER_DELSLOTSRANGE = 1;
	Object.defineProperty(CLUSTER_DELSLOTSRANGE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	CLUSTER_DELSLOTSRANGE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Removes hash slot ranges from the current node in a Redis Cluster
	     * @param parser - The Redis command parser
	     * @param ranges - One or more slot ranges to be removed, each specified as [start, end]
	     */
	    parseCommand(parser, ranges) {
	        parser.push('CLUSTER', 'DELSLOTSRANGE');
	        (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_DELSLOTSRANGE;
}

var CLUSTER_FAILOVER = {};

var hasRequiredCLUSTER_FAILOVER;

function requireCLUSTER_FAILOVER () {
	if (hasRequiredCLUSTER_FAILOVER) return CLUSTER_FAILOVER;
	hasRequiredCLUSTER_FAILOVER = 1;
	Object.defineProperty(CLUSTER_FAILOVER, "__esModule", { value: true });
	CLUSTER_FAILOVER.FAILOVER_MODES = void 0;
	CLUSTER_FAILOVER.FAILOVER_MODES = {
	    FORCE: 'FORCE',
	    TAKEOVER: 'TAKEOVER'
	};
	CLUSTER_FAILOVER.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Forces a replica to perform a manual failover of its master
	     * @param parser - The Redis command parser
	     * @param options - Optional configuration with FORCE or TAKEOVER mode
	     */
	    parseCommand(parser, options) {
	        parser.push('CLUSTER', 'FAILOVER');
	        if (options?.mode) {
	            parser.push(options.mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_FAILOVER;
}

var CLUSTER_FLUSHSLOTS = {};

var hasRequiredCLUSTER_FLUSHSLOTS;

function requireCLUSTER_FLUSHSLOTS () {
	if (hasRequiredCLUSTER_FLUSHSLOTS) return CLUSTER_FLUSHSLOTS;
	hasRequiredCLUSTER_FLUSHSLOTS = 1;
	Object.defineProperty(CLUSTER_FLUSHSLOTS, "__esModule", { value: true });
	CLUSTER_FLUSHSLOTS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Deletes all hash slots from the current node in a Redis Cluster
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLUSTER', 'FLUSHSLOTS');
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_FLUSHSLOTS;
}

var CLUSTER_FORGET = {};

var hasRequiredCLUSTER_FORGET;

function requireCLUSTER_FORGET () {
	if (hasRequiredCLUSTER_FORGET) return CLUSTER_FORGET;
	hasRequiredCLUSTER_FORGET = 1;
	Object.defineProperty(CLUSTER_FORGET, "__esModule", { value: true });
	CLUSTER_FORGET.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Removes a node from the cluster
	     * @param parser - The Redis command parser
	     * @param nodeId - The ID of the node to remove
	     */
	    parseCommand(parser, nodeId) {
	        parser.push('CLUSTER', 'FORGET', nodeId);
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_FORGET;
}

var CLUSTER_GETKEYSINSLOT = {};

var hasRequiredCLUSTER_GETKEYSINSLOT;

function requireCLUSTER_GETKEYSINSLOT () {
	if (hasRequiredCLUSTER_GETKEYSINSLOT) return CLUSTER_GETKEYSINSLOT;
	hasRequiredCLUSTER_GETKEYSINSLOT = 1;
	Object.defineProperty(CLUSTER_GETKEYSINSLOT, "__esModule", { value: true });
	CLUSTER_GETKEYSINSLOT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns a number of keys from the specified hash slot
	     * @param parser - The Redis command parser
	     * @param slot - The hash slot to get keys from
	     * @param count - Maximum number of keys to return
	     */
	    parseCommand(parser, slot, count) {
	        parser.push('CLUSTER', 'GETKEYSINSLOT', slot.toString(), count.toString());
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_GETKEYSINSLOT;
}

var CLUSTER_INFO = {};

var hasRequiredCLUSTER_INFO;

function requireCLUSTER_INFO () {
	if (hasRequiredCLUSTER_INFO) return CLUSTER_INFO;
	hasRequiredCLUSTER_INFO = 1;
	Object.defineProperty(CLUSTER_INFO, "__esModule", { value: true });
	CLUSTER_INFO.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns information about the state of a Redis Cluster
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLUSTER', 'INFO');
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_INFO;
}

var CLUSTER_KEYSLOT = {};

var hasRequiredCLUSTER_KEYSLOT;

function requireCLUSTER_KEYSLOT () {
	if (hasRequiredCLUSTER_KEYSLOT) return CLUSTER_KEYSLOT;
	hasRequiredCLUSTER_KEYSLOT = 1;
	Object.defineProperty(CLUSTER_KEYSLOT, "__esModule", { value: true });
	CLUSTER_KEYSLOT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the hash slot number for a given key
	     * @param parser - The Redis command parser
	     * @param key - The key to get the hash slot for
	     */
	    parseCommand(parser, key) {
	        parser.push('CLUSTER', 'KEYSLOT', key);
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_KEYSLOT;
}

var CLUSTER_LINKS = {};

var hasRequiredCLUSTER_LINKS;

function requireCLUSTER_LINKS () {
	if (hasRequiredCLUSTER_LINKS) return CLUSTER_LINKS;
	hasRequiredCLUSTER_LINKS = 1;
	Object.defineProperty(CLUSTER_LINKS, "__esModule", { value: true });
	CLUSTER_LINKS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns information about all cluster links (lower level connections to other nodes)
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLUSTER', 'LINKS');
	    },
	    transformReply: {
	        2: (reply) => reply.map(link => {
	            const unwrapped = link;
	            return {
	                direction: unwrapped[1],
	                node: unwrapped[3],
	                'create-time': unwrapped[5],
	                events: unwrapped[7],
	                'send-buffer-allocated': unwrapped[9],
	                'send-buffer-used': unwrapped[11]
	            };
	        }),
	        3: undefined
	    }
	};
	
	return CLUSTER_LINKS;
}

var CLUSTER_MEET = {};

var hasRequiredCLUSTER_MEET;

function requireCLUSTER_MEET () {
	if (hasRequiredCLUSTER_MEET) return CLUSTER_MEET;
	hasRequiredCLUSTER_MEET = 1;
	Object.defineProperty(CLUSTER_MEET, "__esModule", { value: true });
	CLUSTER_MEET.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Initiates a handshake with another node in the cluster
	     * @param parser - The Redis command parser
	     * @param host - Host name or IP address of the node
	     * @param port - TCP port of the node
	     */
	    parseCommand(parser, host, port) {
	        parser.push('CLUSTER', 'MEET', host, port.toString());
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_MEET;
}

var CLUSTER_MYID = {};

var hasRequiredCLUSTER_MYID;

function requireCLUSTER_MYID () {
	if (hasRequiredCLUSTER_MYID) return CLUSTER_MYID;
	hasRequiredCLUSTER_MYID = 1;
	Object.defineProperty(CLUSTER_MYID, "__esModule", { value: true });
	CLUSTER_MYID.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the node ID of the current Redis Cluster node
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLUSTER', 'MYID');
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_MYID;
}

var CLUSTER_MYSHARDID = {};

var hasRequiredCLUSTER_MYSHARDID;

function requireCLUSTER_MYSHARDID () {
	if (hasRequiredCLUSTER_MYSHARDID) return CLUSTER_MYSHARDID;
	hasRequiredCLUSTER_MYSHARDID = 1;
	Object.defineProperty(CLUSTER_MYSHARDID, "__esModule", { value: true });
	CLUSTER_MYSHARDID.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the shard ID of the current Redis Cluster node
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLUSTER', 'MYSHARDID');
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_MYSHARDID;
}

var CLUSTER_NODES = {};

var hasRequiredCLUSTER_NODES;

function requireCLUSTER_NODES () {
	if (hasRequiredCLUSTER_NODES) return CLUSTER_NODES;
	hasRequiredCLUSTER_NODES = 1;
	Object.defineProperty(CLUSTER_NODES, "__esModule", { value: true });
	CLUSTER_NODES.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns serialized information about the nodes in a Redis Cluster
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLUSTER', 'NODES');
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_NODES;
}

var CLUSTER_REPLICAS = {};

var hasRequiredCLUSTER_REPLICAS;

function requireCLUSTER_REPLICAS () {
	if (hasRequiredCLUSTER_REPLICAS) return CLUSTER_REPLICAS;
	hasRequiredCLUSTER_REPLICAS = 1;
	Object.defineProperty(CLUSTER_REPLICAS, "__esModule", { value: true });
	CLUSTER_REPLICAS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the replica nodes replicating from the specified primary node
	     * @param parser - The Redis command parser
	     * @param nodeId - Node ID of the primary node
	     */
	    parseCommand(parser, nodeId) {
	        parser.push('CLUSTER', 'REPLICAS', nodeId);
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_REPLICAS;
}

var CLUSTER_REPLICATE = {};

var hasRequiredCLUSTER_REPLICATE;

function requireCLUSTER_REPLICATE () {
	if (hasRequiredCLUSTER_REPLICATE) return CLUSTER_REPLICATE;
	hasRequiredCLUSTER_REPLICATE = 1;
	Object.defineProperty(CLUSTER_REPLICATE, "__esModule", { value: true });
	CLUSTER_REPLICATE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Reconfigures a node as a replica of the specified primary node
	     * @param parser - The Redis command parser
	     * @param nodeId - Node ID of the primary node to replicate
	     */
	    parseCommand(parser, nodeId) {
	        parser.push('CLUSTER', 'REPLICATE', nodeId);
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_REPLICATE;
}

var CLUSTER_RESET = {};

var hasRequiredCLUSTER_RESET;

function requireCLUSTER_RESET () {
	if (hasRequiredCLUSTER_RESET) return CLUSTER_RESET;
	hasRequiredCLUSTER_RESET = 1;
	Object.defineProperty(CLUSTER_RESET, "__esModule", { value: true });
	CLUSTER_RESET.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Resets a Redis Cluster node, clearing all information and returning it to a brand new state
	     * @param parser - The Redis command parser
	     * @param options - Options for the reset operation
	     */
	    parseCommand(parser, options) {
	        parser.push('CLUSTER', 'RESET');
	        if (options?.mode) {
	            parser.push(options.mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_RESET;
}

var CLUSTER_SAVECONFIG = {};

var hasRequiredCLUSTER_SAVECONFIG;

function requireCLUSTER_SAVECONFIG () {
	if (hasRequiredCLUSTER_SAVECONFIG) return CLUSTER_SAVECONFIG;
	hasRequiredCLUSTER_SAVECONFIG = 1;
	Object.defineProperty(CLUSTER_SAVECONFIG, "__esModule", { value: true });
	CLUSTER_SAVECONFIG.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Forces a Redis Cluster node to save the cluster configuration to disk
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLUSTER', 'SAVECONFIG');
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_SAVECONFIG;
}

var CLUSTER_SETCONFIGEPOCH = {};

var hasRequiredCLUSTER_SETCONFIGEPOCH;

function requireCLUSTER_SETCONFIGEPOCH () {
	if (hasRequiredCLUSTER_SETCONFIGEPOCH) return CLUSTER_SETCONFIGEPOCH;
	hasRequiredCLUSTER_SETCONFIGEPOCH = 1;
	Object.defineProperty(CLUSTER_SETCONFIGEPOCH, "__esModule", { value: true });
	CLUSTER_SETCONFIGEPOCH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Sets the configuration epoch for a Redis Cluster node
	     * @param parser - The Redis command parser
	     * @param configEpoch - The configuration epoch to set
	     */
	    parseCommand(parser, configEpoch) {
	        parser.push('CLUSTER', 'SET-CONFIG-EPOCH', configEpoch.toString());
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_SETCONFIGEPOCH;
}

var CLUSTER_SETSLOT = {};

var hasRequiredCLUSTER_SETSLOT;

function requireCLUSTER_SETSLOT () {
	if (hasRequiredCLUSTER_SETSLOT) return CLUSTER_SETSLOT;
	hasRequiredCLUSTER_SETSLOT = 1;
	Object.defineProperty(CLUSTER_SETSLOT, "__esModule", { value: true });
	CLUSTER_SETSLOT.CLUSTER_SLOT_STATES = void 0;
	CLUSTER_SETSLOT.CLUSTER_SLOT_STATES = {
	    IMPORTING: 'IMPORTING',
	    MIGRATING: 'MIGRATING',
	    STABLE: 'STABLE',
	    NODE: 'NODE'
	};
	CLUSTER_SETSLOT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Assigns a hash slot to a specific Redis Cluster node
	     * @param parser - The Redis command parser
	     * @param slot - The slot number to assign
	     * @param state - The state to set for the slot (IMPORTING, MIGRATING, STABLE, NODE)
	     * @param nodeId - Node ID (required for IMPORTING, MIGRATING, and NODE states)
	     */
	    parseCommand(parser, slot, state, nodeId) {
	        parser.push('CLUSTER', 'SETSLOT', slot.toString(), state);
	        if (nodeId) {
	            parser.push(nodeId);
	        }
	    },
	    transformReply: undefined
	};
	
	return CLUSTER_SETSLOT;
}

var CLUSTER_SLOTS = {};

var hasRequiredCLUSTER_SLOTS;

function requireCLUSTER_SLOTS () {
	if (hasRequiredCLUSTER_SLOTS) return CLUSTER_SLOTS;
	hasRequiredCLUSTER_SLOTS = 1;
	Object.defineProperty(CLUSTER_SLOTS, "__esModule", { value: true });
	CLUSTER_SLOTS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns information about which Redis Cluster node handles which hash slots
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CLUSTER', 'SLOTS');
	    },
	    transformReply(reply) {
	        return reply.map(([from, to, master, ...replicas]) => ({
	            from,
	            to,
	            master: transformNode(master),
	            replicas: replicas.map(transformNode)
	        }));
	    }
	};
	function transformNode(node) {
	    const [host, port, id] = node;
	    return {
	        host,
	        port,
	        id
	    };
	}
	
	return CLUSTER_SLOTS;
}

var COMMAND_COUNT = {};

var hasRequiredCOMMAND_COUNT;

function requireCOMMAND_COUNT () {
	if (hasRequiredCOMMAND_COUNT) return COMMAND_COUNT;
	hasRequiredCOMMAND_COUNT = 1;
	Object.defineProperty(COMMAND_COUNT, "__esModule", { value: true });
	COMMAND_COUNT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the total number of commands available in the Redis server
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('COMMAND', 'COUNT');
	    },
	    transformReply: undefined
	};
	
	return COMMAND_COUNT;
}

var COMMAND_GETKEYS = {};

var hasRequiredCOMMAND_GETKEYS;

function requireCOMMAND_GETKEYS () {
	if (hasRequiredCOMMAND_GETKEYS) return COMMAND_GETKEYS;
	hasRequiredCOMMAND_GETKEYS = 1;
	Object.defineProperty(COMMAND_GETKEYS, "__esModule", { value: true });
	COMMAND_GETKEYS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Extracts the key names from a Redis command
	     * @param parser - The Redis command parser
	     * @param args - Command arguments to analyze
	     */
	    parseCommand(parser, args) {
	        parser.push('COMMAND', 'GETKEYS');
	        parser.push(...args);
	    },
	    transformReply: undefined
	};
	
	return COMMAND_GETKEYS;
}

var COMMAND_GETKEYSANDFLAGS = {};

var hasRequiredCOMMAND_GETKEYSANDFLAGS;

function requireCOMMAND_GETKEYSANDFLAGS () {
	if (hasRequiredCOMMAND_GETKEYSANDFLAGS) return COMMAND_GETKEYSANDFLAGS;
	hasRequiredCOMMAND_GETKEYSANDFLAGS = 1;
	Object.defineProperty(COMMAND_GETKEYSANDFLAGS, "__esModule", { value: true });
	COMMAND_GETKEYSANDFLAGS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Extracts the key names and access flags from a Redis command
	     * @param parser - The Redis command parser
	     * @param args - Command arguments to analyze
	     */
	    parseCommand(parser, args) {
	        parser.push('COMMAND', 'GETKEYSANDFLAGS');
	        parser.push(...args);
	    },
	    transformReply(reply) {
	        return reply.map(entry => {
	            const [key, flags] = entry;
	            return {
	                key,
	                flags
	            };
	        });
	    }
	};
	
	return COMMAND_GETKEYSANDFLAGS;
}

var COMMAND_INFO = {};

var hasRequiredCOMMAND_INFO;

function requireCOMMAND_INFO () {
	if (hasRequiredCOMMAND_INFO) return COMMAND_INFO;
	hasRequiredCOMMAND_INFO = 1;
	Object.defineProperty(COMMAND_INFO, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	COMMAND_INFO.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns details about specific Redis commands
	     * @param parser - The Redis command parser
	     * @param commands - Array of command names to get information about
	     */
	    parseCommand(parser, commands) {
	        parser.push('COMMAND', 'INFO', ...commands);
	    },
	    // TODO: This works, as we don't currently handle any of the items returned as a map
	    transformReply(reply) {
	        return reply.map(command => command ? (0, generic_transformers_1.transformCommandReply)(command) : null);
	    }
	};
	
	return COMMAND_INFO;
}

var COMMAND_LIST = {};

var hasRequiredCOMMAND_LIST;

function requireCOMMAND_LIST () {
	if (hasRequiredCOMMAND_LIST) return COMMAND_LIST;
	hasRequiredCOMMAND_LIST = 1;
	Object.defineProperty(COMMAND_LIST, "__esModule", { value: true });
	COMMAND_LIST.COMMAND_LIST_FILTER_BY = void 0;
	COMMAND_LIST.COMMAND_LIST_FILTER_BY = {
	    MODULE: 'MODULE',
	    ACLCAT: 'ACLCAT',
	    PATTERN: 'PATTERN'
	};
	COMMAND_LIST.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns a list of all commands supported by the Redis server
	     * @param parser - The Redis command parser
	     * @param options - Options for filtering the command list
	     */
	    parseCommand(parser, options) {
	        parser.push('COMMAND', 'LIST');
	        if (options?.FILTERBY) {
	            parser.push('FILTERBY', options.FILTERBY.type, options.FILTERBY.value);
	        }
	    },
	    transformReply: undefined
	};
	
	return COMMAND_LIST;
}

var COMMAND = {};

var hasRequiredCOMMAND;

function requireCOMMAND () {
	if (hasRequiredCOMMAND) return COMMAND;
	hasRequiredCOMMAND = 1;
	Object.defineProperty(COMMAND, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	COMMAND.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns an array with details about all Redis commands
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('COMMAND');
	    },
	    // TODO: This works, as we don't currently handle any of the items returned as a map
	    transformReply(reply) {
	        return reply.map(generic_transformers_1.transformCommandReply);
	    }
	};
	
	return COMMAND;
}

var CONFIG_GET$1 = {};

var hasRequiredCONFIG_GET$1;

function requireCONFIG_GET$1 () {
	if (hasRequiredCONFIG_GET$1) return CONFIG_GET$1;
	hasRequiredCONFIG_GET$1 = 1;
	Object.defineProperty(CONFIG_GET$1, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	CONFIG_GET$1.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets the values of configuration parameters
	     * @param parser - The Redis command parser
	     * @param parameters - Pattern or specific configuration parameter names
	     */
	    parseCommand(parser, parameters) {
	        parser.push('CONFIG', 'GET');
	        parser.pushVariadic(parameters);
	    },
	    transformReply: {
	        2: (generic_transformers_1.transformTuplesReply),
	        3: undefined
	    }
	};
	
	return CONFIG_GET$1;
}

var CONFIG_RESETSTAT = {};

var hasRequiredCONFIG_RESETSTAT;

function requireCONFIG_RESETSTAT () {
	if (hasRequiredCONFIG_RESETSTAT) return CONFIG_RESETSTAT;
	hasRequiredCONFIG_RESETSTAT = 1;
	Object.defineProperty(CONFIG_RESETSTAT, "__esModule", { value: true });
	CONFIG_RESETSTAT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Resets the statistics reported by Redis using the INFO command
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CONFIG', 'RESETSTAT');
	    },
	    transformReply: undefined
	};
	
	return CONFIG_RESETSTAT;
}

var CONFIG_REWRITE = {};

var hasRequiredCONFIG_REWRITE;

function requireCONFIG_REWRITE () {
	if (hasRequiredCONFIG_REWRITE) return CONFIG_REWRITE;
	hasRequiredCONFIG_REWRITE = 1;
	Object.defineProperty(CONFIG_REWRITE, "__esModule", { value: true });
	CONFIG_REWRITE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Rewrites the Redis configuration file with the current configuration
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('CONFIG', 'REWRITE');
	    },
	    transformReply: undefined
	};
	
	return CONFIG_REWRITE;
}

var CONFIG_SET$1 = {};

var hasRequiredCONFIG_SET$1;

function requireCONFIG_SET$1 () {
	if (hasRequiredCONFIG_SET$1) return CONFIG_SET$1;
	hasRequiredCONFIG_SET$1 = 1;
	Object.defineProperty(CONFIG_SET$1, "__esModule", { value: true });
	CONFIG_SET$1.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Sets configuration parameters to the specified values
	     * @param parser - The Redis command parser
	     * @param parameterOrConfig - Either a single parameter name or a configuration object
	     * @param value - Value for the parameter (when using single parameter format)
	     */
	    parseCommand(parser, ...[parameterOrConfig, value]) {
	        parser.push('CONFIG', 'SET');
	        if (typeof parameterOrConfig === 'string' || parameterOrConfig instanceof Buffer) {
	            parser.push(parameterOrConfig, value);
	        }
	        else {
	            for (const [key, value] of Object.entries(parameterOrConfig)) {
	                parser.push(key, value);
	            }
	        }
	    },
	    transformReply: undefined
	};
	
	return CONFIG_SET$1;
}

var COPY = {};

var hasRequiredCOPY;

function requireCOPY () {
	if (hasRequiredCOPY) return COPY;
	hasRequiredCOPY = 1;
	Object.defineProperty(COPY, "__esModule", { value: true });
	COPY.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Copies the value stored at the source key to the destination key
	     * @param parser - The Redis command parser
	     * @param source - Source key
	     * @param destination - Destination key
	     * @param options - Options for the copy operation
	     */
	    parseCommand(parser, source, destination, options) {
	        parser.push('COPY');
	        parser.pushKeys([source, destination]);
	        if (options?.DB) {
	            parser.push('DB', options.DB.toString());
	        }
	        if (options?.REPLACE) {
	            parser.push('REPLACE');
	        }
	    },
	    transformReply: undefined
	};
	
	return COPY;
}

var DBSIZE = {};

var hasRequiredDBSIZE;

function requireDBSIZE () {
	if (hasRequiredDBSIZE) return DBSIZE;
	hasRequiredDBSIZE = 1;
	Object.defineProperty(DBSIZE, "__esModule", { value: true });
	DBSIZE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the number of keys in the current database
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('DBSIZE');
	    },
	    transformReply: undefined
	};
	
	return DBSIZE;
}

var DECR = {};

var hasRequiredDECR;

function requireDECR () {
	if (hasRequiredDECR) return DECR;
	hasRequiredDECR = 1;
	Object.defineProperty(DECR, "__esModule", { value: true });
	DECR.default = {
	    /**
	     * Decrements the integer value of a key by one
	     * @param parser - The Redis command parser
	     * @param key - Key to decrement
	     */
	    parseCommand(parser, key) {
	        parser.push('DECR');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return DECR;
}

var DECRBY$1 = {};

var hasRequiredDECRBY$1;

function requireDECRBY$1 () {
	if (hasRequiredDECRBY$1) return DECRBY$1;
	hasRequiredDECRBY$1 = 1;
	Object.defineProperty(DECRBY$1, "__esModule", { value: true });
	DECRBY$1.default = {
	    /**
	     * Decrements the integer value of a key by the given number
	     * @param parser - The Redis command parser
	     * @param key - Key to decrement
	     * @param decrement - Decrement amount
	     */
	    parseCommand(parser, key, decrement) {
	        parser.push('DECRBY');
	        parser.pushKey(key);
	        parser.push(decrement.toString());
	    },
	    transformReply: undefined
	};
	
	return DECRBY$1;
}

var DEL$3 = {};

var hasRequiredDEL$3;

function requireDEL$3 () {
	if (hasRequiredDEL$3) return DEL$3;
	hasRequiredDEL$3 = 1;
	Object.defineProperty(DEL$3, "__esModule", { value: true });
	DEL$3.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes the specified keys. A key is ignored if it does not exist
	     * @param parser - The Redis command parser
	     * @param keys - One or more keys to delete
	     */
	    parseCommand(parser, keys) {
	        parser.push('DEL');
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return DEL$3;
}

var DUMP = {};

var hasRequiredDUMP;

function requireDUMP () {
	if (hasRequiredDUMP) return DUMP;
	hasRequiredDUMP = 1;
	Object.defineProperty(DUMP, "__esModule", { value: true });
	DUMP.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns a serialized version of the value stored at the key
	     * @param parser - The Redis command parser
	     * @param key - Key to dump
	     */
	    parseCommand(parser, key) {
	        parser.push('DUMP');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return DUMP;
}

var ECHO = {};

var hasRequiredECHO;

function requireECHO () {
	if (hasRequiredECHO) return ECHO;
	hasRequiredECHO = 1;
	Object.defineProperty(ECHO, "__esModule", { value: true });
	ECHO.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the given string
	     * @param parser - The Redis command parser
	     * @param message - Message to echo back
	     */
	    parseCommand(parser, message) {
	        parser.push('ECHO', message);
	    },
	    transformReply: undefined
	};
	
	return ECHO;
}

var EVAL_RO = {};

var EVAL = {};

var hasRequiredEVAL;

function requireEVAL () {
	if (hasRequiredEVAL) return EVAL;
	hasRequiredEVAL = 1;
	Object.defineProperty(EVAL, "__esModule", { value: true });
	EVAL.parseEvalArguments = void 0;
	function parseEvalArguments(parser, script, options) {
	    parser.push(script);
	    if (options?.keys) {
	        parser.pushKeysLength(options.keys);
	    }
	    else {
	        parser.push('0');
	    }
	    if (options?.arguments) {
	        parser.push(...options.arguments);
	    }
	}
	EVAL.parseEvalArguments = parseEvalArguments;
	EVAL.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Executes a Lua script server side
	     * @param parser - The Redis command parser
	     * @param script - Lua script to execute
	     * @param options - Script execution options including keys and arguments
	     */
	    parseCommand(...args) {
	        args[0].push('EVAL');
	        parseEvalArguments(...args);
	    },
	    transformReply: undefined
	};
	
	return EVAL;
}

var hasRequiredEVAL_RO;

function requireEVAL_RO () {
	if (hasRequiredEVAL_RO) return EVAL_RO;
	hasRequiredEVAL_RO = 1;
	var __createBinding = (EVAL_RO && EVAL_RO.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (EVAL_RO && EVAL_RO.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (EVAL_RO && EVAL_RO.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(EVAL_RO, "__esModule", { value: true });
	const EVAL_1 = __importStar(requireEVAL());
	EVAL_RO.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Executes a read-only Lua script server side
	     * @param parser - The Redis command parser
	     * @param script - Lua script to execute
	     * @param options - Script execution options including keys and arguments
	     */
	    parseCommand(...args) {
	        args[0].push('EVAL_RO');
	        (0, EVAL_1.parseEvalArguments)(...args);
	    },
	    transformReply: EVAL_1.default.transformReply
	};
	
	return EVAL_RO;
}

var EVALSHA_RO = {};

var hasRequiredEVALSHA_RO;

function requireEVALSHA_RO () {
	if (hasRequiredEVALSHA_RO) return EVALSHA_RO;
	hasRequiredEVALSHA_RO = 1;
	var __createBinding = (EVALSHA_RO && EVALSHA_RO.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (EVALSHA_RO && EVALSHA_RO.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (EVALSHA_RO && EVALSHA_RO.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(EVALSHA_RO, "__esModule", { value: true });
	const EVAL_1 = __importStar(requireEVAL());
	EVALSHA_RO.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Executes a read-only Lua script server side using the script's SHA1 digest
	     * @param parser - The Redis command parser
	     * @param sha1 - SHA1 digest of the script
	     * @param options - Script execution options including keys and arguments
	     */
	    parseCommand(...args) {
	        args[0].push('EVALSHA_RO');
	        (0, EVAL_1.parseEvalArguments)(...args);
	    },
	    transformReply: EVAL_1.default.transformReply
	};
	
	return EVALSHA_RO;
}

var EVALSHA = {};

var hasRequiredEVALSHA;

function requireEVALSHA () {
	if (hasRequiredEVALSHA) return EVALSHA;
	hasRequiredEVALSHA = 1;
	var __createBinding = (EVALSHA && EVALSHA.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (EVALSHA && EVALSHA.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (EVALSHA && EVALSHA.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(EVALSHA, "__esModule", { value: true });
	const EVAL_1 = __importStar(requireEVAL());
	EVALSHA.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Executes a Lua script server side using the script's SHA1 digest
	     * @param parser - The Redis command parser
	     * @param sha1 - SHA1 digest of the script
	     * @param options - Script execution options including keys and arguments
	     */
	    parseCommand(...args) {
	        args[0].push('EVALSHA');
	        (0, EVAL_1.parseEvalArguments)(...args);
	    },
	    transformReply: EVAL_1.default.transformReply
	};
	
	return EVALSHA;
}

var GEOADD = {};

var hasRequiredGEOADD;

function requireGEOADD () {
	if (hasRequiredGEOADD) return GEOADD;
	hasRequiredGEOADD = 1;
	Object.defineProperty(GEOADD, "__esModule", { value: true });
	GEOADD.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds geospatial items to the specified key
	     * @param parser - The Redis command parser
	     * @param key - Key to add the geospatial items to
	     * @param toAdd - Geospatial member(s) to add
	     * @param options - Options for the GEOADD command
	     */
	    parseCommand(parser, key, toAdd, options) {
	        parser.push('GEOADD');
	        parser.pushKey(key);
	        if (options?.condition) {
	            parser.push(options.condition);
	        }
	        else if (options?.NX) {
	            parser.push('NX');
	        }
	        else if (options?.XX) {
	            parser.push('XX');
	        }
	        if (options?.CH) {
	            parser.push('CH');
	        }
	        if (Array.isArray(toAdd)) {
	            for (const member of toAdd) {
	                pushMember(parser, member);
	            }
	        }
	        else {
	            pushMember(parser, toAdd);
	        }
	    },
	    transformReply: undefined
	};
	function pushMember(parser, { longitude, latitude, member }) {
	    parser.push(longitude.toString(), latitude.toString(), member);
	}
	
	return GEOADD;
}

var GEODIST = {};

var hasRequiredGEODIST;

function requireGEODIST () {
	if (hasRequiredGEODIST) return GEODIST;
	hasRequiredGEODIST = 1;
	Object.defineProperty(GEODIST, "__esModule", { value: true });
	GEODIST.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the distance between two members in a geospatial index
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param member1 - First member in the geospatial index
	     * @param member2 - Second member in the geospatial index
	     * @param unit - Unit of distance (m, km, ft, mi)
	     */
	    parseCommand(parser, key, member1, member2, unit) {
	        parser.push('GEODIST');
	        parser.pushKey(key);
	        parser.push(member1, member2);
	        if (unit) {
	            parser.push(unit);
	        }
	    },
	    transformReply(reply) {
	        return reply === null ? null : Number(reply);
	    }
	};
	
	return GEODIST;
}

var GEOHASH = {};

var hasRequiredGEOHASH;

function requireGEOHASH () {
	if (hasRequiredGEOHASH) return GEOHASH;
	hasRequiredGEOHASH = 1;
	Object.defineProperty(GEOHASH, "__esModule", { value: true });
	GEOHASH.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the Geohash string representation of one or more position members
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param member - One or more members in the geospatial index
	     */
	    parseCommand(parser, key, member) {
	        parser.push('GEOHASH');
	        parser.pushKey(key);
	        parser.pushVariadic(member);
	    },
	    transformReply: undefined
	};
	
	return GEOHASH;
}

var GEOPOS = {};

var hasRequiredGEOPOS;

function requireGEOPOS () {
	if (hasRequiredGEOPOS) return GEOPOS;
	hasRequiredGEOPOS = 1;
	Object.defineProperty(GEOPOS, "__esModule", { value: true });
	GEOPOS.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the longitude and latitude of one or more members in a geospatial index
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param member - One or more members in the geospatial index
	     */
	    parseCommand(parser, key, member) {
	        parser.push('GEOPOS');
	        parser.pushKey(key);
	        parser.pushVariadic(member);
	    },
	    transformReply(reply) {
	        return reply.map(item => {
	            const unwrapped = item;
	            return unwrapped === null ? null : {
	                longitude: unwrapped[0],
	                latitude: unwrapped[1]
	            };
	        });
	    }
	};
	
	return GEOPOS;
}

var GEORADIUS_RO_WITH = {};

var GEORADIUS_WITH = {};

var GEORADIUS = {};

var GEOSEARCH = {};

var hasRequiredGEOSEARCH;

function requireGEOSEARCH () {
	if (hasRequiredGEOSEARCH) return GEOSEARCH;
	hasRequiredGEOSEARCH = 1;
	Object.defineProperty(GEOSEARCH, "__esModule", { value: true });
	GEOSEARCH.parseGeoSearchOptions = GEOSEARCH.parseGeoSearchArguments = void 0;
	function parseGeoSearchArguments(parser, key, from, by, options) {
	    parser.pushKey(key);
	    if (typeof from === 'string' || from instanceof Buffer) {
	        parser.push('FROMMEMBER', from);
	    }
	    else {
	        parser.push('FROMLONLAT', from.longitude.toString(), from.latitude.toString());
	    }
	    if ('radius' in by) {
	        parser.push('BYRADIUS', by.radius.toString(), by.unit);
	    }
	    else {
	        parser.push('BYBOX', by.width.toString(), by.height.toString(), by.unit);
	    }
	    parseGeoSearchOptions(parser, options);
	}
	GEOSEARCH.parseGeoSearchArguments = parseGeoSearchArguments;
	function parseGeoSearchOptions(parser, options) {
	    if (options?.SORT) {
	        parser.push(options.SORT);
	    }
	    if (options?.COUNT) {
	        if (typeof options.COUNT === 'number') {
	            parser.push('COUNT', options.COUNT.toString());
	        }
	        else {
	            parser.push('COUNT', options.COUNT.value.toString());
	            if (options.COUNT.ANY) {
	                parser.push('ANY');
	            }
	        }
	    }
	}
	GEOSEARCH.parseGeoSearchOptions = parseGeoSearchOptions;
	GEOSEARCH.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Queries members inside an area of a geospatial index
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Center point of the search (member name or coordinates)
	     * @param by - Search area specification (radius or box dimensions)
	     * @param options - Additional search options
	     */
	    parseCommand(parser, key, from, by, options) {
	        parser.push('GEOSEARCH');
	        parseGeoSearchArguments(parser, key, from, by, options);
	    },
	    transformReply: undefined
	};
	
	return GEOSEARCH;
}

var hasRequiredGEORADIUS;

function requireGEORADIUS () {
	if (hasRequiredGEORADIUS) return GEORADIUS;
	hasRequiredGEORADIUS = 1;
	Object.defineProperty(GEORADIUS, "__esModule", { value: true });
	GEORADIUS.parseGeoRadiusArguments = void 0;
	const GEOSEARCH_1 = requireGEOSEARCH();
	function parseGeoRadiusArguments(parser, key, from, radius, unit, options) {
	    parser.pushKey(key);
	    parser.push(from.longitude.toString(), from.latitude.toString(), radius.toString(), unit);
	    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
	}
	GEORADIUS.parseGeoRadiusArguments = parseGeoRadiusArguments;
	GEORADIUS.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Queries members in a geospatial index based on a radius from a center point
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Center coordinates for the search
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param options - Additional search options
	     */
	    parseCommand(...args) {
	        args[0].push('GEORADIUS');
	        return parseGeoRadiusArguments(...args);
	    },
	    transformReply: undefined
	};
	
	return GEORADIUS;
}

var GEOSEARCH_WITH = {};

var hasRequiredGEOSEARCH_WITH;

function requireGEOSEARCH_WITH () {
	if (hasRequiredGEOSEARCH_WITH) return GEOSEARCH_WITH;
	hasRequiredGEOSEARCH_WITH = 1;
	(function (exports) {
		var __importDefault = (GEOSEARCH_WITH && GEOSEARCH_WITH.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.GEO_REPLY_WITH = void 0;
		const GEOSEARCH_1 = __importDefault(requireGEOSEARCH());
		exports.GEO_REPLY_WITH = {
		    DISTANCE: 'WITHDIST',
		    HASH: 'WITHHASH',
		    COORDINATES: 'WITHCOORD'
		};
		exports.default = {
		    IS_READ_ONLY: GEOSEARCH_1.default.IS_READ_ONLY,
		    /**
		     * Queries members inside an area of a geospatial index with additional information
		     * @param parser - The Redis command parser
		     * @param key - Key of the geospatial index
		     * @param from - Center point of the search (member name or coordinates)
		     * @param by - Search area specification (radius or box dimensions)
		     * @param replyWith - Information to include with each returned member
		     * @param options - Additional search options
		     */
		    parseCommand(parser, key, from, by, replyWith, options) {
		        GEOSEARCH_1.default.parseCommand(parser, key, from, by, options);
		        parser.push(...replyWith);
		        parser.preserve = replyWith;
		    },
		    transformReply(reply, replyWith) {
		        const replyWithSet = new Set(replyWith);
		        let index = 0;
		        const distanceIndex = replyWithSet.has(exports.GEO_REPLY_WITH.DISTANCE) && ++index, hashIndex = replyWithSet.has(exports.GEO_REPLY_WITH.HASH) && ++index, coordinatesIndex = replyWithSet.has(exports.GEO_REPLY_WITH.COORDINATES) && ++index;
		        return reply.map(raw => {
		            const unwrapped = raw;
		            const item = {
		                member: unwrapped[0]
		            };
		            if (distanceIndex) {
		                item.distance = unwrapped[distanceIndex];
		            }
		            if (hashIndex) {
		                item.hash = unwrapped[hashIndex];
		            }
		            if (coordinatesIndex) {
		                const [longitude, latitude] = unwrapped[coordinatesIndex];
		                item.coordinates = {
		                    longitude,
		                    latitude
		                };
		            }
		            return item;
		        });
		    }
		};
		
	} (GEOSEARCH_WITH));
	return GEOSEARCH_WITH;
}

var hasRequiredGEORADIUS_WITH;

function requireGEORADIUS_WITH () {
	if (hasRequiredGEORADIUS_WITH) return GEORADIUS_WITH;
	hasRequiredGEORADIUS_WITH = 1;
	var __createBinding = (GEORADIUS_WITH && GEORADIUS_WITH.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (GEORADIUS_WITH && GEORADIUS_WITH.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (GEORADIUS_WITH && GEORADIUS_WITH.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (GEORADIUS_WITH && GEORADIUS_WITH.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(GEORADIUS_WITH, "__esModule", { value: true });
	GEORADIUS_WITH.parseGeoRadiusWithArguments = void 0;
	const GEORADIUS_1 = __importStar(requireGEORADIUS());
	const GEOSEARCH_WITH_1 = __importDefault(requireGEOSEARCH_WITH());
	function parseGeoRadiusWithArguments(parser, key, from, radius, unit, replyWith, options) {
	    (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from, radius, unit, options);
	    parser.pushVariadic(replyWith);
	    parser.preserve = replyWith;
	}
	GEORADIUS_WITH.parseGeoRadiusWithArguments = parseGeoRadiusWithArguments;
	GEORADIUS_WITH.default = {
	    IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
	    /**
	     * Queries members in a geospatial index based on a radius from a center point with additional information
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Center coordinates for the search
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param replyWith - Information to include with each returned member
	     * @param options - Additional search options
	     */
	    parseCommand(parser, key, from, radius, unit, replyWith, options) {
	        parser.push('GEORADIUS');
	        parseGeoRadiusWithArguments(parser, key, from, radius, unit, replyWith, options);
	    },
	    transformReply: GEOSEARCH_WITH_1.default.transformReply
	};
	
	return GEORADIUS_WITH;
}

var hasRequiredGEORADIUS_RO_WITH;

function requireGEORADIUS_RO_WITH () {
	if (hasRequiredGEORADIUS_RO_WITH) return GEORADIUS_RO_WITH;
	hasRequiredGEORADIUS_RO_WITH = 1;
	var __importDefault = (GEORADIUS_RO_WITH && GEORADIUS_RO_WITH.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(GEORADIUS_RO_WITH, "__esModule", { value: true });
	const GEORADIUS_WITH_1 = requireGEORADIUS_WITH();
	const GEORADIUS_WITH_2 = __importDefault(requireGEORADIUS_WITH());
	GEORADIUS_RO_WITH.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Read-only variant that queries members in a geospatial index based on a radius from a center point with additional information
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Center coordinates for the search
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param replyWith - Information to include with each returned member
	     * @param options - Additional search options
	     */
	    parseCommand(...args) {
	        args[0].push('GEORADIUS_RO');
	        (0, GEORADIUS_WITH_1.parseGeoRadiusWithArguments)(...args);
	    },
	    transformReply: GEORADIUS_WITH_2.default.transformReply
	};
	
	return GEORADIUS_RO_WITH;
}

var GEORADIUS_RO = {};

var hasRequiredGEORADIUS_RO;

function requireGEORADIUS_RO () {
	if (hasRequiredGEORADIUS_RO) return GEORADIUS_RO;
	hasRequiredGEORADIUS_RO = 1;
	var __createBinding = (GEORADIUS_RO && GEORADIUS_RO.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (GEORADIUS_RO && GEORADIUS_RO.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (GEORADIUS_RO && GEORADIUS_RO.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(GEORADIUS_RO, "__esModule", { value: true });
	const GEORADIUS_1 = __importStar(requireGEORADIUS());
	GEORADIUS_RO.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Read-only variant that queries members in a geospatial index based on a radius from a center point
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Center coordinates for the search
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param options - Additional search options
	     */
	    parseCommand(...args) {
	        args[0].push('GEORADIUS_RO');
	        (0, GEORADIUS_1.parseGeoRadiusArguments)(...args);
	    },
	    transformReply: GEORADIUS_1.default.transformReply
	};
	
	return GEORADIUS_RO;
}

var GEORADIUS_STORE = {};

var hasRequiredGEORADIUS_STORE;

function requireGEORADIUS_STORE () {
	if (hasRequiredGEORADIUS_STORE) return GEORADIUS_STORE;
	hasRequiredGEORADIUS_STORE = 1;
	var __createBinding = (GEORADIUS_STORE && GEORADIUS_STORE.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (GEORADIUS_STORE && GEORADIUS_STORE.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (GEORADIUS_STORE && GEORADIUS_STORE.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(GEORADIUS_STORE, "__esModule", { value: true });
	const GEORADIUS_1 = __importStar(requireGEORADIUS());
	GEORADIUS_STORE.default = {
	    IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
	    /**
	     * Queries members in a geospatial index based on a radius from a center point and stores the results
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Center coordinates for the search
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param destination - Key to store the results
	     * @param options - Additional search and storage options
	     */
	    parseCommand(parser, key, from, radius, unit, destination, options) {
	        parser.push('GEORADIUS');
	        (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from, radius, unit, options);
	        if (options?.STOREDIST) {
	            parser.push('STOREDIST');
	            parser.pushKey(destination);
	        }
	        else {
	            parser.push('STORE');
	            parser.pushKey(destination);
	        }
	    },
	    transformReply: undefined
	};
	
	return GEORADIUS_STORE;
}

var GEORADIUSBYMEMBER_RO_WITH = {};

var GEORADIUSBYMEMBER_WITH = {};

var GEORADIUSBYMEMBER = {};

var hasRequiredGEORADIUSBYMEMBER;

function requireGEORADIUSBYMEMBER () {
	if (hasRequiredGEORADIUSBYMEMBER) return GEORADIUSBYMEMBER;
	hasRequiredGEORADIUSBYMEMBER = 1;
	Object.defineProperty(GEORADIUSBYMEMBER, "__esModule", { value: true });
	GEORADIUSBYMEMBER.parseGeoRadiusByMemberArguments = void 0;
	const GEOSEARCH_1 = requireGEOSEARCH();
	function parseGeoRadiusByMemberArguments(parser, key, from, radius, unit, options) {
	    parser.pushKey(key);
	    parser.push(from, radius.toString(), unit);
	    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
	}
	GEORADIUSBYMEMBER.parseGeoRadiusByMemberArguments = parseGeoRadiusByMemberArguments;
	GEORADIUSBYMEMBER.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Queries members in a geospatial index based on a radius from a member
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Member name to use as center point
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param options - Additional search options
	     */
	    parseCommand(parser, key, from, radius, unit, options) {
	        parser.push('GEORADIUSBYMEMBER');
	        parseGeoRadiusByMemberArguments(parser, key, from, radius, unit, options);
	    },
	    transformReply: undefined
	};
	
	return GEORADIUSBYMEMBER;
}

var hasRequiredGEORADIUSBYMEMBER_WITH;

function requireGEORADIUSBYMEMBER_WITH () {
	if (hasRequiredGEORADIUSBYMEMBER_WITH) return GEORADIUSBYMEMBER_WITH;
	hasRequiredGEORADIUSBYMEMBER_WITH = 1;
	var __importDefault = (GEORADIUSBYMEMBER_WITH && GEORADIUSBYMEMBER_WITH.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(GEORADIUSBYMEMBER_WITH, "__esModule", { value: true });
	GEORADIUSBYMEMBER_WITH.parseGeoRadiusByMemberWithArguments = void 0;
	const GEORADIUSBYMEMBER_1 = __importDefault(requireGEORADIUSBYMEMBER());
	const GEOSEARCH_1 = requireGEOSEARCH();
	const GEOSEARCH_WITH_1 = __importDefault(requireGEOSEARCH_WITH());
	function parseGeoRadiusByMemberWithArguments(parser, key, from, radius, unit, replyWith, options) {
	    parser.pushKey(key);
	    parser.push(from, radius.toString(), unit);
	    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
	    parser.push(...replyWith);
	    parser.preserve = replyWith;
	}
	GEORADIUSBYMEMBER_WITH.parseGeoRadiusByMemberWithArguments = parseGeoRadiusByMemberWithArguments;
	GEORADIUSBYMEMBER_WITH.default = {
	    IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
	    /**
	     * Queries members in a geospatial index based on a radius from a member with additional information
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Member name to use as center point
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param replyWith - Information to include with each returned member
	     * @param options - Additional search options
	     */
	    parseCommand(parser, key, from, radius, unit, replyWith, options) {
	        parser.push('GEORADIUSBYMEMBER');
	        parseGeoRadiusByMemberWithArguments(parser, key, from, radius, unit, replyWith, options);
	    },
	    transformReply: GEOSEARCH_WITH_1.default.transformReply
	};
	
	return GEORADIUSBYMEMBER_WITH;
}

var hasRequiredGEORADIUSBYMEMBER_RO_WITH;

function requireGEORADIUSBYMEMBER_RO_WITH () {
	if (hasRequiredGEORADIUSBYMEMBER_RO_WITH) return GEORADIUSBYMEMBER_RO_WITH;
	hasRequiredGEORADIUSBYMEMBER_RO_WITH = 1;
	var __createBinding = (GEORADIUSBYMEMBER_RO_WITH && GEORADIUSBYMEMBER_RO_WITH.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (GEORADIUSBYMEMBER_RO_WITH && GEORADIUSBYMEMBER_RO_WITH.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (GEORADIUSBYMEMBER_RO_WITH && GEORADIUSBYMEMBER_RO_WITH.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(GEORADIUSBYMEMBER_RO_WITH, "__esModule", { value: true });
	const GEORADIUSBYMEMBER_WITH_1 = __importStar(requireGEORADIUSBYMEMBER_WITH());
	GEORADIUSBYMEMBER_RO_WITH.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Read-only variant that queries members in a geospatial index based on a radius from a member with additional information
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Member name to use as center point
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param withValues - Information to include with each returned member
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        parser.push('GEORADIUSBYMEMBER_RO');
	        (0, GEORADIUSBYMEMBER_WITH_1.parseGeoRadiusByMemberWithArguments)(...args);
	    },
	    transformReply: GEORADIUSBYMEMBER_WITH_1.default.transformReply
	};
	
	return GEORADIUSBYMEMBER_RO_WITH;
}

var GEORADIUSBYMEMBER_RO = {};

var hasRequiredGEORADIUSBYMEMBER_RO;

function requireGEORADIUSBYMEMBER_RO () {
	if (hasRequiredGEORADIUSBYMEMBER_RO) return GEORADIUSBYMEMBER_RO;
	hasRequiredGEORADIUSBYMEMBER_RO = 1;
	var __createBinding = (GEORADIUSBYMEMBER_RO && GEORADIUSBYMEMBER_RO.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (GEORADIUSBYMEMBER_RO && GEORADIUSBYMEMBER_RO.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (GEORADIUSBYMEMBER_RO && GEORADIUSBYMEMBER_RO.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(GEORADIUSBYMEMBER_RO, "__esModule", { value: true });
	const GEORADIUSBYMEMBER_1 = __importStar(requireGEORADIUSBYMEMBER());
	GEORADIUSBYMEMBER_RO.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Read-only variant that queries members in a geospatial index based on a radius from a member
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Member name to use as center point
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param options - Additional search options
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        parser.push('GEORADIUSBYMEMBER_RO');
	        (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(...args);
	    },
	    transformReply: GEORADIUSBYMEMBER_1.default.transformReply
	};
	
	return GEORADIUSBYMEMBER_RO;
}

var GEORADIUSBYMEMBER_STORE = {};

var hasRequiredGEORADIUSBYMEMBER_STORE;

function requireGEORADIUSBYMEMBER_STORE () {
	if (hasRequiredGEORADIUSBYMEMBER_STORE) return GEORADIUSBYMEMBER_STORE;
	hasRequiredGEORADIUSBYMEMBER_STORE = 1;
	var __createBinding = (GEORADIUSBYMEMBER_STORE && GEORADIUSBYMEMBER_STORE.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (GEORADIUSBYMEMBER_STORE && GEORADIUSBYMEMBER_STORE.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (GEORADIUSBYMEMBER_STORE && GEORADIUSBYMEMBER_STORE.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(GEORADIUSBYMEMBER_STORE, "__esModule", { value: true });
	const GEORADIUSBYMEMBER_1 = __importStar(requireGEORADIUSBYMEMBER());
	GEORADIUSBYMEMBER_STORE.default = {
	    IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
	    /**
	     * Queries members in a geospatial index based on a radius from a member and stores the results
	     * @param parser - The Redis command parser
	     * @param key - Key of the geospatial index
	     * @param from - Member name to use as center point
	     * @param radius - Radius of the search area
	     * @param unit - Unit of distance (m, km, ft, mi)
	     * @param destination - Key to store the results
	     * @param options - Additional search and storage options
	     */
	    parseCommand(parser, key, from, radius, unit, destination, options) {
	        parser.push('GEORADIUSBYMEMBER');
	        (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(parser, key, from, radius, unit, options);
	        if (options?.STOREDIST) {
	            parser.push('STOREDIST');
	            parser.pushKey(destination);
	        }
	        else {
	            parser.push('STORE');
	            parser.pushKey(destination);
	        }
	    },
	    transformReply: undefined
	};
	
	return GEORADIUSBYMEMBER_STORE;
}

var GEOSEARCHSTORE = {};

var hasRequiredGEOSEARCHSTORE;

function requireGEOSEARCHSTORE () {
	if (hasRequiredGEOSEARCHSTORE) return GEOSEARCHSTORE;
	hasRequiredGEOSEARCHSTORE = 1;
	Object.defineProperty(GEOSEARCHSTORE, "__esModule", { value: true });
	const GEOSEARCH_1 = requireGEOSEARCH();
	GEOSEARCHSTORE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Searches a geospatial index and stores the results in a new sorted set
	     * @param parser - The Redis command parser
	     * @param destination - Key to store the results
	     * @param source - Key of the geospatial index to search
	     * @param from - Center point of the search (member name or coordinates)
	     * @param by - Search area specification (radius or box dimensions)
	     * @param options - Additional search and storage options
	     */
	    parseCommand(parser, destination, source, from, by, options) {
	        parser.push('GEOSEARCHSTORE');
	        if (destination !== undefined) {
	            parser.pushKey(destination);
	        }
	        (0, GEOSEARCH_1.parseGeoSearchArguments)(parser, source, from, by, options);
	        if (options?.STOREDIST) {
	            parser.push('STOREDIST');
	        }
	    },
	    transformReply: undefined
	};
	
	return GEOSEARCHSTORE;
}

var GET$2 = {};

var hasRequiredGET$2;

function requireGET$2 () {
	if (hasRequiredGET$2) return GET$2;
	hasRequiredGET$2 = 1;
	Object.defineProperty(GET$2, "__esModule", { value: true });
	GET$2.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets the value of a key
	     * @param parser - The Redis command parser
	     * @param key - Key to get the value of
	     */
	    parseCommand(parser, key) {
	        parser.push('GET');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return GET$2;
}

var GETBIT = {};

var hasRequiredGETBIT;

function requireGETBIT () {
	if (hasRequiredGETBIT) return GETBIT;
	hasRequiredGETBIT = 1;
	Object.defineProperty(GETBIT, "__esModule", { value: true });
	GETBIT.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the bit value at a given offset in a string value
	     * @param parser - The Redis command parser
	     * @param key - Key to retrieve the bit from
	     * @param offset - Bit offset
	     */
	    parseCommand(parser, key, offset) {
	        parser.push('GETBIT');
	        parser.pushKey(key);
	        parser.push(offset.toString());
	    },
	    transformReply: undefined
	};
	
	return GETBIT;
}

var GETDEL = {};

var hasRequiredGETDEL;

function requireGETDEL () {
	if (hasRequiredGETDEL) return GETDEL;
	hasRequiredGETDEL = 1;
	Object.defineProperty(GETDEL, "__esModule", { value: true });
	GETDEL.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets the value of a key and deletes the key
	     * @param parser - The Redis command parser
	     * @param key - Key to get and delete
	     */
	    parseCommand(parser, key) {
	        parser.push('GETDEL');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return GETDEL;
}

var GETEX = {};

var hasRequiredGETEX;

function requireGETEX () {
	if (hasRequiredGETEX) return GETEX;
	hasRequiredGETEX = 1;
	Object.defineProperty(GETEX, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	GETEX.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets the value of a key and optionally sets its expiration
	     * @param parser - The Redis command parser
	     * @param key - Key to get value from
	     * @param options - Options for setting expiration
	     */
	    parseCommand(parser, key, options) {
	        parser.push('GETEX');
	        parser.pushKey(key);
	        if ('type' in options) {
	            switch (options.type) {
	                case 'EX':
	                case 'PX':
	                    parser.push(options.type, options.value.toString());
	                    break;
	                case 'EXAT':
	                case 'PXAT':
	                    parser.push(options.type, (0, generic_transformers_1.transformEXAT)(options.value));
	                    break;
	                case 'PERSIST':
	                    parser.push('PERSIST');
	                    break;
	            }
	        }
	        else {
	            if ('EX' in options) {
	                parser.push('EX', options.EX.toString());
	            }
	            else if ('PX' in options) {
	                parser.push('PX', options.PX.toString());
	            }
	            else if ('EXAT' in options) {
	                parser.push('EXAT', (0, generic_transformers_1.transformEXAT)(options.EXAT));
	            }
	            else if ('PXAT' in options) {
	                parser.push('PXAT', (0, generic_transformers_1.transformPXAT)(options.PXAT));
	            }
	            else { // PERSIST
	                parser.push('PERSIST');
	            }
	        }
	    },
	    transformReply: undefined
	};
	
	return GETEX;
}

var GETRANGE = {};

var hasRequiredGETRANGE;

function requireGETRANGE () {
	if (hasRequiredGETRANGE) return GETRANGE;
	hasRequiredGETRANGE = 1;
	Object.defineProperty(GETRANGE, "__esModule", { value: true });
	GETRANGE.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns a substring of the string stored at a key
	     * @param parser - The Redis command parser
	     * @param key - Key to get substring from
	     * @param start - Start position of the substring
	     * @param end - End position of the substring
	     */
	    parseCommand(parser, key, start, end) {
	        parser.push('GETRANGE');
	        parser.pushKey(key);
	        parser.push(start.toString(), end.toString());
	    },
	    transformReply: undefined
	};
	
	return GETRANGE;
}

var GETSET = {};

var hasRequiredGETSET;

function requireGETSET () {
	if (hasRequiredGETSET) return GETSET;
	hasRequiredGETSET = 1;
	Object.defineProperty(GETSET, "__esModule", { value: true });
	GETSET.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Sets a key to a new value and returns its old value
	     * @param parser - The Redis command parser
	     * @param key - Key to set
	     * @param value - Value to set
	     */
	    parseCommand(parser, key, value) {
	        parser.push('GETSET');
	        parser.pushKey(key);
	        parser.push(value);
	    },
	    transformReply: undefined
	};
	
	return GETSET;
}

var EXISTS$2 = {};

var hasRequiredEXISTS$2;

function requireEXISTS$2 () {
	if (hasRequiredEXISTS$2) return EXISTS$2;
	hasRequiredEXISTS$2 = 1;
	Object.defineProperty(EXISTS$2, "__esModule", { value: true });
	EXISTS$2.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Determines if the specified keys exist
	     * @param parser - The Redis command parser
	     * @param keys - One or more keys to check
	     */
	    parseCommand(parser, keys) {
	        parser.push('EXISTS');
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return EXISTS$2;
}

var EXPIRE = {};

var hasRequiredEXPIRE;

function requireEXPIRE () {
	if (hasRequiredEXPIRE) return EXPIRE;
	hasRequiredEXPIRE = 1;
	Object.defineProperty(EXPIRE, "__esModule", { value: true });
	EXPIRE.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Sets a timeout on key. After the timeout has expired, the key will be automatically deleted
	     * @param parser - The Redis command parser
	     * @param key - Key to set expiration on
	     * @param seconds - Number of seconds until key expiration
	     * @param mode - Expiration mode: NX (only if key has no expiry), XX (only if key has existing expiry), GT (only if new expiry is greater than current), LT (only if new expiry is less than current)
	     */
	    parseCommand(parser, key, seconds, mode) {
	        parser.push('EXPIRE');
	        parser.pushKey(key);
	        parser.push(seconds.toString());
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return EXPIRE;
}

var EXPIREAT = {};

var hasRequiredEXPIREAT;

function requireEXPIREAT () {
	if (hasRequiredEXPIREAT) return EXPIREAT;
	hasRequiredEXPIREAT = 1;
	Object.defineProperty(EXPIREAT, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	EXPIREAT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Sets the expiration for a key at a specific Unix timestamp
	     * @param parser - The Redis command parser
	     * @param key - Key to set expiration on
	     * @param timestamp - Unix timestamp (seconds since January 1, 1970) or Date object
	     * @param mode - Expiration mode: NX (only if key has no expiry), XX (only if key has existing expiry), GT (only if new expiry is greater than current), LT (only if new expiry is less than current)
	     */
	    parseCommand(parser, key, timestamp, mode) {
	        parser.push('EXPIREAT');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return EXPIREAT;
}

var EXPIRETIME = {};

var hasRequiredEXPIRETIME;

function requireEXPIRETIME () {
	if (hasRequiredEXPIRETIME) return EXPIRETIME;
	hasRequiredEXPIRETIME = 1;
	Object.defineProperty(EXPIRETIME, "__esModule", { value: true });
	EXPIRETIME.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the absolute Unix timestamp (since January 1, 1970) at which the given key will expire
	     * @param parser - The Redis command parser
	     * @param key - Key to check expiration time
	     */
	    parseCommand(parser, key) {
	        parser.push('EXPIRETIME');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return EXPIRETIME;
}

var FLUSHALL = {};

var hasRequiredFLUSHALL;

function requireFLUSHALL () {
	if (hasRequiredFLUSHALL) return FLUSHALL;
	hasRequiredFLUSHALL = 1;
	Object.defineProperty(FLUSHALL, "__esModule", { value: true });
	FLUSHALL.REDIS_FLUSH_MODES = void 0;
	FLUSHALL.REDIS_FLUSH_MODES = {
	    ASYNC: 'ASYNC',
	    SYNC: 'SYNC'
	};
	FLUSHALL.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: false,
	    /**
	     * Removes all keys from all databases
	     * @param parser - The Redis command parser
	     * @param mode - Optional flush mode (ASYNC or SYNC)
	     */
	    parseCommand(parser, mode) {
	        parser.push('FLUSHALL');
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return FLUSHALL;
}

var FLUSHDB = {};

var hasRequiredFLUSHDB;

function requireFLUSHDB () {
	if (hasRequiredFLUSHDB) return FLUSHDB;
	hasRequiredFLUSHDB = 1;
	Object.defineProperty(FLUSHDB, "__esModule", { value: true });
	FLUSHDB.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: false,
	    /**
	     * Removes all keys from the current database
	     * @param parser - The Redis command parser
	     * @param mode - Optional flush mode (ASYNC or SYNC)
	     */
	    parseCommand(parser, mode) {
	        parser.push('FLUSHDB');
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return FLUSHDB;
}

var FCALL = {};

var hasRequiredFCALL;

function requireFCALL () {
	if (hasRequiredFCALL) return FCALL;
	hasRequiredFCALL = 1;
	var __createBinding = (FCALL && FCALL.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (FCALL && FCALL.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (FCALL && FCALL.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(FCALL, "__esModule", { value: true });
	const EVAL_1 = __importStar(requireEVAL());
	FCALL.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Invokes a Redis function
	     * @param parser - The Redis command parser
	     * @param functionName - Name of the function to call
	     * @param options - Function execution options including keys and arguments
	     */
	    parseCommand(...args) {
	        args[0].push('FCALL');
	        (0, EVAL_1.parseEvalArguments)(...args);
	    },
	    transformReply: EVAL_1.default.transformReply
	};
	
	return FCALL;
}

var FCALL_RO = {};

var hasRequiredFCALL_RO;

function requireFCALL_RO () {
	if (hasRequiredFCALL_RO) return FCALL_RO;
	hasRequiredFCALL_RO = 1;
	var __createBinding = (FCALL_RO && FCALL_RO.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (FCALL_RO && FCALL_RO.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (FCALL_RO && FCALL_RO.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(FCALL_RO, "__esModule", { value: true });
	const EVAL_1 = __importStar(requireEVAL());
	FCALL_RO.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Invokes a read-only Redis function
	     * @param parser - The Redis command parser
	     * @param functionName - Name of the function to call
	     * @param options - Function execution options including keys and arguments
	     */
	    parseCommand(...args) {
	        args[0].push('FCALL_RO');
	        (0, EVAL_1.parseEvalArguments)(...args);
	    },
	    transformReply: EVAL_1.default.transformReply
	};
	
	return FCALL_RO;
}

var FUNCTION_DELETE = {};

var hasRequiredFUNCTION_DELETE;

function requireFUNCTION_DELETE () {
	if (hasRequiredFUNCTION_DELETE) return FUNCTION_DELETE;
	hasRequiredFUNCTION_DELETE = 1;
	Object.defineProperty(FUNCTION_DELETE, "__esModule", { value: true });
	FUNCTION_DELETE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: false,
	    /**
	     * Deletes a library and all its functions
	     * @param parser - The Redis command parser
	     * @param library - Name of the library to delete
	     */
	    parseCommand(parser, library) {
	        parser.push('FUNCTION', 'DELETE', library);
	    },
	    transformReply: undefined
	};
	
	return FUNCTION_DELETE;
}

var FUNCTION_DUMP = {};

var hasRequiredFUNCTION_DUMP;

function requireFUNCTION_DUMP () {
	if (hasRequiredFUNCTION_DUMP) return FUNCTION_DUMP;
	hasRequiredFUNCTION_DUMP = 1;
	Object.defineProperty(FUNCTION_DUMP, "__esModule", { value: true });
	FUNCTION_DUMP.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns a serialized payload representing the current functions loaded in the server
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('FUNCTION', 'DUMP');
	    },
	    transformReply: undefined
	};
	
	return FUNCTION_DUMP;
}

var FUNCTION_FLUSH = {};

var hasRequiredFUNCTION_FLUSH;

function requireFUNCTION_FLUSH () {
	if (hasRequiredFUNCTION_FLUSH) return FUNCTION_FLUSH;
	hasRequiredFUNCTION_FLUSH = 1;
	Object.defineProperty(FUNCTION_FLUSH, "__esModule", { value: true });
	FUNCTION_FLUSH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: false,
	    /**
	     * Deletes all the libraries and functions from a Redis server
	     * @param parser - The Redis command parser
	     * @param mode - Optional flush mode (ASYNC or SYNC)
	     */
	    parseCommand(parser, mode) {
	        parser.push('FUNCTION', 'FLUSH');
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return FUNCTION_FLUSH;
}

var FUNCTION_KILL = {};

var hasRequiredFUNCTION_KILL;

function requireFUNCTION_KILL () {
	if (hasRequiredFUNCTION_KILL) return FUNCTION_KILL;
	hasRequiredFUNCTION_KILL = 1;
	Object.defineProperty(FUNCTION_KILL, "__esModule", { value: true });
	FUNCTION_KILL.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Kills a function that is currently executing
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('FUNCTION', 'KILL');
	    },
	    transformReply: undefined
	};
	
	return FUNCTION_KILL;
}

var FUNCTION_LIST_WITHCODE = {};

var FUNCTION_LIST = {};

var hasRequiredFUNCTION_LIST;

function requireFUNCTION_LIST () {
	if (hasRequiredFUNCTION_LIST) return FUNCTION_LIST;
	hasRequiredFUNCTION_LIST = 1;
	Object.defineProperty(FUNCTION_LIST, "__esModule", { value: true });
	FUNCTION_LIST.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: false,
	    /**
	     * Returns all libraries and functions
	     * @param parser - The Redis command parser
	     * @param options - Options for listing functions
	     */
	    parseCommand(parser, options) {
	        parser.push('FUNCTION', 'LIST');
	        if (options?.LIBRARYNAME) {
	            parser.push('LIBRARYNAME', options.LIBRARYNAME);
	        }
	    },
	    transformReply: {
	        2: (reply) => {
	            return reply.map(library => {
	                const unwrapped = library;
	                return {
	                    library_name: unwrapped[1],
	                    engine: unwrapped[3],
	                    functions: unwrapped[5].map(fn => {
	                        const unwrapped = fn;
	                        return {
	                            name: unwrapped[1],
	                            description: unwrapped[3],
	                            flags: unwrapped[5]
	                        };
	                    })
	                };
	            });
	        },
	        3: undefined
	    }
	};
	
	return FUNCTION_LIST;
}

var hasRequiredFUNCTION_LIST_WITHCODE;

function requireFUNCTION_LIST_WITHCODE () {
	if (hasRequiredFUNCTION_LIST_WITHCODE) return FUNCTION_LIST_WITHCODE;
	hasRequiredFUNCTION_LIST_WITHCODE = 1;
	var __importDefault = (FUNCTION_LIST_WITHCODE && FUNCTION_LIST_WITHCODE.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(FUNCTION_LIST_WITHCODE, "__esModule", { value: true });
	const FUNCTION_LIST_1 = __importDefault(requireFUNCTION_LIST());
	FUNCTION_LIST_WITHCODE.default = {
	    NOT_KEYED_COMMAND: FUNCTION_LIST_1.default.NOT_KEYED_COMMAND,
	    IS_READ_ONLY: FUNCTION_LIST_1.default.IS_READ_ONLY,
	    /**
	     * Returns all libraries and functions including their source code
	     * @param parser - The Redis command parser
	     * @param options - Options for listing functions
	     */
	    parseCommand(...args) {
	        FUNCTION_LIST_1.default.parseCommand(...args);
	        args[0].push('WITHCODE');
	    },
	    transformReply: {
	        2: (reply) => {
	            return reply.map(library => {
	                const unwrapped = library;
	                return {
	                    library_name: unwrapped[1],
	                    engine: unwrapped[3],
	                    functions: unwrapped[5].map(fn => {
	                        const unwrapped = fn;
	                        return {
	                            name: unwrapped[1],
	                            description: unwrapped[3],
	                            flags: unwrapped[5]
	                        };
	                    }),
	                    library_code: unwrapped[7]
	                };
	            });
	        },
	        3: undefined
	    }
	};
	
	return FUNCTION_LIST_WITHCODE;
}

var FUNCTION_LOAD = {};

var hasRequiredFUNCTION_LOAD;

function requireFUNCTION_LOAD () {
	if (hasRequiredFUNCTION_LOAD) return FUNCTION_LOAD;
	hasRequiredFUNCTION_LOAD = 1;
	Object.defineProperty(FUNCTION_LOAD, "__esModule", { value: true });
	FUNCTION_LOAD.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: false,
	    /**
	     * Loads a library to Redis
	     * @param parser - The Redis command parser
	     * @param code - Library code to load
	     * @param options - Function load options
	     */
	    parseCommand(parser, code, options) {
	        parser.push('FUNCTION', 'LOAD');
	        if (options?.REPLACE) {
	            parser.push('REPLACE');
	        }
	        parser.push(code);
	    },
	    transformReply: undefined
	};
	
	return FUNCTION_LOAD;
}

var FUNCTION_RESTORE = {};

var hasRequiredFUNCTION_RESTORE;

function requireFUNCTION_RESTORE () {
	if (hasRequiredFUNCTION_RESTORE) return FUNCTION_RESTORE;
	hasRequiredFUNCTION_RESTORE = 1;
	Object.defineProperty(FUNCTION_RESTORE, "__esModule", { value: true });
	FUNCTION_RESTORE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: false,
	    /**
	     * Restores libraries from the dump payload
	     * @param parser - The Redis command parser
	     * @param dump - Serialized payload of functions to restore
	     * @param options - Options for the restore operation
	     */
	    parseCommand(parser, dump, options) {
	        parser.push('FUNCTION', 'RESTORE', dump);
	        if (options?.mode) {
	            parser.push(options.mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return FUNCTION_RESTORE;
}

var FUNCTION_STATS = {};

var hasRequiredFUNCTION_STATS;

function requireFUNCTION_STATS () {
	if (hasRequiredFUNCTION_STATS) return FUNCTION_STATS;
	hasRequiredFUNCTION_STATS = 1;
	Object.defineProperty(FUNCTION_STATS, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	FUNCTION_STATS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns information about the function that is currently running and information about the available execution engines
	     * @param parser - The Redis command parser
	     */
	    parseCommand(parser) {
	        parser.push('FUNCTION', 'STATS');
	    },
	    transformReply: {
	        2: (reply) => {
	            return {
	                running_script: transformRunningScript(reply[1]),
	                engines: transformEngines(reply[3])
	            };
	        },
	        3: undefined
	    }
	};
	function transformRunningScript(reply) {
	    if ((0, generic_transformers_1.isNullReply)(reply)) {
	        return null;
	    }
	    const unwraped = reply;
	    return {
	        name: unwraped[1],
	        command: unwraped[3],
	        duration_ms: unwraped[5]
	    };
	}
	function transformEngines(reply) {
	    const unwraped = reply;
	    const engines = Object.create(null);
	    for (let i = 0; i < unwraped.length; i++) {
	        const name = unwraped[i], stats = unwraped[++i], unwrapedStats = stats;
	        engines[name.toString()] = {
	            libraries_count: unwrapedStats[1],
	            functions_count: unwrapedStats[3]
	        };
	    }
	    return engines;
	}
	
	return FUNCTION_STATS;
}

var HDEL = {};

var hasRequiredHDEL;

function requireHDEL () {
	if (hasRequiredHDEL) return HDEL;
	hasRequiredHDEL = 1;
	Object.defineProperty(HDEL, "__esModule", { value: true });
	HDEL.default = {
	    /**
	     * Removes one or more fields from a hash
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param field - Field(s) to remove
	     */
	    parseCommand(parser, key, field) {
	        parser.push('HDEL');
	        parser.pushKey(key);
	        parser.pushVariadic(field);
	    },
	    transformReply: undefined
	};
	
	return HDEL;
}

var HELLO = {};

var hasRequiredHELLO;

function requireHELLO () {
	if (hasRequiredHELLO) return HELLO;
	hasRequiredHELLO = 1;
	Object.defineProperty(HELLO, "__esModule", { value: true });
	HELLO.default = {
	    /**
	     * Handshakes with the Redis server and switches to the specified protocol version
	     * @param parser - The Redis command parser
	     * @param protover - Protocol version to use
	     * @param options - Additional options for authentication and connection naming
	     */
	    parseCommand(parser, protover, options) {
	        parser.push('HELLO');
	        if (protover) {
	            parser.push(protover.toString());
	            if (options?.AUTH) {
	                parser.push('AUTH', options.AUTH.username, options.AUTH.password);
	            }
	            if (options?.SETNAME) {
	                parser.push('SETNAME', options.SETNAME);
	            }
	        }
	    },
	    transformReply: {
	        2: (reply) => ({
	            server: reply[1],
	            version: reply[3],
	            proto: reply[5],
	            id: reply[7],
	            mode: reply[9],
	            role: reply[11],
	            modules: reply[13]
	        }),
	        3: undefined
	    }
	};
	
	return HELLO;
}

var HEXISTS = {};

var hasRequiredHEXISTS;

function requireHEXISTS () {
	if (hasRequiredHEXISTS) return HEXISTS;
	hasRequiredHEXISTS = 1;
	Object.defineProperty(HEXISTS, "__esModule", { value: true });
	HEXISTS.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Determines whether a field exists in a hash
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param field - Field to check
	     */
	    parseCommand(parser, key, field) {
	        parser.push('HEXISTS');
	        parser.pushKey(key);
	        parser.push(field);
	    },
	    transformReply: undefined
	};
	
	return HEXISTS;
}

var HEXPIRE = {};

var hasRequiredHEXPIRE;

function requireHEXPIRE () {
	if (hasRequiredHEXPIRE) return HEXPIRE;
	hasRequiredHEXPIRE = 1;
	Object.defineProperty(HEXPIRE, "__esModule", { value: true });
	HEXPIRE.HASH_EXPIRATION = void 0;
	HEXPIRE.HASH_EXPIRATION = {
	    /** The field does not exist */
	    FIELD_NOT_EXISTS: -2,
	    /** Specified NX | XX | GT | LT condition not met */
	    CONDITION_NOT_MET: 0,
	    /** Expiration time was set or updated */
	    UPDATED: 1,
	    /** Field deleted because the specified expiration time is in the past */
	    DELETED: 2
	};
	HEXPIRE.default = {
	    /**
	     * Sets a timeout on hash fields. After the timeout has expired, the fields will be automatically deleted
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param fields - Fields to set expiration on
	     * @param seconds - Number of seconds until field expiration
	     * @param mode - Expiration mode: NX (only if field has no expiry), XX (only if field has existing expiry), GT (only if new expiry is greater than current), LT (only if new expiry is less than current)
	     */
	    parseCommand(parser, key, fields, seconds, mode) {
	        parser.push('HEXPIRE');
	        parser.pushKey(key);
	        parser.push(seconds.toString());
	        if (mode) {
	            parser.push(mode);
	        }
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HEXPIRE;
}

var HEXPIREAT = {};

var hasRequiredHEXPIREAT;

function requireHEXPIREAT () {
	if (hasRequiredHEXPIREAT) return HEXPIREAT;
	hasRequiredHEXPIREAT = 1;
	Object.defineProperty(HEXPIREAT, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	HEXPIREAT.default = {
	    /**
	     * Sets the expiration for hash fields at a specific Unix timestamp
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param fields - Fields to set expiration on
	     * @param timestamp - Unix timestamp (seconds since January 1, 1970) or Date object
	     * @param mode - Expiration mode: NX (only if field has no expiry), XX (only if field has existing expiry), GT (only if new expiry is greater than current), LT (only if new expiry is less than current)
	     */
	    parseCommand(parser, key, fields, timestamp, mode) {
	        parser.push('HEXPIREAT');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
	        if (mode) {
	            parser.push(mode);
	        }
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HEXPIREAT;
}

var HEXPIRETIME = {};

var hasRequiredHEXPIRETIME;

function requireHEXPIRETIME () {
	if (hasRequiredHEXPIRETIME) return HEXPIRETIME;
	hasRequiredHEXPIRETIME = 1;
	Object.defineProperty(HEXPIRETIME, "__esModule", { value: true });
	HEXPIRETIME.HASH_EXPIRATION_TIME = void 0;
	HEXPIRETIME.HASH_EXPIRATION_TIME = {
	    /** The field does not exist */
	    FIELD_NOT_EXISTS: -2,
	    /** The field exists but has no associated expire */
	    NO_EXPIRATION: -1,
	};
	HEXPIRETIME.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the absolute Unix timestamp (since January 1, 1970) at which the given hash fields will expire
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param fields - Fields to check expiration time
	     */
	    parseCommand(parser, key, fields) {
	        parser.push('HEXPIRETIME');
	        parser.pushKey(key);
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HEXPIRETIME;
}

var HGET = {};

var hasRequiredHGET;

function requireHGET () {
	if (hasRequiredHGET) return HGET;
	hasRequiredHGET = 1;
	Object.defineProperty(HGET, "__esModule", { value: true });
	HGET.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets the value of a field in a hash
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param field - Field to get the value of
	     */
	    parseCommand(parser, key, field) {
	        parser.push('HGET');
	        parser.pushKey(key);
	        parser.push(field);
	    },
	    transformReply: undefined
	};
	
	return HGET;
}

var HGETALL = {};

var hasRequiredHGETALL;

function requireHGETALL () {
	if (hasRequiredHGETALL) return HGETALL;
	hasRequiredHGETALL = 1;
	Object.defineProperty(HGETALL, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	HGETALL.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets all fields and values in a hash
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     */
	    parseCommand(parser, key) {
	        parser.push('HGETALL');
	        parser.pushKey(key);
	    },
	    TRANSFORM_LEGACY_REPLY: true,
	    transformReply: {
	        2: (generic_transformers_1.transformTuplesReply),
	        3: undefined
	    }
	};
	
	return HGETALL;
}

var HGETDEL = {};

var hasRequiredHGETDEL;

function requireHGETDEL () {
	if (hasRequiredHGETDEL) return HGETDEL;
	hasRequiredHGETDEL = 1;
	Object.defineProperty(HGETDEL, "__esModule", { value: true });
	HGETDEL.default = {
	    /**
	     * Gets and deletes the specified fields from a hash
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param fields - Fields to get and delete
	     */
	    parseCommand(parser, key, fields) {
	        parser.push('HGETDEL');
	        parser.pushKey(key);
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HGETDEL;
}

var HGETEX = {};

var hasRequiredHGETEX;

function requireHGETEX () {
	if (hasRequiredHGETEX) return HGETEX;
	hasRequiredHGETEX = 1;
	Object.defineProperty(HGETEX, "__esModule", { value: true });
	HGETEX.default = {
	    /**
	     * Gets the values of the specified fields in a hash and optionally sets their expiration
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param fields - Fields to get values from
	     * @param options - Options for setting expiration
	     */
	    parseCommand(parser, key, fields, options) {
	        parser.push('HGETEX');
	        parser.pushKey(key);
	        if (options?.expiration) {
	            if (typeof options.expiration === 'string') {
	                parser.push(options.expiration);
	            }
	            else if (options.expiration.type === 'PERSIST') {
	                parser.push('PERSIST');
	            }
	            else {
	                parser.push(options.expiration.type, options.expiration.value.toString());
	            }
	        }
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HGETEX;
}

var HINCRBY = {};

var hasRequiredHINCRBY;

function requireHINCRBY () {
	if (hasRequiredHINCRBY) return HINCRBY;
	hasRequiredHINCRBY = 1;
	Object.defineProperty(HINCRBY, "__esModule", { value: true });
	HINCRBY.default = {
	    /**
	     * Increments the integer value of a field in a hash by the given number
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param field - Field to increment
	     * @param increment - Increment amount
	     */
	    parseCommand(parser, key, field, increment) {
	        parser.push('HINCRBY');
	        parser.pushKey(key);
	        parser.push(field, increment.toString());
	    },
	    transformReply: undefined
	};
	
	return HINCRBY;
}

var HINCRBYFLOAT = {};

var hasRequiredHINCRBYFLOAT;

function requireHINCRBYFLOAT () {
	if (hasRequiredHINCRBYFLOAT) return HINCRBYFLOAT;
	hasRequiredHINCRBYFLOAT = 1;
	Object.defineProperty(HINCRBYFLOAT, "__esModule", { value: true });
	HINCRBYFLOAT.default = {
	    /**
	     * Increments the float value of a field in a hash by the given amount
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     * @param field - Field to increment
	     * @param increment - Increment amount (float)
	     */
	    parseCommand(parser, key, field, increment) {
	        parser.push('HINCRBYFLOAT');
	        parser.pushKey(key);
	        parser.push(field, increment.toString());
	    },
	    transformReply: undefined
	};
	
	return HINCRBYFLOAT;
}

var HKEYS = {};

var hasRequiredHKEYS;

function requireHKEYS () {
	if (hasRequiredHKEYS) return HKEYS;
	hasRequiredHKEYS = 1;
	Object.defineProperty(HKEYS, "__esModule", { value: true });
	HKEYS.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets all field names in a hash
	     * @param parser - The Redis command parser
	     * @param key - Key of the hash
	     */
	    parseCommand(parser, key) {
	        parser.push('HKEYS');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return HKEYS;
}

var HLEN = {};

var hasRequiredHLEN;

function requireHLEN () {
	if (hasRequiredHLEN) return HLEN;
	hasRequiredHLEN = 1;
	Object.defineProperty(HLEN, "__esModule", { value: true });
	HLEN.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets the number of fields in a hash.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the hash.
	     */
	    parseCommand(parser, key) {
	        parser.push('HLEN');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return HLEN;
}

var HMGET = {};

var hasRequiredHMGET;

function requireHMGET () {
	if (hasRequiredHMGET) return HMGET;
	hasRequiredHMGET = 1;
	Object.defineProperty(HMGET, "__esModule", { value: true });
	HMGET.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets the values of all the specified fields in a hash.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the hash.
	     * @param fields - Fields to get from the hash.
	     */
	    parseCommand(parser, key, fields) {
	        parser.push('HMGET');
	        parser.pushKey(key);
	        parser.pushVariadic(fields);
	    },
	    transformReply: undefined
	};
	
	return HMGET;
}

var HPERSIST = {};

var hasRequiredHPERSIST;

function requireHPERSIST () {
	if (hasRequiredHPERSIST) return HPERSIST;
	hasRequiredHPERSIST = 1;
	Object.defineProperty(HPERSIST, "__esModule", { value: true });
	HPERSIST.default = {
	    /**
	     * Removes the expiration from the specified fields in a hash.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the hash.
	     * @param fields - Fields to remove expiration from.
	     */
	    parseCommand(parser, key, fields) {
	        parser.push('HPERSIST');
	        parser.pushKey(key);
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HPERSIST;
}

var HPEXPIRE = {};

var hasRequiredHPEXPIRE;

function requireHPEXPIRE () {
	if (hasRequiredHPEXPIRE) return HPEXPIRE;
	hasRequiredHPEXPIRE = 1;
	Object.defineProperty(HPEXPIRE, "__esModule", { value: true });
	HPEXPIRE.default = {
	    /**
	     * Parses the arguments for the `HPEXPIRE` command.
	     *
	     * @param parser - The command parser instance.
	     * @param key - The key of the hash.
	     * @param fields - The fields to set the expiration for.
	     * @param ms - The expiration time in milliseconds.
	     * @param mode - Optional mode for the command ('NX', 'XX', 'GT', 'LT').
	     */
	    parseCommand(parser, key, fields, ms, mode) {
	        parser.push('HPEXPIRE');
	        parser.pushKey(key);
	        parser.push(ms.toString());
	        if (mode) {
	            parser.push(mode);
	        }
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HPEXPIRE;
}

var HPEXPIREAT = {};

var hasRequiredHPEXPIREAT;

function requireHPEXPIREAT () {
	if (hasRequiredHPEXPIREAT) return HPEXPIREAT;
	hasRequiredHPEXPIREAT = 1;
	Object.defineProperty(HPEXPIREAT, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	HPEXPIREAT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Parses the arguments for the `HPEXPIREAT` command.
	     *
	     * @param parser - The command parser instance.
	     * @param key - The key of the hash.
	     * @param fields - The fields to set the expiration for.
	     * @param timestamp - The expiration timestamp (Unix timestamp or Date object).
	     * @param mode - Optional mode for the command ('NX', 'XX', 'GT', 'LT').
	     */
	    parseCommand(parser, key, fields, timestamp, mode) {
	        parser.push('HPEXPIREAT');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformPXAT)(timestamp));
	        if (mode) {
	            parser.push(mode);
	        }
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HPEXPIREAT;
}

var HPEXPIRETIME = {};

var hasRequiredHPEXPIRETIME;

function requireHPEXPIRETIME () {
	if (hasRequiredHPEXPIRETIME) return HPEXPIRETIME;
	hasRequiredHPEXPIRETIME = 1;
	Object.defineProperty(HPEXPIRETIME, "__esModule", { value: true });
	HPEXPIRETIME.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the HPEXPIRETIME command
	     *
	     * @param parser - The command parser
	     * @param key - The key to retrieve expiration time for
	     * @param fields - The fields to retrieve expiration time for
	     * @see https://redis.io/commands/hpexpiretime/
	     */
	    parseCommand(parser, key, fields) {
	        parser.push('HPEXPIRETIME');
	        parser.pushKey(key);
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HPEXPIRETIME;
}

var HPTTL = {};

var hasRequiredHPTTL;

function requireHPTTL () {
	if (hasRequiredHPTTL) return HPTTL;
	hasRequiredHPTTL = 1;
	Object.defineProperty(HPTTL, "__esModule", { value: true });
	HPTTL.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the HPTTL command
	     *
	     * @param parser - The command parser
	     * @param key - The key to check time-to-live for
	     * @param fields - The fields to check time-to-live for
	     * @see https://redis.io/commands/hpttl/
	     */
	    parseCommand(parser, key, fields) {
	        parser.push('HPTTL');
	        parser.pushKey(key);
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HPTTL;
}

var HRANDFIELD_COUNT_WITHVALUES = {};

var hasRequiredHRANDFIELD_COUNT_WITHVALUES;

function requireHRANDFIELD_COUNT_WITHVALUES () {
	if (hasRequiredHRANDFIELD_COUNT_WITHVALUES) return HRANDFIELD_COUNT_WITHVALUES;
	hasRequiredHRANDFIELD_COUNT_WITHVALUES = 1;
	Object.defineProperty(HRANDFIELD_COUNT_WITHVALUES, "__esModule", { value: true });
	HRANDFIELD_COUNT_WITHVALUES.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the HRANDFIELD command with count parameter and WITHVALUES option
	     *
	     * @param parser - The command parser
	     * @param key - The key of the hash to get random fields from
	     * @param count - The number of fields to return (positive: unique fields, negative: may repeat fields)
	     * @see https://redis.io/commands/hrandfield/
	     */
	    parseCommand(parser, key, count) {
	        parser.push('HRANDFIELD');
	        parser.pushKey(key);
	        parser.push(count.toString(), 'WITHVALUES');
	    },
	    transformReply: {
	        2: (rawReply) => {
	            const reply = [];
	            let i = 0;
	            while (i < rawReply.length) {
	                reply.push({
	                    field: rawReply[i++],
	                    value: rawReply[i++]
	                });
	            }
	            return reply;
	        },
	        3: (reply) => {
	            return reply.map(entry => {
	                const [field, value] = entry;
	                return {
	                    field,
	                    value
	                };
	            });
	        }
	    }
	};
	
	return HRANDFIELD_COUNT_WITHVALUES;
}

var HRANDFIELD_COUNT = {};

var hasRequiredHRANDFIELD_COUNT;

function requireHRANDFIELD_COUNT () {
	if (hasRequiredHRANDFIELD_COUNT) return HRANDFIELD_COUNT;
	hasRequiredHRANDFIELD_COUNT = 1;
	Object.defineProperty(HRANDFIELD_COUNT, "__esModule", { value: true });
	HRANDFIELD_COUNT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the HRANDFIELD command with count parameter
	     *
	     * @param parser - The command parser
	     * @param key - The key of the hash to get random fields from
	     * @param count - The number of fields to return (positive: unique fields, negative: may repeat fields)
	     * @see https://redis.io/commands/hrandfield/
	     */
	    parseCommand(parser, key, count) {
	        parser.push('HRANDFIELD');
	        parser.pushKey(key);
	        parser.push(count.toString());
	    },
	    transformReply: undefined
	};
	
	return HRANDFIELD_COUNT;
}

var HRANDFIELD = {};

var hasRequiredHRANDFIELD;

function requireHRANDFIELD () {
	if (hasRequiredHRANDFIELD) return HRANDFIELD;
	hasRequiredHRANDFIELD = 1;
	Object.defineProperty(HRANDFIELD, "__esModule", { value: true });
	HRANDFIELD.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the HRANDFIELD command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the hash to get a random field from
	     * @see https://redis.io/commands/hrandfield/
	     */
	    parseCommand(parser, key) {
	        parser.push('HRANDFIELD');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return HRANDFIELD;
}

var HSCAN = {};

var SCAN = {};

var hasRequiredSCAN;

function requireSCAN () {
	if (hasRequiredSCAN) return SCAN;
	hasRequiredSCAN = 1;
	Object.defineProperty(SCAN, "__esModule", { value: true });
	SCAN.pushScanArguments = SCAN.parseScanArguments = void 0;
	/**
	 * Parses scan arguments for SCAN-type commands
	 *
	 * @param parser - The command parser
	 * @param cursor - The cursor position for iteration
	 * @param options - Scan options
	 */
	function parseScanArguments(parser, cursor, options) {
	    parser.push(cursor);
	    if (options?.MATCH) {
	        parser.push('MATCH', options.MATCH);
	    }
	    if (options?.COUNT) {
	        parser.push('COUNT', options.COUNT.toString());
	    }
	}
	SCAN.parseScanArguments = parseScanArguments;
	/**
	 * Pushes scan arguments to the command arguments array
	 *
	 * @param args - The command arguments array
	 * @param cursor - The cursor position for iteration
	 * @param options - Scan options
	 * @returns The updated command arguments array
	 */
	function pushScanArguments(args, cursor, options) {
	    args.push(cursor.toString());
	    if (options?.MATCH) {
	        args.push('MATCH', options.MATCH);
	    }
	    if (options?.COUNT) {
	        args.push('COUNT', options.COUNT.toString());
	    }
	    return args;
	}
	SCAN.pushScanArguments = pushScanArguments;
	SCAN.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SCAN command
	     *
	     * @param parser - The command parser
	     * @param cursor - The cursor position to start scanning from
	     * @param options - Scan options
	     * @see https://redis.io/commands/scan/
	     */
	    parseCommand(parser, cursor, options) {
	        parser.push('SCAN');
	        parseScanArguments(parser, cursor, options);
	        if (options?.TYPE) {
	            parser.push('TYPE', options.TYPE);
	        }
	        console.log('eeeeeeeeee', parser.redisArgs);
	    },
	    /**
	     * Transforms the SCAN reply into a structured object
	     *
	     * @param reply - The raw reply containing cursor and keys
	     * @returns Object with cursor and keys properties
	     */
	    transformReply([cursor, keys]) {
	        console.log(cursor, keys);
	        return {
	            cursor,
	            keys
	        };
	    }
	};
	
	return SCAN;
}

var hasRequiredHSCAN;

function requireHSCAN () {
	if (hasRequiredHSCAN) return HSCAN;
	hasRequiredHSCAN = 1;
	Object.defineProperty(HSCAN, "__esModule", { value: true });
	const SCAN_1 = requireSCAN();
	HSCAN.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the HSCAN command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the hash to scan
	     * @param cursor - The cursor position to start scanning from
	     * @param options - Options for the scan (COUNT, MATCH, TYPE)
	     * @see https://redis.io/commands/hscan/
	     */
	    parseCommand(parser, key, cursor, options) {
	        parser.push('HSCAN');
	        parser.pushKey(key);
	        (0, SCAN_1.parseScanArguments)(parser, cursor, options);
	    },
	    transformReply([cursor, rawEntries]) {
	        const entries = [];
	        let i = 0;
	        while (i < rawEntries.length) {
	            entries.push({
	                field: rawEntries[i++],
	                value: rawEntries[i++]
	            });
	        }
	        return {
	            cursor,
	            entries
	        };
	    }
	};
	
	return HSCAN;
}

var HSCAN_NOVALUES = {};

var hasRequiredHSCAN_NOVALUES;

function requireHSCAN_NOVALUES () {
	if (hasRequiredHSCAN_NOVALUES) return HSCAN_NOVALUES;
	hasRequiredHSCAN_NOVALUES = 1;
	var __importDefault = (HSCAN_NOVALUES && HSCAN_NOVALUES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(HSCAN_NOVALUES, "__esModule", { value: true });
	const HSCAN_1 = __importDefault(requireHSCAN());
	HSCAN_NOVALUES.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the HSCAN command with NOVALUES option
	     *
	     * @param args - The same parameters as HSCAN command
	     * @see https://redis.io/commands/hscan/
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        HSCAN_1.default.parseCommand(...args);
	        parser.push('NOVALUES');
	    },
	    transformReply([cursor, fields]) {
	        return {
	            cursor,
	            fields
	        };
	    }
	};
	
	return HSCAN_NOVALUES;
}

var HSET = {};

var hasRequiredHSET;

function requireHSET () {
	if (hasRequiredHSET) return HSET;
	hasRequiredHSET = 1;
	Object.defineProperty(HSET, "__esModule", { value: true });
	HSET.default = {
	    /**
	     * Constructs the HSET command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the hash
	     * @param value - Either the field name (when using single field) or an object/map/array of field-value pairs
	     * @param fieldValue - The value to set (only used with single field variant)
	     * @see https://redis.io/commands/hset/
	     */
	    parseCommand(parser, ...[key, value, fieldValue]) {
	        parser.push('HSET');
	        parser.pushKey(key);
	        if (typeof value === 'string' || typeof value === 'number' || value instanceof Buffer) {
	            parser.push(convertValue(value), convertValue(fieldValue));
	        }
	        else if (value instanceof Map) {
	            pushMap(parser, value);
	        }
	        else if (Array.isArray(value)) {
	            pushTuples(parser, value);
	        }
	        else {
	            pushObject(parser, value);
	        }
	    },
	    transformReply: undefined
	};
	function pushMap(parser, map) {
	    for (const [key, value] of map.entries()) {
	        parser.push(convertValue(key), convertValue(value));
	    }
	}
	function pushTuples(parser, tuples) {
	    for (const tuple of tuples) {
	        if (Array.isArray(tuple)) {
	            pushTuples(parser, tuple);
	            continue;
	        }
	        parser.push(convertValue(tuple));
	    }
	}
	function pushObject(parser, object) {
	    for (const key of Object.keys(object)) {
	        parser.push(convertValue(key), convertValue(object[key]));
	    }
	}
	function convertValue(value) {
	    return typeof value === 'number' ?
	        value.toString() :
	        value;
	}
	
	return HSET;
}

var HSETEX = {};

var hasRequiredHSETEX;

function requireHSETEX () {
	if (hasRequiredHSETEX) return HSETEX;
	hasRequiredHSETEX = 1;
	Object.defineProperty(HSETEX, "__esModule", { value: true });
	const parser_1 = requireParser();
	HSETEX.default = {
	    /**
	     * Constructs the HSETEX command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the hash
	     * @param fields - Object, Map, or Array of field-value pairs to set
	     * @param options - Optional configuration for expiration and mode settings
	     * @see https://redis.io/commands/hsetex/
	     */
	    parseCommand(parser, key, fields, options) {
	        parser.push('HSETEX');
	        parser.pushKey(key);
	        if (options?.mode) {
	            parser.push(options.mode);
	        }
	        if (options?.expiration) {
	            if (typeof options.expiration === 'string') {
	                parser.push(options.expiration);
	            }
	            else if (options.expiration.type === 'KEEPTTL') {
	                parser.push('KEEPTTL');
	            }
	            else {
	                parser.push(options.expiration.type, options.expiration.value.toString());
	            }
	        }
	        parser.push('FIELDS');
	        if (fields instanceof Map) {
	            pushMap(parser, fields);
	        }
	        else if (Array.isArray(fields)) {
	            pushTuples(parser, fields);
	        }
	        else {
	            pushObject(parser, fields);
	        }
	    },
	    transformReply: undefined
	};
	function pushMap(parser, map) {
	    parser.push(map.size.toString());
	    for (const [key, value] of map.entries()) {
	        parser.push(convertValue(key), convertValue(value));
	    }
	}
	function pushTuples(parser, tuples) {
	    const tmpParser = new parser_1.BasicCommandParser;
	    _pushTuples(tmpParser, tuples);
	    if (tmpParser.redisArgs.length % 2 != 0) {
	        throw Error('invalid number of arguments, expected key value ....[key value] pairs, got key without value');
	    }
	    parser.push((tmpParser.redisArgs.length / 2).toString());
	    parser.push(...tmpParser.redisArgs);
	}
	function _pushTuples(parser, tuples) {
	    for (const tuple of tuples) {
	        if (Array.isArray(tuple)) {
	            _pushTuples(parser, tuple);
	            continue;
	        }
	        parser.push(convertValue(tuple));
	    }
	}
	function pushObject(parser, object) {
	    const len = Object.keys(object).length;
	    if (len == 0) {
	        throw Error('object without keys');
	    }
	    parser.push(len.toString());
	    for (const key of Object.keys(object)) {
	        parser.push(convertValue(key), convertValue(object[key]));
	    }
	}
	function convertValue(value) {
	    return typeof value === 'number' ? value.toString() : value;
	}
	
	return HSETEX;
}

var HSETNX = {};

var hasRequiredHSETNX;

function requireHSETNX () {
	if (hasRequiredHSETNX) return HSETNX;
	hasRequiredHSETNX = 1;
	Object.defineProperty(HSETNX, "__esModule", { value: true });
	HSETNX.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the HSETNX command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the hash
	     * @param field - The field to set if it does not exist
	     * @param value - The value to set
	     * @see https://redis.io/commands/hsetnx/
	     */
	    parseCommand(parser, key, field, value) {
	        parser.push('HSETNX');
	        parser.pushKey(key);
	        parser.push(field, value);
	    },
	    transformReply: undefined
	};
	
	return HSETNX;
}

var HSTRLEN = {};

var hasRequiredHSTRLEN;

function requireHSTRLEN () {
	if (hasRequiredHSTRLEN) return HSTRLEN;
	hasRequiredHSTRLEN = 1;
	Object.defineProperty(HSTRLEN, "__esModule", { value: true });
	HSTRLEN.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the HSTRLEN command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the hash
	     * @param field - The field to get the string length of
	     * @see https://redis.io/commands/hstrlen/
	     */
	    parseCommand(parser, key, field) {
	        parser.push('HSTRLEN');
	        parser.pushKey(key);
	        parser.push(field);
	    },
	    transformReply: undefined
	};
	
	return HSTRLEN;
}

var HTTL = {};

var hasRequiredHTTL;

function requireHTTL () {
	if (hasRequiredHTTL) return HTTL;
	hasRequiredHTTL = 1;
	Object.defineProperty(HTTL, "__esModule", { value: true });
	HTTL.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the remaining time to live of field(s) in a hash.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the hash.
	     * @param fields - Fields to check time to live.
	     */
	    parseCommand(parser, key, fields) {
	        parser.push('HTTL');
	        parser.pushKey(key);
	        parser.push('FIELDS');
	        parser.pushVariadicWithLength(fields);
	    },
	    transformReply: undefined
	};
	
	return HTTL;
}

var HVALS = {};

var hasRequiredHVALS;

function requireHVALS () {
	if (hasRequiredHVALS) return HVALS;
	hasRequiredHVALS = 1;
	Object.defineProperty(HVALS, "__esModule", { value: true });
	HVALS.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets all values in a hash.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the hash.
	     */
	    parseCommand(parser, key) {
	        parser.push('HVALS');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return HVALS;
}

var INCR = {};

var hasRequiredINCR;

function requireINCR () {
	if (hasRequiredINCR) return INCR;
	hasRequiredINCR = 1;
	Object.defineProperty(INCR, "__esModule", { value: true });
	INCR.default = {
	    /**
	     * Constructs the INCR command
	     *
	     * @param parser - The command parser
	     * @param key - The key to increment
	     * @see https://redis.io/commands/incr/
	     */
	    parseCommand(parser, key) {
	        parser.push('INCR');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return INCR;
}

var INCRBY$3 = {};

var hasRequiredINCRBY$3;

function requireINCRBY$3 () {
	if (hasRequiredINCRBY$3) return INCRBY$3;
	hasRequiredINCRBY$3 = 1;
	Object.defineProperty(INCRBY$3, "__esModule", { value: true });
	INCRBY$3.default = {
	    /**
	     * Constructs the INCRBY command
	     *
	     * @param parser - The command parser
	     * @param key - The key to increment
	     * @param increment - The amount to increment by
	     * @see https://redis.io/commands/incrby/
	     */
	    parseCommand(parser, key, increment) {
	        parser.push('INCRBY');
	        parser.pushKey(key);
	        parser.push(increment.toString());
	    },
	    transformReply: undefined
	};
	
	return INCRBY$3;
}

var INCRBYFLOAT = {};

var hasRequiredINCRBYFLOAT;

function requireINCRBYFLOAT () {
	if (hasRequiredINCRBYFLOAT) return INCRBYFLOAT;
	hasRequiredINCRBYFLOAT = 1;
	Object.defineProperty(INCRBYFLOAT, "__esModule", { value: true });
	INCRBYFLOAT.default = {
	    /**
	     * Constructs the INCRBYFLOAT command
	     *
	     * @param parser - The command parser
	     * @param key - The key to increment
	     * @param increment - The floating-point value to increment by
	     * @see https://redis.io/commands/incrbyfloat/
	     */
	    parseCommand(parser, key, increment) {
	        parser.push('INCRBYFLOAT');
	        parser.pushKey(key);
	        parser.push(increment.toString());
	    },
	    transformReply: undefined
	};
	
	return INCRBYFLOAT;
}

var INFO$7 = {};

var hasRequiredINFO$7;

function requireINFO$7 () {
	if (hasRequiredINFO$7) return INFO$7;
	hasRequiredINFO$7 = 1;
	Object.defineProperty(INFO$7, "__esModule", { value: true });
	INFO$7.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the INFO command
	     *
	     * @param parser - The command parser
	     * @param section - Optional specific section of information to retrieve
	     * @see https://redis.io/commands/info/
	     */
	    parseCommand(parser, section) {
	        parser.push('INFO');
	        if (section) {
	            parser.push(section);
	        }
	    },
	    transformReply: undefined
	};
	
	return INFO$7;
}

var KEYS = {};

var hasRequiredKEYS;

function requireKEYS () {
	if (hasRequiredKEYS) return KEYS;
	hasRequiredKEYS = 1;
	Object.defineProperty(KEYS, "__esModule", { value: true });
	KEYS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the KEYS command
	     *
	     * @param parser - The command parser
	     * @param pattern - The pattern to match keys against
	     * @see https://redis.io/commands/keys/
	     */
	    parseCommand(parser, pattern) {
	        parser.push('KEYS', pattern);
	    },
	    transformReply: undefined
	};
	
	return KEYS;
}

var LASTSAVE = {};

var hasRequiredLASTSAVE;

function requireLASTSAVE () {
	if (hasRequiredLASTSAVE) return LASTSAVE;
	hasRequiredLASTSAVE = 1;
	Object.defineProperty(LASTSAVE, "__esModule", { value: true });
	LASTSAVE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LASTSAVE command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/lastsave/
	     */
	    parseCommand(parser) {
	        parser.push('LASTSAVE');
	    },
	    transformReply: undefined
	};
	
	return LASTSAVE;
}

var LATENCY_DOCTOR = {};

var hasRequiredLATENCY_DOCTOR;

function requireLATENCY_DOCTOR () {
	if (hasRequiredLATENCY_DOCTOR) return LATENCY_DOCTOR;
	hasRequiredLATENCY_DOCTOR = 1;
	Object.defineProperty(LATENCY_DOCTOR, "__esModule", { value: true });
	LATENCY_DOCTOR.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LATENCY DOCTOR command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/latency-doctor/
	     */
	    parseCommand(parser) {
	        parser.push('LATENCY', 'DOCTOR');
	    },
	    transformReply: undefined
	};
	
	return LATENCY_DOCTOR;
}

var LATENCY_GRAPH = {};

var hasRequiredLATENCY_GRAPH;

function requireLATENCY_GRAPH () {
	if (hasRequiredLATENCY_GRAPH) return LATENCY_GRAPH;
	hasRequiredLATENCY_GRAPH = 1;
	Object.defineProperty(LATENCY_GRAPH, "__esModule", { value: true });
	LATENCY_GRAPH.LATENCY_EVENTS = void 0;
	LATENCY_GRAPH.LATENCY_EVENTS = {
	    ACTIVE_DEFRAG_CYCLE: 'active-defrag-cycle',
	    AOF_FSYNC_ALWAYS: 'aof-fsync-always',
	    AOF_STAT: 'aof-stat',
	    AOF_REWRITE_DIFF_WRITE: 'aof-rewrite-diff-write',
	    AOF_RENAME: 'aof-rename',
	    AOF_WRITE: 'aof-write',
	    AOF_WRITE_ACTIVE_CHILD: 'aof-write-active-child',
	    AOF_WRITE_ALONE: 'aof-write-alone',
	    AOF_WRITE_PENDING_FSYNC: 'aof-write-pending-fsync',
	    COMMAND: 'command',
	    EXPIRE_CYCLE: 'expire-cycle',
	    EVICTION_CYCLE: 'eviction-cycle',
	    EVICTION_DEL: 'eviction-del',
	    FAST_COMMAND: 'fast-command',
	    FORK: 'fork',
	    RDB_UNLINK_TEMP_FILE: 'rdb-unlink-temp-file'
	};
	LATENCY_GRAPH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LATENCY GRAPH command
	     *
	     * @param parser - The command parser
	     * @param event - The latency event to get the graph for
	     * @see https://redis.io/commands/latency-graph/
	     */
	    parseCommand(parser, event) {
	        parser.push('LATENCY', 'GRAPH', event);
	    },
	    transformReply: undefined
	};
	
	return LATENCY_GRAPH;
}

var LATENCY_HISTORY = {};

var hasRequiredLATENCY_HISTORY;

function requireLATENCY_HISTORY () {
	if (hasRequiredLATENCY_HISTORY) return LATENCY_HISTORY;
	hasRequiredLATENCY_HISTORY = 1;
	Object.defineProperty(LATENCY_HISTORY, "__esModule", { value: true });
	LATENCY_HISTORY.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LATENCY HISTORY command
	     *
	     * @param parser - The command parser
	     * @param event - The latency event to get the history for
	     * @see https://redis.io/commands/latency-history/
	     */
	    parseCommand(parser, event) {
	        parser.push('LATENCY', 'HISTORY', event);
	    },
	    transformReply: undefined
	};
	
	return LATENCY_HISTORY;
}

var LATENCY_LATEST = {};

var hasRequiredLATENCY_LATEST;

function requireLATENCY_LATEST () {
	if (hasRequiredLATENCY_LATEST) return LATENCY_LATEST;
	hasRequiredLATENCY_LATEST = 1;
	Object.defineProperty(LATENCY_LATEST, "__esModule", { value: true });
	LATENCY_LATEST.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LATENCY LATEST command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/latency-latest/
	     */
	    parseCommand(parser) {
	        parser.push('LATENCY', 'LATEST');
	    },
	    transformReply: undefined
	};
	
	return LATENCY_LATEST;
}

var LCS_IDX_WITHMATCHLEN = {};

var LCS_IDX = {};

var LCS = {};

var hasRequiredLCS;

function requireLCS () {
	if (hasRequiredLCS) return LCS;
	hasRequiredLCS = 1;
	Object.defineProperty(LCS, "__esModule", { value: true });
	LCS.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LCS command (Longest Common Substring)
	     *
	     * @param parser - The command parser
	     * @param key1 - First key containing the first string
	     * @param key2 - Second key containing the second string
	     * @see https://redis.io/commands/lcs/
	     */
	    parseCommand(parser, key1, key2) {
	        parser.push('LCS');
	        parser.pushKeys([key1, key2]);
	    },
	    transformReply: undefined
	};
	
	return LCS;
}

var hasRequiredLCS_IDX;

function requireLCS_IDX () {
	if (hasRequiredLCS_IDX) return LCS_IDX;
	hasRequiredLCS_IDX = 1;
	var __importDefault = (LCS_IDX && LCS_IDX.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(LCS_IDX, "__esModule", { value: true });
	const LCS_1 = __importDefault(requireLCS());
	LCS_IDX.default = {
	    IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
	    /**
	     * Constructs the LCS command with IDX option
	     *
	     * @param parser - The command parser
	     * @param key1 - First key containing the first string
	     * @param key2 - Second key containing the second string
	     * @param options - Additional options for the LCS IDX command
	     * @see https://redis.io/commands/lcs/
	     */
	    parseCommand(parser, key1, key2, options) {
	        LCS_1.default.parseCommand(parser, key1, key2);
	        parser.push('IDX');
	        if (options?.MINMATCHLEN) {
	            parser.push('MINMATCHLEN', options.MINMATCHLEN.toString());
	        }
	    },
	    transformReply: {
	        2: (reply) => ({
	            matches: reply[1],
	            len: reply[3]
	        }),
	        3: undefined
	    }
	};
	
	return LCS_IDX;
}

var hasRequiredLCS_IDX_WITHMATCHLEN;

function requireLCS_IDX_WITHMATCHLEN () {
	if (hasRequiredLCS_IDX_WITHMATCHLEN) return LCS_IDX_WITHMATCHLEN;
	hasRequiredLCS_IDX_WITHMATCHLEN = 1;
	var __importDefault = (LCS_IDX_WITHMATCHLEN && LCS_IDX_WITHMATCHLEN.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(LCS_IDX_WITHMATCHLEN, "__esModule", { value: true });
	const LCS_IDX_1 = __importDefault(requireLCS_IDX());
	LCS_IDX_WITHMATCHLEN.default = {
	    IS_READ_ONLY: LCS_IDX_1.default.IS_READ_ONLY,
	    /**
	     * Constructs the LCS command with IDX and WITHMATCHLEN options
	     *
	     * @param args - The same parameters as LCS_IDX command
	     * @see https://redis.io/commands/lcs/
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        LCS_IDX_1.default.parseCommand(...args);
	        parser.push('WITHMATCHLEN');
	    },
	    transformReply: {
	        2: (reply) => ({
	            matches: reply[1],
	            len: reply[3]
	        }),
	        3: undefined
	    }
	};
	
	return LCS_IDX_WITHMATCHLEN;
}

var LCS_LEN = {};

var hasRequiredLCS_LEN;

function requireLCS_LEN () {
	if (hasRequiredLCS_LEN) return LCS_LEN;
	hasRequiredLCS_LEN = 1;
	var __importDefault = (LCS_LEN && LCS_LEN.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(LCS_LEN, "__esModule", { value: true });
	const LCS_1 = __importDefault(requireLCS());
	LCS_LEN.default = {
	    IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
	    /**
	     * Constructs the LCS command with LEN option
	     *
	     * @param args - The same parameters as LCS command
	     * @see https://redis.io/commands/lcs/
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        LCS_1.default.parseCommand(...args);
	        parser.push('LEN');
	    },
	    transformReply: undefined
	};
	
	return LCS_LEN;
}

var LINDEX = {};

var hasRequiredLINDEX;

function requireLINDEX () {
	if (hasRequiredLINDEX) return LINDEX;
	hasRequiredLINDEX = 1;
	Object.defineProperty(LINDEX, "__esModule", { value: true });
	LINDEX.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LINDEX command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param index - The index of the element to retrieve
	     * @see https://redis.io/commands/lindex/
	     */
	    parseCommand(parser, key, index) {
	        parser.push('LINDEX');
	        parser.pushKey(key);
	        parser.push(index.toString());
	    },
	    transformReply: undefined
	};
	
	return LINDEX;
}

var LINSERT = {};

var hasRequiredLINSERT;

function requireLINSERT () {
	if (hasRequiredLINSERT) return LINSERT;
	hasRequiredLINSERT = 1;
	Object.defineProperty(LINSERT, "__esModule", { value: true });
	LINSERT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LINSERT command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param position - The position where to insert (BEFORE or AFTER)
	     * @param pivot - The element to find in the list
	     * @param element - The element to insert
	     * @see https://redis.io/commands/linsert/
	     */
	    parseCommand(parser, key, position, pivot, element) {
	        parser.push('LINSERT');
	        parser.pushKey(key);
	        parser.push(position, pivot, element);
	    },
	    transformReply: undefined
	};
	
	return LINSERT;
}

var LLEN = {};

var hasRequiredLLEN;

function requireLLEN () {
	if (hasRequiredLLEN) return LLEN;
	hasRequiredLLEN = 1;
	Object.defineProperty(LLEN, "__esModule", { value: true });
	LLEN.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LLEN command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list to get the length of
	     * @see https://redis.io/commands/llen/
	     */
	    parseCommand(parser, key) {
	        parser.push('LLEN');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return LLEN;
}

var LMOVE = {};

var hasRequiredLMOVE;

function requireLMOVE () {
	if (hasRequiredLMOVE) return LMOVE;
	hasRequiredLMOVE = 1;
	Object.defineProperty(LMOVE, "__esModule", { value: true });
	LMOVE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the LMOVE command
	     *
	     * @param parser - The command parser
	     * @param source - The source list key
	     * @param destination - The destination list key
	     * @param sourceSide - The side to pop from (LEFT or RIGHT)
	     * @param destinationSide - The side to push to (LEFT or RIGHT)
	     * @see https://redis.io/commands/lmove/
	     */
	    parseCommand(parser, source, destination, sourceSide, destinationSide) {
	        parser.push('LMOVE');
	        parser.pushKeys([source, destination]);
	        parser.push(sourceSide, destinationSide);
	    },
	    transformReply: undefined
	};
	
	return LMOVE;
}

var LOLWUT = {};

var hasRequiredLOLWUT;

function requireLOLWUT () {
	if (hasRequiredLOLWUT) return LOLWUT;
	hasRequiredLOLWUT = 1;
	Object.defineProperty(LOLWUT, "__esModule", { value: true });
	LOLWUT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LOLWUT command
	     *
	     * @param parser - The command parser
	     * @param version - Optional version parameter
	     * @param optionalArguments - Additional optional numeric arguments
	     * @see https://redis.io/commands/lolwut/
	     */
	    parseCommand(parser, version, ...optionalArguments) {
	        parser.push('LOLWUT');
	        if (version) {
	            parser.push('VERSION', version.toString());
	            parser.pushVariadic(optionalArguments.map(String));
	        }
	    },
	    transformReply: undefined
	};
	
	return LOLWUT;
}

var LPOP_COUNT = {};

var LPOP = {};

var hasRequiredLPOP;

function requireLPOP () {
	if (hasRequiredLPOP) return LPOP;
	hasRequiredLPOP = 1;
	Object.defineProperty(LPOP, "__esModule", { value: true });
	LPOP.default = {
	    /**
	     * Constructs the LPOP command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list to pop from
	     * @see https://redis.io/commands/lpop/
	     */
	    parseCommand(parser, key) {
	        parser.push('LPOP');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return LPOP;
}

var hasRequiredLPOP_COUNT;

function requireLPOP_COUNT () {
	if (hasRequiredLPOP_COUNT) return LPOP_COUNT;
	hasRequiredLPOP_COUNT = 1;
	var __importDefault = (LPOP_COUNT && LPOP_COUNT.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(LPOP_COUNT, "__esModule", { value: true });
	const LPOP_1 = __importDefault(requireLPOP());
	LPOP_COUNT.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the LPOP command with count parameter
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list to pop from
	     * @param count - The number of elements to pop
	     * @see https://redis.io/commands/lpop/
	     */
	    parseCommand(parser, key, count) {
	        LPOP_1.default.parseCommand(parser, key);
	        parser.push(count.toString());
	    },
	    transformReply: undefined
	};
	
	return LPOP_COUNT;
}

var LPOS_COUNT = {};

var LPOS = {};

var hasRequiredLPOS;

function requireLPOS () {
	if (hasRequiredLPOS) return LPOS;
	hasRequiredLPOS = 1;
	Object.defineProperty(LPOS, "__esModule", { value: true });
	LPOS.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LPOS command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param element - The element to search for
	     * @param options - Optional parameters for RANK and MAXLEN
	     * @see https://redis.io/commands/lpos/
	     */
	    parseCommand(parser, key, element, options) {
	        parser.push('LPOS');
	        parser.pushKey(key);
	        parser.push(element);
	        if (options?.RANK !== undefined) {
	            parser.push('RANK', options.RANK.toString());
	        }
	        if (options?.MAXLEN !== undefined) {
	            parser.push('MAXLEN', options.MAXLEN.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return LPOS;
}

var hasRequiredLPOS_COUNT;

function requireLPOS_COUNT () {
	if (hasRequiredLPOS_COUNT) return LPOS_COUNT;
	hasRequiredLPOS_COUNT = 1;
	var __importDefault = (LPOS_COUNT && LPOS_COUNT.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(LPOS_COUNT, "__esModule", { value: true });
	const LPOS_1 = __importDefault(requireLPOS());
	LPOS_COUNT.default = {
	    CACHEABLE: LPOS_1.default.CACHEABLE,
	    IS_READ_ONLY: LPOS_1.default.IS_READ_ONLY,
	    /**
	     * Constructs the LPOS command with COUNT option
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param element - The element to search for
	     * @param count - The number of positions to return
	     * @param options - Optional parameters for RANK and MAXLEN
	     * @see https://redis.io/commands/lpos/
	     */
	    parseCommand(parser, key, element, count, options) {
	        LPOS_1.default.parseCommand(parser, key, element, options);
	        parser.push('COUNT', count.toString());
	    },
	    transformReply: undefined
	};
	
	return LPOS_COUNT;
}

var LPUSH = {};

var hasRequiredLPUSH;

function requireLPUSH () {
	if (hasRequiredLPUSH) return LPUSH;
	hasRequiredLPUSH = 1;
	Object.defineProperty(LPUSH, "__esModule", { value: true });
	LPUSH.default = {
	    /**
	     * Constructs the LPUSH command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param elements - One or more elements to push to the list
	     * @see https://redis.io/commands/lpush/
	     */
	    parseCommand(parser, key, elements) {
	        parser.push('LPUSH');
	        parser.pushKey(key);
	        parser.pushVariadic(elements);
	    },
	    transformReply: undefined
	};
	
	return LPUSH;
}

var LPUSHX = {};

var hasRequiredLPUSHX;

function requireLPUSHX () {
	if (hasRequiredLPUSHX) return LPUSHX;
	hasRequiredLPUSHX = 1;
	Object.defineProperty(LPUSHX, "__esModule", { value: true });
	LPUSHX.default = {
	    /**
	     * Constructs the LPUSHX command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param elements - One or more elements to push to the list if it exists
	     * @see https://redis.io/commands/lpushx/
	     */
	    parseCommand(parser, key, elements) {
	        parser.push('LPUSHX');
	        parser.pushKey(key);
	        parser.pushVariadic(elements);
	    },
	    transformReply: undefined
	};
	
	return LPUSHX;
}

var LRANGE = {};

var hasRequiredLRANGE;

function requireLRANGE () {
	if (hasRequiredLRANGE) return LRANGE;
	hasRequiredLRANGE = 1;
	Object.defineProperty(LRANGE, "__esModule", { value: true });
	LRANGE.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LRANGE command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param start - The starting index
	     * @param stop - The ending index
	     * @see https://redis.io/commands/lrange/
	     */
	    parseCommand(parser, key, start, stop) {
	        parser.push('LRANGE');
	        parser.pushKey(key);
	        parser.push(start.toString(), stop.toString());
	    },
	    transformReply: undefined
	};
	
	return LRANGE;
}

var LREM = {};

var hasRequiredLREM;

function requireLREM () {
	if (hasRequiredLREM) return LREM;
	hasRequiredLREM = 1;
	Object.defineProperty(LREM, "__esModule", { value: true });
	LREM.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LREM command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param count - The count of elements to remove (negative: from tail to head, 0: all occurrences, positive: from head to tail)
	     * @param element - The element to remove
	     * @see https://redis.io/commands/lrem/
	     */
	    parseCommand(parser, key, count, element) {
	        parser.push('LREM');
	        parser.pushKey(key);
	        parser.push(count.toString());
	        parser.push(element);
	    },
	    transformReply: undefined
	};
	
	return LREM;
}

var LSET = {};

var hasRequiredLSET;

function requireLSET () {
	if (hasRequiredLSET) return LSET;
	hasRequiredLSET = 1;
	Object.defineProperty(LSET, "__esModule", { value: true });
	LSET.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the LSET command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param index - The index of the element to replace
	     * @param element - The new value to set
	     * @see https://redis.io/commands/lset/
	     */
	    parseCommand(parser, key, index, element) {
	        parser.push('LSET');
	        parser.pushKey(key);
	        parser.push(index.toString(), element);
	    },
	    transformReply: undefined
	};
	
	return LSET;
}

var LTRIM = {};

var hasRequiredLTRIM;

function requireLTRIM () {
	if (hasRequiredLTRIM) return LTRIM;
	hasRequiredLTRIM = 1;
	Object.defineProperty(LTRIM, "__esModule", { value: true });
	LTRIM.default = {
	    /**
	     * Constructs the LTRIM command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the list
	     * @param start - The starting index
	     * @param stop - The ending index
	     * @see https://redis.io/commands/ltrim/
	     */
	    parseCommand(parser, key, start, stop) {
	        parser.push('LTRIM');
	        parser.pushKey(key);
	        parser.push(start.toString(), stop.toString());
	    },
	    transformReply: undefined
	};
	
	return LTRIM;
}

var MEMORY_DOCTOR = {};

var hasRequiredMEMORY_DOCTOR;

function requireMEMORY_DOCTOR () {
	if (hasRequiredMEMORY_DOCTOR) return MEMORY_DOCTOR;
	hasRequiredMEMORY_DOCTOR = 1;
	Object.defineProperty(MEMORY_DOCTOR, "__esModule", { value: true });
	MEMORY_DOCTOR.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MEMORY DOCTOR command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/memory-doctor/
	     */
	    parseCommand(parser) {
	        parser.push('MEMORY', 'DOCTOR');
	    },
	    transformReply: undefined
	};
	
	return MEMORY_DOCTOR;
}

var MEMORY_MALLOCSTATS = {};

var hasRequiredMEMORY_MALLOCSTATS;

function requireMEMORY_MALLOCSTATS () {
	if (hasRequiredMEMORY_MALLOCSTATS) return MEMORY_MALLOCSTATS;
	hasRequiredMEMORY_MALLOCSTATS = 1;
	Object.defineProperty(MEMORY_MALLOCSTATS, "__esModule", { value: true });
	MEMORY_MALLOCSTATS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MEMORY MALLOC-STATS command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/memory-malloc-stats/
	     */
	    parseCommand(parser) {
	        parser.push('MEMORY', 'MALLOC-STATS');
	    },
	    transformReply: undefined
	};
	
	return MEMORY_MALLOCSTATS;
}

var MEMORY_PURGE = {};

var hasRequiredMEMORY_PURGE;

function requireMEMORY_PURGE () {
	if (hasRequiredMEMORY_PURGE) return MEMORY_PURGE;
	hasRequiredMEMORY_PURGE = 1;
	Object.defineProperty(MEMORY_PURGE, "__esModule", { value: true });
	MEMORY_PURGE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the MEMORY PURGE command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/memory-purge/
	     */
	    parseCommand(parser) {
	        parser.push('MEMORY', 'PURGE');
	    },
	    transformReply: undefined
	};
	
	return MEMORY_PURGE;
}

var MEMORY_STATS = {};

var hasRequiredMEMORY_STATS;

function requireMEMORY_STATS () {
	if (hasRequiredMEMORY_STATS) return MEMORY_STATS;
	hasRequiredMEMORY_STATS = 1;
	Object.defineProperty(MEMORY_STATS, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	MEMORY_STATS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MEMORY STATS command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/memory-stats/
	     */
	    parseCommand(parser) {
	        parser.push('MEMORY', 'STATS');
	    },
	    transformReply: {
	        2: (rawReply, preserve, typeMapping) => {
	            const reply = {};
	            let i = 0;
	            while (i < rawReply.length) {
	                switch (rawReply[i].toString()) {
	                    case 'dataset.percentage':
	                    case 'peak.percentage':
	                    case 'allocator-fragmentation.ratio':
	                    case 'allocator-rss.ratio':
	                    case 'rss-overhead.ratio':
	                    case 'fragmentation':
	                        reply[rawReply[i++]] = generic_transformers_1.transformDoubleReply[2](rawReply[i++], preserve, typeMapping);
	                        break;
	                    default:
	                        reply[rawReply[i++]] = rawReply[i++];
	                }
	            }
	            return reply;
	        },
	        3: undefined
	    }
	};
	
	return MEMORY_STATS;
}

var MEMORY_USAGE = {};

var hasRequiredMEMORY_USAGE;

function requireMEMORY_USAGE () {
	if (hasRequiredMEMORY_USAGE) return MEMORY_USAGE;
	hasRequiredMEMORY_USAGE = 1;
	Object.defineProperty(MEMORY_USAGE, "__esModule", { value: true });
	MEMORY_USAGE.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MEMORY USAGE command
	     *
	     * @param parser - The command parser
	     * @param key - The key to get memory usage for
	     * @param options - Optional parameters including SAMPLES
	     * @see https://redis.io/commands/memory-usage/
	     */
	    parseCommand(parser, key, options) {
	        parser.push('MEMORY', 'USAGE');
	        parser.pushKey(key);
	        if (options?.SAMPLES) {
	            parser.push('SAMPLES', options.SAMPLES.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return MEMORY_USAGE;
}

var MGET$2 = {};

var hasRequiredMGET$2;

function requireMGET$2 () {
	if (hasRequiredMGET$2) return MGET$2;
	hasRequiredMGET$2 = 1;
	Object.defineProperty(MGET$2, "__esModule", { value: true });
	MGET$2.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MGET command
	     *
	     * @param parser - The command parser
	     * @param keys - Array of keys to get
	     * @see https://redis.io/commands/mget/
	     */
	    parseCommand(parser, keys) {
	        parser.push('MGET');
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return MGET$2;
}

var MIGRATE = {};

var hasRequiredMIGRATE;

function requireMIGRATE () {
	if (hasRequiredMIGRATE) return MIGRATE;
	hasRequiredMIGRATE = 1;
	Object.defineProperty(MIGRATE, "__esModule", { value: true });
	MIGRATE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the MIGRATE command
	     *
	     * @param parser - The command parser
	     * @param host - Target Redis instance host
	     * @param port - Target Redis instance port
	     * @param key - Key or keys to migrate
	     * @param destinationDb - Target database index
	     * @param timeout - Timeout in milliseconds
	     * @param options - Optional parameters including COPY, REPLACE, and AUTH
	     * @see https://redis.io/commands/migrate/
	     */
	    parseCommand(parser, host, port, key, destinationDb, timeout, options) {
	        parser.push('MIGRATE', host, port.toString());
	        const isKeyArray = Array.isArray(key);
	        if (isKeyArray) {
	            parser.push('');
	        }
	        else {
	            parser.push(key);
	        }
	        parser.push(destinationDb.toString(), timeout.toString());
	        if (options?.COPY) {
	            parser.push('COPY');
	        }
	        if (options?.REPLACE) {
	            parser.push('REPLACE');
	        }
	        if (options?.AUTH) {
	            if (options.AUTH.username) {
	                parser.push('AUTH2', options.AUTH.username, options.AUTH.password);
	            }
	            else {
	                parser.push('AUTH', options.AUTH.password);
	            }
	        }
	        if (isKeyArray) {
	            parser.push('KEYS');
	            parser.pushVariadic(key);
	        }
	    },
	    transformReply: undefined
	};
	
	return MIGRATE;
}

var MODULE_LIST = {};

var hasRequiredMODULE_LIST;

function requireMODULE_LIST () {
	if (hasRequiredMODULE_LIST) return MODULE_LIST;
	hasRequiredMODULE_LIST = 1;
	Object.defineProperty(MODULE_LIST, "__esModule", { value: true });
	MODULE_LIST.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MODULE LIST command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/module-list/
	     */
	    parseCommand(parser) {
	        parser.push('MODULE', 'LIST');
	    },
	    transformReply: {
	        2: (reply) => {
	            return reply.map(module => {
	                const unwrapped = module;
	                return {
	                    name: unwrapped[1],
	                    ver: unwrapped[3]
	                };
	            });
	        },
	        3: undefined
	    }
	};
	
	return MODULE_LIST;
}

var MODULE_LOAD = {};

var hasRequiredMODULE_LOAD;

function requireMODULE_LOAD () {
	if (hasRequiredMODULE_LOAD) return MODULE_LOAD;
	hasRequiredMODULE_LOAD = 1;
	Object.defineProperty(MODULE_LOAD, "__esModule", { value: true });
	MODULE_LOAD.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MODULE LOAD command
	     *
	     * @param parser - The command parser
	     * @param path - Path to the module file
	     * @param moduleArguments - Optional arguments to pass to the module
	     * @see https://redis.io/commands/module-load/
	     */
	    parseCommand(parser, path, moduleArguments) {
	        parser.push('MODULE', 'LOAD', path);
	        if (moduleArguments) {
	            parser.push(...moduleArguments);
	        }
	    },
	    transformReply: undefined
	};
	
	return MODULE_LOAD;
}

var MODULE_UNLOAD = {};

var hasRequiredMODULE_UNLOAD;

function requireMODULE_UNLOAD () {
	if (hasRequiredMODULE_UNLOAD) return MODULE_UNLOAD;
	hasRequiredMODULE_UNLOAD = 1;
	Object.defineProperty(MODULE_UNLOAD, "__esModule", { value: true });
	MODULE_UNLOAD.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MODULE UNLOAD command
	     *
	     * @param parser - The command parser
	     * @param name - The name of the module to unload
	     * @see https://redis.io/commands/module-unload/
	     */
	    parseCommand(parser, name) {
	        parser.push('MODULE', 'UNLOAD', name);
	    },
	    transformReply: undefined
	};
	
	return MODULE_UNLOAD;
}

var MOVE = {};

var hasRequiredMOVE;

function requireMOVE () {
	if (hasRequiredMOVE) return MOVE;
	hasRequiredMOVE = 1;
	Object.defineProperty(MOVE, "__esModule", { value: true });
	MOVE.default = {
	    /**
	     * Constructs the MOVE command
	     *
	     * @param parser - The command parser
	     * @param key - The key to move
	     * @param db - The destination database index
	     * @see https://redis.io/commands/move/
	     */
	    parseCommand(parser, key, db) {
	        parser.push('MOVE');
	        parser.pushKey(key);
	        parser.push(db.toString());
	    },
	    transformReply: undefined
	};
	
	return MOVE;
}

var MSET$1 = {};

var hasRequiredMSET$1;

function requireMSET$1 () {
	if (hasRequiredMSET$1) return MSET$1;
	hasRequiredMSET$1 = 1;
	Object.defineProperty(MSET$1, "__esModule", { value: true });
	MSET$1.parseMSetArguments = void 0;
	function parseMSetArguments(parser, toSet) {
	    if (Array.isArray(toSet)) {
	        if (toSet.length == 0) {
	            throw new Error("empty toSet Argument");
	        }
	        if (Array.isArray(toSet[0])) {
	            for (const tuple of toSet) {
	                parser.pushKey(tuple[0]);
	                parser.push(tuple[1]);
	            }
	        }
	        else {
	            const arr = toSet;
	            for (let i = 0; i < arr.length; i += 2) {
	                parser.pushKey(arr[i]);
	                parser.push(arr[i + 1]);
	            }
	        }
	    }
	    else {
	        for (const tuple of Object.entries(toSet)) {
	            parser.pushKey(tuple[0]);
	            parser.push(tuple[1]);
	        }
	    }
	}
	MSET$1.parseMSetArguments = parseMSetArguments;
	MSET$1.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MSET command
	     *
	     * @param parser - The command parser
	     * @param toSet - Key-value pairs to set (array of tuples, flat array, or object)
	     * @see https://redis.io/commands/mset/
	     */
	    parseCommand(parser, toSet) {
	        parser.push('MSET');
	        return parseMSetArguments(parser, toSet);
	    },
	    transformReply: undefined
	};
	
	return MSET$1;
}

var MSETNX = {};

var hasRequiredMSETNX;

function requireMSETNX () {
	if (hasRequiredMSETNX) return MSETNX;
	hasRequiredMSETNX = 1;
	Object.defineProperty(MSETNX, "__esModule", { value: true });
	const MSET_1 = requireMSET$1();
	MSETNX.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the MSETNX command
	     *
	     * @param parser - The command parser
	     * @param toSet - Key-value pairs to set if none of the keys exist (array of tuples, flat array, or object)
	     * @see https://redis.io/commands/msetnx/
	     */
	    parseCommand(parser, toSet) {
	        parser.push('MSETNX');
	        return (0, MSET_1.parseMSetArguments)(parser, toSet);
	    },
	    transformReply: undefined
	};
	
	return MSETNX;
}

var OBJECT_ENCODING = {};

var hasRequiredOBJECT_ENCODING;

function requireOBJECT_ENCODING () {
	if (hasRequiredOBJECT_ENCODING) return OBJECT_ENCODING;
	hasRequiredOBJECT_ENCODING = 1;
	Object.defineProperty(OBJECT_ENCODING, "__esModule", { value: true });
	OBJECT_ENCODING.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the OBJECT ENCODING command
	     *
	     * @param parser - The command parser
	     * @param key - The key to get the internal encoding for
	     * @see https://redis.io/commands/object-encoding/
	     */
	    parseCommand(parser, key) {
	        parser.push('OBJECT', 'ENCODING');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return OBJECT_ENCODING;
}

var OBJECT_FREQ = {};

var hasRequiredOBJECT_FREQ;

function requireOBJECT_FREQ () {
	if (hasRequiredOBJECT_FREQ) return OBJECT_FREQ;
	hasRequiredOBJECT_FREQ = 1;
	Object.defineProperty(OBJECT_FREQ, "__esModule", { value: true });
	OBJECT_FREQ.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the OBJECT FREQ command
	     *
	     * @param parser - The command parser
	     * @param key - The key to get the access frequency for
	     * @see https://redis.io/commands/object-freq/
	     */
	    parseCommand(parser, key) {
	        parser.push('OBJECT', 'FREQ');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return OBJECT_FREQ;
}

var OBJECT_IDLETIME = {};

var hasRequiredOBJECT_IDLETIME;

function requireOBJECT_IDLETIME () {
	if (hasRequiredOBJECT_IDLETIME) return OBJECT_IDLETIME;
	hasRequiredOBJECT_IDLETIME = 1;
	Object.defineProperty(OBJECT_IDLETIME, "__esModule", { value: true });
	OBJECT_IDLETIME.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the OBJECT IDLETIME command
	     *
	     * @param parser - The command parser
	     * @param key - The key to get the idle time for
	     * @see https://redis.io/commands/object-idletime/
	     */
	    parseCommand(parser, key) {
	        parser.push('OBJECT', 'IDLETIME');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return OBJECT_IDLETIME;
}

var OBJECT_REFCOUNT = {};

var hasRequiredOBJECT_REFCOUNT;

function requireOBJECT_REFCOUNT () {
	if (hasRequiredOBJECT_REFCOUNT) return OBJECT_REFCOUNT;
	hasRequiredOBJECT_REFCOUNT = 1;
	Object.defineProperty(OBJECT_REFCOUNT, "__esModule", { value: true });
	OBJECT_REFCOUNT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the OBJECT REFCOUNT command
	     *
	     * @param parser - The command parser
	     * @param key - The key to get the reference count for
	     * @see https://redis.io/commands/object-refcount/
	     */
	    parseCommand(parser, key) {
	        parser.push('OBJECT', 'REFCOUNT');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return OBJECT_REFCOUNT;
}

var PERSIST = {};

var hasRequiredPERSIST;

function requirePERSIST () {
	if (hasRequiredPERSIST) return PERSIST;
	hasRequiredPERSIST = 1;
	Object.defineProperty(PERSIST, "__esModule", { value: true });
	PERSIST.default = {
	    /**
	     * Constructs the PERSIST command
	     *
	     * @param parser - The command parser
	     * @param key - The key to remove the expiration from
	     * @see https://redis.io/commands/persist/
	     */
	    parseCommand(parser, key) {
	        parser.push('PERSIST');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return PERSIST;
}

var PEXPIRE = {};

var hasRequiredPEXPIRE;

function requirePEXPIRE () {
	if (hasRequiredPEXPIRE) return PEXPIRE;
	hasRequiredPEXPIRE = 1;
	Object.defineProperty(PEXPIRE, "__esModule", { value: true });
	PEXPIRE.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PEXPIRE command
	     *
	     * @param parser - The command parser
	     * @param key - The key to set the expiration for
	     * @param ms - The expiration time in milliseconds
	     * @param mode - Optional mode for the command ('NX', 'XX', 'GT', 'LT')
	     * @see https://redis.io/commands/pexpire/
	     */
	    parseCommand(parser, key, ms, mode) {
	        parser.push('PEXPIRE');
	        parser.pushKey(key);
	        parser.push(ms.toString());
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return PEXPIRE;
}

var PEXPIREAT = {};

var hasRequiredPEXPIREAT;

function requirePEXPIREAT () {
	if (hasRequiredPEXPIREAT) return PEXPIREAT;
	hasRequiredPEXPIREAT = 1;
	Object.defineProperty(PEXPIREAT, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	PEXPIREAT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PEXPIREAT command
	     *
	     * @param parser - The command parser
	     * @param key - The key to set the expiration for
	     * @param msTimestamp - The expiration timestamp in milliseconds (Unix timestamp or Date object)
	     * @param mode - Optional mode for the command ('NX', 'XX', 'GT', 'LT')
	     * @see https://redis.io/commands/pexpireat/
	     */
	    parseCommand(parser, key, msTimestamp, mode) {
	        parser.push('PEXPIREAT');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformPXAT)(msTimestamp));
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return PEXPIREAT;
}

var PEXPIRETIME = {};

var hasRequiredPEXPIRETIME;

function requirePEXPIRETIME () {
	if (hasRequiredPEXPIRETIME) return PEXPIRETIME;
	hasRequiredPEXPIRETIME = 1;
	Object.defineProperty(PEXPIRETIME, "__esModule", { value: true });
	PEXPIRETIME.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PEXPIRETIME command
	     *
	     * @param parser - The command parser
	     * @param key - The key to get the expiration time for in milliseconds
	     * @see https://redis.io/commands/pexpiretime/
	     */
	    parseCommand(parser, key) {
	        parser.push('PEXPIRETIME');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return PEXPIRETIME;
}

var PFADD = {};

var hasRequiredPFADD;

function requirePFADD () {
	if (hasRequiredPFADD) return PFADD;
	hasRequiredPFADD = 1;
	Object.defineProperty(PFADD, "__esModule", { value: true });
	PFADD.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PFADD command
	     *
	     * @param parser - The command parser
	     * @param key - The key of the HyperLogLog
	     * @param element - Optional elements to add
	     * @see https://redis.io/commands/pfadd/
	     */
	    parseCommand(parser, key, element) {
	        parser.push('PFADD');
	        parser.pushKey(key);
	        if (element) {
	            parser.pushVariadic(element);
	        }
	    },
	    transformReply: undefined
	};
	
	return PFADD;
}

var PFCOUNT = {};

var hasRequiredPFCOUNT;

function requirePFCOUNT () {
	if (hasRequiredPFCOUNT) return PFCOUNT;
	hasRequiredPFCOUNT = 1;
	Object.defineProperty(PFCOUNT, "__esModule", { value: true });
	PFCOUNT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PFCOUNT command
	     *
	     * @param parser - The command parser
	     * @param keys - One or more keys of HyperLogLog structures to count
	     * @see https://redis.io/commands/pfcount/
	     */
	    parseCommand(parser, keys) {
	        parser.push('PFCOUNT');
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return PFCOUNT;
}

var PFMERGE = {};

var hasRequiredPFMERGE;

function requirePFMERGE () {
	if (hasRequiredPFMERGE) return PFMERGE;
	hasRequiredPFMERGE = 1;
	Object.defineProperty(PFMERGE, "__esModule", { value: true });
	PFMERGE.default = {
	    /**
	     * Constructs the PFMERGE command
	     *
	     * @param parser - The command parser
	     * @param destination - The destination key to merge to
	     * @param sources - One or more source keys to merge from
	     * @see https://redis.io/commands/pfmerge/
	     */
	    parseCommand(parser, destination, sources) {
	        parser.push('PFMERGE');
	        parser.pushKey(destination);
	        if (sources) {
	            parser.pushKeys(sources);
	        }
	    },
	    transformReply: undefined
	};
	
	return PFMERGE;
}

var PING = {};

var hasRequiredPING;

function requirePING () {
	if (hasRequiredPING) return PING;
	hasRequiredPING = 1;
	Object.defineProperty(PING, "__esModule", { value: true });
	PING.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PING command
	     *
	     * @param parser - The command parser
	     * @param message - Optional message to be returned instead of PONG
	     * @see https://redis.io/commands/ping/
	     */
	    parseCommand(parser, message) {
	        parser.push('PING');
	        if (message) {
	            parser.push(message);
	        }
	    },
	    transformReply: undefined
	};
	
	return PING;
}

var PSETEX = {};

var hasRequiredPSETEX;

function requirePSETEX () {
	if (hasRequiredPSETEX) return PSETEX;
	hasRequiredPSETEX = 1;
	Object.defineProperty(PSETEX, "__esModule", { value: true });
	PSETEX.default = {
	    /**
	     * Constructs the PSETEX command
	     *
	     * @param parser - The command parser
	     * @param key - The key to set
	     * @param ms - The expiration time in milliseconds
	     * @param value - The value to set
	     * @see https://redis.io/commands/psetex/
	     */
	    parseCommand(parser, key, ms, value) {
	        parser.push('PSETEX');
	        parser.pushKey(key);
	        parser.push(ms.toString(), value);
	    },
	    transformReply: undefined
	};
	
	return PSETEX;
}

var PTTL = {};

var hasRequiredPTTL;

function requirePTTL () {
	if (hasRequiredPTTL) return PTTL;
	hasRequiredPTTL = 1;
	Object.defineProperty(PTTL, "__esModule", { value: true });
	PTTL.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PTTL command
	     *
	     * @param parser - The command parser
	     * @param key - The key to get the time to live in milliseconds
	     * @see https://redis.io/commands/pttl/
	     */
	    parseCommand(parser, key) {
	        parser.push('PTTL');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return PTTL;
}

var PUBLISH = {};

var hasRequiredPUBLISH;

function requirePUBLISH () {
	if (hasRequiredPUBLISH) return PUBLISH;
	hasRequiredPUBLISH = 1;
	Object.defineProperty(PUBLISH, "__esModule", { value: true });
	PUBLISH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    IS_FORWARD_COMMAND: true,
	    /**
	     * Constructs the PUBLISH command
	     *
	     * @param parser - The command parser
	     * @param channel - The channel to publish to
	     * @param message - The message to publish
	     * @see https://redis.io/commands/publish/
	     */
	    parseCommand(parser, channel, message) {
	        parser.push('PUBLISH', channel, message);
	    },
	    transformReply: undefined
	};
	
	return PUBLISH;
}

var PUBSUB_CHANNELS = {};

var hasRequiredPUBSUB_CHANNELS;

function requirePUBSUB_CHANNELS () {
	if (hasRequiredPUBSUB_CHANNELS) return PUBSUB_CHANNELS;
	hasRequiredPUBSUB_CHANNELS = 1;
	Object.defineProperty(PUBSUB_CHANNELS, "__esModule", { value: true });
	PUBSUB_CHANNELS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PUBSUB CHANNELS command
	     *
	     * @param parser - The command parser
	     * @param pattern - Optional pattern to filter channels
	     * @see https://redis.io/commands/pubsub-channels/
	     */
	    parseCommand(parser, pattern) {
	        parser.push('PUBSUB', 'CHANNELS');
	        if (pattern) {
	            parser.push(pattern);
	        }
	    },
	    transformReply: undefined
	};
	
	return PUBSUB_CHANNELS;
}

var PUBSUB_NUMPAT = {};

var hasRequiredPUBSUB_NUMPAT;

function requirePUBSUB_NUMPAT () {
	if (hasRequiredPUBSUB_NUMPAT) return PUBSUB_NUMPAT;
	hasRequiredPUBSUB_NUMPAT = 1;
	Object.defineProperty(PUBSUB_NUMPAT, "__esModule", { value: true });
	PUBSUB_NUMPAT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PUBSUB NUMPAT command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/pubsub-numpat/
	     */
	    parseCommand(parser) {
	        parser.push('PUBSUB', 'NUMPAT');
	    },
	    transformReply: undefined
	};
	
	return PUBSUB_NUMPAT;
}

var PUBSUB_NUMSUB = {};

var hasRequiredPUBSUB_NUMSUB;

function requirePUBSUB_NUMSUB () {
	if (hasRequiredPUBSUB_NUMSUB) return PUBSUB_NUMSUB;
	hasRequiredPUBSUB_NUMSUB = 1;
	Object.defineProperty(PUBSUB_NUMSUB, "__esModule", { value: true });
	PUBSUB_NUMSUB.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PUBSUB NUMSUB command
	     *
	     * @param parser - The command parser
	     * @param channels - Optional channel names to get subscription count for
	     * @see https://redis.io/commands/pubsub-numsub/
	     */
	    parseCommand(parser, channels) {
	        parser.push('PUBSUB', 'NUMSUB');
	        if (channels) {
	            parser.pushVariadic(channels);
	        }
	    },
	    /**
	     * Transforms the PUBSUB NUMSUB reply into a record of channel name to subscriber count
	     *
	     * @param rawReply - The raw reply from Redis
	     * @returns Record mapping channel names to their subscriber counts
	     */
	    transformReply(rawReply) {
	        const reply = Object.create(null);
	        let i = 0;
	        while (i < rawReply.length) {
	            reply[rawReply[i++].toString()] = rawReply[i++].toString();
	        }
	        return reply;
	    }
	};
	
	return PUBSUB_NUMSUB;
}

var PUBSUB_SHARDNUMSUB = {};

var hasRequiredPUBSUB_SHARDNUMSUB;

function requirePUBSUB_SHARDNUMSUB () {
	if (hasRequiredPUBSUB_SHARDNUMSUB) return PUBSUB_SHARDNUMSUB;
	hasRequiredPUBSUB_SHARDNUMSUB = 1;
	Object.defineProperty(PUBSUB_SHARDNUMSUB, "__esModule", { value: true });
	PUBSUB_SHARDNUMSUB.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PUBSUB SHARDNUMSUB command
	     *
	     * @param parser - The command parser
	     * @param channels - Optional shard channel names to get subscription count for
	     * @see https://redis.io/commands/pubsub-shardnumsub/
	     */
	    parseCommand(parser, channels) {
	        parser.push('PUBSUB', 'SHARDNUMSUB');
	        if (channels) {
	            parser.pushVariadic(channels);
	        }
	    },
	    /**
	     * Transforms the PUBSUB SHARDNUMSUB reply into a record of shard channel name to subscriber count
	     *
	     * @param reply - The raw reply from Redis
	     * @returns Record mapping shard channel names to their subscriber counts
	     */
	    transformReply(reply) {
	        const transformedReply = Object.create(null);
	        for (let i = 0; i < reply.length; i += 2) {
	            transformedReply[reply[i].toString()] = reply[i + 1];
	        }
	        return transformedReply;
	    }
	};
	
	return PUBSUB_SHARDNUMSUB;
}

var PUBSUB_SHARDCHANNELS = {};

var hasRequiredPUBSUB_SHARDCHANNELS;

function requirePUBSUB_SHARDCHANNELS () {
	if (hasRequiredPUBSUB_SHARDCHANNELS) return PUBSUB_SHARDCHANNELS;
	hasRequiredPUBSUB_SHARDCHANNELS = 1;
	Object.defineProperty(PUBSUB_SHARDCHANNELS, "__esModule", { value: true });
	PUBSUB_SHARDCHANNELS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the PUBSUB SHARDCHANNELS command
	     *
	     * @param parser - The command parser
	     * @param pattern - Optional pattern to filter shard channels
	     * @see https://redis.io/commands/pubsub-shardchannels/
	     */
	    parseCommand(parser, pattern) {
	        parser.push('PUBSUB', 'SHARDCHANNELS');
	        if (pattern) {
	            parser.push(pattern);
	        }
	    },
	    transformReply: undefined
	};
	
	return PUBSUB_SHARDCHANNELS;
}

var RANDOMKEY = {};

var hasRequiredRANDOMKEY;

function requireRANDOMKEY () {
	if (hasRequiredRANDOMKEY) return RANDOMKEY;
	hasRequiredRANDOMKEY = 1;
	Object.defineProperty(RANDOMKEY, "__esModule", { value: true });
	RANDOMKEY.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the RANDOMKEY command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/randomkey/
	     */
	    parseCommand(parser) {
	        parser.push('RANDOMKEY');
	    },
	    transformReply: undefined
	};
	
	return RANDOMKEY;
}

var READONLY = {};

var hasRequiredREADONLY;

function requireREADONLY () {
	if (hasRequiredREADONLY) return READONLY;
	hasRequiredREADONLY = 1;
	Object.defineProperty(READONLY, "__esModule", { value: true });
	READONLY.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the READONLY command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/readonly/
	     */
	    parseCommand(parser) {
	        parser.push('READONLY');
	    },
	    transformReply: undefined
	};
	
	return READONLY;
}

var RENAME = {};

var hasRequiredRENAME;

function requireRENAME () {
	if (hasRequiredRENAME) return RENAME;
	hasRequiredRENAME = 1;
	Object.defineProperty(RENAME, "__esModule", { value: true });
	RENAME.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the RENAME command
	     *
	     * @param parser - The command parser
	     * @param key - The key to rename
	     * @param newKey - The new key name
	     * @see https://redis.io/commands/rename/
	     */
	    parseCommand(parser, key, newKey) {
	        parser.push('RENAME');
	        parser.pushKeys([key, newKey]);
	    },
	    transformReply: undefined
	};
	
	return RENAME;
}

var RENAMENX = {};

var hasRequiredRENAMENX;

function requireRENAMENX () {
	if (hasRequiredRENAMENX) return RENAMENX;
	hasRequiredRENAMENX = 1;
	Object.defineProperty(RENAMENX, "__esModule", { value: true });
	RENAMENX.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the RENAMENX command
	     *
	     * @param parser - The command parser
	     * @param key - The key to rename
	     * @param newKey - The new key name, if it doesn't exist
	     * @see https://redis.io/commands/renamenx/
	     */
	    parseCommand(parser, key, newKey) {
	        parser.push('RENAMENX');
	        parser.pushKeys([key, newKey]);
	    },
	    transformReply: undefined
	};
	
	return RENAMENX;
}

var REPLICAOF = {};

var hasRequiredREPLICAOF;

function requireREPLICAOF () {
	if (hasRequiredREPLICAOF) return REPLICAOF;
	hasRequiredREPLICAOF = 1;
	Object.defineProperty(REPLICAOF, "__esModule", { value: true });
	REPLICAOF.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the REPLICAOF command
	     *
	     * @param parser - The command parser
	     * @param host - The host of the master to replicate from
	     * @param port - The port of the master to replicate from
	     * @see https://redis.io/commands/replicaof/
	     */
	    parseCommand(parser, host, port) {
	        parser.push('REPLICAOF', host, port.toString());
	    },
	    transformReply: undefined
	};
	
	return REPLICAOF;
}

var RESTOREASKING = {};

var hasRequiredRESTOREASKING;

function requireRESTOREASKING () {
	if (hasRequiredRESTOREASKING) return RESTOREASKING;
	hasRequiredRESTOREASKING = 1;
	Object.defineProperty(RESTOREASKING, "__esModule", { value: true });
	RESTOREASKING.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the RESTORE-ASKING command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/restore-asking/
	     */
	    parseCommand(parser) {
	        parser.push('RESTORE-ASKING');
	    },
	    transformReply: undefined
	};
	
	return RESTOREASKING;
}

var RESTORE = {};

var hasRequiredRESTORE;

function requireRESTORE () {
	if (hasRequiredRESTORE) return RESTORE;
	hasRequiredRESTORE = 1;
	Object.defineProperty(RESTORE, "__esModule", { value: true });
	RESTORE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the RESTORE command
	     *
	     * @param parser - The command parser
	     * @param key - The key to restore
	     * @param ttl - Time to live in milliseconds, 0 for no expiry
	     * @param serializedValue - The serialized value from DUMP command
	     * @param options - Options for the RESTORE command
	     * @see https://redis.io/commands/restore/
	     */
	    parseCommand(parser, key, ttl, serializedValue, options) {
	        parser.push('RESTORE');
	        parser.pushKey(key);
	        parser.push(ttl.toString(), serializedValue);
	        if (options?.REPLACE) {
	            parser.push('REPLACE');
	        }
	        if (options?.ABSTTL) {
	            parser.push('ABSTTL');
	        }
	        if (options?.IDLETIME) {
	            parser.push('IDLETIME', options.IDLETIME.toString());
	        }
	        if (options?.FREQ) {
	            parser.push('FREQ', options.FREQ.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return RESTORE;
}

var ROLE = {};

var hasRequiredROLE;

function requireROLE () {
	if (hasRequiredROLE) return ROLE;
	hasRequiredROLE = 1;
	Object.defineProperty(ROLE, "__esModule", { value: true });
	ROLE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the ROLE command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/role/
	     */
	    parseCommand(parser) {
	        parser.push('ROLE');
	    },
	    /**
	     * Transforms the ROLE reply into a structured object
	     *
	     * @param reply - The raw reply from Redis
	     * @returns Structured object representing role information
	     */
	    transformReply(reply) {
	        switch (reply[0]) {
	            case 'master': {
	                const [role, replicationOffest, replicas] = reply;
	                return {
	                    role,
	                    replicationOffest,
	                    replicas: replicas.map(replica => {
	                        const [host, port, replicationOffest] = replica;
	                        return {
	                            host,
	                            port: Number(port),
	                            replicationOffest: Number(replicationOffest)
	                        };
	                    })
	                };
	            }
	            case 'slave': {
	                const [role, masterHost, masterPort, state, dataReceived] = reply;
	                return {
	                    role,
	                    master: {
	                        host: masterHost,
	                        port: masterPort
	                    },
	                    state,
	                    dataReceived,
	                };
	            }
	            case 'sentinel': {
	                const [role, masterNames] = reply;
	                return {
	                    role,
	                    masterNames
	                };
	            }
	        }
	    }
	};
	
	return ROLE;
}

var RPOP_COUNT = {};

var hasRequiredRPOP_COUNT;

function requireRPOP_COUNT () {
	if (hasRequiredRPOP_COUNT) return RPOP_COUNT;
	hasRequiredRPOP_COUNT = 1;
	Object.defineProperty(RPOP_COUNT, "__esModule", { value: true });
	RPOP_COUNT.default = {
	    /**
	     * Constructs the RPOP command with count parameter
	     *
	     * @param parser - The command parser
	     * @param key - The list key to pop from
	     * @param count - The number of elements to pop
	     * @see https://redis.io/commands/rpop/
	     */
	    parseCommand(parser, key, count) {
	        parser.push('RPOP');
	        parser.pushKey(key);
	        parser.push(count.toString());
	    },
	    transformReply: undefined
	};
	
	return RPOP_COUNT;
}

var RPOP = {};

var hasRequiredRPOP;

function requireRPOP () {
	if (hasRequiredRPOP) return RPOP;
	hasRequiredRPOP = 1;
	Object.defineProperty(RPOP, "__esModule", { value: true });
	RPOP.default = {
	    /**
	     * Constructs the RPOP command
	     *
	     * @param parser - The command parser
	     * @param key - The list key to pop from
	     * @see https://redis.io/commands/rpop/
	     */
	    parseCommand(parser, key) {
	        parser.push('RPOP');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return RPOP;
}

var RPOPLPUSH = {};

var hasRequiredRPOPLPUSH;

function requireRPOPLPUSH () {
	if (hasRequiredRPOPLPUSH) return RPOPLPUSH;
	hasRequiredRPOPLPUSH = 1;
	Object.defineProperty(RPOPLPUSH, "__esModule", { value: true });
	RPOPLPUSH.default = {
	    /**
	     * Constructs the RPOPLPUSH command
	     *
	     * @param parser - The command parser
	     * @param source - The source list key
	     * @param destination - The destination list key
	     * @see https://redis.io/commands/rpoplpush/
	     */
	    parseCommand(parser, source, destination) {
	        parser.push('RPOPLPUSH');
	        parser.pushKeys([source, destination]);
	    },
	    transformReply: undefined
	};
	
	return RPOPLPUSH;
}

var RPUSH = {};

var hasRequiredRPUSH;

function requireRPUSH () {
	if (hasRequiredRPUSH) return RPUSH;
	hasRequiredRPUSH = 1;
	Object.defineProperty(RPUSH, "__esModule", { value: true });
	RPUSH.default = {
	    /**
	     * Constructs the RPUSH command
	     *
	     * @param parser - The command parser
	     * @param key - The list key to push to
	     * @param element - One or more elements to push
	     * @see https://redis.io/commands/rpush/
	     */
	    parseCommand(parser, key, element) {
	        parser.push('RPUSH');
	        parser.pushKey(key);
	        parser.pushVariadic(element);
	    },
	    transformReply: undefined
	};
	
	return RPUSH;
}

var RPUSHX = {};

var hasRequiredRPUSHX;

function requireRPUSHX () {
	if (hasRequiredRPUSHX) return RPUSHX;
	hasRequiredRPUSHX = 1;
	Object.defineProperty(RPUSHX, "__esModule", { value: true });
	RPUSHX.default = {
	    /**
	     * Constructs the RPUSHX command
	     *
	     * @param parser - The command parser
	     * @param key - The list key to push to (only if it exists)
	     * @param element - One or more elements to push
	     * @see https://redis.io/commands/rpushx/
	     */
	    parseCommand(parser, key, element) {
	        parser.push('RPUSHX');
	        parser.pushKey(key);
	        parser.pushVariadic(element);
	    },
	    transformReply: undefined
	};
	
	return RPUSHX;
}

var SADD = {};

var hasRequiredSADD;

function requireSADD () {
	if (hasRequiredSADD) return SADD;
	hasRequiredSADD = 1;
	Object.defineProperty(SADD, "__esModule", { value: true });
	SADD.default = {
	    /**
	     * Constructs the SADD command
	     *
	     * @param parser - The command parser
	     * @param key - The set key to add members to
	     * @param members - One or more members to add to the set
	     * @see https://redis.io/commands/sadd/
	     */
	    parseCommand(parser, key, members) {
	        parser.push('SADD');
	        parser.pushKey(key);
	        parser.pushVariadic(members);
	    },
	    transformReply: undefined
	};
	
	return SADD;
}

var SCARD = {};

var hasRequiredSCARD;

function requireSCARD () {
	if (hasRequiredSCARD) return SCARD;
	hasRequiredSCARD = 1;
	Object.defineProperty(SCARD, "__esModule", { value: true });
	SCARD.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SCARD command
	     *
	     * @param parser - The command parser
	     * @param key - The set key to get the cardinality of
	     * @see https://redis.io/commands/scard/
	     */
	    parseCommand(parser, key) {
	        parser.push('SCARD');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return SCARD;
}

var SCRIPT_DEBUG = {};

var hasRequiredSCRIPT_DEBUG;

function requireSCRIPT_DEBUG () {
	if (hasRequiredSCRIPT_DEBUG) return SCRIPT_DEBUG;
	hasRequiredSCRIPT_DEBUG = 1;
	Object.defineProperty(SCRIPT_DEBUG, "__esModule", { value: true });
	SCRIPT_DEBUG.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SCRIPT DEBUG command
	     *
	     * @param parser - The command parser
	     * @param mode - Debug mode: YES, SYNC, or NO
	     * @see https://redis.io/commands/script-debug/
	     */
	    parseCommand(parser, mode) {
	        parser.push('SCRIPT', 'DEBUG', mode);
	    },
	    transformReply: undefined
	};
	
	return SCRIPT_DEBUG;
}

var SCRIPT_EXISTS = {};

var hasRequiredSCRIPT_EXISTS;

function requireSCRIPT_EXISTS () {
	if (hasRequiredSCRIPT_EXISTS) return SCRIPT_EXISTS;
	hasRequiredSCRIPT_EXISTS = 1;
	Object.defineProperty(SCRIPT_EXISTS, "__esModule", { value: true });
	SCRIPT_EXISTS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SCRIPT EXISTS command
	     *
	     * @param parser - The command parser
	     * @param sha1 - One or more SHA1 digests of scripts
	     * @see https://redis.io/commands/script-exists/
	     */
	    parseCommand(parser, sha1) {
	        parser.push('SCRIPT', 'EXISTS');
	        parser.pushVariadic(sha1);
	    },
	    transformReply: undefined
	};
	
	return SCRIPT_EXISTS;
}

var SCRIPT_FLUSH = {};

var hasRequiredSCRIPT_FLUSH;

function requireSCRIPT_FLUSH () {
	if (hasRequiredSCRIPT_FLUSH) return SCRIPT_FLUSH;
	hasRequiredSCRIPT_FLUSH = 1;
	Object.defineProperty(SCRIPT_FLUSH, "__esModule", { value: true });
	SCRIPT_FLUSH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SCRIPT FLUSH command
	     *
	     * @param parser - The command parser
	     * @param mode - Optional flush mode: ASYNC or SYNC
	     * @see https://redis.io/commands/script-flush/
	     */
	    parseCommand(parser, mode) {
	        parser.push('SCRIPT', 'FLUSH');
	        if (mode) {
	            parser.push(mode);
	        }
	    },
	    transformReply: undefined
	};
	
	return SCRIPT_FLUSH;
}

var SCRIPT_KILL = {};

var hasRequiredSCRIPT_KILL;

function requireSCRIPT_KILL () {
	if (hasRequiredSCRIPT_KILL) return SCRIPT_KILL;
	hasRequiredSCRIPT_KILL = 1;
	Object.defineProperty(SCRIPT_KILL, "__esModule", { value: true });
	SCRIPT_KILL.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SCRIPT KILL command
	     *
	     * @param parser - The command parser
	     * @see https://redis.io/commands/script-kill/
	     */
	    parseCommand(parser) {
	        parser.push('SCRIPT', 'KILL');
	    },
	    transformReply: undefined
	};
	
	return SCRIPT_KILL;
}

var SCRIPT_LOAD = {};

var hasRequiredSCRIPT_LOAD;

function requireSCRIPT_LOAD () {
	if (hasRequiredSCRIPT_LOAD) return SCRIPT_LOAD;
	hasRequiredSCRIPT_LOAD = 1;
	Object.defineProperty(SCRIPT_LOAD, "__esModule", { value: true });
	SCRIPT_LOAD.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SCRIPT LOAD command
	     *
	     * @param parser - The command parser
	     * @param script - The Lua script to load
	     * @see https://redis.io/commands/script-load/
	     */
	    parseCommand(parser, script) {
	        parser.push('SCRIPT', 'LOAD', script);
	    },
	    transformReply: undefined
	};
	
	return SCRIPT_LOAD;
}

var SDIFF = {};

var hasRequiredSDIFF;

function requireSDIFF () {
	if (hasRequiredSDIFF) return SDIFF;
	hasRequiredSDIFF = 1;
	Object.defineProperty(SDIFF, "__esModule", { value: true });
	SDIFF.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SDIFF command
	     *
	     * @param parser - The command parser
	     * @param keys - One or more set keys to compute the difference from
	     * @see https://redis.io/commands/sdiff/
	     */
	    parseCommand(parser, keys) {
	        parser.push('SDIFF');
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return SDIFF;
}

var SDIFFSTORE = {};

var hasRequiredSDIFFSTORE;

function requireSDIFFSTORE () {
	if (hasRequiredSDIFFSTORE) return SDIFFSTORE;
	hasRequiredSDIFFSTORE = 1;
	Object.defineProperty(SDIFFSTORE, "__esModule", { value: true });
	SDIFFSTORE.default = {
	    /**
	     * Constructs the SDIFFSTORE command
	     *
	     * @param parser - The command parser
	     * @param destination - The destination key to store the result
	     * @param keys - One or more set keys to compute the difference from
	     * @see https://redis.io/commands/sdiffstore/
	     */
	    parseCommand(parser, destination, keys) {
	        parser.push('SDIFFSTORE');
	        parser.pushKey(destination);
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return SDIFFSTORE;
}

var SET$1 = {};

var hasRequiredSET$1;

function requireSET$1 () {
	if (hasRequiredSET$1) return SET$1;
	hasRequiredSET$1 = 1;
	Object.defineProperty(SET$1, "__esModule", { value: true });
	SET$1.default = {
	    /**
	     * Constructs the SET command
	     *
	     * @param parser - The command parser
	     * @param key - The key to set
	     * @param value - The value to set
	     * @param options - Additional options for the SET command
	     * @see https://redis.io/commands/set/
	     */
	    parseCommand(parser, key, value, options) {
	        parser.push('SET');
	        parser.pushKey(key);
	        parser.push(typeof value === 'number' ? value.toString() : value);
	        if (options?.expiration) {
	            if (typeof options.expiration === 'string') {
	                parser.push(options.expiration);
	            }
	            else if (options.expiration.type === 'KEEPTTL') {
	                parser.push('KEEPTTL');
	            }
	            else {
	                parser.push(options.expiration.type, options.expiration.value.toString());
	            }
	        }
	        else if (options?.EX !== undefined) {
	            parser.push('EX', options.EX.toString());
	        }
	        else if (options?.PX !== undefined) {
	            parser.push('PX', options.PX.toString());
	        }
	        else if (options?.EXAT !== undefined) {
	            parser.push('EXAT', options.EXAT.toString());
	        }
	        else if (options?.PXAT !== undefined) {
	            parser.push('PXAT', options.PXAT.toString());
	        }
	        else if (options?.KEEPTTL) {
	            parser.push('KEEPTTL');
	        }
	        if (options?.condition) {
	            parser.push(options.condition);
	        }
	        else if (options?.NX) {
	            parser.push('NX');
	        }
	        else if (options?.XX) {
	            parser.push('XX');
	        }
	        if (options?.GET) {
	            parser.push('GET');
	        }
	    },
	    transformReply: undefined
	};
	
	return SET$1;
}

var SETBIT = {};

var hasRequiredSETBIT;

function requireSETBIT () {
	if (hasRequiredSETBIT) return SETBIT;
	hasRequiredSETBIT = 1;
	Object.defineProperty(SETBIT, "__esModule", { value: true });
	SETBIT.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the SETBIT command
	     *
	     * @param parser - The command parser
	     * @param key - The key to set the bit on
	     * @param offset - The bit offset (zero-based)
	     * @param value - The bit value (0 or 1)
	     * @see https://redis.io/commands/setbit/
	     */
	    parseCommand(parser, key, offset, value) {
	        parser.push('SETBIT');
	        parser.pushKey(key);
	        parser.push(offset.toString(), value.toString());
	    },
	    transformReply: undefined
	};
	
	return SETBIT;
}

var SETEX = {};

var hasRequiredSETEX;

function requireSETEX () {
	if (hasRequiredSETEX) return SETEX;
	hasRequiredSETEX = 1;
	Object.defineProperty(SETEX, "__esModule", { value: true });
	SETEX.default = {
	    /**
	     * Constructs the SETEX command
	     *
	     * @param parser - The command parser
	     * @param key - The key to set
	     * @param seconds - The expiration time in seconds
	     * @param value - The value to set
	     * @see https://redis.io/commands/setex/
	     */
	    parseCommand(parser, key, seconds, value) {
	        parser.push('SETEX');
	        parser.pushKey(key);
	        parser.push(seconds.toString(), value);
	    },
	    transformReply: undefined
	};
	
	return SETEX;
}

var SETNX = {};

var hasRequiredSETNX;

function requireSETNX () {
	if (hasRequiredSETNX) return SETNX;
	hasRequiredSETNX = 1;
	Object.defineProperty(SETNX, "__esModule", { value: true });
	SETNX.default = {
	    /**
	     * Constructs the SETNX command
	     *
	     * @param parser - The command parser
	     * @param key - The key to set if it doesn't exist
	     * @param value - The value to set
	     * @see https://redis.io/commands/setnx/
	     */
	    parseCommand(parser, key, value) {
	        parser.push('SETNX');
	        parser.pushKey(key);
	        parser.push(value);
	    },
	    transformReply: undefined
	};
	
	return SETNX;
}

var SETRANGE = {};

var hasRequiredSETRANGE;

function requireSETRANGE () {
	if (hasRequiredSETRANGE) return SETRANGE;
	hasRequiredSETRANGE = 1;
	Object.defineProperty(SETRANGE, "__esModule", { value: true });
	SETRANGE.default = {
	    /**
	     * Constructs the SETRANGE command
	     *
	     * @param parser - The command parser
	     * @param key - The key to modify
	     * @param offset - The offset at which to start writing
	     * @param value - The value to write at the offset
	     * @see https://redis.io/commands/setrange/
	     */
	    parseCommand(parser, key, offset, value) {
	        parser.push('SETRANGE');
	        parser.pushKey(key);
	        parser.push(offset.toString(), value);
	    },
	    transformReply: undefined
	};
	
	return SETRANGE;
}

var SINTER = {};

var hasRequiredSINTER;

function requireSINTER () {
	if (hasRequiredSINTER) return SINTER;
	hasRequiredSINTER = 1;
	Object.defineProperty(SINTER, "__esModule", { value: true });
	SINTER.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SINTER command
	     *
	     * @param parser - The command parser
	     * @param keys - One or more set keys to compute the intersection from
	     * @see https://redis.io/commands/sinter/
	     */
	    parseCommand(parser, keys) {
	        parser.push('SINTER');
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return SINTER;
}

var SINTERCARD = {};

var hasRequiredSINTERCARD;

function requireSINTERCARD () {
	if (hasRequiredSINTERCARD) return SINTERCARD;
	hasRequiredSINTERCARD = 1;
	Object.defineProperty(SINTERCARD, "__esModule", { value: true });
	SINTERCARD.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SINTERCARD command
	     *
	     * @param parser - The command parser
	     * @param keys - One or more set keys to compute the intersection cardinality from
	     * @param options - Options for the SINTERCARD command or a number for LIMIT (backwards compatibility)
	     * @see https://redis.io/commands/sintercard/
	     */
	    parseCommand(parser, keys, options) {
	        parser.push('SINTERCARD');
	        parser.pushKeysLength(keys);
	        if (typeof options === 'number') { // backwards compatibility
	            parser.push('LIMIT', options.toString());
	        }
	        else if (options?.LIMIT !== undefined) {
	            parser.push('LIMIT', options.LIMIT.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return SINTERCARD;
}

var SINTERSTORE = {};

var hasRequiredSINTERSTORE;

function requireSINTERSTORE () {
	if (hasRequiredSINTERSTORE) return SINTERSTORE;
	hasRequiredSINTERSTORE = 1;
	Object.defineProperty(SINTERSTORE, "__esModule", { value: true });
	SINTERSTORE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the SINTERSTORE command
	     *
	     * @param parser - The command parser
	     * @param destination - The destination key to store the result
	     * @param keys - One or more set keys to compute the intersection from
	     * @see https://redis.io/commands/sinterstore/
	     */
	    parseCommand(parser, destination, keys) {
	        parser.push('SINTERSTORE');
	        parser.pushKey(destination);
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return SINTERSTORE;
}

var SISMEMBER = {};

var hasRequiredSISMEMBER;

function requireSISMEMBER () {
	if (hasRequiredSISMEMBER) return SISMEMBER;
	hasRequiredSISMEMBER = 1;
	Object.defineProperty(SISMEMBER, "__esModule", { value: true });
	SISMEMBER.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SISMEMBER command
	     *
	     * @param parser - The command parser
	     * @param key - The set key to check membership in
	     * @param member - The member to check for existence
	     * @see https://redis.io/commands/sismember/
	     */
	    parseCommand(parser, key, member) {
	        parser.push('SISMEMBER');
	        parser.pushKey(key);
	        parser.push(member);
	    },
	    transformReply: undefined
	};
	
	return SISMEMBER;
}

var SMEMBERS = {};

var hasRequiredSMEMBERS;

function requireSMEMBERS () {
	if (hasRequiredSMEMBERS) return SMEMBERS;
	hasRequiredSMEMBERS = 1;
	Object.defineProperty(SMEMBERS, "__esModule", { value: true });
	SMEMBERS.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SMEMBERS command
	     *
	     * @param parser - The command parser
	     * @param key - The set key to get all members from
	     * @see https://redis.io/commands/smembers/
	     */
	    parseCommand(parser, key) {
	        parser.push('SMEMBERS');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        2: undefined,
	        3: undefined
	    }
	};
	
	return SMEMBERS;
}

var SMISMEMBER = {};

var hasRequiredSMISMEMBER;

function requireSMISMEMBER () {
	if (hasRequiredSMISMEMBER) return SMISMEMBER;
	hasRequiredSMISMEMBER = 1;
	Object.defineProperty(SMISMEMBER, "__esModule", { value: true });
	SMISMEMBER.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SMISMEMBER command
	     *
	     * @param parser - The command parser
	     * @param key - The set key to check membership in
	     * @param members - The members to check for existence
	     * @see https://redis.io/commands/smismember/
	     */
	    parseCommand(parser, key, members) {
	        parser.push('SMISMEMBER');
	        parser.pushKey(key);
	        parser.pushVariadic(members);
	    },
	    transformReply: undefined
	};
	
	return SMISMEMBER;
}

var SMOVE = {};

var hasRequiredSMOVE;

function requireSMOVE () {
	if (hasRequiredSMOVE) return SMOVE;
	hasRequiredSMOVE = 1;
	Object.defineProperty(SMOVE, "__esModule", { value: true });
	SMOVE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the SMOVE command
	     *
	     * @param parser - The command parser
	     * @param source - The source set key
	     * @param destination - The destination set key
	     * @param member - The member to move
	     * @see https://redis.io/commands/smove/
	     */
	    parseCommand(parser, source, destination, member) {
	        parser.push('SMOVE');
	        parser.pushKeys([source, destination]);
	        parser.push(member);
	    },
	    transformReply: undefined
	};
	
	return SMOVE;
}

var SORT_RO = {};

var SORT = {};

var hasRequiredSORT;

function requireSORT () {
	if (hasRequiredSORT) return SORT;
	hasRequiredSORT = 1;
	Object.defineProperty(SORT, "__esModule", { value: true });
	SORT.parseSortArguments = void 0;
	/**
	 * Parses sort arguments for the SORT command
	 *
	 * @param parser - The command parser
	 * @param key - The key to sort
	 * @param options - Sort options
	 */
	function parseSortArguments(parser, key, options) {
	    parser.pushKey(key);
	    if (options?.BY) {
	        parser.push('BY', options.BY);
	    }
	    if (options?.LIMIT) {
	        parser.push('LIMIT', options.LIMIT.offset.toString(), options.LIMIT.count.toString());
	    }
	    if (options?.GET) {
	        if (Array.isArray(options.GET)) {
	            for (const pattern of options.GET) {
	                parser.push('GET', pattern);
	            }
	        }
	        else {
	            parser.push('GET', options.GET);
	        }
	    }
	    if (options?.DIRECTION) {
	        parser.push(options.DIRECTION);
	    }
	    if (options?.ALPHA) {
	        parser.push('ALPHA');
	    }
	}
	SORT.parseSortArguments = parseSortArguments;
	SORT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SORT command
	     *
	     * @param parser - The command parser
	     * @param key - The key to sort (list, set, or sorted set)
	     * @param options - Sort options
	     * @see https://redis.io/commands/sort/
	     */
	    parseCommand(parser, key, options) {
	        parser.push('SORT');
	        parseSortArguments(parser, key, options);
	    },
	    transformReply: undefined
	};
	
	return SORT;
}

var hasRequiredSORT_RO;

function requireSORT_RO () {
	if (hasRequiredSORT_RO) return SORT_RO;
	hasRequiredSORT_RO = 1;
	var __createBinding = (SORT_RO && SORT_RO.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (SORT_RO && SORT_RO.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (SORT_RO && SORT_RO.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(SORT_RO, "__esModule", { value: true });
	const SORT_1 = __importStar(requireSORT());
	SORT_RO.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Read-only variant of SORT that sorts the elements in a list, set or sorted set.
	     * @param args - Same parameters as the SORT command.
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        parser.push('SORT_RO');
	        (0, SORT_1.parseSortArguments)(...args);
	    },
	    transformReply: SORT_1.default.transformReply
	};
	
	return SORT_RO;
}

var SORT_STORE = {};

var hasRequiredSORT_STORE;

function requireSORT_STORE () {
	if (hasRequiredSORT_STORE) return SORT_STORE;
	hasRequiredSORT_STORE = 1;
	var __importDefault = (SORT_STORE && SORT_STORE.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(SORT_STORE, "__esModule", { value: true });
	const SORT_1 = __importDefault(requireSORT());
	SORT_STORE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Sorts the elements in a list, set or sorted set and stores the result in a new list.
	     * @param parser - The Redis command parser.
	     * @param source - Key of the source list, set or sorted set.
	     * @param destination - Destination key where the result will be stored.
	     * @param options - Optional sorting parameters.
	     */
	    parseCommand(parser, source, destination, options) {
	        SORT_1.default.parseCommand(parser, source, options);
	        parser.push('STORE', destination);
	    },
	    transformReply: undefined
	};
	
	return SORT_STORE;
}

var SPOP_COUNT = {};

var hasRequiredSPOP_COUNT;

function requireSPOP_COUNT () {
	if (hasRequiredSPOP_COUNT) return SPOP_COUNT;
	hasRequiredSPOP_COUNT = 1;
	Object.defineProperty(SPOP_COUNT, "__esModule", { value: true });
	SPOP_COUNT.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the SPOP command to remove and return multiple random members from a set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the set to pop from
	     * @param count - The number of members to pop
	     * @see https://redis.io/commands/spop/
	     */
	    parseCommand(parser, key, count) {
	        parser.push('SPOP');
	        parser.pushKey(key);
	        parser.push(count.toString());
	    },
	    transformReply: undefined
	};
	
	return SPOP_COUNT;
}

var SPOP = {};

var hasRequiredSPOP;

function requireSPOP () {
	if (hasRequiredSPOP) return SPOP;
	hasRequiredSPOP = 1;
	Object.defineProperty(SPOP, "__esModule", { value: true });
	SPOP.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the SPOP command to remove and return a random member from a set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the set to pop from
	     * @see https://redis.io/commands/spop/
	     */
	    parseCommand(parser, key) {
	        parser.push('SPOP');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return SPOP;
}

var SPUBLISH = {};

var hasRequiredSPUBLISH;

function requireSPUBLISH () {
	if (hasRequiredSPUBLISH) return SPUBLISH;
	hasRequiredSPUBLISH = 1;
	Object.defineProperty(SPUBLISH, "__esModule", { value: true });
	SPUBLISH.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SPUBLISH command to post a message to a Sharded Pub/Sub channel
	     *
	     * @param parser - The command parser
	     * @param channel - The channel to publish to
	     * @param message - The message to publish
	     * @see https://redis.io/commands/spublish/
	     */
	    parseCommand(parser, channel, message) {
	        parser.push('SPUBLISH');
	        parser.pushKey(channel);
	        parser.push(message);
	    },
	    transformReply: undefined
	};
	
	return SPUBLISH;
}

var SRANDMEMBER_COUNT = {};

var SRANDMEMBER = {};

var hasRequiredSRANDMEMBER;

function requireSRANDMEMBER () {
	if (hasRequiredSRANDMEMBER) return SRANDMEMBER;
	hasRequiredSRANDMEMBER = 1;
	Object.defineProperty(SRANDMEMBER, "__esModule", { value: true });
	SRANDMEMBER.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SRANDMEMBER command to get a random member from a set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the set to get random member from
	     * @see https://redis.io/commands/srandmember/
	     */
	    parseCommand(parser, key) {
	        parser.push('SRANDMEMBER');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return SRANDMEMBER;
}

var hasRequiredSRANDMEMBER_COUNT;

function requireSRANDMEMBER_COUNT () {
	if (hasRequiredSRANDMEMBER_COUNT) return SRANDMEMBER_COUNT;
	hasRequiredSRANDMEMBER_COUNT = 1;
	var __importDefault = (SRANDMEMBER_COUNT && SRANDMEMBER_COUNT.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(SRANDMEMBER_COUNT, "__esModule", { value: true });
	const SRANDMEMBER_1 = __importDefault(requireSRANDMEMBER());
	SRANDMEMBER_COUNT.default = {
	    IS_READ_ONLY: SRANDMEMBER_1.default.IS_READ_ONLY,
	    /**
	     * Constructs the SRANDMEMBER command to get multiple random members from a set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the set to get random members from
	     * @param count - The number of members to return. If negative, may return the same member multiple times
	     * @see https://redis.io/commands/srandmember/
	     */
	    parseCommand(parser, key, count) {
	        SRANDMEMBER_1.default.parseCommand(parser, key);
	        parser.push(count.toString());
	    },
	    transformReply: undefined
	};
	
	return SRANDMEMBER_COUNT;
}

var SREM = {};

var hasRequiredSREM;

function requireSREM () {
	if (hasRequiredSREM) return SREM;
	hasRequiredSREM = 1;
	Object.defineProperty(SREM, "__esModule", { value: true });
	SREM.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the SREM command to remove one or more members from a set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the set to remove members from
	     * @param members - One or more members to remove from the set
	     * @returns The number of members that were removed from the set
	     * @see https://redis.io/commands/srem/
	     */
	    parseCommand(parser, key, members) {
	        parser.push('SREM');
	        parser.pushKey(key);
	        parser.pushVariadic(members);
	    },
	    transformReply: undefined
	};
	
	return SREM;
}

var SSCAN = {};

var hasRequiredSSCAN;

function requireSSCAN () {
	if (hasRequiredSSCAN) return SSCAN;
	hasRequiredSSCAN = 1;
	Object.defineProperty(SSCAN, "__esModule", { value: true });
	const SCAN_1 = requireSCAN();
	SSCAN.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SSCAN command to incrementally iterate over elements in a set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the set to scan
	     * @param cursor - The cursor position to start scanning from
	     * @param options - Optional scanning parameters (COUNT and MATCH)
	     * @returns Iterator containing cursor position and matching members
	     * @see https://redis.io/commands/sscan/
	     */
	    parseCommand(parser, key, cursor, options) {
	        parser.push('SSCAN');
	        parser.pushKey(key);
	        (0, SCAN_1.parseScanArguments)(parser, cursor, options);
	    },
	    /**
	     * Transforms the SSCAN reply into a cursor result object
	     *
	     * @param cursor - The next cursor position
	     * @param members - Array of matching set members
	     * @returns Object containing cursor and members array
	     */
	    transformReply([cursor, members]) {
	        return {
	            cursor,
	            members
	        };
	    }
	};
	
	return SSCAN;
}

var STRLEN$1 = {};

var hasRequiredSTRLEN$1;

function requireSTRLEN$1 () {
	if (hasRequiredSTRLEN$1) return STRLEN$1;
	hasRequiredSTRLEN$1 = 1;
	Object.defineProperty(STRLEN$1, "__esModule", { value: true });
	STRLEN$1.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the STRLEN command to get the length of a string value
	     *
	     * @param parser - The command parser
	     * @param key - The key holding the string value
	     * @returns The length of the string value, or 0 when key does not exist
	     * @see https://redis.io/commands/strlen/
	     */
	    parseCommand(parser, key) {
	        parser.push('STRLEN');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return STRLEN$1;
}

var SUNION = {};

var hasRequiredSUNION;

function requireSUNION () {
	if (hasRequiredSUNION) return SUNION;
	hasRequiredSUNION = 1;
	Object.defineProperty(SUNION, "__esModule", { value: true });
	SUNION.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the SUNION command to return the members of the set resulting from the union of all the given sets
	     *
	     * @param parser - The command parser
	     * @param keys - One or more set keys to compute the union from
	     * @returns Array of all elements that are members of at least one of the given sets
	     * @see https://redis.io/commands/sunion/
	     */
	    parseCommand(parser, keys) {
	        parser.push('SUNION');
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return SUNION;
}

var SUNIONSTORE = {};

var hasRequiredSUNIONSTORE;

function requireSUNIONSTORE () {
	if (hasRequiredSUNIONSTORE) return SUNIONSTORE;
	hasRequiredSUNIONSTORE = 1;
	Object.defineProperty(SUNIONSTORE, "__esModule", { value: true });
	SUNIONSTORE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the SUNIONSTORE command to store the union of multiple sets into a destination set
	     *
	     * @param parser - The command parser
	     * @param destination - The destination key to store the resulting set
	     * @param keys - One or more source set keys to compute the union from
	     * @returns The number of elements in the resulting set
	     * @see https://redis.io/commands/sunionstore/
	     */
	    parseCommand(parser, destination, keys) {
	        parser.push('SUNIONSTORE');
	        parser.pushKey(destination);
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return SUNIONSTORE;
}

var SWAPDB = {};

var hasRequiredSWAPDB;

function requireSWAPDB () {
	if (hasRequiredSWAPDB) return SWAPDB;
	hasRequiredSWAPDB = 1;
	Object.defineProperty(SWAPDB, "__esModule", { value: true });
	SWAPDB.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: false,
	    /**
	     * Swaps the data of two Redis databases.
	     * @param parser - The Redis command parser.
	     * @param index1 - First database index.
	     * @param index2 - Second database index.
	     */
	    parseCommand(parser, index1, index2) {
	        parser.push('SWAPDB', index1.toString(), index2.toString());
	    },
	    transformReply: undefined
	};
	
	return SWAPDB;
}

var TIME = {};

var hasRequiredTIME;

function requireTIME () {
	if (hasRequiredTIME) return TIME;
	hasRequiredTIME = 1;
	Object.defineProperty(TIME, "__esModule", { value: true });
	TIME.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the TIME command to return the server's current time
	     *
	     * @param parser - The command parser
	     * @returns Array containing the Unix timestamp in seconds and microseconds
	     * @see https://redis.io/commands/time/
	     */
	    parseCommand(parser) {
	        parser.push('TIME');
	    },
	    transformReply: undefined
	};
	
	return TIME;
}

var TOUCH = {};

var hasRequiredTOUCH;

function requireTOUCH () {
	if (hasRequiredTOUCH) return TOUCH;
	hasRequiredTOUCH = 1;
	Object.defineProperty(TOUCH, "__esModule", { value: true });
	TOUCH.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the TOUCH command to alter the last access time of keys
	     *
	     * @param parser - The command parser
	     * @param key - One or more keys to touch
	     * @returns The number of keys that were touched
	     * @see https://redis.io/commands/touch/
	     */
	    parseCommand(parser, key) {
	        parser.push('TOUCH');
	        parser.pushKeys(key);
	    },
	    transformReply: undefined
	};
	
	return TOUCH;
}

var TTL = {};

var hasRequiredTTL;

function requireTTL () {
	if (hasRequiredTTL) return TTL;
	hasRequiredTTL = 1;
	Object.defineProperty(TTL, "__esModule", { value: true });
	TTL.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the TTL command to get the remaining time to live of a key
	     *
	     * @param parser - The command parser
	     * @param key - Key to check
	     * @returns Time to live in seconds, -2 if key does not exist, -1 if has no timeout
	     * @see https://redis.io/commands/ttl/
	     */
	    parseCommand(parser, key) {
	        parser.push('TTL');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return TTL;
}

var TYPE$1 = {};

var hasRequiredTYPE$1;

function requireTYPE$1 () {
	if (hasRequiredTYPE$1) return TYPE$1;
	hasRequiredTYPE$1 = 1;
	Object.defineProperty(TYPE$1, "__esModule", { value: true });
	TYPE$1.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the TYPE command to determine the data type stored at key
	     *
	     * @param parser - The command parser
	     * @param key - Key to check
	     * @returns String reply: "none", "string", "list", "set", "zset", "hash", "stream"
	     * @see https://redis.io/commands/type/
	     */
	    parseCommand(parser, key) {
	        parser.push('TYPE');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return TYPE$1;
}

var UNLINK = {};

var hasRequiredUNLINK;

function requireUNLINK () {
	if (hasRequiredUNLINK) return UNLINK;
	hasRequiredUNLINK = 1;
	Object.defineProperty(UNLINK, "__esModule", { value: true });
	UNLINK.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the UNLINK command to asynchronously delete one or more keys
	     *
	     * @param parser - The command parser
	     * @param keys - One or more keys to unlink
	     * @returns The number of keys that were unlinked
	     * @see https://redis.io/commands/unlink/
	     */
	    parseCommand(parser, keys) {
	        parser.push('UNLINK');
	        parser.pushKeys(keys);
	    },
	    transformReply: undefined
	};
	
	return UNLINK;
}

var WAIT = {};

var hasRequiredWAIT;

function requireWAIT () {
	if (hasRequiredWAIT) return WAIT;
	hasRequiredWAIT = 1;
	Object.defineProperty(WAIT, "__esModule", { value: true });
	WAIT.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the WAIT command to synchronize with replicas
	     *
	     * @param parser - The command parser
	     * @param numberOfReplicas - Number of replicas that must acknowledge the write
	     * @param timeout - Maximum time to wait in milliseconds
	     * @returns The number of replicas that acknowledged the write
	     * @see https://redis.io/commands/wait/
	     */
	    parseCommand(parser, numberOfReplicas, timeout) {
	        parser.push('WAIT', numberOfReplicas.toString(), timeout.toString());
	    },
	    transformReply: undefined
	};
	
	return WAIT;
}

var XACK = {};

var hasRequiredXACK;

function requireXACK () {
	if (hasRequiredXACK) return XACK;
	hasRequiredXACK = 1;
	Object.defineProperty(XACK, "__esModule", { value: true });
	XACK.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XACK command to acknowledge the processing of stream messages in a consumer group
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - The consumer group name
	     * @param id - One or more message IDs to acknowledge
	     * @returns The number of messages successfully acknowledged
	     * @see https://redis.io/commands/xack/
	     */
	    parseCommand(parser, key, group, id) {
	        parser.push('XACK');
	        parser.pushKey(key);
	        parser.push(group);
	        parser.pushVariadic(id);
	    },
	    transformReply: undefined
	};
	
	return XACK;
}

var XADD_NOMKSTREAM = {};

var XADD = {};

var hasRequiredXADD;

function requireXADD () {
	if (hasRequiredXADD) return XADD;
	hasRequiredXADD = 1;
	Object.defineProperty(XADD, "__esModule", { value: true });
	XADD.parseXAddArguments = void 0;
	/**
	 * Parses arguments for the XADD command
	 *
	 * @param optional - Optional command modifier
	 * @param parser - The command parser
	 * @param key - The stream key
	 * @param id - Message ID (* for auto-generation)
	 * @param message - Key-value pairs representing the message fields
	 * @param options - Additional options for stream trimming
	 */
	function parseXAddArguments(optional, parser, key, id, message, options) {
	    parser.push('XADD');
	    parser.pushKey(key);
	    if (optional) {
	        parser.push(optional);
	    }
	    if (options?.TRIM) {
	        if (options.TRIM.strategy) {
	            parser.push(options.TRIM.strategy);
	        }
	        if (options.TRIM.strategyModifier) {
	            parser.push(options.TRIM.strategyModifier);
	        }
	        parser.push(options.TRIM.threshold.toString());
	        if (options.TRIM.limit) {
	            parser.push('LIMIT', options.TRIM.limit.toString());
	        }
	    }
	    parser.push(id);
	    for (const [key, value] of Object.entries(message)) {
	        parser.push(key, value);
	    }
	}
	XADD.parseXAddArguments = parseXAddArguments;
	XADD.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XADD command to append a new entry to a stream
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param id - Message ID (* for auto-generation)
	     * @param message - Key-value pairs representing the message fields
	     * @param options - Additional options for stream trimming
	     * @returns The ID of the added entry
	     * @see https://redis.io/commands/xadd/
	     */
	    parseCommand(...args) {
	        return parseXAddArguments(undefined, ...args);
	    },
	    transformReply: undefined
	};
	
	return XADD;
}

var hasRequiredXADD_NOMKSTREAM;

function requireXADD_NOMKSTREAM () {
	if (hasRequiredXADD_NOMKSTREAM) return XADD_NOMKSTREAM;
	hasRequiredXADD_NOMKSTREAM = 1;
	Object.defineProperty(XADD_NOMKSTREAM, "__esModule", { value: true });
	const XADD_1 = requireXADD();
	/**
	 * Command for adding entries to an existing stream without creating it if it doesn't exist
	 */
	XADD_NOMKSTREAM.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XADD command with NOMKSTREAM option to append a new entry to an existing stream
	     *
	     * @param args - Arguments tuple containing parser, key, id, message, and options
	     * @returns The ID of the added entry, or null if the stream doesn't exist
	     * @see https://redis.io/commands/xadd/
	     */
	    parseCommand(...args) {
	        return (0, XADD_1.parseXAddArguments)('NOMKSTREAM', ...args);
	    },
	    transformReply: undefined
	};
	
	return XADD_NOMKSTREAM;
}

var XAUTOCLAIM_JUSTID = {};

var XAUTOCLAIM = {};

var hasRequiredXAUTOCLAIM;

function requireXAUTOCLAIM () {
	if (hasRequiredXAUTOCLAIM) return XAUTOCLAIM;
	hasRequiredXAUTOCLAIM = 1;
	Object.defineProperty(XAUTOCLAIM, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	XAUTOCLAIM.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XAUTOCLAIM command to automatically claim pending messages in a consumer group
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - The consumer group name
	     * @param consumer - The consumer name that will claim the messages
	     * @param minIdleTime - Minimum idle time in milliseconds for a message to be claimed
	     * @param start - Message ID to start scanning from
	     * @param options - Additional options for the claim operation
	     * @returns Object containing nextId, claimed messages, and list of deleted message IDs
	     * @see https://redis.io/commands/xautoclaim/
	     */
	    parseCommand(parser, key, group, consumer, minIdleTime, start, options) {
	        parser.push('XAUTOCLAIM');
	        parser.pushKey(key);
	        parser.push(group, consumer, minIdleTime.toString(), start);
	        if (options?.COUNT) {
	            parser.push('COUNT', options.COUNT.toString());
	        }
	    },
	    /**
	     * Transforms the raw XAUTOCLAIM reply into a structured object
	     *
	     * @param reply - Raw reply from Redis
	     * @param preserve - Preserve options (unused)
	     * @param typeMapping - Type mapping for message fields
	     * @returns Structured object containing nextId, messages, and deletedMessages
	     */
	    transformReply(reply, preserve, typeMapping) {
	        return {
	            nextId: reply[0],
	            messages: reply[1].map(generic_transformers_1.transformStreamMessageNullReply.bind(undefined, typeMapping)),
	            deletedMessages: reply[2]
	        };
	    }
	};
	
	return XAUTOCLAIM;
}

var hasRequiredXAUTOCLAIM_JUSTID;

function requireXAUTOCLAIM_JUSTID () {
	if (hasRequiredXAUTOCLAIM_JUSTID) return XAUTOCLAIM_JUSTID;
	hasRequiredXAUTOCLAIM_JUSTID = 1;
	var __importDefault = (XAUTOCLAIM_JUSTID && XAUTOCLAIM_JUSTID.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(XAUTOCLAIM_JUSTID, "__esModule", { value: true });
	const XAUTOCLAIM_1 = __importDefault(requireXAUTOCLAIM());
	XAUTOCLAIM_JUSTID.default = {
	    IS_READ_ONLY: XAUTOCLAIM_1.default.IS_READ_ONLY,
	    /**
	     * Constructs the XAUTOCLAIM command with JUSTID option to get only message IDs
	     *
	     * @param args - Same parameters as XAUTOCLAIM command
	     * @returns Object containing nextId and arrays of claimed and deleted message IDs
	     * @see https://redis.io/commands/xautoclaim/
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        XAUTOCLAIM_1.default.parseCommand(...args);
	        parser.push('JUSTID');
	    },
	    /**
	     * Transforms the raw XAUTOCLAIM JUSTID reply into a structured object
	     *
	     * @param reply - Raw reply from Redis
	     * @returns Structured object containing nextId, message IDs, and deleted message IDs
	     */
	    transformReply(reply) {
	        return {
	            nextId: reply[0],
	            messages: reply[1],
	            deletedMessages: reply[2]
	        };
	    }
	};
	
	return XAUTOCLAIM_JUSTID;
}

var XCLAIM_JUSTID = {};

var XCLAIM = {};

var hasRequiredXCLAIM;

function requireXCLAIM () {
	if (hasRequiredXCLAIM) return XCLAIM;
	hasRequiredXCLAIM = 1;
	Object.defineProperty(XCLAIM, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	XCLAIM.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XCLAIM command to claim pending messages in a consumer group
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - The consumer group name
	     * @param consumer - The consumer name that will claim the messages
	     * @param minIdleTime - Minimum idle time in milliseconds for a message to be claimed
	     * @param id - One or more message IDs to claim
	     * @param options - Additional options for the claim operation
	     * @returns Array of claimed messages
	     * @see https://redis.io/commands/xclaim/
	     */
	    parseCommand(parser, key, group, consumer, minIdleTime, id, options) {
	        parser.push('XCLAIM');
	        parser.pushKey(key);
	        parser.push(group, consumer, minIdleTime.toString());
	        parser.pushVariadic(id);
	        if (options?.IDLE !== undefined) {
	            parser.push('IDLE', options.IDLE.toString());
	        }
	        if (options?.TIME !== undefined) {
	            parser.push('TIME', (options.TIME instanceof Date ? options.TIME.getTime() : options.TIME).toString());
	        }
	        if (options?.RETRYCOUNT !== undefined) {
	            parser.push('RETRYCOUNT', options.RETRYCOUNT.toString());
	        }
	        if (options?.FORCE) {
	            parser.push('FORCE');
	        }
	        if (options?.LASTID !== undefined) {
	            parser.push('LASTID', options.LASTID);
	        }
	    },
	    /**
	     * Transforms the raw XCLAIM reply into an array of messages
	     *
	     * @param reply - Raw reply from Redis
	     * @param preserve - Preserve options (unused)
	     * @param typeMapping - Type mapping for message fields
	     * @returns Array of claimed messages with their fields
	     */
	    transformReply(reply, preserve, typeMapping) {
	        return reply.map(generic_transformers_1.transformStreamMessageNullReply.bind(undefined, typeMapping));
	    }
	};
	
	return XCLAIM;
}

var hasRequiredXCLAIM_JUSTID;

function requireXCLAIM_JUSTID () {
	if (hasRequiredXCLAIM_JUSTID) return XCLAIM_JUSTID;
	hasRequiredXCLAIM_JUSTID = 1;
	var __importDefault = (XCLAIM_JUSTID && XCLAIM_JUSTID.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(XCLAIM_JUSTID, "__esModule", { value: true });
	const XCLAIM_1 = __importDefault(requireXCLAIM());
	/**
	 * Command variant for XCLAIM that returns only message IDs
	 */
	XCLAIM_JUSTID.default = {
	    IS_READ_ONLY: XCLAIM_1.default.IS_READ_ONLY,
	    /**
	     * Constructs the XCLAIM command with JUSTID option to get only message IDs
	     *
	     * @param args - Same parameters as XCLAIM command
	     * @returns Array of successfully claimed message IDs
	     * @see https://redis.io/commands/xclaim/
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        XCLAIM_1.default.parseCommand(...args);
	        parser.push('JUSTID');
	    },
	    /**
	     * Transforms the XCLAIM JUSTID reply into an array of message IDs
	     *
	     * @returns Array of claimed message IDs
	     */
	    transformReply: undefined
	};
	
	return XCLAIM_JUSTID;
}

var XDEL = {};

var hasRequiredXDEL;

function requireXDEL () {
	if (hasRequiredXDEL) return XDEL;
	hasRequiredXDEL = 1;
	Object.defineProperty(XDEL, "__esModule", { value: true });
	/**
	 * Command for removing messages from a stream
	 */
	XDEL.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XDEL command to remove one or more messages from a stream
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param id - One or more message IDs to delete
	     * @returns The number of messages actually deleted
	     * @see https://redis.io/commands/xdel/
	     */
	    parseCommand(parser, key, id) {
	        parser.push('XDEL');
	        parser.pushKey(key);
	        parser.pushVariadic(id);
	    },
	    transformReply: undefined
	};
	
	return XDEL;
}

var XGROUP_CREATE = {};

var hasRequiredXGROUP_CREATE;

function requireXGROUP_CREATE () {
	if (hasRequiredXGROUP_CREATE) return XGROUP_CREATE;
	hasRequiredXGROUP_CREATE = 1;
	Object.defineProperty(XGROUP_CREATE, "__esModule", { value: true });
	XGROUP_CREATE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XGROUP CREATE command to create a consumer group for a stream
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - Name of the consumer group
	     * @param id - ID of the last delivered item in the stream ('$' for last item, '0' for all items)
	     * @param options - Additional options for group creation
	     * @returns 'OK' if successful
	     * @see https://redis.io/commands/xgroup-create/
	     */
	    parseCommand(parser, key, group, id, options) {
	        parser.push('XGROUP', 'CREATE');
	        parser.pushKey(key);
	        parser.push(group, id);
	        if (options?.MKSTREAM) {
	            parser.push('MKSTREAM');
	        }
	        if (options?.ENTRIESREAD) {
	            parser.push('ENTRIESREAD', options.ENTRIESREAD.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return XGROUP_CREATE;
}

var XGROUP_CREATECONSUMER = {};

var hasRequiredXGROUP_CREATECONSUMER;

function requireXGROUP_CREATECONSUMER () {
	if (hasRequiredXGROUP_CREATECONSUMER) return XGROUP_CREATECONSUMER;
	hasRequiredXGROUP_CREATECONSUMER = 1;
	Object.defineProperty(XGROUP_CREATECONSUMER, "__esModule", { value: true });
	/**
	 * Command for creating a new consumer in a consumer group
	 */
	XGROUP_CREATECONSUMER.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XGROUP CREATECONSUMER command to create a new consumer in a consumer group
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - Name of the consumer group
	     * @param consumer - Name of the consumer to create
	     * @returns 1 if the consumer was created, 0 if it already existed
	     * @see https://redis.io/commands/xgroup-createconsumer/
	     */
	    parseCommand(parser, key, group, consumer) {
	        parser.push('XGROUP', 'CREATECONSUMER');
	        parser.pushKey(key);
	        parser.push(group, consumer);
	    },
	    transformReply: undefined
	};
	
	return XGROUP_CREATECONSUMER;
}

var XGROUP_DELCONSUMER = {};

var hasRequiredXGROUP_DELCONSUMER;

function requireXGROUP_DELCONSUMER () {
	if (hasRequiredXGROUP_DELCONSUMER) return XGROUP_DELCONSUMER;
	hasRequiredXGROUP_DELCONSUMER = 1;
	Object.defineProperty(XGROUP_DELCONSUMER, "__esModule", { value: true });
	/**
	 * Command for removing a consumer from a consumer group
	 */
	XGROUP_DELCONSUMER.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XGROUP DELCONSUMER command to remove a consumer from a consumer group
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - Name of the consumer group
	     * @param consumer - Name of the consumer to remove
	     * @returns The number of pending messages owned by the deleted consumer
	     * @see https://redis.io/commands/xgroup-delconsumer/
	     */
	    parseCommand(parser, key, group, consumer) {
	        parser.push('XGROUP', 'DELCONSUMER');
	        parser.pushKey(key);
	        parser.push(group, consumer);
	    },
	    transformReply: undefined
	};
	
	return XGROUP_DELCONSUMER;
}

var XGROUP_DESTROY = {};

var hasRequiredXGROUP_DESTROY;

function requireXGROUP_DESTROY () {
	if (hasRequiredXGROUP_DESTROY) return XGROUP_DESTROY;
	hasRequiredXGROUP_DESTROY = 1;
	Object.defineProperty(XGROUP_DESTROY, "__esModule", { value: true });
	/**
	 * Command for removing a consumer group
	 */
	XGROUP_DESTROY.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XGROUP DESTROY command to remove a consumer group
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - Name of the consumer group to destroy
	     * @returns 1 if the group was destroyed, 0 if it did not exist
	     * @see https://redis.io/commands/xgroup-destroy/
	     */
	    parseCommand(parser, key, group) {
	        parser.push('XGROUP', 'DESTROY');
	        parser.pushKey(key);
	        parser.push(group);
	    },
	    transformReply: undefined
	};
	
	return XGROUP_DESTROY;
}

var XGROUP_SETID = {};

var hasRequiredXGROUP_SETID;

function requireXGROUP_SETID () {
	if (hasRequiredXGROUP_SETID) return XGROUP_SETID;
	hasRequiredXGROUP_SETID = 1;
	Object.defineProperty(XGROUP_SETID, "__esModule", { value: true });
	XGROUP_SETID.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XGROUP SETID command to set the last delivered ID for a consumer group
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - Name of the consumer group
	     * @param id - ID to set as last delivered message ('$' for last item, '0' for all items)
	     * @param options - Additional options for setting the group ID
	     * @returns 'OK' if successful
	     * @see https://redis.io/commands/xgroup-setid/
	     */
	    parseCommand(parser, key, group, id, options) {
	        parser.push('XGROUP', 'SETID');
	        parser.pushKey(key);
	        parser.push(group, id);
	        if (options?.ENTRIESREAD) {
	            parser.push('ENTRIESREAD', options.ENTRIESREAD.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return XGROUP_SETID;
}

var XINFO_CONSUMERS = {};

var hasRequiredXINFO_CONSUMERS;

function requireXINFO_CONSUMERS () {
	if (hasRequiredXINFO_CONSUMERS) return XINFO_CONSUMERS;
	hasRequiredXINFO_CONSUMERS = 1;
	Object.defineProperty(XINFO_CONSUMERS, "__esModule", { value: true });
	XINFO_CONSUMERS.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the XINFO CONSUMERS command to list the consumers in a consumer group
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - Name of the consumer group
	     * @returns Array of consumer information objects
	     * @see https://redis.io/commands/xinfo-consumers/
	     */
	    parseCommand(parser, key, group) {
	        parser.push('XINFO', 'CONSUMERS');
	        parser.pushKey(key);
	        parser.push(group);
	    },
	    transformReply: {
	        /**
	         * Transforms RESP2 reply into a structured consumer information array
	         *
	         * @param reply - Raw RESP2 reply from Redis
	         * @returns Array of consumer information objects
	         */
	        2: (reply) => {
	            return reply.map(consumer => {
	                const unwrapped = consumer;
	                return {
	                    name: unwrapped[1],
	                    pending: unwrapped[3],
	                    idle: unwrapped[5],
	                    inactive: unwrapped[7]
	                };
	            });
	        },
	        3: undefined
	    }
	};
	
	return XINFO_CONSUMERS;
}

var XINFO_GROUPS = {};

var hasRequiredXINFO_GROUPS;

function requireXINFO_GROUPS () {
	if (hasRequiredXINFO_GROUPS) return XINFO_GROUPS;
	hasRequiredXINFO_GROUPS = 1;
	Object.defineProperty(XINFO_GROUPS, "__esModule", { value: true });
	XINFO_GROUPS.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the XINFO GROUPS command to list the consumer groups of a stream
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @returns Array of consumer group information objects
	     * @see https://redis.io/commands/xinfo-groups/
	     */
	    parseCommand(parser, key) {
	        parser.push('XINFO', 'GROUPS');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        /**
	         * Transforms RESP2 reply into a structured consumer group information array
	         *
	         * @param reply - Raw RESP2 reply from Redis
	         * @returns Array of consumer group information objects containing:
	         *          name - Name of the consumer group
	         *          consumers - Number of consumers in the group
	         *          pending - Number of pending messages for the group
	         *          last-delivered-id - ID of the last delivered message
	         *          entries-read - Number of entries read in the group (Redis 7.0+)
	         *          lag - Number of entries not read by the group (Redis 7.0+)
	         */
	        2: (reply) => {
	            return reply.map(group => {
	                const unwrapped = group;
	                return {
	                    name: unwrapped[1],
	                    consumers: unwrapped[3],
	                    pending: unwrapped[5],
	                    'last-delivered-id': unwrapped[7],
	                    'entries-read': unwrapped[9],
	                    lag: unwrapped[11]
	                };
	            });
	        },
	        3: undefined
	    }
	};
	
	return XINFO_GROUPS;
}

var XINFO_STREAM = {};

var hasRequiredXINFO_STREAM;

function requireXINFO_STREAM () {
	if (hasRequiredXINFO_STREAM) return XINFO_STREAM;
	hasRequiredXINFO_STREAM = 1;
	Object.defineProperty(XINFO_STREAM, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	XINFO_STREAM.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the XINFO STREAM command to get detailed information about a stream
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @returns Detailed information about the stream including its length, structure, and entries
	     * @see https://redis.io/commands/xinfo-stream/
	     */
	    parseCommand(parser, key) {
	        parser.push('XINFO', 'STREAM');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        // TODO: is there a "type safe" way to do it?
	        2(reply) {
	            const parsedReply = {};
	            for (let i = 0; i < reply.length; i += 2) {
	                switch (reply[i]) {
	                    case 'first-entry':
	                    case 'last-entry':
	                        parsedReply[reply[i]] = transformEntry(reply[i + 1]);
	                        break;
	                    default:
	                        parsedReply[reply[i]] = reply[i + 1];
	                        break;
	                }
	            }
	            return parsedReply;
	        },
	        3(reply) {
	            if (reply instanceof Map) {
	                reply.set('first-entry', transformEntry(reply.get('first-entry')));
	                reply.set('last-entry', transformEntry(reply.get('last-entry')));
	            }
	            else if (reply instanceof Array) {
	                reply[17] = transformEntry(reply[17]);
	                reply[19] = transformEntry(reply[19]);
	            }
	            else {
	                reply['first-entry'] = transformEntry(reply['first-entry']);
	                reply['last-entry'] = transformEntry(reply['last-entry']);
	            }
	            return reply;
	        }
	    }
	};
	/**
	 * Transforms a raw stream entry into a structured object
	 *
	 * @param entry - Raw entry from Redis
	 * @returns Structured object with id and message, or null if entry is null
	 */
	function transformEntry(entry) {
	    if ((0, generic_transformers_1.isNullReply)(entry))
	        return entry;
	    const [id, message] = entry;
	    return {
	        id,
	        message: (0, generic_transformers_1.transformTuplesReply)(message)
	    };
	}
	
	return XINFO_STREAM;
}

var XLEN = {};

var hasRequiredXLEN;

function requireXLEN () {
	if (hasRequiredXLEN) return XLEN;
	hasRequiredXLEN = 1;
	Object.defineProperty(XLEN, "__esModule", { value: true });
	/**
	 * Command for getting the length of a stream
	 */
	XLEN.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the XLEN command to get the number of entries in a stream
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @returns The number of entries inside the stream
	     * @see https://redis.io/commands/xlen/
	     */
	    parseCommand(parser, key) {
	        parser.push('XLEN');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return XLEN;
}

var XPENDING_RANGE = {};

var hasRequiredXPENDING_RANGE;

function requireXPENDING_RANGE () {
	if (hasRequiredXPENDING_RANGE) return XPENDING_RANGE;
	hasRequiredXPENDING_RANGE = 1;
	Object.defineProperty(XPENDING_RANGE, "__esModule", { value: true });
	XPENDING_RANGE.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the XPENDING command with range parameters to get detailed information about pending messages
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - Name of the consumer group
	     * @param start - Start of ID range (use '-' for minimum ID)
	     * @param end - End of ID range (use '+' for maximum ID)
	     * @param count - Maximum number of messages to return
	     * @param options - Additional filtering options
	     * @returns Array of pending message details
	     * @see https://redis.io/commands/xpending/
	     */
	    parseCommand(parser, key, group, start, end, count, options) {
	        parser.push('XPENDING');
	        parser.pushKey(key);
	        parser.push(group);
	        if (options?.IDLE !== undefined) {
	            parser.push('IDLE', options.IDLE.toString());
	        }
	        parser.push(start, end, count.toString());
	        if (options?.consumer) {
	            parser.push(options.consumer);
	        }
	    },
	    /**
	     * Transforms the raw XPENDING RANGE reply into a structured array of message details
	     *
	     * @param reply - Raw reply from Redis
	     * @returns Array of objects containing message ID, consumer, idle time, and delivery count
	     */
	    transformReply(reply) {
	        return reply.map(pending => {
	            const unwrapped = pending;
	            return {
	                id: unwrapped[0],
	                consumer: unwrapped[1],
	                millisecondsSinceLastDelivery: unwrapped[2],
	                deliveriesCounter: unwrapped[3]
	            };
	        });
	    }
	};
	
	return XPENDING_RANGE;
}

var XPENDING = {};

var hasRequiredXPENDING;

function requireXPENDING () {
	if (hasRequiredXPENDING) return XPENDING;
	hasRequiredXPENDING = 1;
	Object.defineProperty(XPENDING, "__esModule", { value: true });
	XPENDING.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the XPENDING command to inspect pending messages of a consumer group
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param group - Name of the consumer group
	     * @returns Summary of pending messages including total count, ID range, and per-consumer stats
	     * @see https://redis.io/commands/xpending/
	     */
	    parseCommand(parser, key, group) {
	        parser.push('XPENDING');
	        parser.pushKey(key);
	        parser.push(group);
	    },
	    /**
	     * Transforms the raw XPENDING reply into a structured object
	     *
	     * @param reply - Raw reply from Redis
	     * @returns Object containing pending count, ID range, and consumer statistics
	     */
	    transformReply(reply) {
	        const consumers = reply[3];
	        return {
	            pending: reply[0],
	            firstId: reply[1],
	            lastId: reply[2],
	            consumers: consumers === null ? null : consumers.map(consumer => {
	                const [name, deliveriesCounter] = consumer;
	                return {
	                    name,
	                    deliveriesCounter: Number(deliveriesCounter)
	                };
	            })
	        };
	    }
	};
	
	return XPENDING;
}

var XRANGE = {};

var hasRequiredXRANGE;

function requireXRANGE () {
	if (hasRequiredXRANGE) return XRANGE;
	hasRequiredXRANGE = 1;
	Object.defineProperty(XRANGE, "__esModule", { value: true });
	XRANGE.xRangeArguments = void 0;
	const generic_transformers_1 = requireGenericTransformers();
	/**
	 * Helper function to build XRANGE command arguments
	 *
	 * @param start - Start of ID range (use '-' for minimum ID)
	 * @param end - End of ID range (use '+' for maximum ID)
	 * @param options - Additional options for the range query
	 * @returns Array of arguments for the XRANGE command
	 */
	function xRangeArguments(start, end, options) {
	    const args = [start, end];
	    if (options?.COUNT) {
	        args.push('COUNT', options.COUNT.toString());
	    }
	    return args;
	}
	XRANGE.xRangeArguments = xRangeArguments;
	XRANGE.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the XRANGE command to read stream entries in a specific range
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param args - Arguments tuple containing start ID, end ID, and options
	     * @returns Array of messages in the specified range
	     * @see https://redis.io/commands/xrange/
	     */
	    parseCommand(parser, key, ...args) {
	        parser.push('XRANGE');
	        parser.pushKey(key);
	        parser.pushVariadic(xRangeArguments(args[0], args[1], args[2]));
	    },
	    /**
	     * Transforms the raw XRANGE reply into structured message objects
	     *
	     * @param reply - Raw reply from Redis
	     * @param preserve - Preserve options (unused)
	     * @param typeMapping - Type mapping for message fields
	     * @returns Array of structured message objects
	     */
	    transformReply(reply, preserve, typeMapping) {
	        return reply.map(generic_transformers_1.transformStreamMessageReply.bind(undefined, typeMapping));
	    }
	};
	
	return XRANGE;
}

var XREAD = {};

var hasRequiredXREAD;

function requireXREAD () {
	if (hasRequiredXREAD) return XREAD;
	hasRequiredXREAD = 1;
	Object.defineProperty(XREAD, "__esModule", { value: true });
	XREAD.pushXReadStreams = void 0;
	const generic_transformers_1 = requireGenericTransformers();
	/**
	 * Helper function to push stream keys and IDs to the command parser
	 *
	 * @param parser - The command parser
	 * @param streams - Single stream or array of streams to read from
	 */
	function pushXReadStreams(parser, streams) {
	    parser.push('STREAMS');
	    if (Array.isArray(streams)) {
	        for (let i = 0; i < streams.length; i++) {
	            parser.pushKey(streams[i].key);
	        }
	        for (let i = 0; i < streams.length; i++) {
	            parser.push(streams[i].id);
	        }
	    }
	    else {
	        parser.pushKey(streams.key);
	        parser.push(streams.id);
	    }
	}
	XREAD.pushXReadStreams = pushXReadStreams;
	XREAD.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the XREAD command to read messages from one or more streams
	     *
	     * @param parser - The command parser
	     * @param streams - Single stream or array of streams to read from
	     * @param options - Additional options for reading streams
	     * @returns Array of stream entries, each containing the stream name and its messages
	     * @see https://redis.io/commands/xread/
	     */
	    parseCommand(parser, streams, options) {
	        parser.push('XREAD');
	        if (options?.COUNT) {
	            parser.push('COUNT', options.COUNT.toString());
	        }
	        if (options?.BLOCK !== undefined) {
	            parser.push('BLOCK', options.BLOCK.toString());
	        }
	        pushXReadStreams(parser, streams);
	    },
	    /**
	     * Transform functions for different RESP versions
	     */
	    transformReply: {
	        2: generic_transformers_1.transformStreamsMessagesReplyResp2,
	        3: undefined
	    },
	    unstableResp3: true
	};
	
	return XREAD;
}

var XREADGROUP = {};

var hasRequiredXREADGROUP;

function requireXREADGROUP () {
	if (hasRequiredXREADGROUP) return XREADGROUP;
	hasRequiredXREADGROUP = 1;
	Object.defineProperty(XREADGROUP, "__esModule", { value: true });
	const XREAD_1 = requireXREAD();
	const generic_transformers_1 = requireGenericTransformers();
	XREADGROUP.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the XREADGROUP command to read messages from streams as a consumer group member
	     *
	     * @param parser - The command parser
	     * @param group - Name of the consumer group
	     * @param consumer - Name of the consumer in the group
	     * @param streams - Single stream or array of streams to read from
	     * @param options - Additional options for reading streams
	     * @returns Array of stream entries, each containing the stream name and its messages
	     * @see https://redis.io/commands/xreadgroup/
	     */
	    parseCommand(parser, group, consumer, streams, options) {
	        parser.push('XREADGROUP', 'GROUP', group, consumer);
	        if (options?.COUNT !== undefined) {
	            parser.push('COUNT', options.COUNT.toString());
	        }
	        if (options?.BLOCK !== undefined) {
	            parser.push('BLOCK', options.BLOCK.toString());
	        }
	        if (options?.NOACK) {
	            parser.push('NOACK');
	        }
	        (0, XREAD_1.pushXReadStreams)(parser, streams);
	    },
	    /**
	     * Transform functions for different RESP versions
	     */
	    transformReply: {
	        2: generic_transformers_1.transformStreamsMessagesReplyResp2,
	        3: undefined
	    },
	    unstableResp3: true,
	};
	
	return XREADGROUP;
}

var XREVRANGE = {};

var hasRequiredXREVRANGE;

function requireXREVRANGE () {
	if (hasRequiredXREVRANGE) return XREVRANGE;
	hasRequiredXREVRANGE = 1;
	var __createBinding = (XREVRANGE && XREVRANGE.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (XREVRANGE && XREVRANGE.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (XREVRANGE && XREVRANGE.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(XREVRANGE, "__esModule", { value: true });
	const XRANGE_1 = __importStar(requireXRANGE());
	/**
	 * Command for reading stream entries in reverse order
	 */
	XREVRANGE.default = {
	    CACHEABLE: XRANGE_1.default.CACHEABLE,
	    IS_READ_ONLY: XRANGE_1.default.IS_READ_ONLY,
	    /**
	     * Constructs the XREVRANGE command to read stream entries in reverse order
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param args - Arguments tuple containing start ID, end ID, and options
	     * @returns Array of messages in the specified range in reverse order
	     * @see https://redis.io/commands/xrevrange/
	     */
	    parseCommand(parser, key, ...args) {
	        parser.push('XREVRANGE');
	        parser.pushKey(key);
	        parser.pushVariadic((0, XRANGE_1.xRangeArguments)(args[0], args[1], args[2]));
	    },
	    transformReply: XRANGE_1.default.transformReply
	};
	
	return XREVRANGE;
}

var XSETID = {};

var hasRequiredXSETID;

function requireXSETID () {
	if (hasRequiredXSETID) return XSETID;
	hasRequiredXSETID = 1;
	Object.defineProperty(XSETID, "__esModule", { value: true });
	XSETID.default = {
	    IS_READ_ONLY: false,
	    parseCommand(parser, key, lastId, options) {
	        parser.push('XSETID');
	        parser.pushKey(key);
	        parser.push(lastId);
	        if (options?.ENTRIESADDED) {
	            parser.push('ENTRIESADDED', options.ENTRIESADDED.toString());
	        }
	        if (options?.MAXDELETEDID) {
	            parser.push('MAXDELETEDID', options.MAXDELETEDID);
	        }
	    },
	    transformReply: undefined
	};
	
	return XSETID;
}

var XTRIM = {};

var hasRequiredXTRIM;

function requireXTRIM () {
	if (hasRequiredXTRIM) return XTRIM;
	hasRequiredXTRIM = 1;
	Object.defineProperty(XTRIM, "__esModule", { value: true });
	/**
	 * Command for trimming a stream to a specified length or minimum ID
	 */
	XTRIM.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Constructs the XTRIM command to trim a stream by length or minimum ID
	     *
	     * @param parser - The command parser
	     * @param key - The stream key
	     * @param strategy - Trim by maximum length (MAXLEN) or minimum ID (MINID)
	     * @param threshold - Maximum length or minimum ID threshold
	     * @param options - Additional options for trimming
	     * @returns Number of entries removed from the stream
	     * @see https://redis.io/commands/xtrim/
	     */
	    parseCommand(parser, key, strategy, threshold, options) {
	        parser.push('XTRIM');
	        parser.pushKey(key);
	        parser.push(strategy);
	        if (options?.strategyModifier) {
	            parser.push(options.strategyModifier);
	        }
	        parser.push(threshold.toString());
	        if (options?.LIMIT) {
	            parser.push('LIMIT', options.LIMIT.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return XTRIM;
}

var ZADD_INCR = {};

var ZADD = {};

var hasRequiredZADD;

function requireZADD () {
	if (hasRequiredZADD) return ZADD;
	hasRequiredZADD = 1;
	Object.defineProperty(ZADD, "__esModule", { value: true });
	ZADD.pushMembers = void 0;
	const generic_transformers_1 = requireGenericTransformers();
	/**
	 * Command for adding members to a sorted set
	 */
	ZADD.default = {
	    /**
	     * Constructs the ZADD command to add one or more members to a sorted set
	     *
	     * @param parser - The command parser
	     * @param key - The sorted set key
	     * @param members - One or more members to add with their scores
	     * @param options - Additional options for adding members
	     * @returns Number of new members added (or changed members if CH is set)
	     * @see https://redis.io/commands/zadd/
	     */
	    parseCommand(parser, key, members, options) {
	        parser.push('ZADD');
	        parser.pushKey(key);
	        if (options?.condition) {
	            parser.push(options.condition);
	        }
	        else if (options?.NX) {
	            parser.push('NX');
	        }
	        else if (options?.XX) {
	            parser.push('XX');
	        }
	        if (options?.comparison) {
	            parser.push(options.comparison);
	        }
	        else if (options?.LT) {
	            parser.push('LT');
	        }
	        else if (options?.GT) {
	            parser.push('GT');
	        }
	        if (options?.CH) {
	            parser.push('CH');
	        }
	        pushMembers(parser, members);
	    },
	    transformReply: generic_transformers_1.transformDoubleReply
	};
	/**
	 * Helper function to push sorted set members to the command
	 *
	 * @param parser - The command parser
	 * @param members - One or more members with their scores
	 */
	function pushMembers(parser, members) {
	    if (Array.isArray(members)) {
	        for (const member of members) {
	            pushMember(parser, member);
	        }
	    }
	    else {
	        pushMember(parser, members);
	    }
	}
	ZADD.pushMembers = pushMembers;
	/**
	 * Helper function to push a single sorted set member to the command
	 *
	 * @param parser - The command parser
	 * @param member - Member with its score
	 */
	function pushMember(parser, member) {
	    parser.push((0, generic_transformers_1.transformDoubleArgument)(member.score), member.value);
	}
	
	return ZADD;
}

var hasRequiredZADD_INCR;

function requireZADD_INCR () {
	if (hasRequiredZADD_INCR) return ZADD_INCR;
	hasRequiredZADD_INCR = 1;
	Object.defineProperty(ZADD_INCR, "__esModule", { value: true });
	const ZADD_1 = requireZADD();
	const generic_transformers_1 = requireGenericTransformers();
	/**
	 * Command for incrementing the score of a member in a sorted set
	 */
	ZADD_INCR.default = {
	    /**
	     * Constructs the ZADD command with INCR option to increment the score of a member
	     *
	     * @param parser - The command parser
	     * @param key - The sorted set key
	     * @param members - Member(s) whose score to increment
	     * @param options - Additional options for the increment operation
	     * @returns The new score of the member after increment (null if member does not exist with XX option)
	     * @see https://redis.io/commands/zadd/
	     */
	    parseCommand(parser, key, members, options) {
	        parser.push('ZADD');
	        parser.pushKey(key);
	        if (options?.condition) {
	            parser.push(options.condition);
	        }
	        if (options?.comparison) {
	            parser.push(options.comparison);
	        }
	        if (options?.CH) {
	            parser.push('CH');
	        }
	        parser.push('INCR');
	        (0, ZADD_1.pushMembers)(parser, members);
	    },
	    transformReply: generic_transformers_1.transformNullableDoubleReply
	};
	
	return ZADD_INCR;
}

var ZCARD = {};

var hasRequiredZCARD;

function requireZCARD () {
	if (hasRequiredZCARD) return ZCARD;
	hasRequiredZCARD = 1;
	Object.defineProperty(ZCARD, "__esModule", { value: true });
	/**
	 * Command for getting the number of members in a sorted set
	 */
	ZCARD.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Constructs the ZCARD command to get the cardinality (number of members) of a sorted set
	     *
	     * @param parser - The command parser
	     * @param key - The sorted set key
	     * @returns Number of members in the sorted set
	     * @see https://redis.io/commands/zcard/
	     */
	    parseCommand(parser, key) {
	        parser.push('ZCARD');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return ZCARD;
}

var ZCOUNT = {};

var hasRequiredZCOUNT;

function requireZCOUNT () {
	if (hasRequiredZCOUNT) return ZCOUNT;
	hasRequiredZCOUNT = 1;
	Object.defineProperty(ZCOUNT, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZCOUNT.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the number of elements in the sorted set with a score between min and max.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param min - Minimum score to count from (inclusive).
	     * @param max - Maximum score to count to (inclusive).
	     */
	    parseCommand(parser, key, min, max) {
	        parser.push('ZCOUNT');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
	    },
	    transformReply: undefined
	};
	
	return ZCOUNT;
}

var ZDIFF_WITHSCORES = {};

var ZDIFF = {};

var hasRequiredZDIFF;

function requireZDIFF () {
	if (hasRequiredZDIFF) return ZDIFF;
	hasRequiredZDIFF = 1;
	Object.defineProperty(ZDIFF, "__esModule", { value: true });
	ZDIFF.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the difference between the first sorted set and all the successive sorted sets.
	     * @param parser - The Redis command parser.
	     * @param keys - Keys of the sorted sets.
	     */
	    parseCommand(parser, keys) {
	        parser.push('ZDIFF');
	        parser.pushKeysLength(keys);
	    },
	    transformReply: undefined
	};
	
	return ZDIFF;
}

var hasRequiredZDIFF_WITHSCORES;

function requireZDIFF_WITHSCORES () {
	if (hasRequiredZDIFF_WITHSCORES) return ZDIFF_WITHSCORES;
	hasRequiredZDIFF_WITHSCORES = 1;
	var __importDefault = (ZDIFF_WITHSCORES && ZDIFF_WITHSCORES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ZDIFF_WITHSCORES, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const ZDIFF_1 = __importDefault(requireZDIFF());
	ZDIFF_WITHSCORES.default = {
	    IS_READ_ONLY: ZDIFF_1.default.IS_READ_ONLY,
	    /**
	     * Returns the difference between the first sorted set and all successive sorted sets with their scores.
	     * @param parser - The Redis command parser.
	     * @param keys - Keys of the sorted sets.
	     */
	    parseCommand(parser, keys) {
	        ZDIFF_1.default.parseCommand(parser, keys);
	        parser.push('WITHSCORES');
	    },
	    transformReply: generic_transformers_1.transformSortedSetReply
	};
	
	return ZDIFF_WITHSCORES;
}

var ZDIFFSTORE = {};

var hasRequiredZDIFFSTORE;

function requireZDIFFSTORE () {
	if (hasRequiredZDIFFSTORE) return ZDIFFSTORE;
	hasRequiredZDIFFSTORE = 1;
	Object.defineProperty(ZDIFFSTORE, "__esModule", { value: true });
	ZDIFFSTORE.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Computes the difference between the first and all successive sorted sets and stores it in a new key.
	     * @param parser - The Redis command parser.
	     * @param destination - Destination key where the result will be stored.
	     * @param inputKeys - Keys of the sorted sets to find the difference between.
	     */
	    parseCommand(parser, destination, inputKeys) {
	        parser.push('ZDIFFSTORE');
	        parser.pushKey(destination);
	        parser.pushKeysLength(inputKeys);
	    },
	    transformReply: undefined
	};
	
	return ZDIFFSTORE;
}

var ZINCRBY = {};

var hasRequiredZINCRBY;

function requireZINCRBY () {
	if (hasRequiredZINCRBY) return ZINCRBY;
	hasRequiredZINCRBY = 1;
	Object.defineProperty(ZINCRBY, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZINCRBY.default = {
	    /**
	     * Increments the score of a member in a sorted set by the specified increment.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param increment - Value to increment the score by.
	     * @param member - Member whose score should be incremented.
	     */
	    parseCommand(parser, key, increment, member) {
	        parser.push('ZINCRBY');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformDoubleArgument)(increment), member);
	    },
	    transformReply: generic_transformers_1.transformDoubleReply
	};
	
	return ZINCRBY;
}

var ZINTER_WITHSCORES = {};

var ZINTER = {};

var hasRequiredZINTER;

function requireZINTER () {
	if (hasRequiredZINTER) return ZINTER;
	hasRequiredZINTER = 1;
	Object.defineProperty(ZINTER, "__esModule", { value: true });
	ZINTER.parseZInterArguments = void 0;
	const generic_transformers_1 = requireGenericTransformers();
	function parseZInterArguments(parser, keys, options) {
	    (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
	    if (options?.AGGREGATE) {
	        parser.push('AGGREGATE', options.AGGREGATE);
	    }
	}
	ZINTER.parseZInterArguments = parseZInterArguments;
	ZINTER.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Intersects multiple sorted sets and returns the result as a new sorted set.
	     * @param parser - The Redis command parser.
	     * @param keys - Keys of the sorted sets to intersect.
	     * @param options - Optional parameters for the intersection operation.
	     */
	    parseCommand(parser, keys, options) {
	        parser.push('ZINTER');
	        parseZInterArguments(parser, keys, options);
	    },
	    transformReply: undefined
	};
	
	return ZINTER;
}

var hasRequiredZINTER_WITHSCORES;

function requireZINTER_WITHSCORES () {
	if (hasRequiredZINTER_WITHSCORES) return ZINTER_WITHSCORES;
	hasRequiredZINTER_WITHSCORES = 1;
	var __importDefault = (ZINTER_WITHSCORES && ZINTER_WITHSCORES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ZINTER_WITHSCORES, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const ZINTER_1 = __importDefault(requireZINTER());
	ZINTER_WITHSCORES.default = {
	    IS_READ_ONLY: ZINTER_1.default.IS_READ_ONLY,
	    /**
	     * Intersects multiple sorted sets and returns the result with scores.
	     * @param args - Same parameters as ZINTER command.
	     */
	    parseCommand(...args) {
	        ZINTER_1.default.parseCommand(...args);
	        args[0].push('WITHSCORES');
	    },
	    transformReply: generic_transformers_1.transformSortedSetReply
	};
	
	return ZINTER_WITHSCORES;
}

var ZINTERCARD = {};

var hasRequiredZINTERCARD;

function requireZINTERCARD () {
	if (hasRequiredZINTERCARD) return ZINTERCARD;
	hasRequiredZINTERCARD = 1;
	Object.defineProperty(ZINTERCARD, "__esModule", { value: true });
	ZINTERCARD.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the cardinality of the intersection of multiple sorted sets.
	     * @param parser - The Redis command parser.
	     * @param keys - Keys of the sorted sets to intersect.
	     * @param options - Limit option or options object with limit.
	     */
	    parseCommand(parser, keys, options) {
	        parser.push('ZINTERCARD');
	        parser.pushKeysLength(keys);
	        // backwards compatibility
	        if (typeof options === 'number') {
	            parser.push('LIMIT', options.toString());
	        }
	        else if (options?.LIMIT) {
	            parser.push('LIMIT', options.LIMIT.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return ZINTERCARD;
}

var ZINTERSTORE = {};

var hasRequiredZINTERSTORE;

function requireZINTERSTORE () {
	if (hasRequiredZINTERSTORE) return ZINTERSTORE;
	hasRequiredZINTERSTORE = 1;
	Object.defineProperty(ZINTERSTORE, "__esModule", { value: true });
	const ZINTER_1 = requireZINTER();
	ZINTERSTORE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Stores the result of intersection of multiple sorted sets in a new sorted set.
	     * @param parser - The Redis command parser.
	     * @param destination - Destination key where the result will be stored.
	     * @param keys - Keys of the sorted sets to intersect.
	     * @param options - Optional parameters for the intersection operation.
	     */
	    parseCommand(parser, destination, keys, options) {
	        parser.push('ZINTERSTORE');
	        parser.pushKey(destination);
	        (0, ZINTER_1.parseZInterArguments)(parser, keys, options);
	    },
	    transformReply: undefined
	};
	
	return ZINTERSTORE;
}

var ZLEXCOUNT = {};

var hasRequiredZLEXCOUNT;

function requireZLEXCOUNT () {
	if (hasRequiredZLEXCOUNT) return ZLEXCOUNT;
	hasRequiredZLEXCOUNT = 1;
	Object.defineProperty(ZLEXCOUNT, "__esModule", { value: true });
	ZLEXCOUNT.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the number of elements in the sorted set between the lexicographical range specified by min and max.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param min - Minimum lexicographical value (inclusive).
	     * @param max - Maximum lexicographical value (inclusive).
	     */
	    parseCommand(parser, key, min, max) {
	        parser.push('ZLEXCOUNT');
	        parser.pushKey(key);
	        parser.push(min);
	        parser.push(max);
	    },
	    transformReply: undefined
	};
	
	return ZLEXCOUNT;
}

var ZMSCORE = {};

var hasRequiredZMSCORE;

function requireZMSCORE () {
	if (hasRequiredZMSCORE) return ZMSCORE;
	hasRequiredZMSCORE = 1;
	Object.defineProperty(ZMSCORE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZMSCORE.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the scores associated with the specified members in the sorted set stored at key.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param member - One or more members to get scores for.
	     */
	    parseCommand(parser, key, member) {
	        parser.push('ZMSCORE');
	        parser.pushKey(key);
	        parser.pushVariadic(member);
	    },
	    transformReply: {
	        2: (reply, preserve, typeMapping) => {
	            return reply.map((0, generic_transformers_1.createTransformNullableDoubleReplyResp2Func)(preserve, typeMapping));
	        },
	        3: undefined
	    }
	};
	
	return ZMSCORE;
}

var ZPOPMAX_COUNT = {};

var hasRequiredZPOPMAX_COUNT;

function requireZPOPMAX_COUNT () {
	if (hasRequiredZPOPMAX_COUNT) return ZPOPMAX_COUNT;
	hasRequiredZPOPMAX_COUNT = 1;
	Object.defineProperty(ZPOPMAX_COUNT, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZPOPMAX_COUNT.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes and returns up to count members with the highest scores in the sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param count - Number of members to pop.
	     */
	    parseCommand(parser, key, count) {
	        parser.push('ZPOPMAX');
	        parser.pushKey(key);
	        parser.push(count.toString());
	    },
	    transformReply: generic_transformers_1.transformSortedSetReply
	};
	
	return ZPOPMAX_COUNT;
}

var ZPOPMAX = {};

var hasRequiredZPOPMAX;

function requireZPOPMAX () {
	if (hasRequiredZPOPMAX) return ZPOPMAX;
	hasRequiredZPOPMAX = 1;
	Object.defineProperty(ZPOPMAX, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZPOPMAX.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes and returns the member with the highest score in the sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     */
	    parseCommand(parser, key) {
	        parser.push('ZPOPMAX');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        2: (reply, preserve, typeMapping) => {
	            if (reply.length === 0)
	                return null;
	            return {
	                value: reply[0],
	                score: generic_transformers_1.transformDoubleReply[2](reply[1], preserve, typeMapping),
	            };
	        },
	        3: (reply) => {
	            if (reply.length === 0)
	                return null;
	            return {
	                value: reply[0],
	                score: reply[1]
	            };
	        }
	    }
	};
	
	return ZPOPMAX;
}

var ZPOPMIN_COUNT = {};

var hasRequiredZPOPMIN_COUNT;

function requireZPOPMIN_COUNT () {
	if (hasRequiredZPOPMIN_COUNT) return ZPOPMIN_COUNT;
	hasRequiredZPOPMIN_COUNT = 1;
	Object.defineProperty(ZPOPMIN_COUNT, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZPOPMIN_COUNT.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes and returns up to count members with the lowest scores in the sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param count - Number of members to pop.
	     */
	    parseCommand(parser, key, count) {
	        parser.push('ZPOPMIN');
	        parser.pushKey(key);
	        parser.push(count.toString());
	    },
	    transformReply: generic_transformers_1.transformSortedSetReply
	};
	
	return ZPOPMIN_COUNT;
}

var ZPOPMIN = {};

var hasRequiredZPOPMIN;

function requireZPOPMIN () {
	if (hasRequiredZPOPMIN) return ZPOPMIN;
	hasRequiredZPOPMIN = 1;
	var __importDefault = (ZPOPMIN && ZPOPMIN.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ZPOPMIN, "__esModule", { value: true });
	const ZPOPMAX_1 = __importDefault(requireZPOPMAX());
	ZPOPMIN.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes and returns the member with the lowest score in the sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     */
	    parseCommand(parser, key) {
	        parser.push('ZPOPMIN');
	        parser.pushKey(key);
	    },
	    transformReply: ZPOPMAX_1.default.transformReply
	};
	
	return ZPOPMIN;
}

var ZRANDMEMBER_COUNT_WITHSCORES = {};

var ZRANDMEMBER_COUNT = {};

var ZRANDMEMBER = {};

var hasRequiredZRANDMEMBER;

function requireZRANDMEMBER () {
	if (hasRequiredZRANDMEMBER) return ZRANDMEMBER;
	hasRequiredZRANDMEMBER = 1;
	Object.defineProperty(ZRANDMEMBER, "__esModule", { value: true });
	ZRANDMEMBER.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns a random member from a sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     */
	    parseCommand(parser, key) {
	        parser.push('ZRANDMEMBER');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return ZRANDMEMBER;
}

var hasRequiredZRANDMEMBER_COUNT;

function requireZRANDMEMBER_COUNT () {
	if (hasRequiredZRANDMEMBER_COUNT) return ZRANDMEMBER_COUNT;
	hasRequiredZRANDMEMBER_COUNT = 1;
	var __importDefault = (ZRANDMEMBER_COUNT && ZRANDMEMBER_COUNT.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ZRANDMEMBER_COUNT, "__esModule", { value: true });
	const ZRANDMEMBER_1 = __importDefault(requireZRANDMEMBER());
	ZRANDMEMBER_COUNT.default = {
	    IS_READ_ONLY: ZRANDMEMBER_1.default.IS_READ_ONLY,
	    /**
	     * Returns one or more random members from a sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param count - Number of members to return.
	     */
	    parseCommand(parser, key, count) {
	        ZRANDMEMBER_1.default.parseCommand(parser, key);
	        parser.push(count.toString());
	    },
	    transformReply: undefined
	};
	
	return ZRANDMEMBER_COUNT;
}

var hasRequiredZRANDMEMBER_COUNT_WITHSCORES;

function requireZRANDMEMBER_COUNT_WITHSCORES () {
	if (hasRequiredZRANDMEMBER_COUNT_WITHSCORES) return ZRANDMEMBER_COUNT_WITHSCORES;
	hasRequiredZRANDMEMBER_COUNT_WITHSCORES = 1;
	var __importDefault = (ZRANDMEMBER_COUNT_WITHSCORES && ZRANDMEMBER_COUNT_WITHSCORES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ZRANDMEMBER_COUNT_WITHSCORES, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const ZRANDMEMBER_COUNT_1 = __importDefault(requireZRANDMEMBER_COUNT());
	ZRANDMEMBER_COUNT_WITHSCORES.default = {
	    IS_READ_ONLY: ZRANDMEMBER_COUNT_1.default.IS_READ_ONLY,
	    /**
	     * Returns one or more random members with their scores from a sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param count - Number of members to return.
	     */
	    parseCommand(parser, key, count) {
	        ZRANDMEMBER_COUNT_1.default.parseCommand(parser, key, count);
	        parser.push('WITHSCORES');
	    },
	    transformReply: generic_transformers_1.transformSortedSetReply
	};
	
	return ZRANDMEMBER_COUNT_WITHSCORES;
}

var ZRANGE_WITHSCORES = {};

var ZRANGE = {};

var hasRequiredZRANGE;

function requireZRANGE () {
	if (hasRequiredZRANGE) return ZRANGE;
	hasRequiredZRANGE = 1;
	Object.defineProperty(ZRANGE, "__esModule", { value: true });
	ZRANGE.zRangeArgument = void 0;
	const generic_transformers_1 = requireGenericTransformers();
	function zRangeArgument(min, max, options) {
	    const args = [
	        (0, generic_transformers_1.transformStringDoubleArgument)(min),
	        (0, generic_transformers_1.transformStringDoubleArgument)(max)
	    ];
	    switch (options?.BY) {
	        case 'SCORE':
	            args.push('BYSCORE');
	            break;
	        case 'LEX':
	            args.push('BYLEX');
	            break;
	    }
	    if (options?.REV) {
	        args.push('REV');
	    }
	    if (options?.LIMIT) {
	        args.push('LIMIT', options.LIMIT.offset.toString(), options.LIMIT.count.toString());
	    }
	    return args;
	}
	ZRANGE.zRangeArgument = zRangeArgument;
	ZRANGE.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the specified range of elements in the sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param min - Minimum index, score or lexicographical value.
	     * @param max - Maximum index, score or lexicographical value.
	     * @param options - Optional parameters for range retrieval (BY, REV, LIMIT).
	     */
	    parseCommand(parser, key, min, max, options) {
	        parser.push('ZRANGE');
	        parser.pushKey(key);
	        parser.pushVariadic(zRangeArgument(min, max, options));
	    },
	    transformReply: undefined
	};
	
	return ZRANGE;
}

var hasRequiredZRANGE_WITHSCORES;

function requireZRANGE_WITHSCORES () {
	if (hasRequiredZRANGE_WITHSCORES) return ZRANGE_WITHSCORES;
	hasRequiredZRANGE_WITHSCORES = 1;
	var __importDefault = (ZRANGE_WITHSCORES && ZRANGE_WITHSCORES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ZRANGE_WITHSCORES, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const ZRANGE_1 = __importDefault(requireZRANGE());
	ZRANGE_WITHSCORES.default = {
	    CACHEABLE: ZRANGE_1.default.CACHEABLE,
	    IS_READ_ONLY: ZRANGE_1.default.IS_READ_ONLY,
	    /**
	     * Returns the specified range of elements in the sorted set with their scores.
	     * @param args - Same parameters as the ZRANGE command.
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        ZRANGE_1.default.parseCommand(...args);
	        parser.push('WITHSCORES');
	    },
	    transformReply: generic_transformers_1.transformSortedSetReply
	};
	
	return ZRANGE_WITHSCORES;
}

var ZRANGEBYLEX = {};

var hasRequiredZRANGEBYLEX;

function requireZRANGEBYLEX () {
	if (hasRequiredZRANGEBYLEX) return ZRANGEBYLEX;
	hasRequiredZRANGEBYLEX = 1;
	Object.defineProperty(ZRANGEBYLEX, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZRANGEBYLEX.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns all the elements in the sorted set at key with a lexicographical value between min and max.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param min - Minimum lexicographical value.
	     * @param max - Maximum lexicographical value.
	     * @param options - Optional parameters including LIMIT.
	     */
	    parseCommand(parser, key, min, max, options) {
	        parser.push('ZRANGEBYLEX');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
	        if (options?.LIMIT) {
	            parser.push('LIMIT', options.LIMIT.offset.toString(), options.LIMIT.count.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return ZRANGEBYLEX;
}

var ZRANGEBYSCORE_WITHSCORES = {};

var ZRANGEBYSCORE = {};

var hasRequiredZRANGEBYSCORE;

function requireZRANGEBYSCORE () {
	if (hasRequiredZRANGEBYSCORE) return ZRANGEBYSCORE;
	hasRequiredZRANGEBYSCORE = 1;
	Object.defineProperty(ZRANGEBYSCORE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZRANGEBYSCORE.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns all the elements in the sorted set with a score between min and max.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param min - Minimum score.
	     * @param max - Maximum score.
	     * @param options - Optional parameters including LIMIT.
	     */
	    parseCommand(parser, key, min, max, options) {
	        parser.push('ZRANGEBYSCORE');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
	        if (options?.LIMIT) {
	            parser.push('LIMIT', options.LIMIT.offset.toString(), options.LIMIT.count.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return ZRANGEBYSCORE;
}

var hasRequiredZRANGEBYSCORE_WITHSCORES;

function requireZRANGEBYSCORE_WITHSCORES () {
	if (hasRequiredZRANGEBYSCORE_WITHSCORES) return ZRANGEBYSCORE_WITHSCORES;
	hasRequiredZRANGEBYSCORE_WITHSCORES = 1;
	var __importDefault = (ZRANGEBYSCORE_WITHSCORES && ZRANGEBYSCORE_WITHSCORES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ZRANGEBYSCORE_WITHSCORES, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const ZRANGEBYSCORE_1 = __importDefault(requireZRANGEBYSCORE());
	ZRANGEBYSCORE_WITHSCORES.default = {
	    CACHEABLE: ZRANGEBYSCORE_1.default.CACHEABLE,
	    IS_READ_ONLY: ZRANGEBYSCORE_1.default.IS_READ_ONLY,
	    /**
	     * Returns all the elements in the sorted set with a score between min and max, with their scores.
	     * @param args - Same parameters as the ZRANGEBYSCORE command.
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        ZRANGEBYSCORE_1.default.parseCommand(...args);
	        parser.push('WITHSCORES');
	    },
	    transformReply: generic_transformers_1.transformSortedSetReply
	};
	
	return ZRANGEBYSCORE_WITHSCORES;
}

var ZRANGESTORE = {};

var hasRequiredZRANGESTORE;

function requireZRANGESTORE () {
	if (hasRequiredZRANGESTORE) return ZRANGESTORE;
	hasRequiredZRANGESTORE = 1;
	Object.defineProperty(ZRANGESTORE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZRANGESTORE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Stores the result of a range operation on a sorted set into a new sorted set.
	     * @param parser - The Redis command parser.
	     * @param destination - Destination key where the result will be stored.
	     * @param source - Key of the source sorted set.
	     * @param min - Minimum index, score or lexicographical value.
	     * @param max - Maximum index, score or lexicographical value.
	     * @param options - Optional parameters for the range operation (BY, REV, LIMIT).
	     */
	    parseCommand(parser, destination, source, min, max, options) {
	        parser.push('ZRANGESTORE');
	        parser.pushKey(destination);
	        parser.pushKey(source);
	        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
	        switch (options?.BY) {
	            case 'SCORE':
	                parser.push('BYSCORE');
	                break;
	            case 'LEX':
	                parser.push('BYLEX');
	                break;
	        }
	        if (options?.REV) {
	            parser.push('REV');
	        }
	        if (options?.LIMIT) {
	            parser.push('LIMIT', options.LIMIT.offset.toString(), options.LIMIT.count.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return ZRANGESTORE;
}

var ZREMRANGEBYSCORE = {};

var hasRequiredZREMRANGEBYSCORE;

function requireZREMRANGEBYSCORE () {
	if (hasRequiredZREMRANGEBYSCORE) return ZREMRANGEBYSCORE;
	hasRequiredZREMRANGEBYSCORE = 1;
	Object.defineProperty(ZREMRANGEBYSCORE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZREMRANGEBYSCORE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes all elements in the sorted set with scores between min and max.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param min - Minimum score.
	     * @param max - Maximum score.
	     */
	    parseCommand(parser, key, min, max) {
	        parser.push('ZREMRANGEBYSCORE');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
	    },
	    transformReply: undefined
	};
	
	return ZREMRANGEBYSCORE;
}

var ZRANK_WITHSCORE = {};

var ZRANK = {};

var hasRequiredZRANK;

function requireZRANK () {
	if (hasRequiredZRANK) return ZRANK;
	hasRequiredZRANK = 1;
	Object.defineProperty(ZRANK, "__esModule", { value: true });
	ZRANK.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the rank of a member in the sorted set, with scores ordered from low to high.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param member - Member to get the rank for.
	     */
	    parseCommand(parser, key, member) {
	        parser.push('ZRANK');
	        parser.pushKey(key);
	        parser.push(member);
	    },
	    transformReply: undefined
	};
	
	return ZRANK;
}

var hasRequiredZRANK_WITHSCORE;

function requireZRANK_WITHSCORE () {
	if (hasRequiredZRANK_WITHSCORE) return ZRANK_WITHSCORE;
	hasRequiredZRANK_WITHSCORE = 1;
	var __importDefault = (ZRANK_WITHSCORE && ZRANK_WITHSCORE.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ZRANK_WITHSCORE, "__esModule", { value: true });
	const ZRANK_1 = __importDefault(requireZRANK());
	ZRANK_WITHSCORE.default = {
	    CACHEABLE: ZRANK_1.default.CACHEABLE,
	    IS_READ_ONLY: ZRANK_1.default.IS_READ_ONLY,
	    /**
	     * Returns the rank of a member in the sorted set with its score.
	     * @param args - Same parameters as the ZRANK command.
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        ZRANK_1.default.parseCommand(...args);
	        parser.push('WITHSCORE');
	    },
	    transformReply: {
	        2: (reply) => {
	            if (reply === null)
	                return null;
	            return {
	                rank: reply[0],
	                score: Number(reply[1])
	            };
	        },
	        3: (reply) => {
	            if (reply === null)
	                return null;
	            return {
	                rank: reply[0],
	                score: reply[1]
	            };
	        }
	    }
	};
	
	return ZRANK_WITHSCORE;
}

var ZREM = {};

var hasRequiredZREM;

function requireZREM () {
	if (hasRequiredZREM) return ZREM;
	hasRequiredZREM = 1;
	Object.defineProperty(ZREM, "__esModule", { value: true });
	ZREM.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes the specified members from the sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param member - One or more members to remove.
	     */
	    parseCommand(parser, key, member) {
	        parser.push('ZREM');
	        parser.pushKey(key);
	        parser.pushVariadic(member);
	    },
	    transformReply: undefined
	};
	
	return ZREM;
}

var ZREMRANGEBYLEX = {};

var hasRequiredZREMRANGEBYLEX;

function requireZREMRANGEBYLEX () {
	if (hasRequiredZREMRANGEBYLEX) return ZREMRANGEBYLEX;
	hasRequiredZREMRANGEBYLEX = 1;
	Object.defineProperty(ZREMRANGEBYLEX, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZREMRANGEBYLEX.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes all elements in the sorted set with lexicographical values between min and max.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param min - Minimum lexicographical value.
	     * @param max - Maximum lexicographical value.
	     */
	    parseCommand(parser, key, min, max) {
	        parser.push('ZREMRANGEBYLEX');
	        parser.pushKey(key);
	        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
	    },
	    transformReply: undefined
	};
	
	return ZREMRANGEBYLEX;
}

var ZREMRANGEBYRANK = {};

var hasRequiredZREMRANGEBYRANK;

function requireZREMRANGEBYRANK () {
	if (hasRequiredZREMRANGEBYRANK) return ZREMRANGEBYRANK;
	hasRequiredZREMRANGEBYRANK = 1;
	Object.defineProperty(ZREMRANGEBYRANK, "__esModule", { value: true });
	ZREMRANGEBYRANK.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes all elements in the sorted set with rank between start and stop.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param start - Minimum rank (starting from 0).
	     * @param stop - Maximum rank.
	     */
	    parseCommand(parser, key, start, stop) {
	        parser.push('ZREMRANGEBYRANK');
	        parser.pushKey(key);
	        parser.push(start.toString(), stop.toString());
	    },
	    transformReply: undefined
	};
	
	return ZREMRANGEBYRANK;
}

var ZREVRANK = {};

var hasRequiredZREVRANK;

function requireZREVRANK () {
	if (hasRequiredZREVRANK) return ZREVRANK;
	hasRequiredZREVRANK = 1;
	Object.defineProperty(ZREVRANK, "__esModule", { value: true });
	ZREVRANK.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the rank of a member in the sorted set, with scores ordered from high to low.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param member - Member to get the rank for.
	     */
	    parseCommand(parser, key, member) {
	        parser.push('ZREVRANK');
	        parser.pushKey(key);
	        parser.push(member);
	    },
	    transformReply: undefined
	};
	
	return ZREVRANK;
}

var ZSCAN = {};

var hasRequiredZSCAN;

function requireZSCAN () {
	if (hasRequiredZSCAN) return ZSCAN;
	hasRequiredZSCAN = 1;
	Object.defineProperty(ZSCAN, "__esModule", { value: true });
	const SCAN_1 = requireSCAN();
	const generic_transformers_1 = requireGenericTransformers();
	ZSCAN.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Incrementally iterates over a sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param cursor - Cursor position to start the scan from.
	     * @param options - Optional scan parameters (COUNT, MATCH, TYPE).
	     */
	    parseCommand(parser, key, cursor, options) {
	        parser.push('ZSCAN');
	        parser.pushKey(key);
	        (0, SCAN_1.parseScanArguments)(parser, cursor, options);
	    },
	    transformReply([cursor, rawMembers]) {
	        return {
	            cursor,
	            members: generic_transformers_1.transformSortedSetReply[2](rawMembers)
	        };
	    }
	};
	
	return ZSCAN;
}

var ZSCORE = {};

var hasRequiredZSCORE;

function requireZSCORE () {
	if (hasRequiredZSCORE) return ZSCORE;
	hasRequiredZSCORE = 1;
	Object.defineProperty(ZSCORE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZSCORE.default = {
	    CACHEABLE: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the score of a member in a sorted set.
	     * @param parser - The Redis command parser.
	     * @param key - Key of the sorted set.
	     * @param member - Member to get the score for.
	     */
	    parseCommand(parser, key, member) {
	        parser.push('ZSCORE');
	        parser.pushKey(key);
	        parser.push(member);
	    },
	    transformReply: generic_transformers_1.transformNullableDoubleReply
	};
	
	return ZSCORE;
}

var ZUNION_WITHSCORES = {};

var ZUNION = {};

var hasRequiredZUNION;

function requireZUNION () {
	if (hasRequiredZUNION) return ZUNION;
	hasRequiredZUNION = 1;
	Object.defineProperty(ZUNION, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZUNION.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the union of multiple sorted sets.
	     * @param parser - The Redis command parser.
	     * @param keys - Keys of the sorted sets to combine.
	     * @param options - Optional parameters for the union operation.
	     */
	    parseCommand(parser, keys, options) {
	        parser.push('ZUNION');
	        (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
	        if (options?.AGGREGATE) {
	            parser.push('AGGREGATE', options.AGGREGATE);
	        }
	    },
	    transformReply: undefined
	};
	
	return ZUNION;
}

var hasRequiredZUNION_WITHSCORES;

function requireZUNION_WITHSCORES () {
	if (hasRequiredZUNION_WITHSCORES) return ZUNION_WITHSCORES;
	hasRequiredZUNION_WITHSCORES = 1;
	var __importDefault = (ZUNION_WITHSCORES && ZUNION_WITHSCORES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ZUNION_WITHSCORES, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const ZUNION_1 = __importDefault(requireZUNION());
	ZUNION_WITHSCORES.default = {
	    IS_READ_ONLY: ZUNION_1.default.IS_READ_ONLY,
	    /**
	     * Returns the union of multiple sorted sets with their scores.
	     * @param args - Same parameters as the ZUNION command.
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        ZUNION_1.default.parseCommand(...args);
	        parser.push('WITHSCORES');
	    },
	    transformReply: generic_transformers_1.transformSortedSetReply
	};
	
	return ZUNION_WITHSCORES;
}

var ZUNIONSTORE = {};

var hasRequiredZUNIONSTORE;

function requireZUNIONSTORE () {
	if (hasRequiredZUNIONSTORE) return ZUNIONSTORE;
	hasRequiredZUNIONSTORE = 1;
	Object.defineProperty(ZUNIONSTORE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ZUNIONSTORE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Stores the union of multiple sorted sets in a new sorted set.
	     * @param parser - The Redis command parser.
	     * @param destination - Destination key where the result will be stored.
	     * @param keys - Keys of the sorted sets to combine.
	     * @param options - Optional parameters for the union operation.
	     */
	    parseCommand(parser, destination, keys, options) {
	        parser.push('ZUNIONSTORE');
	        parser.pushKey(destination);
	        (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
	        if (options?.AGGREGATE) {
	            parser.push('AGGREGATE', options.AGGREGATE);
	        }
	    },
	    transformReply: undefined
	};
	
	return ZUNIONSTORE;
}

var VADD = {};

var hasRequiredVADD;

function requireVADD () {
	if (hasRequiredVADD) return VADD;
	hasRequiredVADD = 1;
	Object.defineProperty(VADD, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	VADD.default = {
	    /**
	     * Add a new element into the vector set specified by key
	     *
	     * @param parser - The command parser
	     * @param key - The name of the key that will hold the vector set data
	     * @param vector - The vector data as array of numbers
	     * @param element - The name of the element being added to the vector set
	     * @param options - Optional parameters for vector addition
	     * @see https://redis.io/commands/vadd/
	     */
	    parseCommand(parser, key, vector, element, options) {
	        parser.push('VADD');
	        parser.pushKey(key);
	        if (options?.REDUCE !== undefined) {
	            parser.push('REDUCE', options.REDUCE.toString());
	        }
	        parser.push('VALUES', vector.length.toString());
	        for (const value of vector) {
	            parser.push((0, generic_transformers_1.transformDoubleArgument)(value));
	        }
	        parser.push(element);
	        if (options?.CAS) {
	            parser.push('CAS');
	        }
	        options?.QUANT && parser.push(options.QUANT);
	        if (options?.EF !== undefined) {
	            parser.push('EF', options.EF.toString());
	        }
	        if (options?.SETATTR) {
	            parser.push('SETATTR', JSON.stringify(options.SETATTR));
	        }
	        if (options?.M !== undefined) {
	            parser.push('M', options.M.toString());
	        }
	    },
	    transformReply: generic_transformers_1.transformBooleanReply
	};
	
	return VADD;
}

var VCARD = {};

var hasRequiredVCARD;

function requireVCARD () {
	if (hasRequiredVCARD) return VCARD;
	hasRequiredVCARD = 1;
	Object.defineProperty(VCARD, "__esModule", { value: true });
	VCARD.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Retrieve the number of elements in a vector set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @see https://redis.io/commands/vcard/
	     */
	    parseCommand(parser, key) {
	        parser.push('VCARD');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return VCARD;
}

var VDIM = {};

var hasRequiredVDIM;

function requireVDIM () {
	if (hasRequiredVDIM) return VDIM;
	hasRequiredVDIM = 1;
	Object.defineProperty(VDIM, "__esModule", { value: true });
	VDIM.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Retrieve the dimension of the vectors in a vector set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @see https://redis.io/commands/vdim/
	     */
	    parseCommand(parser, key) {
	        parser.push('VDIM');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return VDIM;
}

var VEMB = {};

var hasRequiredVEMB;

function requireVEMB () {
	if (hasRequiredVEMB) return VEMB;
	hasRequiredVEMB = 1;
	Object.defineProperty(VEMB, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	VEMB.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Retrieve the approximate vector associated with a vector set element
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @param element - The name of the element to retrieve the vector for
	     * @see https://redis.io/commands/vemb/
	     */
	    parseCommand(parser, key, element) {
	        parser.push('VEMB');
	        parser.pushKey(key);
	        parser.push(element);
	    },
	    transformReply: generic_transformers_1.transformDoubleArrayReply
	};
	
	return VEMB;
}

var VEMB_RAW = {};

var hasRequiredVEMB_RAW;

function requireVEMB_RAW () {
	if (hasRequiredVEMB_RAW) return VEMB_RAW;
	hasRequiredVEMB_RAW = 1;
	var __importDefault = (VEMB_RAW && VEMB_RAW.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(VEMB_RAW, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const VEMB_1 = __importDefault(requireVEMB());
	const transformRawVembReply = {
	    2: (reply) => {
	        return {
	            quantization: reply[0],
	            raw: reply[1],
	            l2Norm: generic_transformers_1.transformDoubleReply[2](reply[2]),
	            ...(reply[3] !== undefined && { quantizationRange: generic_transformers_1.transformDoubleReply[2](reply[3]) })
	        };
	    },
	    3: (reply) => {
	        return {
	            quantization: reply[0],
	            raw: reply[1],
	            l2Norm: reply[2],
	            quantizationRange: reply[3]
	        };
	    },
	};
	VEMB_RAW.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Retrieve the RAW approximate vector associated with a vector set element
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @param element - The name of the element to retrieve the vector for
	     * @see https://redis.io/commands/vemb/
	     */
	    parseCommand(parser, key, element) {
	        VEMB_1.default.parseCommand(parser, key, element);
	        parser.push('RAW');
	    },
	    transformReply: transformRawVembReply
	};
	
	return VEMB_RAW;
}

var VGETATTR = {};

var hasRequiredVGETATTR;

function requireVGETATTR () {
	if (hasRequiredVGETATTR) return VGETATTR;
	hasRequiredVGETATTR = 1;
	Object.defineProperty(VGETATTR, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	VGETATTR.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Retrieve the attributes of a vector set element
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @param element - The name of the element to retrieve attributes for
	     * @see https://redis.io/commands/vgetattr/
	     */
	    parseCommand(parser, key, element) {
	        parser.push('VGETATTR');
	        parser.pushKey(key);
	        parser.push(element);
	    },
	    transformReply: generic_transformers_1.transformRedisJsonNullReply
	};
	
	return VGETATTR;
}

var VINFO = {};

var hasRequiredVINFO;

function requireVINFO () {
	if (hasRequiredVINFO) return VINFO;
	hasRequiredVINFO = 1;
	Object.defineProperty(VINFO, "__esModule", { value: true });
	VINFO.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Retrieve metadata and internal details about a vector set, including size, dimensions, quantization type, and graph structure
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @see https://redis.io/commands/vinfo/
	     */
	    parseCommand(parser, key) {
	        parser.push('VINFO');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        2: (reply) => {
	            const ret = Object.create(null);
	            for (let i = 0; i < reply.length; i += 2) {
	                ret[reply[i].toString()] = reply[i + 1];
	            }
	            return ret;
	        },
	        3: undefined
	    }
	};
	
	return VINFO;
}

var VLINKS = {};

var hasRequiredVLINKS;

function requireVLINKS () {
	if (hasRequiredVLINKS) return VLINKS;
	hasRequiredVLINKS = 1;
	Object.defineProperty(VLINKS, "__esModule", { value: true });
	VLINKS.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Retrieve the neighbors of a specified element in a vector set; the connections for each layer of the HNSW graph
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @param element - The name of the element to retrieve neighbors for
	     * @see https://redis.io/commands/vlinks/
	     */
	    parseCommand(parser, key, element) {
	        parser.push('VLINKS');
	        parser.pushKey(key);
	        parser.push(element);
	    },
	    transformReply: undefined
	};
	
	return VLINKS;
}

var VLINKS_WITHSCORES = {};

var hasRequiredVLINKS_WITHSCORES;

function requireVLINKS_WITHSCORES () {
	if (hasRequiredVLINKS_WITHSCORES) return VLINKS_WITHSCORES;
	hasRequiredVLINKS_WITHSCORES = 1;
	var __importDefault = (VLINKS_WITHSCORES && VLINKS_WITHSCORES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(VLINKS_WITHSCORES, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const VLINKS_1 = __importDefault(requireVLINKS());
	function transformVLinksWithScoresReply(reply) {
	    const layers = [];
	    for (const layer of reply) {
	        const obj = Object.create(null);
	        // Each layer contains alternating element names and scores
	        for (let i = 0; i < layer.length; i += 2) {
	            const element = layer[i];
	            const score = generic_transformers_1.transformDoubleReply[2](layer[i + 1]);
	            obj[element.toString()] = score;
	        }
	        layers.push(obj);
	    }
	    return layers;
	}
	VLINKS_WITHSCORES.default = {
	    IS_READ_ONLY: VLINKS_1.default.IS_READ_ONLY,
	    /**
	     * Get the connections for each layer of the HNSW graph with similarity scores
	     * @param args - Same parameters as the VLINKS command
	     * @see https://redis.io/commands/vlinks/
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        VLINKS_1.default.parseCommand(...args);
	        parser.push('WITHSCORES');
	    },
	    transformReply: {
	        2: transformVLinksWithScoresReply,
	        3: undefined
	    }
	};
	
	return VLINKS_WITHSCORES;
}

var VRANDMEMBER = {};

var hasRequiredVRANDMEMBER;

function requireVRANDMEMBER () {
	if (hasRequiredVRANDMEMBER) return VRANDMEMBER;
	hasRequiredVRANDMEMBER = 1;
	Object.defineProperty(VRANDMEMBER, "__esModule", { value: true });
	VRANDMEMBER.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Retrieve random elements of a vector set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @param count - Optional number of elements to return
	     * @see https://redis.io/commands/vrandmember/
	     */
	    parseCommand(parser, key, count) {
	        parser.push('VRANDMEMBER');
	        parser.pushKey(key);
	        if (count !== undefined) {
	            parser.push(count.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return VRANDMEMBER;
}

var VREM = {};

var hasRequiredVREM;

function requireVREM () {
	if (hasRequiredVREM) return VREM;
	hasRequiredVREM = 1;
	Object.defineProperty(VREM, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	VREM.default = {
	    /**
	     * Remove an element from a vector set
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @param element - The name of the element to remove from the vector set
	     * @see https://redis.io/commands/vrem/
	     */
	    parseCommand(parser, key, element) {
	        parser.push('VREM');
	        parser.pushKey(key);
	        parser.push(element);
	    },
	    transformReply: generic_transformers_1.transformBooleanReply
	};
	
	return VREM;
}

var VSETATTR = {};

var hasRequiredVSETATTR;

function requireVSETATTR () {
	if (hasRequiredVSETATTR) return VSETATTR;
	hasRequiredVSETATTR = 1;
	Object.defineProperty(VSETATTR, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	VSETATTR.default = {
	    /**
	     * Set or replace attributes on a vector set element
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @param element - The name of the element to set attributes for
	     * @param attributes - The attributes to set (as JSON string or object)
	     * @see https://redis.io/commands/vsetattr/
	     */
	    parseCommand(parser, key, element, attributes) {
	        parser.push('VSETATTR');
	        parser.pushKey(key);
	        parser.push(element);
	        if (typeof attributes === 'object' && attributes !== null) {
	            parser.push(JSON.stringify(attributes));
	        }
	        else {
	            parser.push(attributes);
	        }
	    },
	    transformReply: generic_transformers_1.transformBooleanReply
	};
	
	return VSETATTR;
}

var VSIM = {};

var hasRequiredVSIM;

function requireVSIM () {
	if (hasRequiredVSIM) return VSIM;
	hasRequiredVSIM = 1;
	Object.defineProperty(VSIM, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	VSIM.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Retrieve elements similar to a given vector or element with optional filtering
	     *
	     * @param parser - The command parser
	     * @param key - The key of the vector set
	     * @param query - The query vector (array of numbers) or element name (string)
	     * @param options - Optional parameters for similarity search
	     * @see https://redis.io/commands/vsim/
	     */
	    parseCommand(parser, key, query, options) {
	        parser.push('VSIM');
	        parser.pushKey(key);
	        if (Array.isArray(query)) {
	            parser.push('VALUES', query.length.toString());
	            for (const value of query) {
	                parser.push((0, generic_transformers_1.transformDoubleArgument)(value));
	            }
	        }
	        else {
	            parser.push('ELE', query);
	        }
	        if (options?.COUNT !== undefined) {
	            parser.push('COUNT', options.COUNT.toString());
	        }
	        if (options?.EF !== undefined) {
	            parser.push('EF', options.EF.toString());
	        }
	        if (options?.FILTER) {
	            parser.push('FILTER', options.FILTER);
	        }
	        if (options?.['FILTER-EF'] !== undefined) {
	            parser.push('FILTER-EF', options['FILTER-EF'].toString());
	        }
	        if (options?.TRUTH) {
	            parser.push('TRUTH');
	        }
	        if (options?.NOTHREAD) {
	            parser.push('NOTHREAD');
	        }
	    },
	    transformReply: undefined
	};
	
	return VSIM;
}

var VSIM_WITHSCORES = {};

var hasRequiredVSIM_WITHSCORES;

function requireVSIM_WITHSCORES () {
	if (hasRequiredVSIM_WITHSCORES) return VSIM_WITHSCORES;
	hasRequiredVSIM_WITHSCORES = 1;
	var __importDefault = (VSIM_WITHSCORES && VSIM_WITHSCORES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(VSIM_WITHSCORES, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const VSIM_1 = __importDefault(requireVSIM());
	VSIM_WITHSCORES.default = {
	    IS_READ_ONLY: VSIM_1.default.IS_READ_ONLY,
	    /**
	     * Retrieve elements similar to a given vector or element with similarity scores
	     * @param args - Same parameters as the VSIM command
	     * @see https://redis.io/commands/vsim/
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        VSIM_1.default.parseCommand(...args);
	        parser.push('WITHSCORES');
	    },
	    transformReply: {
	        2: (reply) => {
	            const inferred = reply;
	            const members = {};
	            for (let i = 0; i < inferred.length; i += 2) {
	                members[inferred[i].toString()] = generic_transformers_1.transformDoubleReply[2](inferred[i + 1]);
	            }
	            return members;
	        },
	        3: undefined
	    }
	};
	
	return VSIM_WITHSCORES;
}

var hasRequiredCommands$5;

function requireCommands$5 () {
	if (hasRequiredCommands$5) return commands$5;
	hasRequiredCommands$5 = 1;
	var __importDefault = (commands$5 && commands$5.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(commands$5, "__esModule", { value: true });
	const ACL_CAT_1 = __importDefault(requireACL_CAT());
	const ACL_DELUSER_1 = __importDefault(requireACL_DELUSER());
	const ACL_DRYRUN_1 = __importDefault(requireACL_DRYRUN());
	const ACL_GENPASS_1 = __importDefault(requireACL_GENPASS());
	const ACL_GETUSER_1 = __importDefault(requireACL_GETUSER());
	const ACL_LIST_1 = __importDefault(requireACL_LIST());
	const ACL_LOAD_1 = __importDefault(requireACL_LOAD());
	const ACL_LOG_RESET_1 = __importDefault(requireACL_LOG_RESET());
	const ACL_LOG_1 = __importDefault(requireACL_LOG());
	const ACL_SAVE_1 = __importDefault(requireACL_SAVE());
	const ACL_SETUSER_1 = __importDefault(requireACL_SETUSER());
	const ACL_USERS_1 = __importDefault(requireACL_USERS());
	const ACL_WHOAMI_1 = __importDefault(requireACL_WHOAMI());
	const APPEND_1 = __importDefault(requireAPPEND());
	const ASKING_1 = __importDefault(requireASKING());
	const AUTH_1 = __importDefault(requireAUTH());
	const BGREWRITEAOF_1 = __importDefault(requireBGREWRITEAOF());
	const BGSAVE_1 = __importDefault(requireBGSAVE());
	const BITCOUNT_1 = __importDefault(requireBITCOUNT());
	const BITFIELD_RO_1 = __importDefault(requireBITFIELD_RO());
	const BITFIELD_1 = __importDefault(requireBITFIELD());
	const BITOP_1 = __importDefault(requireBITOP());
	const BITPOS_1 = __importDefault(requireBITPOS());
	const BLMOVE_1 = __importDefault(requireBLMOVE());
	const BLMPOP_1 = __importDefault(requireBLMPOP());
	const BLPOP_1 = __importDefault(requireBLPOP());
	const BRPOP_1 = __importDefault(requireBRPOP());
	const BRPOPLPUSH_1 = __importDefault(requireBRPOPLPUSH());
	const BZMPOP_1 = __importDefault(requireBZMPOP());
	const BZPOPMAX_1 = __importDefault(requireBZPOPMAX());
	const BZPOPMIN_1 = __importDefault(requireBZPOPMIN());
	const CLIENT_CACHING_1 = __importDefault(requireCLIENT_CACHING());
	const CLIENT_GETNAME_1 = __importDefault(requireCLIENT_GETNAME());
	const CLIENT_GETREDIR_1 = __importDefault(requireCLIENT_GETREDIR());
	const CLIENT_ID_1 = __importDefault(requireCLIENT_ID());
	const CLIENT_INFO_1 = __importDefault(requireCLIENT_INFO());
	const CLIENT_KILL_1 = __importDefault(requireCLIENT_KILL());
	const CLIENT_LIST_1 = __importDefault(requireCLIENT_LIST());
	const CLIENT_NO_EVICT_1 = __importDefault(requireCLIENT_NOEVICT());
	const CLIENT_NO_TOUCH_1 = __importDefault(requireCLIENT_NOTOUCH());
	const CLIENT_PAUSE_1 = __importDefault(requireCLIENT_PAUSE());
	const CLIENT_SETNAME_1 = __importDefault(requireCLIENT_SETNAME());
	const CLIENT_TRACKING_1 = __importDefault(requireCLIENT_TRACKING());
	const CLIENT_TRACKINGINFO_1 = __importDefault(requireCLIENT_TRACKINGINFO());
	const CLIENT_UNPAUSE_1 = __importDefault(requireCLIENT_UNPAUSE());
	const CLUSTER_ADDSLOTS_1 = __importDefault(requireCLUSTER_ADDSLOTS());
	const CLUSTER_ADDSLOTSRANGE_1 = __importDefault(requireCLUSTER_ADDSLOTSRANGE());
	const CLUSTER_BUMPEPOCH_1 = __importDefault(requireCLUSTER_BUMPEPOCH());
	const CLUSTER_COUNT_FAILURE_REPORTS_1 = __importDefault(requireCLUSTER_COUNTFAILUREREPORTS());
	const CLUSTER_COUNTKEYSINSLOT_1 = __importDefault(requireCLUSTER_COUNTKEYSINSLOT());
	const CLUSTER_DELSLOTS_1 = __importDefault(requireCLUSTER_DELSLOTS());
	const CLUSTER_DELSLOTSRANGE_1 = __importDefault(requireCLUSTER_DELSLOTSRANGE());
	const CLUSTER_FAILOVER_1 = __importDefault(requireCLUSTER_FAILOVER());
	const CLUSTER_FLUSHSLOTS_1 = __importDefault(requireCLUSTER_FLUSHSLOTS());
	const CLUSTER_FORGET_1 = __importDefault(requireCLUSTER_FORGET());
	const CLUSTER_GETKEYSINSLOT_1 = __importDefault(requireCLUSTER_GETKEYSINSLOT());
	const CLUSTER_INFO_1 = __importDefault(requireCLUSTER_INFO());
	const CLUSTER_KEYSLOT_1 = __importDefault(requireCLUSTER_KEYSLOT());
	const CLUSTER_LINKS_1 = __importDefault(requireCLUSTER_LINKS());
	const CLUSTER_MEET_1 = __importDefault(requireCLUSTER_MEET());
	const CLUSTER_MYID_1 = __importDefault(requireCLUSTER_MYID());
	const CLUSTER_MYSHARDID_1 = __importDefault(requireCLUSTER_MYSHARDID());
	const CLUSTER_NODES_1 = __importDefault(requireCLUSTER_NODES());
	const CLUSTER_REPLICAS_1 = __importDefault(requireCLUSTER_REPLICAS());
	const CLUSTER_REPLICATE_1 = __importDefault(requireCLUSTER_REPLICATE());
	const CLUSTER_RESET_1 = __importDefault(requireCLUSTER_RESET());
	const CLUSTER_SAVECONFIG_1 = __importDefault(requireCLUSTER_SAVECONFIG());
	const CLUSTER_SET_CONFIG_EPOCH_1 = __importDefault(requireCLUSTER_SETCONFIGEPOCH());
	const CLUSTER_SETSLOT_1 = __importDefault(requireCLUSTER_SETSLOT());
	const CLUSTER_SLOTS_1 = __importDefault(requireCLUSTER_SLOTS());
	const COMMAND_COUNT_1 = __importDefault(requireCOMMAND_COUNT());
	const COMMAND_GETKEYS_1 = __importDefault(requireCOMMAND_GETKEYS());
	const COMMAND_GETKEYSANDFLAGS_1 = __importDefault(requireCOMMAND_GETKEYSANDFLAGS());
	const COMMAND_INFO_1 = __importDefault(requireCOMMAND_INFO());
	const COMMAND_LIST_1 = __importDefault(requireCOMMAND_LIST());
	const COMMAND_1 = __importDefault(requireCOMMAND());
	const CONFIG_GET_1 = __importDefault(requireCONFIG_GET$1());
	const CONFIG_RESETSTAT_1 = __importDefault(requireCONFIG_RESETSTAT());
	const CONFIG_REWRITE_1 = __importDefault(requireCONFIG_REWRITE());
	const CONFIG_SET_1 = __importDefault(requireCONFIG_SET$1());
	const COPY_1 = __importDefault(requireCOPY());
	const DBSIZE_1 = __importDefault(requireDBSIZE());
	const DECR_1 = __importDefault(requireDECR());
	const DECRBY_1 = __importDefault(requireDECRBY$1());
	const DEL_1 = __importDefault(requireDEL$3());
	const DUMP_1 = __importDefault(requireDUMP());
	const ECHO_1 = __importDefault(requireECHO());
	const EVAL_RO_1 = __importDefault(requireEVAL_RO());
	const EVAL_1 = __importDefault(requireEVAL());
	const EVALSHA_RO_1 = __importDefault(requireEVALSHA_RO());
	const EVALSHA_1 = __importDefault(requireEVALSHA());
	const GEOADD_1 = __importDefault(requireGEOADD());
	const GEODIST_1 = __importDefault(requireGEODIST());
	const GEOHASH_1 = __importDefault(requireGEOHASH());
	const GEOPOS_1 = __importDefault(requireGEOPOS());
	const GEORADIUS_RO_WITH_1 = __importDefault(requireGEORADIUS_RO_WITH());
	const GEORADIUS_RO_1 = __importDefault(requireGEORADIUS_RO());
	const GEORADIUS_STORE_1 = __importDefault(requireGEORADIUS_STORE());
	const GEORADIUS_WITH_1 = __importDefault(requireGEORADIUS_WITH());
	const GEORADIUS_1 = __importDefault(requireGEORADIUS());
	const GEORADIUSBYMEMBER_RO_WITH_1 = __importDefault(requireGEORADIUSBYMEMBER_RO_WITH());
	const GEORADIUSBYMEMBER_RO_1 = __importDefault(requireGEORADIUSBYMEMBER_RO());
	const GEORADIUSBYMEMBER_STORE_1 = __importDefault(requireGEORADIUSBYMEMBER_STORE());
	const GEORADIUSBYMEMBER_WITH_1 = __importDefault(requireGEORADIUSBYMEMBER_WITH());
	const GEORADIUSBYMEMBER_1 = __importDefault(requireGEORADIUSBYMEMBER());
	const GEOSEARCH_WITH_1 = __importDefault(requireGEOSEARCH_WITH());
	const GEOSEARCH_1 = __importDefault(requireGEOSEARCH());
	const GEOSEARCHSTORE_1 = __importDefault(requireGEOSEARCHSTORE());
	const GET_1 = __importDefault(requireGET$2());
	const GETBIT_1 = __importDefault(requireGETBIT());
	const GETDEL_1 = __importDefault(requireGETDEL());
	const GETEX_1 = __importDefault(requireGETEX());
	const GETRANGE_1 = __importDefault(requireGETRANGE());
	const GETSET_1 = __importDefault(requireGETSET());
	const EXISTS_1 = __importDefault(requireEXISTS$2());
	const EXPIRE_1 = __importDefault(requireEXPIRE());
	const EXPIREAT_1 = __importDefault(requireEXPIREAT());
	const EXPIRETIME_1 = __importDefault(requireEXPIRETIME());
	const FLUSHALL_1 = __importDefault(requireFLUSHALL());
	const FLUSHDB_1 = __importDefault(requireFLUSHDB());
	const FCALL_1 = __importDefault(requireFCALL());
	const FCALL_RO_1 = __importDefault(requireFCALL_RO());
	const FUNCTION_DELETE_1 = __importDefault(requireFUNCTION_DELETE());
	const FUNCTION_DUMP_1 = __importDefault(requireFUNCTION_DUMP());
	const FUNCTION_FLUSH_1 = __importDefault(requireFUNCTION_FLUSH());
	const FUNCTION_KILL_1 = __importDefault(requireFUNCTION_KILL());
	const FUNCTION_LIST_WITHCODE_1 = __importDefault(requireFUNCTION_LIST_WITHCODE());
	const FUNCTION_LIST_1 = __importDefault(requireFUNCTION_LIST());
	const FUNCTION_LOAD_1 = __importDefault(requireFUNCTION_LOAD());
	const FUNCTION_RESTORE_1 = __importDefault(requireFUNCTION_RESTORE());
	const FUNCTION_STATS_1 = __importDefault(requireFUNCTION_STATS());
	const HDEL_1 = __importDefault(requireHDEL());
	const HELLO_1 = __importDefault(requireHELLO());
	const HEXISTS_1 = __importDefault(requireHEXISTS());
	const HEXPIRE_1 = __importDefault(requireHEXPIRE());
	const HEXPIREAT_1 = __importDefault(requireHEXPIREAT());
	const HEXPIRETIME_1 = __importDefault(requireHEXPIRETIME());
	const HGET_1 = __importDefault(requireHGET());
	const HGETALL_1 = __importDefault(requireHGETALL());
	const HGETDEL_1 = __importDefault(requireHGETDEL());
	const HGETEX_1 = __importDefault(requireHGETEX());
	const HINCRBY_1 = __importDefault(requireHINCRBY());
	const HINCRBYFLOAT_1 = __importDefault(requireHINCRBYFLOAT());
	const HKEYS_1 = __importDefault(requireHKEYS());
	const HLEN_1 = __importDefault(requireHLEN());
	const HMGET_1 = __importDefault(requireHMGET());
	const HPERSIST_1 = __importDefault(requireHPERSIST());
	const HPEXPIRE_1 = __importDefault(requireHPEXPIRE());
	const HPEXPIREAT_1 = __importDefault(requireHPEXPIREAT());
	const HPEXPIRETIME_1 = __importDefault(requireHPEXPIRETIME());
	const HPTTL_1 = __importDefault(requireHPTTL());
	const HRANDFIELD_COUNT_WITHVALUES_1 = __importDefault(requireHRANDFIELD_COUNT_WITHVALUES());
	const HRANDFIELD_COUNT_1 = __importDefault(requireHRANDFIELD_COUNT());
	const HRANDFIELD_1 = __importDefault(requireHRANDFIELD());
	const HSCAN_1 = __importDefault(requireHSCAN());
	const HSCAN_NOVALUES_1 = __importDefault(requireHSCAN_NOVALUES());
	const HSET_1 = __importDefault(requireHSET());
	const HSETEX_1 = __importDefault(requireHSETEX());
	const HSETNX_1 = __importDefault(requireHSETNX());
	const HSTRLEN_1 = __importDefault(requireHSTRLEN());
	const HTTL_1 = __importDefault(requireHTTL());
	const HVALS_1 = __importDefault(requireHVALS());
	const INCR_1 = __importDefault(requireINCR());
	const INCRBY_1 = __importDefault(requireINCRBY$3());
	const INCRBYFLOAT_1 = __importDefault(requireINCRBYFLOAT());
	const INFO_1 = __importDefault(requireINFO$7());
	const KEYS_1 = __importDefault(requireKEYS());
	const LASTSAVE_1 = __importDefault(requireLASTSAVE());
	const LATENCY_DOCTOR_1 = __importDefault(requireLATENCY_DOCTOR());
	const LATENCY_GRAPH_1 = __importDefault(requireLATENCY_GRAPH());
	const LATENCY_HISTORY_1 = __importDefault(requireLATENCY_HISTORY());
	const LATENCY_LATEST_1 = __importDefault(requireLATENCY_LATEST());
	const LCS_IDX_WITHMATCHLEN_1 = __importDefault(requireLCS_IDX_WITHMATCHLEN());
	const LCS_IDX_1 = __importDefault(requireLCS_IDX());
	const LCS_LEN_1 = __importDefault(requireLCS_LEN());
	const LCS_1 = __importDefault(requireLCS());
	const LINDEX_1 = __importDefault(requireLINDEX());
	const LINSERT_1 = __importDefault(requireLINSERT());
	const LLEN_1 = __importDefault(requireLLEN());
	const LMOVE_1 = __importDefault(requireLMOVE());
	const LMPOP_1 = __importDefault(requireLMPOP());
	const LOLWUT_1 = __importDefault(requireLOLWUT());
	const LPOP_COUNT_1 = __importDefault(requireLPOP_COUNT());
	const LPOP_1 = __importDefault(requireLPOP());
	const LPOS_COUNT_1 = __importDefault(requireLPOS_COUNT());
	const LPOS_1 = __importDefault(requireLPOS());
	const LPUSH_1 = __importDefault(requireLPUSH());
	const LPUSHX_1 = __importDefault(requireLPUSHX());
	const LRANGE_1 = __importDefault(requireLRANGE());
	const LREM_1 = __importDefault(requireLREM());
	const LSET_1 = __importDefault(requireLSET());
	const LTRIM_1 = __importDefault(requireLTRIM());
	const MEMORY_DOCTOR_1 = __importDefault(requireMEMORY_DOCTOR());
	const MEMORY_MALLOC_STATS_1 = __importDefault(requireMEMORY_MALLOCSTATS());
	const MEMORY_PURGE_1 = __importDefault(requireMEMORY_PURGE());
	const MEMORY_STATS_1 = __importDefault(requireMEMORY_STATS());
	const MEMORY_USAGE_1 = __importDefault(requireMEMORY_USAGE());
	const MGET_1 = __importDefault(requireMGET$2());
	const MIGRATE_1 = __importDefault(requireMIGRATE());
	const MODULE_LIST_1 = __importDefault(requireMODULE_LIST());
	const MODULE_LOAD_1 = __importDefault(requireMODULE_LOAD());
	const MODULE_UNLOAD_1 = __importDefault(requireMODULE_UNLOAD());
	const MOVE_1 = __importDefault(requireMOVE());
	const MSET_1 = __importDefault(requireMSET$1());
	const MSETNX_1 = __importDefault(requireMSETNX());
	const OBJECT_ENCODING_1 = __importDefault(requireOBJECT_ENCODING());
	const OBJECT_FREQ_1 = __importDefault(requireOBJECT_FREQ());
	const OBJECT_IDLETIME_1 = __importDefault(requireOBJECT_IDLETIME());
	const OBJECT_REFCOUNT_1 = __importDefault(requireOBJECT_REFCOUNT());
	const PERSIST_1 = __importDefault(requirePERSIST());
	const PEXPIRE_1 = __importDefault(requirePEXPIRE());
	const PEXPIREAT_1 = __importDefault(requirePEXPIREAT());
	const PEXPIRETIME_1 = __importDefault(requirePEXPIRETIME());
	const PFADD_1 = __importDefault(requirePFADD());
	const PFCOUNT_1 = __importDefault(requirePFCOUNT());
	const PFMERGE_1 = __importDefault(requirePFMERGE());
	const PING_1 = __importDefault(requirePING());
	const PSETEX_1 = __importDefault(requirePSETEX());
	const PTTL_1 = __importDefault(requirePTTL());
	const PUBLISH_1 = __importDefault(requirePUBLISH());
	const PUBSUB_CHANNELS_1 = __importDefault(requirePUBSUB_CHANNELS());
	const PUBSUB_NUMPAT_1 = __importDefault(requirePUBSUB_NUMPAT());
	const PUBSUB_NUMSUB_1 = __importDefault(requirePUBSUB_NUMSUB());
	const PUBSUB_SHARDNUMSUB_1 = __importDefault(requirePUBSUB_SHARDNUMSUB());
	const PUBSUB_SHARDCHANNELS_1 = __importDefault(requirePUBSUB_SHARDCHANNELS());
	const RANDOMKEY_1 = __importDefault(requireRANDOMKEY());
	const READONLY_1 = __importDefault(requireREADONLY());
	const RENAME_1 = __importDefault(requireRENAME());
	const RENAMENX_1 = __importDefault(requireRENAMENX());
	const REPLICAOF_1 = __importDefault(requireREPLICAOF());
	const RESTORE_ASKING_1 = __importDefault(requireRESTOREASKING());
	const RESTORE_1 = __importDefault(requireRESTORE());
	const ROLE_1 = __importDefault(requireROLE());
	const RPOP_COUNT_1 = __importDefault(requireRPOP_COUNT());
	const RPOP_1 = __importDefault(requireRPOP());
	const RPOPLPUSH_1 = __importDefault(requireRPOPLPUSH());
	const RPUSH_1 = __importDefault(requireRPUSH());
	const RPUSHX_1 = __importDefault(requireRPUSHX());
	const SADD_1 = __importDefault(requireSADD());
	const SCAN_1 = __importDefault(requireSCAN());
	const SCARD_1 = __importDefault(requireSCARD());
	const SCRIPT_DEBUG_1 = __importDefault(requireSCRIPT_DEBUG());
	const SCRIPT_EXISTS_1 = __importDefault(requireSCRIPT_EXISTS());
	const SCRIPT_FLUSH_1 = __importDefault(requireSCRIPT_FLUSH());
	const SCRIPT_KILL_1 = __importDefault(requireSCRIPT_KILL());
	const SCRIPT_LOAD_1 = __importDefault(requireSCRIPT_LOAD());
	const SDIFF_1 = __importDefault(requireSDIFF());
	const SDIFFSTORE_1 = __importDefault(requireSDIFFSTORE());
	const SET_1 = __importDefault(requireSET$1());
	const SETBIT_1 = __importDefault(requireSETBIT());
	const SETEX_1 = __importDefault(requireSETEX());
	const SETNX_1 = __importDefault(requireSETNX());
	const SETRANGE_1 = __importDefault(requireSETRANGE());
	const SINTER_1 = __importDefault(requireSINTER());
	const SINTERCARD_1 = __importDefault(requireSINTERCARD());
	const SINTERSTORE_1 = __importDefault(requireSINTERSTORE());
	const SISMEMBER_1 = __importDefault(requireSISMEMBER());
	const SMEMBERS_1 = __importDefault(requireSMEMBERS());
	const SMISMEMBER_1 = __importDefault(requireSMISMEMBER());
	const SMOVE_1 = __importDefault(requireSMOVE());
	const SORT_RO_1 = __importDefault(requireSORT_RO());
	const SORT_STORE_1 = __importDefault(requireSORT_STORE());
	const SORT_1 = __importDefault(requireSORT());
	const SPOP_COUNT_1 = __importDefault(requireSPOP_COUNT());
	const SPOP_1 = __importDefault(requireSPOP());
	const SPUBLISH_1 = __importDefault(requireSPUBLISH());
	const SRANDMEMBER_COUNT_1 = __importDefault(requireSRANDMEMBER_COUNT());
	const SRANDMEMBER_1 = __importDefault(requireSRANDMEMBER());
	const SREM_1 = __importDefault(requireSREM());
	const SSCAN_1 = __importDefault(requireSSCAN());
	const STRLEN_1 = __importDefault(requireSTRLEN$1());
	const SUNION_1 = __importDefault(requireSUNION());
	const SUNIONSTORE_1 = __importDefault(requireSUNIONSTORE());
	const SWAPDB_1 = __importDefault(requireSWAPDB());
	const TIME_1 = __importDefault(requireTIME());
	const TOUCH_1 = __importDefault(requireTOUCH());
	const TTL_1 = __importDefault(requireTTL());
	const TYPE_1 = __importDefault(requireTYPE$1());
	const UNLINK_1 = __importDefault(requireUNLINK());
	const WAIT_1 = __importDefault(requireWAIT());
	const XACK_1 = __importDefault(requireXACK());
	const XADD_NOMKSTREAM_1 = __importDefault(requireXADD_NOMKSTREAM());
	const XADD_1 = __importDefault(requireXADD());
	const XAUTOCLAIM_JUSTID_1 = __importDefault(requireXAUTOCLAIM_JUSTID());
	const XAUTOCLAIM_1 = __importDefault(requireXAUTOCLAIM());
	const XCLAIM_JUSTID_1 = __importDefault(requireXCLAIM_JUSTID());
	const XCLAIM_1 = __importDefault(requireXCLAIM());
	const XDEL_1 = __importDefault(requireXDEL());
	const XGROUP_CREATE_1 = __importDefault(requireXGROUP_CREATE());
	const XGROUP_CREATECONSUMER_1 = __importDefault(requireXGROUP_CREATECONSUMER());
	const XGROUP_DELCONSUMER_1 = __importDefault(requireXGROUP_DELCONSUMER());
	const XGROUP_DESTROY_1 = __importDefault(requireXGROUP_DESTROY());
	const XGROUP_SETID_1 = __importDefault(requireXGROUP_SETID());
	const XINFO_CONSUMERS_1 = __importDefault(requireXINFO_CONSUMERS());
	const XINFO_GROUPS_1 = __importDefault(requireXINFO_GROUPS());
	const XINFO_STREAM_1 = __importDefault(requireXINFO_STREAM());
	const XLEN_1 = __importDefault(requireXLEN());
	const XPENDING_RANGE_1 = __importDefault(requireXPENDING_RANGE());
	const XPENDING_1 = __importDefault(requireXPENDING());
	const XRANGE_1 = __importDefault(requireXRANGE());
	const XREAD_1 = __importDefault(requireXREAD());
	const XREADGROUP_1 = __importDefault(requireXREADGROUP());
	const XREVRANGE_1 = __importDefault(requireXREVRANGE());
	const XSETID_1 = __importDefault(requireXSETID());
	const XTRIM_1 = __importDefault(requireXTRIM());
	const ZADD_INCR_1 = __importDefault(requireZADD_INCR());
	const ZADD_1 = __importDefault(requireZADD());
	const ZCARD_1 = __importDefault(requireZCARD());
	const ZCOUNT_1 = __importDefault(requireZCOUNT());
	const ZDIFF_WITHSCORES_1 = __importDefault(requireZDIFF_WITHSCORES());
	const ZDIFF_1 = __importDefault(requireZDIFF());
	const ZDIFFSTORE_1 = __importDefault(requireZDIFFSTORE());
	const ZINCRBY_1 = __importDefault(requireZINCRBY());
	const ZINTER_WITHSCORES_1 = __importDefault(requireZINTER_WITHSCORES());
	const ZINTER_1 = __importDefault(requireZINTER());
	const ZINTERCARD_1 = __importDefault(requireZINTERCARD());
	const ZINTERSTORE_1 = __importDefault(requireZINTERSTORE());
	const ZLEXCOUNT_1 = __importDefault(requireZLEXCOUNT());
	const ZMPOP_1 = __importDefault(requireZMPOP());
	const ZMSCORE_1 = __importDefault(requireZMSCORE());
	const ZPOPMAX_COUNT_1 = __importDefault(requireZPOPMAX_COUNT());
	const ZPOPMAX_1 = __importDefault(requireZPOPMAX());
	const ZPOPMIN_COUNT_1 = __importDefault(requireZPOPMIN_COUNT());
	const ZPOPMIN_1 = __importDefault(requireZPOPMIN());
	const ZRANDMEMBER_COUNT_WITHSCORES_1 = __importDefault(requireZRANDMEMBER_COUNT_WITHSCORES());
	const ZRANDMEMBER_COUNT_1 = __importDefault(requireZRANDMEMBER_COUNT());
	const ZRANDMEMBER_1 = __importDefault(requireZRANDMEMBER());
	const ZRANGE_WITHSCORES_1 = __importDefault(requireZRANGE_WITHSCORES());
	const ZRANGE_1 = __importDefault(requireZRANGE());
	const ZRANGEBYLEX_1 = __importDefault(requireZRANGEBYLEX());
	const ZRANGEBYSCORE_WITHSCORES_1 = __importDefault(requireZRANGEBYSCORE_WITHSCORES());
	const ZRANGEBYSCORE_1 = __importDefault(requireZRANGEBYSCORE());
	const ZRANGESTORE_1 = __importDefault(requireZRANGESTORE());
	const ZREMRANGEBYSCORE_1 = __importDefault(requireZREMRANGEBYSCORE());
	const ZRANK_WITHSCORE_1 = __importDefault(requireZRANK_WITHSCORE());
	const ZRANK_1 = __importDefault(requireZRANK());
	const ZREM_1 = __importDefault(requireZREM());
	const ZREMRANGEBYLEX_1 = __importDefault(requireZREMRANGEBYLEX());
	const ZREMRANGEBYRANK_1 = __importDefault(requireZREMRANGEBYRANK());
	const ZREVRANK_1 = __importDefault(requireZREVRANK());
	const ZSCAN_1 = __importDefault(requireZSCAN());
	const ZSCORE_1 = __importDefault(requireZSCORE());
	const ZUNION_WITHSCORES_1 = __importDefault(requireZUNION_WITHSCORES());
	const ZUNION_1 = __importDefault(requireZUNION());
	const ZUNIONSTORE_1 = __importDefault(requireZUNIONSTORE());
	const VADD_1 = __importDefault(requireVADD());
	const VCARD_1 = __importDefault(requireVCARD());
	const VDIM_1 = __importDefault(requireVDIM());
	const VEMB_1 = __importDefault(requireVEMB());
	const VEMB_RAW_1 = __importDefault(requireVEMB_RAW());
	const VGETATTR_1 = __importDefault(requireVGETATTR());
	const VINFO_1 = __importDefault(requireVINFO());
	const VLINKS_1 = __importDefault(requireVLINKS());
	const VLINKS_WITHSCORES_1 = __importDefault(requireVLINKS_WITHSCORES());
	const VRANDMEMBER_1 = __importDefault(requireVRANDMEMBER());
	const VREM_1 = __importDefault(requireVREM());
	const VSETATTR_1 = __importDefault(requireVSETATTR());
	const VSIM_1 = __importDefault(requireVSIM());
	const VSIM_WITHSCORES_1 = __importDefault(requireVSIM_WITHSCORES());
	commands$5.default = {
	    ACL_CAT: ACL_CAT_1.default,
	    aclCat: ACL_CAT_1.default,
	    ACL_DELUSER: ACL_DELUSER_1.default,
	    aclDelUser: ACL_DELUSER_1.default,
	    ACL_DRYRUN: ACL_DRYRUN_1.default,
	    aclDryRun: ACL_DRYRUN_1.default,
	    ACL_GENPASS: ACL_GENPASS_1.default,
	    aclGenPass: ACL_GENPASS_1.default,
	    ACL_GETUSER: ACL_GETUSER_1.default,
	    aclGetUser: ACL_GETUSER_1.default,
	    ACL_LIST: ACL_LIST_1.default,
	    aclList: ACL_LIST_1.default,
	    ACL_LOAD: ACL_LOAD_1.default,
	    aclLoad: ACL_LOAD_1.default,
	    ACL_LOG_RESET: ACL_LOG_RESET_1.default,
	    aclLogReset: ACL_LOG_RESET_1.default,
	    ACL_LOG: ACL_LOG_1.default,
	    aclLog: ACL_LOG_1.default,
	    ACL_SAVE: ACL_SAVE_1.default,
	    aclSave: ACL_SAVE_1.default,
	    ACL_SETUSER: ACL_SETUSER_1.default,
	    aclSetUser: ACL_SETUSER_1.default,
	    ACL_USERS: ACL_USERS_1.default,
	    aclUsers: ACL_USERS_1.default,
	    ACL_WHOAMI: ACL_WHOAMI_1.default,
	    aclWhoAmI: ACL_WHOAMI_1.default,
	    APPEND: APPEND_1.default,
	    append: APPEND_1.default,
	    ASKING: ASKING_1.default,
	    asking: ASKING_1.default,
	    AUTH: AUTH_1.default,
	    auth: AUTH_1.default,
	    BGREWRITEAOF: BGREWRITEAOF_1.default,
	    bgRewriteAof: BGREWRITEAOF_1.default,
	    BGSAVE: BGSAVE_1.default,
	    bgSave: BGSAVE_1.default,
	    BITCOUNT: BITCOUNT_1.default,
	    bitCount: BITCOUNT_1.default,
	    BITFIELD_RO: BITFIELD_RO_1.default,
	    bitFieldRo: BITFIELD_RO_1.default,
	    BITFIELD: BITFIELD_1.default,
	    bitField: BITFIELD_1.default,
	    BITOP: BITOP_1.default,
	    bitOp: BITOP_1.default,
	    BITPOS: BITPOS_1.default,
	    bitPos: BITPOS_1.default,
	    BLMOVE: BLMOVE_1.default,
	    blMove: BLMOVE_1.default,
	    BLMPOP: BLMPOP_1.default,
	    blmPop: BLMPOP_1.default,
	    BLPOP: BLPOP_1.default,
	    blPop: BLPOP_1.default,
	    BRPOP: BRPOP_1.default,
	    brPop: BRPOP_1.default,
	    BRPOPLPUSH: BRPOPLPUSH_1.default,
	    brPopLPush: BRPOPLPUSH_1.default,
	    BZMPOP: BZMPOP_1.default,
	    bzmPop: BZMPOP_1.default,
	    BZPOPMAX: BZPOPMAX_1.default,
	    bzPopMax: BZPOPMAX_1.default,
	    BZPOPMIN: BZPOPMIN_1.default,
	    bzPopMin: BZPOPMIN_1.default,
	    CLIENT_CACHING: CLIENT_CACHING_1.default,
	    clientCaching: CLIENT_CACHING_1.default,
	    CLIENT_GETNAME: CLIENT_GETNAME_1.default,
	    clientGetName: CLIENT_GETNAME_1.default,
	    CLIENT_GETREDIR: CLIENT_GETREDIR_1.default,
	    clientGetRedir: CLIENT_GETREDIR_1.default,
	    CLIENT_ID: CLIENT_ID_1.default,
	    clientId: CLIENT_ID_1.default,
	    CLIENT_INFO: CLIENT_INFO_1.default,
	    clientInfo: CLIENT_INFO_1.default,
	    CLIENT_KILL: CLIENT_KILL_1.default,
	    clientKill: CLIENT_KILL_1.default,
	    CLIENT_LIST: CLIENT_LIST_1.default,
	    clientList: CLIENT_LIST_1.default,
	    'CLIENT_NO-EVICT': CLIENT_NO_EVICT_1.default,
	    clientNoEvict: CLIENT_NO_EVICT_1.default,
	    'CLIENT_NO-TOUCH': CLIENT_NO_TOUCH_1.default,
	    clientNoTouch: CLIENT_NO_TOUCH_1.default,
	    CLIENT_PAUSE: CLIENT_PAUSE_1.default,
	    clientPause: CLIENT_PAUSE_1.default,
	    CLIENT_SETNAME: CLIENT_SETNAME_1.default,
	    clientSetName: CLIENT_SETNAME_1.default,
	    CLIENT_TRACKING: CLIENT_TRACKING_1.default,
	    clientTracking: CLIENT_TRACKING_1.default,
	    CLIENT_TRACKINGINFO: CLIENT_TRACKINGINFO_1.default,
	    clientTrackingInfo: CLIENT_TRACKINGINFO_1.default,
	    CLIENT_UNPAUSE: CLIENT_UNPAUSE_1.default,
	    clientUnpause: CLIENT_UNPAUSE_1.default,
	    CLUSTER_ADDSLOTS: CLUSTER_ADDSLOTS_1.default,
	    clusterAddSlots: CLUSTER_ADDSLOTS_1.default,
	    CLUSTER_ADDSLOTSRANGE: CLUSTER_ADDSLOTSRANGE_1.default,
	    clusterAddSlotsRange: CLUSTER_ADDSLOTSRANGE_1.default,
	    CLUSTER_BUMPEPOCH: CLUSTER_BUMPEPOCH_1.default,
	    clusterBumpEpoch: CLUSTER_BUMPEPOCH_1.default,
	    'CLUSTER_COUNT-FAILURE-REPORTS': CLUSTER_COUNT_FAILURE_REPORTS_1.default,
	    clusterCountFailureReports: CLUSTER_COUNT_FAILURE_REPORTS_1.default,
	    CLUSTER_COUNTKEYSINSLOT: CLUSTER_COUNTKEYSINSLOT_1.default,
	    clusterCountKeysInSlot: CLUSTER_COUNTKEYSINSLOT_1.default,
	    CLUSTER_DELSLOTS: CLUSTER_DELSLOTS_1.default,
	    clusterDelSlots: CLUSTER_DELSLOTS_1.default,
	    CLUSTER_DELSLOTSRANGE: CLUSTER_DELSLOTSRANGE_1.default,
	    clusterDelSlotsRange: CLUSTER_DELSLOTSRANGE_1.default,
	    CLUSTER_FAILOVER: CLUSTER_FAILOVER_1.default,
	    clusterFailover: CLUSTER_FAILOVER_1.default,
	    CLUSTER_FLUSHSLOTS: CLUSTER_FLUSHSLOTS_1.default,
	    clusterFlushSlots: CLUSTER_FLUSHSLOTS_1.default,
	    CLUSTER_FORGET: CLUSTER_FORGET_1.default,
	    clusterForget: CLUSTER_FORGET_1.default,
	    CLUSTER_GETKEYSINSLOT: CLUSTER_GETKEYSINSLOT_1.default,
	    clusterGetKeysInSlot: CLUSTER_GETKEYSINSLOT_1.default,
	    CLUSTER_INFO: CLUSTER_INFO_1.default,
	    clusterInfo: CLUSTER_INFO_1.default,
	    CLUSTER_KEYSLOT: CLUSTER_KEYSLOT_1.default,
	    clusterKeySlot: CLUSTER_KEYSLOT_1.default,
	    CLUSTER_LINKS: CLUSTER_LINKS_1.default,
	    clusterLinks: CLUSTER_LINKS_1.default,
	    CLUSTER_MEET: CLUSTER_MEET_1.default,
	    clusterMeet: CLUSTER_MEET_1.default,
	    CLUSTER_MYID: CLUSTER_MYID_1.default,
	    clusterMyId: CLUSTER_MYID_1.default,
	    CLUSTER_MYSHARDID: CLUSTER_MYSHARDID_1.default,
	    clusterMyShardId: CLUSTER_MYSHARDID_1.default,
	    CLUSTER_NODES: CLUSTER_NODES_1.default,
	    clusterNodes: CLUSTER_NODES_1.default,
	    CLUSTER_REPLICAS: CLUSTER_REPLICAS_1.default,
	    clusterReplicas: CLUSTER_REPLICAS_1.default,
	    CLUSTER_REPLICATE: CLUSTER_REPLICATE_1.default,
	    clusterReplicate: CLUSTER_REPLICATE_1.default,
	    CLUSTER_RESET: CLUSTER_RESET_1.default,
	    clusterReset: CLUSTER_RESET_1.default,
	    CLUSTER_SAVECONFIG: CLUSTER_SAVECONFIG_1.default,
	    clusterSaveConfig: CLUSTER_SAVECONFIG_1.default,
	    'CLUSTER_SET-CONFIG-EPOCH': CLUSTER_SET_CONFIG_EPOCH_1.default,
	    clusterSetConfigEpoch: CLUSTER_SET_CONFIG_EPOCH_1.default,
	    CLUSTER_SETSLOT: CLUSTER_SETSLOT_1.default,
	    clusterSetSlot: CLUSTER_SETSLOT_1.default,
	    CLUSTER_SLOTS: CLUSTER_SLOTS_1.default,
	    clusterSlots: CLUSTER_SLOTS_1.default,
	    COMMAND_COUNT: COMMAND_COUNT_1.default,
	    commandCount: COMMAND_COUNT_1.default,
	    COMMAND_GETKEYS: COMMAND_GETKEYS_1.default,
	    commandGetKeys: COMMAND_GETKEYS_1.default,
	    COMMAND_GETKEYSANDFLAGS: COMMAND_GETKEYSANDFLAGS_1.default,
	    commandGetKeysAndFlags: COMMAND_GETKEYSANDFLAGS_1.default,
	    COMMAND_INFO: COMMAND_INFO_1.default,
	    commandInfo: COMMAND_INFO_1.default,
	    COMMAND_LIST: COMMAND_LIST_1.default,
	    commandList: COMMAND_LIST_1.default,
	    COMMAND: COMMAND_1.default,
	    command: COMMAND_1.default,
	    CONFIG_GET: CONFIG_GET_1.default,
	    configGet: CONFIG_GET_1.default,
	    CONFIG_RESETASTAT: CONFIG_RESETSTAT_1.default,
	    configResetStat: CONFIG_RESETSTAT_1.default,
	    CONFIG_REWRITE: CONFIG_REWRITE_1.default,
	    configRewrite: CONFIG_REWRITE_1.default,
	    CONFIG_SET: CONFIG_SET_1.default,
	    configSet: CONFIG_SET_1.default,
	    COPY: COPY_1.default,
	    copy: COPY_1.default,
	    DBSIZE: DBSIZE_1.default,
	    dbSize: DBSIZE_1.default,
	    DECR: DECR_1.default,
	    decr: DECR_1.default,
	    DECRBY: DECRBY_1.default,
	    decrBy: DECRBY_1.default,
	    DEL: DEL_1.default,
	    del: DEL_1.default,
	    DUMP: DUMP_1.default,
	    dump: DUMP_1.default,
	    ECHO: ECHO_1.default,
	    echo: ECHO_1.default,
	    EVAL_RO: EVAL_RO_1.default,
	    evalRo: EVAL_RO_1.default,
	    EVAL: EVAL_1.default,
	    eval: EVAL_1.default,
	    EVALSHA_RO: EVALSHA_RO_1.default,
	    evalShaRo: EVALSHA_RO_1.default,
	    EVALSHA: EVALSHA_1.default,
	    evalSha: EVALSHA_1.default,
	    EXISTS: EXISTS_1.default,
	    exists: EXISTS_1.default,
	    EXPIRE: EXPIRE_1.default,
	    expire: EXPIRE_1.default,
	    EXPIREAT: EXPIREAT_1.default,
	    expireAt: EXPIREAT_1.default,
	    EXPIRETIME: EXPIRETIME_1.default,
	    expireTime: EXPIRETIME_1.default,
	    FLUSHALL: FLUSHALL_1.default,
	    flushAll: FLUSHALL_1.default,
	    FLUSHDB: FLUSHDB_1.default,
	    flushDb: FLUSHDB_1.default,
	    FCALL: FCALL_1.default,
	    fCall: FCALL_1.default,
	    FCALL_RO: FCALL_RO_1.default,
	    fCallRo: FCALL_RO_1.default,
	    FUNCTION_DELETE: FUNCTION_DELETE_1.default,
	    functionDelete: FUNCTION_DELETE_1.default,
	    FUNCTION_DUMP: FUNCTION_DUMP_1.default,
	    functionDump: FUNCTION_DUMP_1.default,
	    FUNCTION_FLUSH: FUNCTION_FLUSH_1.default,
	    functionFlush: FUNCTION_FLUSH_1.default,
	    FUNCTION_KILL: FUNCTION_KILL_1.default,
	    functionKill: FUNCTION_KILL_1.default,
	    FUNCTION_LIST_WITHCODE: FUNCTION_LIST_WITHCODE_1.default,
	    functionListWithCode: FUNCTION_LIST_WITHCODE_1.default,
	    FUNCTION_LIST: FUNCTION_LIST_1.default,
	    functionList: FUNCTION_LIST_1.default,
	    FUNCTION_LOAD: FUNCTION_LOAD_1.default,
	    functionLoad: FUNCTION_LOAD_1.default,
	    FUNCTION_RESTORE: FUNCTION_RESTORE_1.default,
	    functionRestore: FUNCTION_RESTORE_1.default,
	    FUNCTION_STATS: FUNCTION_STATS_1.default,
	    functionStats: FUNCTION_STATS_1.default,
	    GEOADD: GEOADD_1.default,
	    geoAdd: GEOADD_1.default,
	    GEODIST: GEODIST_1.default,
	    geoDist: GEODIST_1.default,
	    GEOHASH: GEOHASH_1.default,
	    geoHash: GEOHASH_1.default,
	    GEOPOS: GEOPOS_1.default,
	    geoPos: GEOPOS_1.default,
	    GEORADIUS_RO_WITH: GEORADIUS_RO_WITH_1.default,
	    geoRadiusRoWith: GEORADIUS_RO_WITH_1.default,
	    GEORADIUS_RO: GEORADIUS_RO_1.default,
	    geoRadiusRo: GEORADIUS_RO_1.default,
	    GEORADIUS_STORE: GEORADIUS_STORE_1.default,
	    geoRadiusStore: GEORADIUS_STORE_1.default,
	    GEORADIUS_WITH: GEORADIUS_WITH_1.default,
	    geoRadiusWith: GEORADIUS_WITH_1.default,
	    GEORADIUS: GEORADIUS_1.default,
	    geoRadius: GEORADIUS_1.default,
	    GEORADIUSBYMEMBER_RO_WITH: GEORADIUSBYMEMBER_RO_WITH_1.default,
	    geoRadiusByMemberRoWith: GEORADIUSBYMEMBER_RO_WITH_1.default,
	    GEORADIUSBYMEMBER_RO: GEORADIUSBYMEMBER_RO_1.default,
	    geoRadiusByMemberRo: GEORADIUSBYMEMBER_RO_1.default,
	    GEORADIUSBYMEMBER_STORE: GEORADIUSBYMEMBER_STORE_1.default,
	    geoRadiusByMemberStore: GEORADIUSBYMEMBER_STORE_1.default,
	    GEORADIUSBYMEMBER_WITH: GEORADIUSBYMEMBER_WITH_1.default,
	    geoRadiusByMemberWith: GEORADIUSBYMEMBER_WITH_1.default,
	    GEORADIUSBYMEMBER: GEORADIUSBYMEMBER_1.default,
	    geoRadiusByMember: GEORADIUSBYMEMBER_1.default,
	    GEOSEARCH_WITH: GEOSEARCH_WITH_1.default,
	    geoSearchWith: GEOSEARCH_WITH_1.default,
	    GEOSEARCH: GEOSEARCH_1.default,
	    geoSearch: GEOSEARCH_1.default,
	    GEOSEARCHSTORE: GEOSEARCHSTORE_1.default,
	    geoSearchStore: GEOSEARCHSTORE_1.default,
	    GET: GET_1.default,
	    get: GET_1.default,
	    GETBIT: GETBIT_1.default,
	    getBit: GETBIT_1.default,
	    GETDEL: GETDEL_1.default,
	    getDel: GETDEL_1.default,
	    GETEX: GETEX_1.default,
	    getEx: GETEX_1.default,
	    GETRANGE: GETRANGE_1.default,
	    getRange: GETRANGE_1.default,
	    GETSET: GETSET_1.default,
	    getSet: GETSET_1.default,
	    HDEL: HDEL_1.default,
	    hDel: HDEL_1.default,
	    HELLO: HELLO_1.default,
	    hello: HELLO_1.default,
	    HEXISTS: HEXISTS_1.default,
	    hExists: HEXISTS_1.default,
	    HEXPIRE: HEXPIRE_1.default,
	    hExpire: HEXPIRE_1.default,
	    HEXPIREAT: HEXPIREAT_1.default,
	    hExpireAt: HEXPIREAT_1.default,
	    HEXPIRETIME: HEXPIRETIME_1.default,
	    hExpireTime: HEXPIRETIME_1.default,
	    HGET: HGET_1.default,
	    hGet: HGET_1.default,
	    HGETALL: HGETALL_1.default,
	    hGetAll: HGETALL_1.default,
	    HGETDEL: HGETDEL_1.default,
	    hGetDel: HGETDEL_1.default,
	    HGETEX: HGETEX_1.default,
	    hGetEx: HGETEX_1.default,
	    HINCRBY: HINCRBY_1.default,
	    hIncrBy: HINCRBY_1.default,
	    HINCRBYFLOAT: HINCRBYFLOAT_1.default,
	    hIncrByFloat: HINCRBYFLOAT_1.default,
	    HKEYS: HKEYS_1.default,
	    hKeys: HKEYS_1.default,
	    HLEN: HLEN_1.default,
	    hLen: HLEN_1.default,
	    HMGET: HMGET_1.default,
	    hmGet: HMGET_1.default,
	    HPERSIST: HPERSIST_1.default,
	    hPersist: HPERSIST_1.default,
	    HPEXPIRE: HPEXPIRE_1.default,
	    hpExpire: HPEXPIRE_1.default,
	    HPEXPIREAT: HPEXPIREAT_1.default,
	    hpExpireAt: HPEXPIREAT_1.default,
	    HPEXPIRETIME: HPEXPIRETIME_1.default,
	    hpExpireTime: HPEXPIRETIME_1.default,
	    HPTTL: HPTTL_1.default,
	    hpTTL: HPTTL_1.default,
	    HRANDFIELD_COUNT_WITHVALUES: HRANDFIELD_COUNT_WITHVALUES_1.default,
	    hRandFieldCountWithValues: HRANDFIELD_COUNT_WITHVALUES_1.default,
	    HRANDFIELD_COUNT: HRANDFIELD_COUNT_1.default,
	    hRandFieldCount: HRANDFIELD_COUNT_1.default,
	    HRANDFIELD: HRANDFIELD_1.default,
	    hRandField: HRANDFIELD_1.default,
	    HSCAN: HSCAN_1.default,
	    hScan: HSCAN_1.default,
	    HSCAN_NOVALUES: HSCAN_NOVALUES_1.default,
	    hScanNoValues: HSCAN_NOVALUES_1.default,
	    HSET: HSET_1.default,
	    hSet: HSET_1.default,
	    HSETEX: HSETEX_1.default,
	    hSetEx: HSETEX_1.default,
	    HSETNX: HSETNX_1.default,
	    hSetNX: HSETNX_1.default,
	    HSTRLEN: HSTRLEN_1.default,
	    hStrLen: HSTRLEN_1.default,
	    HTTL: HTTL_1.default,
	    hTTL: HTTL_1.default,
	    HVALS: HVALS_1.default,
	    hVals: HVALS_1.default,
	    INCR: INCR_1.default,
	    incr: INCR_1.default,
	    INCRBY: INCRBY_1.default,
	    incrBy: INCRBY_1.default,
	    INCRBYFLOAT: INCRBYFLOAT_1.default,
	    incrByFloat: INCRBYFLOAT_1.default,
	    INFO: INFO_1.default,
	    info: INFO_1.default,
	    KEYS: KEYS_1.default,
	    keys: KEYS_1.default,
	    LASTSAVE: LASTSAVE_1.default,
	    lastSave: LASTSAVE_1.default,
	    LATENCY_DOCTOR: LATENCY_DOCTOR_1.default,
	    latencyDoctor: LATENCY_DOCTOR_1.default,
	    LATENCY_GRAPH: LATENCY_GRAPH_1.default,
	    latencyGraph: LATENCY_GRAPH_1.default,
	    LATENCY_HISTORY: LATENCY_HISTORY_1.default,
	    latencyHistory: LATENCY_HISTORY_1.default,
	    LATENCY_LATEST: LATENCY_LATEST_1.default,
	    latencyLatest: LATENCY_LATEST_1.default,
	    LCS_IDX_WITHMATCHLEN: LCS_IDX_WITHMATCHLEN_1.default,
	    lcsIdxWithMatchLen: LCS_IDX_WITHMATCHLEN_1.default,
	    LCS_IDX: LCS_IDX_1.default,
	    lcsIdx: LCS_IDX_1.default,
	    LCS_LEN: LCS_LEN_1.default,
	    lcsLen: LCS_LEN_1.default,
	    LCS: LCS_1.default,
	    lcs: LCS_1.default,
	    LINDEX: LINDEX_1.default,
	    lIndex: LINDEX_1.default,
	    LINSERT: LINSERT_1.default,
	    lInsert: LINSERT_1.default,
	    LLEN: LLEN_1.default,
	    lLen: LLEN_1.default,
	    LMOVE: LMOVE_1.default,
	    lMove: LMOVE_1.default,
	    LMPOP: LMPOP_1.default,
	    lmPop: LMPOP_1.default,
	    LOLWUT: LOLWUT_1.default,
	    LPOP_COUNT: LPOP_COUNT_1.default,
	    lPopCount: LPOP_COUNT_1.default,
	    LPOP: LPOP_1.default,
	    lPop: LPOP_1.default,
	    LPOS_COUNT: LPOS_COUNT_1.default,
	    lPosCount: LPOS_COUNT_1.default,
	    LPOS: LPOS_1.default,
	    lPos: LPOS_1.default,
	    LPUSH: LPUSH_1.default,
	    lPush: LPUSH_1.default,
	    LPUSHX: LPUSHX_1.default,
	    lPushX: LPUSHX_1.default,
	    LRANGE: LRANGE_1.default,
	    lRange: LRANGE_1.default,
	    LREM: LREM_1.default,
	    lRem: LREM_1.default,
	    LSET: LSET_1.default,
	    lSet: LSET_1.default,
	    LTRIM: LTRIM_1.default,
	    lTrim: LTRIM_1.default,
	    MEMORY_DOCTOR: MEMORY_DOCTOR_1.default,
	    memoryDoctor: MEMORY_DOCTOR_1.default,
	    'MEMORY_MALLOC-STATS': MEMORY_MALLOC_STATS_1.default,
	    memoryMallocStats: MEMORY_MALLOC_STATS_1.default,
	    MEMORY_PURGE: MEMORY_PURGE_1.default,
	    memoryPurge: MEMORY_PURGE_1.default,
	    MEMORY_STATS: MEMORY_STATS_1.default,
	    memoryStats: MEMORY_STATS_1.default,
	    MEMORY_USAGE: MEMORY_USAGE_1.default,
	    memoryUsage: MEMORY_USAGE_1.default,
	    MGET: MGET_1.default,
	    mGet: MGET_1.default,
	    MIGRATE: MIGRATE_1.default,
	    migrate: MIGRATE_1.default,
	    MODULE_LIST: MODULE_LIST_1.default,
	    moduleList: MODULE_LIST_1.default,
	    MODULE_LOAD: MODULE_LOAD_1.default,
	    moduleLoad: MODULE_LOAD_1.default,
	    MODULE_UNLOAD: MODULE_UNLOAD_1.default,
	    moduleUnload: MODULE_UNLOAD_1.default,
	    MOVE: MOVE_1.default,
	    move: MOVE_1.default,
	    MSET: MSET_1.default,
	    mSet: MSET_1.default,
	    MSETNX: MSETNX_1.default,
	    mSetNX: MSETNX_1.default,
	    OBJECT_ENCODING: OBJECT_ENCODING_1.default,
	    objectEncoding: OBJECT_ENCODING_1.default,
	    OBJECT_FREQ: OBJECT_FREQ_1.default,
	    objectFreq: OBJECT_FREQ_1.default,
	    OBJECT_IDLETIME: OBJECT_IDLETIME_1.default,
	    objectIdleTime: OBJECT_IDLETIME_1.default,
	    OBJECT_REFCOUNT: OBJECT_REFCOUNT_1.default,
	    objectRefCount: OBJECT_REFCOUNT_1.default,
	    PERSIST: PERSIST_1.default,
	    persist: PERSIST_1.default,
	    PEXPIRE: PEXPIRE_1.default,
	    pExpire: PEXPIRE_1.default,
	    PEXPIREAT: PEXPIREAT_1.default,
	    pExpireAt: PEXPIREAT_1.default,
	    PEXPIRETIME: PEXPIRETIME_1.default,
	    pExpireTime: PEXPIRETIME_1.default,
	    PFADD: PFADD_1.default,
	    pfAdd: PFADD_1.default,
	    PFCOUNT: PFCOUNT_1.default,
	    pfCount: PFCOUNT_1.default,
	    PFMERGE: PFMERGE_1.default,
	    pfMerge: PFMERGE_1.default,
	    PING: PING_1.default,
	    /**
	     * ping jsdoc
	     */
	    ping: PING_1.default,
	    PSETEX: PSETEX_1.default,
	    pSetEx: PSETEX_1.default,
	    PTTL: PTTL_1.default,
	    pTTL: PTTL_1.default,
	    PUBLISH: PUBLISH_1.default,
	    publish: PUBLISH_1.default,
	    PUBSUB_CHANNELS: PUBSUB_CHANNELS_1.default,
	    pubSubChannels: PUBSUB_CHANNELS_1.default,
	    PUBSUB_NUMPAT: PUBSUB_NUMPAT_1.default,
	    pubSubNumPat: PUBSUB_NUMPAT_1.default,
	    PUBSUB_NUMSUB: PUBSUB_NUMSUB_1.default,
	    pubSubNumSub: PUBSUB_NUMSUB_1.default,
	    PUBSUB_SHARDNUMSUB: PUBSUB_SHARDNUMSUB_1.default,
	    pubSubShardNumSub: PUBSUB_SHARDNUMSUB_1.default,
	    PUBSUB_SHARDCHANNELS: PUBSUB_SHARDCHANNELS_1.default,
	    pubSubShardChannels: PUBSUB_SHARDCHANNELS_1.default,
	    RANDOMKEY: RANDOMKEY_1.default,
	    randomKey: RANDOMKEY_1.default,
	    READONLY: READONLY_1.default,
	    readonly: READONLY_1.default,
	    RENAME: RENAME_1.default,
	    rename: RENAME_1.default,
	    RENAMENX: RENAMENX_1.default,
	    renameNX: RENAMENX_1.default,
	    REPLICAOF: REPLICAOF_1.default,
	    replicaOf: REPLICAOF_1.default,
	    'RESTORE-ASKING': RESTORE_ASKING_1.default,
	    restoreAsking: RESTORE_ASKING_1.default,
	    RESTORE: RESTORE_1.default,
	    restore: RESTORE_1.default,
	    RPOP_COUNT: RPOP_COUNT_1.default,
	    rPopCount: RPOP_COUNT_1.default,
	    ROLE: ROLE_1.default,
	    role: ROLE_1.default,
	    RPOP: RPOP_1.default,
	    rPop: RPOP_1.default,
	    RPOPLPUSH: RPOPLPUSH_1.default,
	    rPopLPush: RPOPLPUSH_1.default,
	    RPUSH: RPUSH_1.default,
	    rPush: RPUSH_1.default,
	    RPUSHX: RPUSHX_1.default,
	    rPushX: RPUSHX_1.default,
	    SADD: SADD_1.default,
	    sAdd: SADD_1.default,
	    SCAN: SCAN_1.default,
	    scan: SCAN_1.default,
	    SCARD: SCARD_1.default,
	    sCard: SCARD_1.default,
	    SCRIPT_DEBUG: SCRIPT_DEBUG_1.default,
	    scriptDebug: SCRIPT_DEBUG_1.default,
	    SCRIPT_EXISTS: SCRIPT_EXISTS_1.default,
	    scriptExists: SCRIPT_EXISTS_1.default,
	    SCRIPT_FLUSH: SCRIPT_FLUSH_1.default,
	    scriptFlush: SCRIPT_FLUSH_1.default,
	    SCRIPT_KILL: SCRIPT_KILL_1.default,
	    scriptKill: SCRIPT_KILL_1.default,
	    SCRIPT_LOAD: SCRIPT_LOAD_1.default,
	    scriptLoad: SCRIPT_LOAD_1.default,
	    SDIFF: SDIFF_1.default,
	    sDiff: SDIFF_1.default,
	    SDIFFSTORE: SDIFFSTORE_1.default,
	    sDiffStore: SDIFFSTORE_1.default,
	    SET: SET_1.default,
	    set: SET_1.default,
	    SETBIT: SETBIT_1.default,
	    setBit: SETBIT_1.default,
	    SETEX: SETEX_1.default,
	    setEx: SETEX_1.default,
	    SETNX: SETNX_1.default,
	    setNX: SETNX_1.default,
	    SETRANGE: SETRANGE_1.default,
	    setRange: SETRANGE_1.default,
	    SINTER: SINTER_1.default,
	    sInter: SINTER_1.default,
	    SINTERCARD: SINTERCARD_1.default,
	    sInterCard: SINTERCARD_1.default,
	    SINTERSTORE: SINTERSTORE_1.default,
	    sInterStore: SINTERSTORE_1.default,
	    SISMEMBER: SISMEMBER_1.default,
	    sIsMember: SISMEMBER_1.default,
	    SMEMBERS: SMEMBERS_1.default,
	    sMembers: SMEMBERS_1.default,
	    SMISMEMBER: SMISMEMBER_1.default,
	    smIsMember: SMISMEMBER_1.default,
	    SMOVE: SMOVE_1.default,
	    sMove: SMOVE_1.default,
	    SORT_RO: SORT_RO_1.default,
	    sortRo: SORT_RO_1.default,
	    SORT_STORE: SORT_STORE_1.default,
	    sortStore: SORT_STORE_1.default,
	    SORT: SORT_1.default,
	    sort: SORT_1.default,
	    SPOP_COUNT: SPOP_COUNT_1.default,
	    sPopCount: SPOP_COUNT_1.default,
	    SPOP: SPOP_1.default,
	    sPop: SPOP_1.default,
	    SPUBLISH: SPUBLISH_1.default,
	    sPublish: SPUBLISH_1.default,
	    SRANDMEMBER_COUNT: SRANDMEMBER_COUNT_1.default,
	    sRandMemberCount: SRANDMEMBER_COUNT_1.default,
	    SRANDMEMBER: SRANDMEMBER_1.default,
	    sRandMember: SRANDMEMBER_1.default,
	    SREM: SREM_1.default,
	    sRem: SREM_1.default,
	    SSCAN: SSCAN_1.default,
	    sScan: SSCAN_1.default,
	    STRLEN: STRLEN_1.default,
	    strLen: STRLEN_1.default,
	    SUNION: SUNION_1.default,
	    sUnion: SUNION_1.default,
	    SUNIONSTORE: SUNIONSTORE_1.default,
	    sUnionStore: SUNIONSTORE_1.default,
	    SWAPDB: SWAPDB_1.default,
	    swapDb: SWAPDB_1.default,
	    TIME: TIME_1.default,
	    time: TIME_1.default,
	    TOUCH: TOUCH_1.default,
	    touch: TOUCH_1.default,
	    TTL: TTL_1.default,
	    ttl: TTL_1.default,
	    TYPE: TYPE_1.default,
	    type: TYPE_1.default,
	    UNLINK: UNLINK_1.default,
	    unlink: UNLINK_1.default,
	    WAIT: WAIT_1.default,
	    wait: WAIT_1.default,
	    XACK: XACK_1.default,
	    xAck: XACK_1.default,
	    XADD_NOMKSTREAM: XADD_NOMKSTREAM_1.default,
	    xAddNoMkStream: XADD_NOMKSTREAM_1.default,
	    XADD: XADD_1.default,
	    xAdd: XADD_1.default,
	    XAUTOCLAIM_JUSTID: XAUTOCLAIM_JUSTID_1.default,
	    xAutoClaimJustId: XAUTOCLAIM_JUSTID_1.default,
	    XAUTOCLAIM: XAUTOCLAIM_1.default,
	    xAutoClaim: XAUTOCLAIM_1.default,
	    XCLAIM_JUSTID: XCLAIM_JUSTID_1.default,
	    xClaimJustId: XCLAIM_JUSTID_1.default,
	    XCLAIM: XCLAIM_1.default,
	    xClaim: XCLAIM_1.default,
	    XDEL: XDEL_1.default,
	    xDel: XDEL_1.default,
	    XGROUP_CREATE: XGROUP_CREATE_1.default,
	    xGroupCreate: XGROUP_CREATE_1.default,
	    XGROUP_CREATECONSUMER: XGROUP_CREATECONSUMER_1.default,
	    xGroupCreateConsumer: XGROUP_CREATECONSUMER_1.default,
	    XGROUP_DELCONSUMER: XGROUP_DELCONSUMER_1.default,
	    xGroupDelConsumer: XGROUP_DELCONSUMER_1.default,
	    XGROUP_DESTROY: XGROUP_DESTROY_1.default,
	    xGroupDestroy: XGROUP_DESTROY_1.default,
	    XGROUP_SETID: XGROUP_SETID_1.default,
	    xGroupSetId: XGROUP_SETID_1.default,
	    XINFO_CONSUMERS: XINFO_CONSUMERS_1.default,
	    xInfoConsumers: XINFO_CONSUMERS_1.default,
	    XINFO_GROUPS: XINFO_GROUPS_1.default,
	    xInfoGroups: XINFO_GROUPS_1.default,
	    XINFO_STREAM: XINFO_STREAM_1.default,
	    xInfoStream: XINFO_STREAM_1.default,
	    XLEN: XLEN_1.default,
	    xLen: XLEN_1.default,
	    XPENDING_RANGE: XPENDING_RANGE_1.default,
	    xPendingRange: XPENDING_RANGE_1.default,
	    XPENDING: XPENDING_1.default,
	    xPending: XPENDING_1.default,
	    XRANGE: XRANGE_1.default,
	    xRange: XRANGE_1.default,
	    XREAD: XREAD_1.default,
	    xRead: XREAD_1.default,
	    XREADGROUP: XREADGROUP_1.default,
	    xReadGroup: XREADGROUP_1.default,
	    XREVRANGE: XREVRANGE_1.default,
	    xRevRange: XREVRANGE_1.default,
	    XSETID: XSETID_1.default,
	    xSetId: XSETID_1.default,
	    XTRIM: XTRIM_1.default,
	    xTrim: XTRIM_1.default,
	    ZADD_INCR: ZADD_INCR_1.default,
	    zAddIncr: ZADD_INCR_1.default,
	    ZADD: ZADD_1.default,
	    zAdd: ZADD_1.default,
	    ZCARD: ZCARD_1.default,
	    zCard: ZCARD_1.default,
	    ZCOUNT: ZCOUNT_1.default,
	    zCount: ZCOUNT_1.default,
	    ZDIFF_WITHSCORES: ZDIFF_WITHSCORES_1.default,
	    zDiffWithScores: ZDIFF_WITHSCORES_1.default,
	    ZDIFF: ZDIFF_1.default,
	    zDiff: ZDIFF_1.default,
	    ZDIFFSTORE: ZDIFFSTORE_1.default,
	    zDiffStore: ZDIFFSTORE_1.default,
	    ZINCRBY: ZINCRBY_1.default,
	    zIncrBy: ZINCRBY_1.default,
	    ZINTER_WITHSCORES: ZINTER_WITHSCORES_1.default,
	    zInterWithScores: ZINTER_WITHSCORES_1.default,
	    ZINTER: ZINTER_1.default,
	    zInter: ZINTER_1.default,
	    ZINTERCARD: ZINTERCARD_1.default,
	    zInterCard: ZINTERCARD_1.default,
	    ZINTERSTORE: ZINTERSTORE_1.default,
	    zInterStore: ZINTERSTORE_1.default,
	    ZLEXCOUNT: ZLEXCOUNT_1.default,
	    zLexCount: ZLEXCOUNT_1.default,
	    ZMPOP: ZMPOP_1.default,
	    zmPop: ZMPOP_1.default,
	    ZMSCORE: ZMSCORE_1.default,
	    zmScore: ZMSCORE_1.default,
	    ZPOPMAX_COUNT: ZPOPMAX_COUNT_1.default,
	    zPopMaxCount: ZPOPMAX_COUNT_1.default,
	    ZPOPMAX: ZPOPMAX_1.default,
	    zPopMax: ZPOPMAX_1.default,
	    ZPOPMIN_COUNT: ZPOPMIN_COUNT_1.default,
	    zPopMinCount: ZPOPMIN_COUNT_1.default,
	    ZPOPMIN: ZPOPMIN_1.default,
	    zPopMin: ZPOPMIN_1.default,
	    ZRANDMEMBER_COUNT_WITHSCORES: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
	    zRandMemberCountWithScores: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
	    ZRANDMEMBER_COUNT: ZRANDMEMBER_COUNT_1.default,
	    zRandMemberCount: ZRANDMEMBER_COUNT_1.default,
	    ZRANDMEMBER: ZRANDMEMBER_1.default,
	    zRandMember: ZRANDMEMBER_1.default,
	    ZRANGE_WITHSCORES: ZRANGE_WITHSCORES_1.default,
	    zRangeWithScores: ZRANGE_WITHSCORES_1.default,
	    ZRANGE: ZRANGE_1.default,
	    zRange: ZRANGE_1.default,
	    ZRANGEBYLEX: ZRANGEBYLEX_1.default,
	    zRangeByLex: ZRANGEBYLEX_1.default,
	    ZRANGEBYSCORE_WITHSCORES: ZRANGEBYSCORE_WITHSCORES_1.default,
	    zRangeByScoreWithScores: ZRANGEBYSCORE_WITHSCORES_1.default,
	    ZRANGEBYSCORE: ZRANGEBYSCORE_1.default,
	    zRangeByScore: ZRANGEBYSCORE_1.default,
	    ZRANGESTORE: ZRANGESTORE_1.default,
	    zRangeStore: ZRANGESTORE_1.default,
	    ZRANK_WITHSCORE: ZRANK_WITHSCORE_1.default,
	    zRankWithScore: ZRANK_WITHSCORE_1.default,
	    ZRANK: ZRANK_1.default,
	    zRank: ZRANK_1.default,
	    ZREM: ZREM_1.default,
	    zRem: ZREM_1.default,
	    ZREMRANGEBYLEX: ZREMRANGEBYLEX_1.default,
	    zRemRangeByLex: ZREMRANGEBYLEX_1.default,
	    ZREMRANGEBYRANK: ZREMRANGEBYRANK_1.default,
	    zRemRangeByRank: ZREMRANGEBYRANK_1.default,
	    ZREMRANGEBYSCORE: ZREMRANGEBYSCORE_1.default,
	    zRemRangeByScore: ZREMRANGEBYSCORE_1.default,
	    ZREVRANK: ZREVRANK_1.default,
	    zRevRank: ZREVRANK_1.default,
	    ZSCAN: ZSCAN_1.default,
	    zScan: ZSCAN_1.default,
	    ZSCORE: ZSCORE_1.default,
	    zScore: ZSCORE_1.default,
	    ZUNION_WITHSCORES: ZUNION_WITHSCORES_1.default,
	    zUnionWithScores: ZUNION_WITHSCORES_1.default,
	    ZUNION: ZUNION_1.default,
	    zUnion: ZUNION_1.default,
	    ZUNIONSTORE: ZUNIONSTORE_1.default,
	    zUnionStore: ZUNIONSTORE_1.default,
	    VADD: VADD_1.default,
	    vAdd: VADD_1.default,
	    VCARD: VCARD_1.default,
	    vCard: VCARD_1.default,
	    VDIM: VDIM_1.default,
	    vDim: VDIM_1.default,
	    VEMB: VEMB_1.default,
	    vEmb: VEMB_1.default,
	    VEMB_RAW: VEMB_RAW_1.default,
	    vEmbRaw: VEMB_RAW_1.default,
	    VGETATTR: VGETATTR_1.default,
	    vGetAttr: VGETATTR_1.default,
	    VINFO: VINFO_1.default,
	    vInfo: VINFO_1.default,
	    VLINKS: VLINKS_1.default,
	    vLinks: VLINKS_1.default,
	    VLINKS_WITHSCORES: VLINKS_WITHSCORES_1.default,
	    vLinksWithScores: VLINKS_WITHSCORES_1.default,
	    VRANDMEMBER: VRANDMEMBER_1.default,
	    vRandMember: VRANDMEMBER_1.default,
	    VREM: VREM_1.default,
	    vRem: VREM_1.default,
	    VSETATTR: VSETATTR_1.default,
	    vSetAttr: VSETATTR_1.default,
	    VSIM: VSIM_1.default,
	    vSim: VSIM_1.default,
	    VSIM_WITHSCORES: VSIM_WITHSCORES_1.default,
	    vSimWithScores: VSIM_WITHSCORES_1.default
	};
	
	return commands$5;
}

var socket = {};

var hasRequiredSocket;

function requireSocket () {
	if (hasRequiredSocket) return socket;
	hasRequiredSocket = 1;
	var __importDefault = (socket && socket.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(socket, "__esModule", { value: true });
	const node_events_1 = require$$0$5;
	const node_net_1 = __importDefault(require$$1$1);
	const node_tls_1 = __importDefault(require$$2);
	const errors_1 = requireErrors$1();
	const promises_1 = require$$4$1;
	class RedisSocket extends node_events_1.EventEmitter {
	    #initiator;
	    #connectTimeout;
	    #reconnectStrategy;
	    #socketFactory;
	    #socketTimeout;
	    #socket;
	    #isOpen = false;
	    get isOpen() {
	        return this.#isOpen;
	    }
	    #isReady = false;
	    get isReady() {
	        return this.#isReady;
	    }
	    #isSocketUnrefed = false;
	    #socketEpoch = 0;
	    get socketEpoch() {
	        return this.#socketEpoch;
	    }
	    constructor(initiator, options) {
	        super();
	        this.#initiator = initiator;
	        this.#connectTimeout = options?.connectTimeout ?? 5000;
	        this.#reconnectStrategy = this.#createReconnectStrategy(options);
	        this.#socketFactory = this.#createSocketFactory(options);
	        this.#socketTimeout = options?.socketTimeout;
	    }
	    #createReconnectStrategy(options) {
	        const strategy = options?.reconnectStrategy;
	        if (strategy === false || typeof strategy === 'number') {
	            return () => strategy;
	        }
	        if (strategy) {
	            return (retries, cause) => {
	                try {
	                    const retryIn = strategy(retries, cause);
	                    if (retryIn !== false && !(retryIn instanceof Error) && typeof retryIn !== 'number') {
	                        throw new TypeError(`Reconnect strategy should return \`false | Error | number\`, got ${retryIn} instead`);
	                    }
	                    return retryIn;
	                }
	                catch (err) {
	                    this.emit('error', err);
	                    return this.defaultReconnectStrategy(retries, err);
	                }
	            };
	        }
	        return this.defaultReconnectStrategy;
	    }
	    #createSocketFactory(options) {
	        // TLS
	        if (options?.tls === true) {
	            const withDefaults = {
	                ...options,
	                port: options?.port ?? 6379,
	                // https://nodejs.org/api/tls.html#tlsconnectoptions-callback "Any socket.connect() option not already listed"
	                // @types/node is... incorrect...
	                // @ts-expect-error
	                noDelay: options?.noDelay ?? true,
	                // https://nodejs.org/api/tls.html#tlsconnectoptions-callback "Any socket.connect() option not already listed"
	                // @types/node is... incorrect...
	                // @ts-expect-error
	                keepAlive: options?.keepAlive ?? true,
	                // https://nodejs.org/api/tls.html#tlsconnectoptions-callback "Any socket.connect() option not already listed"
	                // @types/node is... incorrect...
	                // @ts-expect-error
	                keepAliveInitialDelay: options?.keepAliveInitialDelay ?? 5000,
	                timeout: undefined,
	                onread: undefined,
	                readable: true,
	                writable: true
	            };
	            return {
	                create() {
	                    return node_tls_1.default.connect(withDefaults);
	                },
	                event: 'secureConnect'
	            };
	        }
	        // IPC
	        if (options && 'path' in options) {
	            const withDefaults = {
	                ...options,
	                timeout: undefined,
	                onread: undefined,
	                readable: true,
	                writable: true
	            };
	            return {
	                create() {
	                    return node_net_1.default.createConnection(withDefaults);
	                },
	                event: 'connect'
	            };
	        }
	        // TCP
	        const withDefaults = {
	            ...options,
	            port: options?.port ?? 6379,
	            noDelay: options?.noDelay ?? true,
	            keepAlive: options?.keepAlive ?? true,
	            keepAliveInitialDelay: options?.keepAliveInitialDelay ?? 5000,
	            timeout: undefined,
	            onread: undefined,
	            readable: true,
	            writable: true
	        };
	        return {
	            create() {
	                return node_net_1.default.createConnection(withDefaults);
	            },
	            event: 'connect'
	        };
	    }
	    #shouldReconnect(retries, cause) {
	        const retryIn = this.#reconnectStrategy(retries, cause);
	        if (retryIn === false) {
	            this.#isOpen = false;
	            this.emit('error', cause);
	            return cause;
	        }
	        else if (retryIn instanceof Error) {
	            this.#isOpen = false;
	            this.emit('error', cause);
	            return new errors_1.ReconnectStrategyError(retryIn, cause);
	        }
	        return retryIn;
	    }
	    async connect() {
	        if (this.#isOpen) {
	            throw new Error('Socket already opened');
	        }
	        this.#isOpen = true;
	        return this.#connect();
	    }
	    async #connect() {
	        let retries = 0;
	        do {
	            try {
	                this.#socket = await this.#createSocket();
	                this.emit('connect');
	                try {
	                    await this.#initiator();
	                }
	                catch (err) {
	                    this.#socket.destroy();
	                    this.#socket = undefined;
	                    throw err;
	                }
	                this.#isReady = true;
	                this.#socketEpoch++;
	                this.emit('ready');
	            }
	            catch (err) {
	                const retryIn = this.#shouldReconnect(retries++, err);
	                if (typeof retryIn !== 'number') {
	                    throw retryIn;
	                }
	                this.emit('error', err);
	                await (0, promises_1.setTimeout)(retryIn);
	                this.emit('reconnecting');
	            }
	        } while (this.#isOpen && !this.#isReady);
	    }
	    async #createSocket() {
	        const socket = this.#socketFactory.create();
	        let onTimeout;
	        if (this.#connectTimeout !== undefined) {
	            onTimeout = () => socket.destroy(new errors_1.ConnectionTimeoutError());
	            socket.once('timeout', onTimeout);
	            socket.setTimeout(this.#connectTimeout);
	        }
	        if (this.#isSocketUnrefed) {
	            socket.unref();
	        }
	        await (0, node_events_1.once)(socket, this.#socketFactory.event);
	        if (onTimeout) {
	            socket.removeListener('timeout', onTimeout);
	        }
	        if (this.#socketTimeout) {
	            socket.once('timeout', () => {
	                socket.destroy(new errors_1.SocketTimeoutError(this.#socketTimeout));
	            });
	            socket.setTimeout(this.#socketTimeout);
	        }
	        socket
	            .once('error', err => this.#onSocketError(err))
	            .once('close', hadError => {
	            if (hadError || !this.#isOpen || this.#socket !== socket)
	                return;
	            this.#onSocketError(new errors_1.SocketClosedUnexpectedlyError());
	        })
	            .on('drain', () => this.emit('drain'))
	            .on('data', data => this.emit('data', data));
	        return socket;
	    }
	    #onSocketError(err) {
	        const wasReady = this.#isReady;
	        this.#isReady = false;
	        this.emit('error', err);
	        if (!wasReady || !this.#isOpen || typeof this.#shouldReconnect(0, err) !== 'number')
	            return;
	        this.emit('reconnecting');
	        this.#connect().catch(() => {
	            // the error was already emitted, silently ignore it
	        });
	    }
	    write(iterable) {
	        if (!this.#socket)
	            return;
	        this.#socket.cork();
	        for (const args of iterable) {
	            for (const toWrite of args) {
	                this.#socket.write(toWrite);
	            }
	            if (this.#socket.writableNeedDrain)
	                break;
	        }
	        this.#socket.uncork();
	    }
	    async quit(fn) {
	        if (!this.#isOpen) {
	            throw new errors_1.ClientClosedError();
	        }
	        this.#isOpen = false;
	        const reply = await fn();
	        this.destroySocket();
	        return reply;
	    }
	    close() {
	        if (!this.#isOpen) {
	            throw new errors_1.ClientClosedError();
	        }
	        this.#isOpen = false;
	    }
	    destroy() {
	        if (!this.#isOpen) {
	            throw new errors_1.ClientClosedError();
	        }
	        this.#isOpen = false;
	        this.destroySocket();
	    }
	    destroySocket() {
	        this.#isReady = false;
	        if (this.#socket) {
	            this.#socket.destroy();
	            this.#socket = undefined;
	        }
	        this.emit('end');
	    }
	    ref() {
	        this.#isSocketUnrefed = false;
	        this.#socket?.ref();
	    }
	    unref() {
	        this.#isSocketUnrefed = true;
	        this.#socket?.unref();
	    }
	    defaultReconnectStrategy(retries, cause) {
	        // By default, do not reconnect on socket timeout.
	        if (cause instanceof errors_1.SocketTimeoutError) {
	            return false;
	        }
	        // Generate a random jitter between 0  200 ms:
	        const jitter = Math.floor(Math.random() * 200);
	        // Delay is an exponential back off, (times^2) * 50 ms, with a maximum value of 2000 ms:
	        const delay = Math.min(Math.pow(2, retries) * 50, 2000);
	        return delay + jitter;
	    }
	}
	socket.default = RedisSocket;
	
	return socket;
}

var authx = {};

var tokenManager = {};

var token = {};

var hasRequiredToken;

function requireToken () {
	if (hasRequiredToken) return token;
	hasRequiredToken = 1;
	Object.defineProperty(token, "__esModule", { value: true });
	token.Token = void 0;
	/**
	 * A token that can be used to authenticate with a service.
	 */
	class Token {
	    value;
	    expiresAtMs;
	    receivedAtMs;
	    constructor(value, 
	    //represents the token deadline - the time in milliseconds since the Unix epoch at which the token expires
	    expiresAtMs, 
	    //represents the time in milliseconds since the Unix epoch at which the token was received
	    receivedAtMs) {
	        this.value = value;
	        this.expiresAtMs = expiresAtMs;
	        this.receivedAtMs = receivedAtMs;
	    }
	    /**
	     * Returns the time-to-live of the token in milliseconds.
	     * @param now The current time in milliseconds since the Unix epoch.
	     */
	    getTtlMs(now) {
	        if (this.expiresAtMs < now) {
	            return 0;
	        }
	        return this.expiresAtMs - now;
	    }
	}
	token.Token = Token;
	
	return token;
}

var hasRequiredTokenManager;

function requireTokenManager () {
	if (hasRequiredTokenManager) return tokenManager;
	hasRequiredTokenManager = 1;
	Object.defineProperty(tokenManager, "__esModule", { value: true });
	tokenManager.TokenManager = tokenManager.IDPError = void 0;
	const token_1 = requireToken();
	/**
	 * IDPError indicates a failure from the identity provider.
	 *
	 * The `isRetryable` flag is determined by the RetryPolicy's error classification function - if an error is
	 * classified as retryable, it will be marked as transient and the token manager will attempt to recover.
	 */
	class IDPError extends Error {
	    message;
	    isRetryable;
	    constructor(message, isRetryable) {
	        super(message);
	        this.message = message;
	        this.isRetryable = isRetryable;
	        this.name = 'IDPError';
	    }
	}
	tokenManager.IDPError = IDPError;
	/**
	 * TokenManager is responsible for obtaining/refreshing tokens and notifying listeners about token changes.
	 * It uses an IdentityProvider to request tokens. The token refresh is scheduled based on the token's TTL and
	 * the expirationRefreshRatio configuration.
	 *
	 * The TokenManager should be disposed when it is no longer needed by calling the dispose method on the Disposable
	 * returned by start.
	 */
	class TokenManager {
	    identityProvider;
	    config;
	    currentToken = null;
	    refreshTimeout = null;
	    listener = null;
	    retryAttempt = 0;
	    constructor(identityProvider, config) {
	        this.identityProvider = identityProvider;
	        this.config = config;
	        if (this.config.expirationRefreshRatio > 1) {
	            throw new Error('expirationRefreshRatio must be less than or equal to 1');
	        }
	        if (this.config.expirationRefreshRatio < 0) {
	            throw new Error('expirationRefreshRatio must be greater or equal to 0');
	        }
	    }
	    /**
	     * Starts the token manager and returns a Disposable that can be used to stop the token manager.
	     *
	     * @param listener The listener that will receive token updates.
	     * @param initialDelayMs The initial delay in milliseconds before the first token refresh.
	     */
	    start(listener, initialDelayMs = 0) {
	        if (this.listener) {
	            this.stop();
	        }
	        this.listener = listener;
	        this.retryAttempt = 0;
	        this.scheduleNextRefresh(initialDelayMs);
	        return {
	            dispose: () => this.stop()
	        };
	    }
	    calculateRetryDelay() {
	        if (!this.config.retry)
	            return 0;
	        const { initialDelayMs, maxDelayMs, backoffMultiplier, jitterPercentage } = this.config.retry;
	        let delay = initialDelayMs * Math.pow(backoffMultiplier, this.retryAttempt - 1);
	        delay = Math.min(delay, maxDelayMs);
	        if (jitterPercentage) {
	            const jitterRange = delay * (jitterPercentage / 100);
	            const jitterAmount = Math.random() * jitterRange - (jitterRange / 2);
	            delay += jitterAmount;
	        }
	        let result = Math.max(0, Math.floor(delay));
	        return result;
	    }
	    shouldRetry(error) {
	        if (!this.config.retry)
	            return false;
	        const { maxAttempts, isRetryable } = this.config.retry;
	        if (this.retryAttempt >= maxAttempts) {
	            return false;
	        }
	        if (isRetryable) {
	            return isRetryable(error, this.retryAttempt);
	        }
	        return false;
	    }
	    isRunning() {
	        return this.listener !== null;
	    }
	    async refresh() {
	        if (!this.listener) {
	            throw new Error('TokenManager is not running, but refresh was called');
	        }
	        try {
	            await this.identityProvider.requestToken().then(this.handleNewToken);
	            this.retryAttempt = 0;
	        }
	        catch (error) {
	            if (this.shouldRetry(error)) {
	                this.retryAttempt++;
	                const retryDelay = this.calculateRetryDelay();
	                this.notifyError(`Token refresh failed (attempt ${this.retryAttempt}), retrying in ${retryDelay}ms: ${error}`, true);
	                this.scheduleNextRefresh(retryDelay);
	            }
	            else {
	                this.notifyError(error, false);
	                this.stop();
	            }
	        }
	    }
	    handleNewToken = async ({ token: nativeToken, ttlMs }) => {
	        if (!this.listener) {
	            throw new Error('TokenManager is not running, but a new token was received');
	        }
	        const token = this.wrapAndSetCurrentToken(nativeToken, ttlMs);
	        this.listener.onNext(token);
	        this.scheduleNextRefresh(this.calculateRefreshTime(token));
	    };
	    /**
	     * Creates a Token object from a native token and sets it as the current token.
	     *
	     * @param nativeToken - The raw token received from the identity provider
	     * @param ttlMs - Time-to-live in milliseconds for the token
	     *
	     * @returns A new Token instance containing the wrapped native token and expiration details
	     *
	     */
	    wrapAndSetCurrentToken(nativeToken, ttlMs) {
	        const now = Date.now();
	        const token = new token_1.Token(nativeToken, now + ttlMs, now);
	        this.currentToken = token;
	        return token;
	    }
	    scheduleNextRefresh(delayMs) {
	        if (this.refreshTimeout) {
	            clearTimeout(this.refreshTimeout);
	            this.refreshTimeout = null;
	        }
	        if (delayMs === 0) {
	            this.refresh();
	        }
	        else {
	            this.refreshTimeout = setTimeout(() => this.refresh(), delayMs);
	        }
	    }
	    /**
	     * Calculates the time in milliseconds when the token should be refreshed
	     * based on the token's TTL and the expirationRefreshRatio configuration.
	     *
	     * @param token The token to calculate the refresh time for.
	     * @param now The current time in milliseconds. Defaults to Date.now().
	     */
	    calculateRefreshTime(token, now = Date.now()) {
	        const ttlMs = token.getTtlMs(now);
	        return Math.floor(ttlMs * this.config.expirationRefreshRatio);
	    }
	    stop() {
	        if (this.refreshTimeout) {
	            clearTimeout(this.refreshTimeout);
	            this.refreshTimeout = null;
	        }
	        this.listener = null;
	        this.currentToken = null;
	        this.retryAttempt = 0;
	    }
	    /**
	     * Returns the current token or null if no token is available.
	     */
	    getCurrentToken() {
	        return this.currentToken;
	    }
	    notifyError(error, isRetryable) {
	        const errorMessage = error instanceof Error ? error.message : String(error);
	        if (!this.listener) {
	            throw new Error(`TokenManager is not running but received an error: ${errorMessage}`);
	        }
	        this.listener.onError(new IDPError(errorMessage, isRetryable));
	    }
	}
	tokenManager.TokenManager = TokenManager;
	
	return tokenManager;
}

var credentialsProvider = {};

var hasRequiredCredentialsProvider;

function requireCredentialsProvider () {
	if (hasRequiredCredentialsProvider) return credentialsProvider;
	hasRequiredCredentialsProvider = 1;
	Object.defineProperty(credentialsProvider, "__esModule", { value: true });
	credentialsProvider.UnableToObtainNewCredentialsError = credentialsProvider.CredentialsError = void 0;
	/**
	 * Thrown when re-authentication fails with provided credentials .
	 * e.g. when the credentials are invalid, expired or revoked.
	 *
	 */
	class CredentialsError extends Error {
	    constructor(message) {
	        super(`Re-authentication with latest credentials failed: ${message}`);
	        this.name = 'CredentialsError';
	    }
	}
	credentialsProvider.CredentialsError = CredentialsError;
	/**
	 * Thrown when new credentials cannot be obtained before current ones expire
	 */
	class UnableToObtainNewCredentialsError extends Error {
	    constructor(message) {
	        super(`Unable to obtain new credentials : ${message}`);
	        this.name = 'UnableToObtainNewCredentialsError';
	    }
	}
	credentialsProvider.UnableToObtainNewCredentialsError = UnableToObtainNewCredentialsError;
	
	return credentialsProvider;
}

var hasRequiredAuthx;

function requireAuthx () {
	if (hasRequiredAuthx) return authx;
	hasRequiredAuthx = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Token = exports.CredentialsError = exports.UnableToObtainNewCredentialsError = exports.IDPError = exports.TokenManager = void 0;
		var token_manager_1 = requireTokenManager();
		Object.defineProperty(exports, "TokenManager", { enumerable: true, get: function () { return token_manager_1.TokenManager; } });
		Object.defineProperty(exports, "IDPError", { enumerable: true, get: function () { return token_manager_1.IDPError; } });
		var credentials_provider_1 = requireCredentialsProvider();
		Object.defineProperty(exports, "UnableToObtainNewCredentialsError", { enumerable: true, get: function () { return credentials_provider_1.UnableToObtainNewCredentialsError; } });
		Object.defineProperty(exports, "CredentialsError", { enumerable: true, get: function () { return credentials_provider_1.CredentialsError; } });
		var token_1 = requireToken();
		Object.defineProperty(exports, "Token", { enumerable: true, get: function () { return token_1.Token; } });
		
	} (authx));
	return authx;
}

var commandsQueue = {};

var linkedList = {};

var hasRequiredLinkedList;

function requireLinkedList () {
	if (hasRequiredLinkedList) return linkedList;
	hasRequiredLinkedList = 1;
	Object.defineProperty(linkedList, "__esModule", { value: true });
	linkedList.SinglyLinkedList = linkedList.DoublyLinkedList = void 0;
	class DoublyLinkedList {
	    #length = 0;
	    get length() {
	        return this.#length;
	    }
	    #head;
	    get head() {
	        return this.#head;
	    }
	    #tail;
	    get tail() {
	        return this.#tail;
	    }
	    push(value) {
	        ++this.#length;
	        if (this.#tail === undefined) {
	            return this.#tail = this.#head = {
	                previous: this.#head,
	                next: undefined,
	                value
	            };
	        }
	        return this.#tail = this.#tail.next = {
	            previous: this.#tail,
	            next: undefined,
	            value
	        };
	    }
	    unshift(value) {
	        ++this.#length;
	        if (this.#head === undefined) {
	            return this.#head = this.#tail = {
	                previous: undefined,
	                next: undefined,
	                value
	            };
	        }
	        return this.#head = this.#head.previous = {
	            previous: undefined,
	            next: this.#head,
	            value
	        };
	    }
	    add(value, prepend = false) {
	        return prepend ?
	            this.unshift(value) :
	            this.push(value);
	    }
	    shift() {
	        if (this.#head === undefined)
	            return undefined;
	        --this.#length;
	        const node = this.#head;
	        if (node.next) {
	            node.next.previous = node.previous;
	            this.#head = node.next;
	            node.next = undefined;
	        }
	        else {
	            this.#head = this.#tail = undefined;
	        }
	        return node.value;
	    }
	    remove(node) {
	        --this.#length;
	        if (this.#tail === node) {
	            this.#tail = node.previous;
	        }
	        if (this.#head === node) {
	            this.#head = node.next;
	        }
	        else {
	            node.previous.next = node.next;
	            node.previous = undefined;
	        }
	        node.next = undefined;
	    }
	    reset() {
	        this.#length = 0;
	        this.#head = this.#tail = undefined;
	    }
	    *[Symbol.iterator]() {
	        let node = this.#head;
	        while (node !== undefined) {
	            yield node.value;
	            node = node.next;
	        }
	    }
	}
	linkedList.DoublyLinkedList = DoublyLinkedList;
	class SinglyLinkedList {
	    #length = 0;
	    get length() {
	        return this.#length;
	    }
	    #head;
	    get head() {
	        return this.#head;
	    }
	    #tail;
	    get tail() {
	        return this.#tail;
	    }
	    push(value) {
	        ++this.#length;
	        const node = {
	            value,
	            next: undefined,
	            removed: false
	        };
	        if (this.#head === undefined) {
	            return this.#head = this.#tail = node;
	        }
	        return this.#tail.next = this.#tail = node;
	    }
	    remove(node, parent) {
	        if (node.removed) {
	            throw new Error("node already removed");
	        }
	        --this.#length;
	        if (this.#head === node) {
	            if (this.#tail === node) {
	                this.#head = this.#tail = undefined;
	            }
	            else {
	                this.#head = node.next;
	            }
	        }
	        else if (this.#tail === node) {
	            this.#tail = parent;
	            parent.next = undefined;
	        }
	        else {
	            parent.next = node.next;
	        }
	        node.removed = true;
	    }
	    shift() {
	        if (this.#head === undefined)
	            return undefined;
	        const node = this.#head;
	        if (--this.#length === 0) {
	            this.#head = this.#tail = undefined;
	        }
	        else {
	            this.#head = node.next;
	        }
	        node.removed = true;
	        return node.value;
	    }
	    reset() {
	        this.#length = 0;
	        this.#head = this.#tail = undefined;
	    }
	    *[Symbol.iterator]() {
	        let node = this.#head;
	        while (node !== undefined) {
	            yield node.value;
	            node = node.next;
	        }
	    }
	}
	linkedList.SinglyLinkedList = SinglyLinkedList;
	
	return linkedList;
}

var encoder = {};

var hasRequiredEncoder;

function requireEncoder () {
	if (hasRequiredEncoder) return encoder;
	hasRequiredEncoder = 1;
	Object.defineProperty(encoder, "__esModule", { value: true });
	const CRLF = '\r\n';
	function encodeCommand(args) {
	    const toWrite = [];
	    let strings = '*' + args.length + CRLF;
	    for (let i = 0; i < args.length; i++) {
	        const arg = args[i];
	        if (typeof arg === 'string') {
	            strings += '$' + Buffer.byteLength(arg) + CRLF + arg + CRLF;
	        }
	        else if (arg instanceof Buffer) {
	            toWrite.push(strings + '$' + arg.length.toString() + CRLF, arg);
	            strings = CRLF;
	        }
	        else {
	            throw new TypeError(`"arguments[${i}]" must be of type "string | Buffer", got ${typeof arg} instead.`);
	        }
	    }
	    toWrite.push(strings);
	    return toWrite;
	}
	encoder.default = encodeCommand;
	
	return encoder;
}

var pubSub = {};

var hasRequiredPubSub;

function requirePubSub () {
	if (hasRequiredPubSub) return pubSub;
	hasRequiredPubSub = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.PubSub = exports.PUBSUB_TYPE = void 0;
		exports.PUBSUB_TYPE = {
		    CHANNELS: 'CHANNELS',
		    PATTERNS: 'PATTERNS',
		    SHARDED: 'SHARDED'
		};
		const COMMANDS = {
		    [exports.PUBSUB_TYPE.CHANNELS]: {
		        subscribe: Buffer.from('subscribe'),
		        unsubscribe: Buffer.from('unsubscribe'),
		        message: Buffer.from('message')
		    },
		    [exports.PUBSUB_TYPE.PATTERNS]: {
		        subscribe: Buffer.from('psubscribe'),
		        unsubscribe: Buffer.from('punsubscribe'),
		        message: Buffer.from('pmessage')
		    },
		    [exports.PUBSUB_TYPE.SHARDED]: {
		        subscribe: Buffer.from('ssubscribe'),
		        unsubscribe: Buffer.from('sunsubscribe'),
		        message: Buffer.from('smessage')
		    }
		};
		class PubSub {
		    static isStatusReply(reply) {
		        return (COMMANDS[exports.PUBSUB_TYPE.CHANNELS].subscribe.equals(reply[0]) ||
		            COMMANDS[exports.PUBSUB_TYPE.CHANNELS].unsubscribe.equals(reply[0]) ||
		            COMMANDS[exports.PUBSUB_TYPE.PATTERNS].subscribe.equals(reply[0]) ||
		            COMMANDS[exports.PUBSUB_TYPE.PATTERNS].unsubscribe.equals(reply[0]) ||
		            COMMANDS[exports.PUBSUB_TYPE.SHARDED].subscribe.equals(reply[0]));
		    }
		    static isShardedUnsubscribe(reply) {
		        return COMMANDS[exports.PUBSUB_TYPE.SHARDED].unsubscribe.equals(reply[0]);
		    }
		    static #channelsArray(channels) {
		        return (Array.isArray(channels) ? channels : [channels]);
		    }
		    static #listenersSet(listeners, returnBuffers) {
		        return (returnBuffers ? listeners.buffers : listeners.strings);
		    }
		    #subscribing = 0;
		    #isActive = false;
		    get isActive() {
		        return this.#isActive;
		    }
		    listeners = {
		        [exports.PUBSUB_TYPE.CHANNELS]: new Map(),
		        [exports.PUBSUB_TYPE.PATTERNS]: new Map(),
		        [exports.PUBSUB_TYPE.SHARDED]: new Map()
		    };
		    subscribe(type, channels, listener, returnBuffers) {
		        const args = [COMMANDS[type].subscribe], channelsArray = PubSub.#channelsArray(channels);
		        for (const channel of channelsArray) {
		            let channelListeners = this.listeners[type].get(channel);
		            if (!channelListeners || channelListeners.unsubscribing) {
		                args.push(channel);
		            }
		        }
		        if (args.length === 1) {
		            // all channels are already subscribed, add listeners without issuing a command
		            for (const channel of channelsArray) {
		                PubSub.#listenersSet(this.listeners[type].get(channel), returnBuffers).add(listener);
		            }
		            return;
		        }
		        this.#isActive = true;
		        this.#subscribing++;
		        return {
		            args,
		            channelsCounter: args.length - 1,
		            resolve: () => {
		                this.#subscribing--;
		                for (const channel of channelsArray) {
		                    let listeners = this.listeners[type].get(channel);
		                    if (!listeners) {
		                        listeners = {
		                            unsubscribing: false,
		                            buffers: new Set(),
		                            strings: new Set()
		                        };
		                        this.listeners[type].set(channel, listeners);
		                    }
		                    PubSub.#listenersSet(listeners, returnBuffers).add(listener);
		                }
		            },
		            reject: () => {
		                this.#subscribing--;
		                this.#updateIsActive();
		            }
		        };
		    }
		    extendChannelListeners(type, channel, listeners) {
		        if (!this.#extendChannelListeners(type, channel, listeners))
		            return;
		        this.#isActive = true;
		        this.#subscribing++;
		        return {
		            args: [
		                COMMANDS[type].subscribe,
		                channel
		            ],
		            channelsCounter: 1,
		            resolve: () => this.#subscribing--,
		            reject: () => {
		                this.#subscribing--;
		                this.#updateIsActive();
		            }
		        };
		    }
		    #extendChannelListeners(type, channel, listeners) {
		        const existingListeners = this.listeners[type].get(channel);
		        if (!existingListeners) {
		            this.listeners[type].set(channel, listeners);
		            return true;
		        }
		        for (const listener of listeners.buffers) {
		            existingListeners.buffers.add(listener);
		        }
		        for (const listener of listeners.strings) {
		            existingListeners.strings.add(listener);
		        }
		        return false;
		    }
		    extendTypeListeners(type, listeners) {
		        const args = [COMMANDS[type].subscribe];
		        for (const [channel, channelListeners] of listeners) {
		            if (this.#extendChannelListeners(type, channel, channelListeners)) {
		                args.push(channel);
		            }
		        }
		        if (args.length === 1)
		            return;
		        this.#isActive = true;
		        this.#subscribing++;
		        return {
		            args,
		            channelsCounter: args.length - 1,
		            resolve: () => this.#subscribing--,
		            reject: () => {
		                this.#subscribing--;
		                this.#updateIsActive();
		            }
		        };
		    }
		    unsubscribe(type, channels, listener, returnBuffers) {
		        const listeners = this.listeners[type];
		        if (!channels) {
		            return this.#unsubscribeCommand([COMMANDS[type].unsubscribe], 
		            // cannot use `this.#subscribed` because there might be some `SUBSCRIBE` commands in the queue
		            // cannot use `this.#subscribed + this.#subscribing` because some `SUBSCRIBE` commands might fail
		            NaN, () => listeners.clear());
		        }
		        const channelsArray = PubSub.#channelsArray(channels);
		        if (!listener) {
		            return this.#unsubscribeCommand([COMMANDS[type].unsubscribe, ...channelsArray], channelsArray.length, () => {
		                for (const channel of channelsArray) {
		                    listeners.delete(channel);
		                }
		            });
		        }
		        const args = [COMMANDS[type].unsubscribe];
		        for (const channel of channelsArray) {
		            const sets = listeners.get(channel);
		            if (sets) {
		                let current, other;
		                if (returnBuffers) {
		                    current = sets.buffers;
		                    other = sets.strings;
		                }
		                else {
		                    current = sets.strings;
		                    other = sets.buffers;
		                }
		                const currentSize = current.has(listener) ? current.size - 1 : current.size;
		                if (currentSize !== 0 || other.size !== 0)
		                    continue;
		                sets.unsubscribing = true;
		            }
		            args.push(channel);
		        }
		        if (args.length === 1) {
		            // all channels has other listeners,
		            // delete the listeners without issuing a command
		            for (const channel of channelsArray) {
		                PubSub.#listenersSet(listeners.get(channel), returnBuffers).delete(listener);
		            }
		            return;
		        }
		        return this.#unsubscribeCommand(args, args.length - 1, () => {
		            for (const channel of channelsArray) {
		                const sets = listeners.get(channel);
		                if (!sets)
		                    continue;
		                (returnBuffers ? sets.buffers : sets.strings).delete(listener);
		                if (sets.buffers.size === 0 && sets.strings.size === 0) {
		                    listeners.delete(channel);
		                }
		            }
		        });
		    }
		    #unsubscribeCommand(args, channelsCounter, removeListeners) {
		        return {
		            args,
		            channelsCounter,
		            resolve: () => {
		                removeListeners();
		                this.#updateIsActive();
		            },
		            reject: undefined
		        };
		    }
		    #updateIsActive() {
		        this.#isActive = (this.listeners[exports.PUBSUB_TYPE.CHANNELS].size !== 0 ||
		            this.listeners[exports.PUBSUB_TYPE.PATTERNS].size !== 0 ||
		            this.listeners[exports.PUBSUB_TYPE.SHARDED].size !== 0 ||
		            this.#subscribing !== 0);
		    }
		    reset() {
		        this.#isActive = false;
		        this.#subscribing = 0;
		    }
		    resubscribe() {
		        const commands = [];
		        for (const [type, listeners] of Object.entries(this.listeners)) {
		            if (!listeners.size)
		                continue;
		            this.#isActive = true;
		            this.#subscribing++;
		            const callback = () => this.#subscribing--;
		            commands.push({
		                args: [
		                    COMMANDS[type].subscribe,
		                    ...listeners.keys()
		                ],
		                channelsCounter: listeners.size,
		                resolve: callback,
		                reject: callback
		            });
		        }
		        return commands;
		    }
		    handleMessageReply(reply) {
		        if (COMMANDS[exports.PUBSUB_TYPE.CHANNELS].message.equals(reply[0])) {
		            this.#emitPubSubMessage(exports.PUBSUB_TYPE.CHANNELS, reply[2], reply[1]);
		            return true;
		        }
		        else if (COMMANDS[exports.PUBSUB_TYPE.PATTERNS].message.equals(reply[0])) {
		            this.#emitPubSubMessage(exports.PUBSUB_TYPE.PATTERNS, reply[3], reply[2], reply[1]);
		            return true;
		        }
		        else if (COMMANDS[exports.PUBSUB_TYPE.SHARDED].message.equals(reply[0])) {
		            this.#emitPubSubMessage(exports.PUBSUB_TYPE.SHARDED, reply[2], reply[1]);
		            return true;
		        }
		        return false;
		    }
		    removeShardedListeners(channel) {
		        const listeners = this.listeners[exports.PUBSUB_TYPE.SHARDED].get(channel);
		        this.listeners[exports.PUBSUB_TYPE.SHARDED].delete(channel);
		        this.#updateIsActive();
		        return listeners;
		    }
		    #emitPubSubMessage(type, message, channel, pattern) {
		        const keyString = (pattern ?? channel).toString(), listeners = this.listeners[type].get(keyString);
		        if (!listeners)
		            return;
		        for (const listener of listeners.buffers) {
		            listener(message, channel);
		        }
		        if (!listeners.strings.size)
		            return;
		        const channelString = pattern ? channel.toString() : keyString, messageString = channelString === '__redis__:invalidate' ?
		            // https://github.com/redis/redis/pull/7469
		            // https://github.com/redis/redis/issues/7463
		            (message === null ? null : message.map(x => x.toString())) :
		            message.toString();
		        for (const listener of listeners.strings) {
		            listener(messageString, channelString);
		        }
		    }
		}
		exports.PubSub = PubSub;
		
	} (pubSub));
	return pubSub;
}

var hasRequiredCommandsQueue;

function requireCommandsQueue () {
	if (hasRequiredCommandsQueue) return commandsQueue;
	hasRequiredCommandsQueue = 1;
	var __importDefault = (commandsQueue && commandsQueue.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(commandsQueue, "__esModule", { value: true });
	const linked_list_1 = requireLinkedList();
	const encoder_1 = __importDefault(requireEncoder());
	const decoder_1 = requireDecoder();
	const pub_sub_1 = requirePubSub();
	const errors_1 = requireErrors$1();
	const PONG = Buffer.from('pong'), RESET = Buffer.from('RESET');
	const RESP2_PUSH_TYPE_MAPPING = {
	    ...decoder_1.PUSH_TYPE_MAPPING,
	    [decoder_1.RESP_TYPES.SIMPLE_STRING]: Buffer
	};
	class RedisCommandsQueue {
	    #respVersion;
	    #maxLength;
	    #toWrite = new linked_list_1.DoublyLinkedList();
	    #waitingForReply = new linked_list_1.SinglyLinkedList();
	    #onShardedChannelMoved;
	    #chainInExecution;
	    decoder;
	    #pubSub = new pub_sub_1.PubSub();
	    get isPubSubActive() {
	        return this.#pubSub.isActive;
	    }
	    #invalidateCallback;
	    constructor(respVersion, maxLength, onShardedChannelMoved) {
	        this.#respVersion = respVersion;
	        this.#maxLength = maxLength;
	        this.#onShardedChannelMoved = onShardedChannelMoved;
	        this.decoder = this.#initiateDecoder();
	    }
	    #onReply(reply) {
	        this.#waitingForReply.shift().resolve(reply);
	    }
	    #onErrorReply(err) {
	        this.#waitingForReply.shift().reject(err);
	    }
	    #onPush(push) {
	        // TODO: type
	        if (this.#pubSub.handleMessageReply(push))
	            return true;
	        const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(push);
	        if (isShardedUnsubscribe && !this.#waitingForReply.length) {
	            const channel = push[1].toString();
	            this.#onShardedChannelMoved(channel, this.#pubSub.removeShardedListeners(channel));
	            return true;
	        }
	        else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(push)) {
	            const head = this.#waitingForReply.head.value;
	            if ((Number.isNaN(head.channelsCounter) && push[2] === 0) ||
	                --head.channelsCounter === 0) {
	                this.#waitingForReply.shift().resolve();
	            }
	            return true;
	        }
	    }
	    #getTypeMapping() {
	        return this.#waitingForReply.head.value.typeMapping ?? {};
	    }
	    #initiateDecoder() {
	        return new decoder_1.Decoder({
	            onReply: reply => this.#onReply(reply),
	            onErrorReply: err => this.#onErrorReply(err),
	            //TODO: we can shave off a few cycles by not adding onPush handler at all if CSC is not used
	            onPush: push => {
	                if (!this.#onPush(push)) {
	                    // currently only supporting "invalidate" over RESP3 push messages
	                    switch (push[0].toString()) {
	                        case "invalidate": {
	                            if (this.#invalidateCallback) {
	                                if (push[1] !== null) {
	                                    for (const key of push[1]) {
	                                        this.#invalidateCallback(key);
	                                    }
	                                }
	                                else {
	                                    this.#invalidateCallback(null);
	                                }
	                            }
	                            break;
	                        }
	                    }
	                }
	            },
	            getTypeMapping: () => this.#getTypeMapping()
	        });
	    }
	    setInvalidateCallback(callback) {
	        this.#invalidateCallback = callback;
	    }
	    addCommand(args, options) {
	        if (this.#maxLength && this.#toWrite.length + this.#waitingForReply.length >= this.#maxLength) {
	            return Promise.reject(new Error('The queue is full'));
	        }
	        else if (options?.abortSignal?.aborted) {
	            return Promise.reject(new errors_1.AbortError());
	        }
	        return new Promise((resolve, reject) => {
	            let node;
	            const value = {
	                args,
	                chainId: options?.chainId,
	                abort: undefined,
	                timeout: undefined,
	                resolve,
	                reject,
	                channelsCounter: undefined,
	                typeMapping: options?.typeMapping
	            };
	            const timeout = options?.timeout;
	            if (timeout) {
	                const signal = AbortSignal.timeout(timeout);
	                value.timeout = {
	                    signal,
	                    listener: () => {
	                        this.#toWrite.remove(node);
	                        value.reject(new errors_1.TimeoutError());
	                    }
	                };
	                signal.addEventListener('abort', value.timeout.listener, { once: true });
	            }
	            const signal = options?.abortSignal;
	            if (signal) {
	                value.abort = {
	                    signal,
	                    listener: () => {
	                        this.#toWrite.remove(node);
	                        value.reject(new errors_1.AbortError());
	                    }
	                };
	                signal.addEventListener('abort', value.abort.listener, { once: true });
	            }
	            node = this.#toWrite.add(value, options?.asap);
	        });
	    }
	    #addPubSubCommand(command, asap = false, chainId) {
	        return new Promise((resolve, reject) => {
	            this.#toWrite.add({
	                args: command.args,
	                chainId,
	                abort: undefined,
	                timeout: undefined,
	                resolve() {
	                    command.resolve();
	                    resolve();
	                },
	                reject(err) {
	                    command.reject?.();
	                    reject(err);
	                },
	                channelsCounter: command.channelsCounter,
	                typeMapping: decoder_1.PUSH_TYPE_MAPPING
	            }, asap);
	        });
	    }
	    #setupPubSubHandler() {
	        // RESP3 uses `onPush` to handle PubSub, so no need to modify `onReply`
	        if (this.#respVersion !== 2)
	            return;
	        this.decoder.onReply = (reply => {
	            if (Array.isArray(reply)) {
	                if (this.#onPush(reply))
	                    return;
	                if (PONG.equals(reply[0])) {
	                    const { resolve, typeMapping } = this.#waitingForReply.shift(), buffer = (reply[1].length === 0 ? reply[0] : reply[1]);
	                    resolve(typeMapping?.[decoder_1.RESP_TYPES.SIMPLE_STRING] === Buffer ? buffer : buffer.toString());
	                    return;
	                }
	            }
	            return this.#onReply(reply);
	        });
	        this.decoder.getTypeMapping = () => RESP2_PUSH_TYPE_MAPPING;
	    }
	    subscribe(type, channels, listener, returnBuffers) {
	        const command = this.#pubSub.subscribe(type, channels, listener, returnBuffers);
	        if (!command)
	            return;
	        this.#setupPubSubHandler();
	        return this.#addPubSubCommand(command);
	    }
	    #resetDecoderCallbacks() {
	        this.decoder.onReply = (reply => this.#onReply(reply));
	        this.decoder.getTypeMapping = () => this.#getTypeMapping();
	    }
	    unsubscribe(type, channels, listener, returnBuffers) {
	        const command = this.#pubSub.unsubscribe(type, channels, listener, returnBuffers);
	        if (!command)
	            return;
	        if (command && this.#respVersion === 2) {
	            // RESP2 modifies `onReply` to handle PubSub (see #setupPubSubHandler)
	            const { resolve } = command;
	            command.resolve = () => {
	                if (!this.#pubSub.isActive) {
	                    this.#resetDecoderCallbacks();
	                }
	                resolve();
	            };
	        }
	        return this.#addPubSubCommand(command);
	    }
	    resubscribe(chainId) {
	        const commands = this.#pubSub.resubscribe();
	        if (!commands.length)
	            return;
	        this.#setupPubSubHandler();
	        return Promise.all(commands.map(command => this.#addPubSubCommand(command, true, chainId)));
	    }
	    extendPubSubChannelListeners(type, channel, listeners) {
	        const command = this.#pubSub.extendChannelListeners(type, channel, listeners);
	        if (!command)
	            return;
	        this.#setupPubSubHandler();
	        return this.#addPubSubCommand(command);
	    }
	    extendPubSubListeners(type, listeners) {
	        const command = this.#pubSub.extendTypeListeners(type, listeners);
	        if (!command)
	            return;
	        this.#setupPubSubHandler();
	        return this.#addPubSubCommand(command);
	    }
	    getPubSubListeners(type) {
	        return this.#pubSub.listeners[type];
	    }
	    monitor(callback, options) {
	        return new Promise((resolve, reject) => {
	            const typeMapping = options?.typeMapping ?? {};
	            this.#toWrite.add({
	                args: ['MONITOR'],
	                chainId: options?.chainId,
	                abort: undefined,
	                timeout: undefined,
	                // using `resolve` instead of using `.then`/`await` to make sure it'll be called before processing the next reply
	                resolve: () => {
	                    // after running `MONITOR` only `MONITOR` and `RESET` replies are expected
	                    // any other command should cause an error
	                    // if `RESET` already overrides `onReply`, set monitor as it's fallback
	                    if (this.#resetFallbackOnReply) {
	                        this.#resetFallbackOnReply = callback;
	                    }
	                    else {
	                        this.decoder.onReply = callback;
	                    }
	                    this.decoder.getTypeMapping = () => typeMapping;
	                    resolve();
	                },
	                reject,
	                channelsCounter: undefined,
	                typeMapping
	            }, options?.asap);
	        });
	    }
	    resetDecoder() {
	        this.#resetDecoderCallbacks();
	        this.decoder.reset();
	    }
	    #resetFallbackOnReply;
	    async reset(chainId, typeMapping) {
	        return new Promise((resolve, reject) => {
	            // overriding onReply to handle `RESET` while in `MONITOR` or PubSub mode
	            this.#resetFallbackOnReply = this.decoder.onReply;
	            this.decoder.onReply = (reply => {
	                if ((typeof reply === 'string' && reply === 'RESET') ||
	                    (reply instanceof Buffer && RESET.equals(reply))) {
	                    this.#resetDecoderCallbacks();
	                    this.#resetFallbackOnReply = undefined;
	                    this.#pubSub.reset();
	                    this.#waitingForReply.shift().resolve(reply);
	                    return;
	                }
	                this.#resetFallbackOnReply(reply);
	            });
	            this.#toWrite.push({
	                args: ['RESET'],
	                chainId,
	                abort: undefined,
	                timeout: undefined,
	                resolve,
	                reject,
	                channelsCounter: undefined,
	                typeMapping
	            });
	        });
	    }
	    isWaitingToWrite() {
	        return this.#toWrite.length > 0;
	    }
	    *commandsToWrite() {
	        let toSend = this.#toWrite.shift();
	        while (toSend) {
	            let encoded;
	            try {
	                encoded = (0, encoder_1.default)(toSend.args);
	            }
	            catch (err) {
	                toSend.reject(err);
	                toSend = this.#toWrite.shift();
	                continue;
	            }
	            // TODO reuse `toSend` or create new object?
	            toSend.args = undefined;
	            if (toSend.abort) {
	                RedisCommandsQueue.#removeAbortListener(toSend);
	                toSend.abort = undefined;
	            }
	            if (toSend.timeout) {
	                RedisCommandsQueue.#removeTimeoutListener(toSend);
	                toSend.timeout = undefined;
	            }
	            this.#chainInExecution = toSend.chainId;
	            toSend.chainId = undefined;
	            this.#waitingForReply.push(toSend);
	            yield encoded;
	            toSend = this.#toWrite.shift();
	        }
	    }
	    #flushWaitingForReply(err) {
	        for (const node of this.#waitingForReply) {
	            node.reject(err);
	        }
	        this.#waitingForReply.reset();
	    }
	    static #removeAbortListener(command) {
	        command.abort.signal.removeEventListener('abort', command.abort.listener);
	    }
	    static #removeTimeoutListener(command) {
	        command.timeout.signal.removeEventListener('abort', command.timeout.listener);
	    }
	    static #flushToWrite(toBeSent, err) {
	        if (toBeSent.abort) {
	            RedisCommandsQueue.#removeAbortListener(toBeSent);
	        }
	        if (toBeSent.timeout) {
	            RedisCommandsQueue.#removeTimeoutListener(toBeSent);
	        }
	        toBeSent.reject(err);
	    }
	    flushWaitingForReply(err) {
	        this.resetDecoder();
	        this.#pubSub.reset();
	        this.#flushWaitingForReply(err);
	        if (!this.#chainInExecution)
	            return;
	        while (this.#toWrite.head?.value.chainId === this.#chainInExecution) {
	            RedisCommandsQueue.#flushToWrite(this.#toWrite.shift(), err);
	        }
	        this.#chainInExecution = undefined;
	    }
	    flushAll(err) {
	        this.resetDecoder();
	        this.#pubSub.reset();
	        this.#flushWaitingForReply(err);
	        for (const node of this.#toWrite) {
	            RedisCommandsQueue.#flushToWrite(node, err);
	        }
	        this.#toWrite.reset();
	    }
	    isEmpty() {
	        return (this.#toWrite.length === 0 &&
	            this.#waitingForReply.length === 0);
	    }
	}
	commandsQueue.default = RedisCommandsQueue;
	
	return commandsQueue;
}

var commander = {};

var hasRequiredCommander;

function requireCommander () {
	if (hasRequiredCommander) return commander;
	hasRequiredCommander = 1;
	Object.defineProperty(commander, "__esModule", { value: true });
	commander.scriptArgumentsPrefix = commander.functionArgumentsPrefix = commander.getTransformReply = commander.attachConfig = void 0;
	/* FIXME: better error message / link */
	function throwResp3SearchModuleUnstableError() {
	    throw new Error('Some RESP3 results for Redis Query Engine responses may change. Refer to the readme for guidance');
	}
	function attachConfig({ BaseClass, commands, createCommand, createModuleCommand, createFunctionCommand, createScriptCommand, config }) {
	    const RESP = config?.RESP ?? 2, Class = class extends BaseClass {
	    };
	    for (const [name, command] of Object.entries(commands)) {
	        if (config?.RESP == 3 && command.unstableResp3 && !config.unstableResp3) {
	            Class.prototype[name] = throwResp3SearchModuleUnstableError;
	        }
	        else {
	            Class.prototype[name] = createCommand(command, RESP);
	        }
	    }
	    if (config?.modules) {
	        for (const [moduleName, module] of Object.entries(config.modules)) {
	            const fns = Object.create(null);
	            for (const [name, command] of Object.entries(module)) {
	                if (config.RESP == 3 && command.unstableResp3 && !config.unstableResp3) {
	                    fns[name] = throwResp3SearchModuleUnstableError;
	                }
	                else {
	                    fns[name] = createModuleCommand(command, RESP);
	                }
	            }
	            attachNamespace(Class.prototype, moduleName, fns);
	        }
	    }
	    if (config?.functions) {
	        for (const [library, commands] of Object.entries(config.functions)) {
	            const fns = Object.create(null);
	            for (const [name, command] of Object.entries(commands)) {
	                fns[name] = createFunctionCommand(name, command, RESP);
	            }
	            attachNamespace(Class.prototype, library, fns);
	        }
	    }
	    if (config?.scripts) {
	        for (const [name, script] of Object.entries(config.scripts)) {
	            Class.prototype[name] = createScriptCommand(script, RESP);
	        }
	    }
	    return Class;
	}
	commander.attachConfig = attachConfig;
	function attachNamespace(prototype, name, fns) {
	    Object.defineProperty(prototype, name, {
	        get() {
	            const value = Object.create(fns);
	            value._self = this;
	            Object.defineProperty(this, name, { value });
	            return value;
	        }
	    });
	}
	function getTransformReply(command, resp) {
	    switch (typeof command.transformReply) {
	        case 'function':
	            return command.transformReply;
	        case 'object':
	            return command.transformReply[resp];
	    }
	}
	commander.getTransformReply = getTransformReply;
	function functionArgumentsPrefix(name, fn) {
	    const prefix = [
	        fn.IS_READ_ONLY ? 'FCALL_RO' : 'FCALL',
	        name
	    ];
	    if (fn.NUMBER_OF_KEYS !== undefined) {
	        prefix.push(fn.NUMBER_OF_KEYS.toString());
	    }
	    return prefix;
	}
	commander.functionArgumentsPrefix = functionArgumentsPrefix;
	function scriptArgumentsPrefix(script) {
	    const prefix = [
	        script.IS_READ_ONLY ? 'EVALSHA_RO' : 'EVALSHA',
	        script.SHA1
	    ];
	    if (script.NUMBER_OF_KEYS !== undefined) {
	        prefix.push(script.NUMBER_OF_KEYS.toString());
	    }
	    return prefix;
	}
	commander.scriptArgumentsPrefix = scriptArgumentsPrefix;
	
	return commander;
}

var multiCommand$2 = {};

var multiCommand$1 = {};

var hasRequiredMultiCommand$2;

function requireMultiCommand$2 () {
	if (hasRequiredMultiCommand$2) return multiCommand$1;
	hasRequiredMultiCommand$2 = 1;
	Object.defineProperty(multiCommand$1, "__esModule", { value: true });
	const errors_1 = requireErrors$1();
	class RedisMultiCommand {
	    typeMapping;
	    constructor(typeMapping) {
	        this.typeMapping = typeMapping;
	    }
	    queue = [];
	    scriptsInUse = new Set();
	    addCommand(args, transformReply) {
	        this.queue.push({
	            args,
	            transformReply
	        });
	    }
	    addScript(script, args, transformReply) {
	        const redisArgs = [];
	        redisArgs.preserve = args.preserve;
	        if (this.scriptsInUse.has(script.SHA1)) {
	            redisArgs.push('EVALSHA', script.SHA1);
	        }
	        else {
	            this.scriptsInUse.add(script.SHA1);
	            redisArgs.push('EVAL', script.SCRIPT);
	        }
	        if (script.NUMBER_OF_KEYS !== undefined) {
	            redisArgs.push(script.NUMBER_OF_KEYS.toString());
	        }
	        redisArgs.push(...args);
	        this.addCommand(redisArgs, transformReply);
	    }
	    transformReplies(rawReplies) {
	        const errorIndexes = [], replies = rawReplies.map((reply, i) => {
	            if (reply instanceof errors_1.ErrorReply) {
	                errorIndexes.push(i);
	                return reply;
	            }
	            const { transformReply, args } = this.queue[i];
	            return transformReply ? transformReply(reply, args.preserve, this.typeMapping) : reply;
	        });
	        if (errorIndexes.length)
	            throw new errors_1.MultiErrorReply(replies, errorIndexes);
	        return replies;
	    }
	}
	multiCommand$1.default = RedisMultiCommand;
	
	return multiCommand$1;
}

var hasRequiredMultiCommand$1;

function requireMultiCommand$1 () {
	if (hasRequiredMultiCommand$1) return multiCommand$2;
	hasRequiredMultiCommand$1 = 1;
	var __importDefault = (multiCommand$2 && multiCommand$2.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(multiCommand$2, "__esModule", { value: true });
	const commands_1 = __importDefault(requireCommands$5());
	const multi_command_1 = __importDefault(requireMultiCommand$2());
	const commander_1 = requireCommander();
	const parser_1 = requireParser();
	class RedisClientMultiCommand {
	    static #createCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            return this.addCommand(redisArgs, transformReply);
	        };
	    }
	    static #createModuleCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            return this._self.addCommand(redisArgs, transformReply);
	        };
	    }
	    static #createFunctionCommand(name, fn, resp) {
	        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
	        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            parser.push(...prefix);
	            fn.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            return this._self.addCommand(redisArgs, transformReply);
	        };
	    }
	    static #createScriptCommand(script, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(script, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            script.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            return this.#addScript(script, redisArgs, transformReply);
	        };
	    }
	    static extend(config) {
	        return (0, commander_1.attachConfig)({
	            BaseClass: RedisClientMultiCommand,
	            commands: commands_1.default,
	            createCommand: RedisClientMultiCommand.#createCommand,
	            createModuleCommand: RedisClientMultiCommand.#createModuleCommand,
	            createFunctionCommand: RedisClientMultiCommand.#createFunctionCommand,
	            createScriptCommand: RedisClientMultiCommand.#createScriptCommand,
	            config
	        });
	    }
	    #multi;
	    #executeMulti;
	    #executePipeline;
	    #selectedDB;
	    constructor(executeMulti, executePipeline, typeMapping) {
	        this.#multi = new multi_command_1.default(typeMapping);
	        this.#executeMulti = executeMulti;
	        this.#executePipeline = executePipeline;
	    }
	    SELECT(db, transformReply) {
	        this.#selectedDB = db;
	        this.#multi.addCommand(['SELECT', db.toString()], transformReply);
	        return this;
	    }
	    select = this.SELECT;
	    addCommand(args, transformReply) {
	        this.#multi.addCommand(args, transformReply);
	        return this;
	    }
	    #addScript(script, args, transformReply) {
	        this.#multi.addScript(script, args, transformReply);
	        return this;
	    }
	    async exec(execAsPipeline = false) {
	        if (execAsPipeline)
	            return this.execAsPipeline();
	        return this.#multi.transformReplies(await this.#executeMulti(this.#multi.queue, this.#selectedDB));
	    }
	    EXEC = this.exec;
	    execTyped(execAsPipeline = false) {
	        return this.exec(execAsPipeline);
	    }
	    async execAsPipeline() {
	        if (this.#multi.queue.length === 0)
	            return [];
	        return this.#multi.transformReplies(await this.#executePipeline(this.#multi.queue, this.#selectedDB));
	    }
	    execAsPipelineTyped() {
	        return this.execAsPipeline();
	    }
	}
	multiCommand$2.default = RedisClientMultiCommand;
	
	return multiCommand$2;
}

var legacyMode = {};

var hasRequiredLegacyMode;

function requireLegacyMode () {
	if (hasRequiredLegacyMode) return legacyMode;
	hasRequiredLegacyMode = 1;
	var __importDefault = (legacyMode && legacyMode.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(legacyMode, "__esModule", { value: true });
	legacyMode.RedisLegacyClient = void 0;
	const commander_1 = requireCommander();
	const commands_1 = __importDefault(requireCommands$5());
	const multi_command_1 = __importDefault(requireMultiCommand$2());
	class RedisLegacyClient {
	    static #transformArguments(redisArgs, args) {
	        let callback;
	        if (typeof args[args.length - 1] === 'function') {
	            callback = args.pop();
	        }
	        RedisLegacyClient.pushArguments(redisArgs, args);
	        return callback;
	    }
	    static pushArguments(redisArgs, args) {
	        for (let i = 0; i < args.length; ++i) {
	            const arg = args[i];
	            if (Array.isArray(arg)) {
	                RedisLegacyClient.pushArguments(redisArgs, arg);
	            }
	            else {
	                redisArgs.push(typeof arg === 'number' || arg instanceof Date ?
	                    arg.toString() :
	                    arg);
	            }
	        }
	    }
	    static getTransformReply(command, resp) {
	        return command.TRANSFORM_LEGACY_REPLY ?
	            (0, commander_1.getTransformReply)(command, resp) :
	            undefined;
	    }
	    static #createCommand(name, command, resp) {
	        const transformReply = RedisLegacyClient.getTransformReply(command, resp);
	        return function (...args) {
	            const redisArgs = [name], callback = RedisLegacyClient.#transformArguments(redisArgs, args), promise = this.#client.sendCommand(redisArgs);
	            if (!callback) {
	                promise.catch(err => this.#client.emit('error', err));
	                return;
	            }
	            promise
	                .then(reply => callback(null, transformReply ? transformReply(reply) : reply))
	                .catch(err => callback(err));
	        };
	    }
	    #client;
	    #Multi;
	    constructor(client) {
	        this.#client = client;
	        const RESP = client.options?.RESP ?? 2;
	        for (const [name, command] of Object.entries(commands_1.default)) {
	            // TODO: as any?
	            this[name] = RedisLegacyClient.#createCommand(name, command, RESP);
	        }
	        this.#Multi = LegacyMultiCommand.factory(RESP);
	    }
	    sendCommand(...args) {
	        const redisArgs = [], callback = RedisLegacyClient.#transformArguments(redisArgs, args), promise = this.#client.sendCommand(redisArgs);
	        if (!callback) {
	            promise.catch(err => this.#client.emit('error', err));
	            return;
	        }
	        promise
	            .then(reply => callback(null, reply))
	            .catch(err => callback(err));
	    }
	    multi() {
	        return this.#Multi(this.#client);
	    }
	}
	legacyMode.RedisLegacyClient = RedisLegacyClient;
	class LegacyMultiCommand {
	    static #createCommand(name, command, resp) {
	        const transformReply = RedisLegacyClient.getTransformReply(command, resp);
	        return function (...args) {
	            const redisArgs = [name];
	            RedisLegacyClient.pushArguments(redisArgs, args);
	            this.#multi.addCommand(redisArgs, transformReply);
	            return this;
	        };
	    }
	    static factory(resp) {
	        const Multi = class extends LegacyMultiCommand {
	        };
	        for (const [name, command] of Object.entries(commands_1.default)) {
	            // TODO: as any?
	            Multi.prototype[name] = LegacyMultiCommand.#createCommand(name, command, resp);
	        }
	        return (client) => {
	            return new Multi(client);
	        };
	    }
	    #multi = new multi_command_1.default();
	    #client;
	    constructor(client) {
	        this.#client = client;
	    }
	    sendCommand(...args) {
	        const redisArgs = [];
	        RedisLegacyClient.pushArguments(redisArgs, args);
	        this.#multi.addCommand(redisArgs);
	        return this;
	    }
	    exec(cb) {
	        const promise = this.#client._executeMulti(this.#multi.queue);
	        if (!cb) {
	            promise.catch(err => this.#client.emit('error', err));
	            return;
	        }
	        promise
	            .then(results => cb(null, this.#multi.transformReplies(results)))
	            .catch(err => cb?.(err));
	    }
	}
	
	return legacyMode;
}

var pool = {};

var cache = {};

var hasRequiredCache;

function requireCache () {
	if (hasRequiredCache) return cache;
	hasRequiredCache = 1;
	Object.defineProperty(cache, "__esModule", { value: true });
	cache.PooledNoRedirectClientSideCache = cache.BasicPooledClientSideCache = cache.PooledClientSideCacheProvider = cache.BasicClientSideCache = cache.ClientSideCacheProvider = cache.CacheStats = void 0;
	const stream_1 = require$$0;
	/**
	 * A snapshot of cache statistics.
	 *
	 * This class provides an immutable view of the cache's operational statistics at a particular
	 * point in time. It is heavily inspired by the statistics reporting capabilities found in
	 * Ben Manes's Caffeine cache (https://github.com/ben-manes/caffeine).
	 *
	 * Instances of `CacheStats` are typically obtained from a {@link StatsCounter} and can be used
	 * for performance monitoring, debugging, or logging. It includes metrics such as hit rate,
	 * miss rate, load success/failure rates, average load penalty, and eviction counts.
	 *
	 * All statistics are non-negative. Rates and averages are typically in the range `[0.0, 1.0]`,
	 * or `0` if the an operation has not occurred (e.g. hit rate is 0 if there are no requests).
	 *
	 * Cache statistics are incremented according to specific rules:
	 * - When a cache lookup encounters an existing entry, hitCount is incremented.
	 * - When a cache lookup encounters a missing entry, missCount is incremented.
	 * - When a new entry is successfully loaded, loadSuccessCount is incremented and the
	 *   loading time is added to totalLoadTime.
	 * - When an entry fails to load, loadFailureCount is incremented and the
	 *   loading time is added to totalLoadTime.
	 * - When an entry is evicted due to size constraints or expiration,
	 *   evictionCount is incremented.
	 */
	class CacheStats {
	    hitCount;
	    missCount;
	    loadSuccessCount;
	    loadFailureCount;
	    totalLoadTime;
	    evictionCount;
	    /**
	     * Creates a new CacheStats instance with the specified statistics.
	     */
	    constructor(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount) {
	        this.hitCount = hitCount;
	        this.missCount = missCount;
	        this.loadSuccessCount = loadSuccessCount;
	        this.loadFailureCount = loadFailureCount;
	        this.totalLoadTime = totalLoadTime;
	        this.evictionCount = evictionCount;
	        if (hitCount < 0 ||
	            missCount < 0 ||
	            loadSuccessCount < 0 ||
	            loadFailureCount < 0 ||
	            totalLoadTime < 0 ||
	            evictionCount < 0) {
	            throw new Error('All statistics values must be non-negative');
	        }
	    }
	    /**
	     * Creates a new CacheStats instance with the specified statistics.
	     *
	     * @param hitCount - Number of cache hits
	     * @param missCount - Number of cache misses
	     * @param loadSuccessCount - Number of successful cache loads
	     * @param loadFailureCount - Number of failed cache loads
	     * @param totalLoadTime - Total load time in milliseconds
	     * @param evictionCount - Number of cache evictions
	     */
	    static of(hitCount = 0, missCount = 0, loadSuccessCount = 0, loadFailureCount = 0, totalLoadTime = 0, evictionCount = 0) {
	        return new CacheStats(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount);
	    }
	    /**
	     * Returns a statistics instance where no cache events have been recorded.
	     *
	     * @returns An empty statistics instance
	     */
	    static empty() {
	        return CacheStats.EMPTY_STATS;
	    }
	    /**
	     * An empty stats instance with all counters set to zero.
	     */
	    static EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);
	    /**
	    * Returns the total number of times cache lookup methods have returned
	    * either a cached or uncached value.
	    *
	    * @returns Total number of requests (hits + misses)
	    */
	    requestCount() {
	        return this.hitCount + this.missCount;
	    }
	    /**
	     * Returns the hit rate of the cache.
	     * This is defined as hitCount / requestCount, or 1.0 when requestCount is 0.
	     *
	     * @returns The ratio of cache requests that were hits (between 0.0 and 1.0)
	     */
	    hitRate() {
	        const requestCount = this.requestCount();
	        return requestCount === 0 ? 1.0 : this.hitCount / requestCount;
	    }
	    /**
	     * Returns the miss rate of the cache.
	     * This is defined as missCount / requestCount, or 0.0 when requestCount is 0.
	     *
	     * @returns The ratio of cache requests that were misses (between 0.0 and 1.0)
	     */
	    missRate() {
	        const requestCount = this.requestCount();
	        return requestCount === 0 ? 0.0 : this.missCount / requestCount;
	    }
	    /**
	    * Returns the total number of load operations (successful + failed).
	    *
	    * @returns Total number of load operations
	    */
	    loadCount() {
	        return this.loadSuccessCount + this.loadFailureCount;
	    }
	    /**
	     * Returns the ratio of cache loading attempts that failed.
	     * This is defined as loadFailureCount / loadCount, or 0.0 when loadCount is 0.
	     *
	     * @returns Ratio of load operations that failed (between 0.0 and 1.0)
	     */
	    loadFailureRate() {
	        const loadCount = this.loadCount();
	        return loadCount === 0 ? 0.0 : this.loadFailureCount / loadCount;
	    }
	    /**
	     * Returns the average time spent loading new values, in milliseconds.
	     * This is defined as totalLoadTime / loadCount, or 0.0 when loadCount is 0.
	     *
	     * @returns Average load time in milliseconds
	     */
	    averageLoadPenalty() {
	        const loadCount = this.loadCount();
	        return loadCount === 0 ? 0.0 : this.totalLoadTime / loadCount;
	    }
	    /**
	    * Returns a new CacheStats representing the difference between this CacheStats
	    * and another. Negative values are rounded up to zero.
	    *
	    * @param other - The statistics to subtract from this instance
	    * @returns The difference between this instance and other
	    */
	    minus(other) {
	        return CacheStats.of(Math.max(0, this.hitCount - other.hitCount), Math.max(0, this.missCount - other.missCount), Math.max(0, this.loadSuccessCount - other.loadSuccessCount), Math.max(0, this.loadFailureCount - other.loadFailureCount), Math.max(0, this.totalLoadTime - other.totalLoadTime), Math.max(0, this.evictionCount - other.evictionCount));
	    }
	    /**
	     * Returns a new CacheStats representing the sum of this CacheStats and another.
	     *
	     * @param other - The statistics to add to this instance
	     * @returns The sum of this instance and other
	     */
	    plus(other) {
	        return CacheStats.of(this.hitCount + other.hitCount, this.missCount + other.missCount, this.loadSuccessCount + other.loadSuccessCount, this.loadFailureCount + other.loadFailureCount, this.totalLoadTime + other.totalLoadTime, this.evictionCount + other.evictionCount);
	    }
	}
	cache.CacheStats = CacheStats;
	/**
	 * A StatsCounter implementation that does nothing and always returns empty stats.
	 */
	class DisabledStatsCounter {
	    static INSTANCE = new DisabledStatsCounter();
	    constructor() { }
	    recordHits(count) { }
	    recordMisses(count) { }
	    recordLoadSuccess(loadTime) { }
	    recordLoadFailure(loadTime) { }
	    recordEvictions(count) { }
	    snapshot() { return CacheStats.empty(); }
	}
	/**
	 * Returns a StatsCounter that does not record any cache events.
	 *
	 * @return A StatsCounter that does not record metrics
	 */
	function disabledStatsCounter() {
	    return DisabledStatsCounter.INSTANCE;
	}
	/**
	 * A StatsCounter implementation that maintains cache statistics.
	 */
	class DefaultStatsCounter {
	    #hitCount = 0;
	    #missCount = 0;
	    #loadSuccessCount = 0;
	    #loadFailureCount = 0;
	    #totalLoadTime = 0;
	    #evictionCount = 0;
	    /**
	     * Records cache hits.
	     *
	     * @param count - The number of hits to record
	     */
	    recordHits(count) {
	        this.#hitCount += count;
	    }
	    /**
	     * Records cache misses.
	     *
	     * @param count - The number of misses to record
	     */
	    recordMisses(count) {
	        this.#missCount += count;
	    }
	    /**
	     * Records the successful load of a new entry.
	     *
	     * @param loadTime - The number of milliseconds spent loading the entry
	     */
	    recordLoadSuccess(loadTime) {
	        this.#loadSuccessCount++;
	        this.#totalLoadTime += loadTime;
	    }
	    /**
	     * Records the failed load of a new entry.
	     *
	     * @param loadTime - The number of milliseconds spent attempting to load the entry
	     */
	    recordLoadFailure(loadTime) {
	        this.#loadFailureCount++;
	        this.#totalLoadTime += loadTime;
	    }
	    /**
	     * Records cache evictions.
	     *
	     * @param count - The number of evictions to record
	     */
	    recordEvictions(count) {
	        this.#evictionCount += count;
	    }
	    /**
	     * Returns a snapshot of the current statistics.
	     *
	     * @returns A snapshot of the current statistics
	     */
	    snapshot() {
	        return CacheStats.of(this.#hitCount, this.#missCount, this.#loadSuccessCount, this.#loadFailureCount, this.#totalLoadTime, this.#evictionCount);
	    }
	    /**
	     * Creates a new DefaultStatsCounter.
	     *
	     * @returns A new DefaultStatsCounter instance
	     */
	    static create() {
	        return new DefaultStatsCounter();
	    }
	}
	/**
	 * Generates a unique cache key from Redis command arguments
	 *
	 * @param redisArgs - Array of Redis command arguments
	 * @returns A unique string key for caching
	 */
	function generateCacheKey(redisArgs) {
	    const tmp = new Array(redisArgs.length * 2);
	    for (let i = 0; i < redisArgs.length; i++) {
	        tmp[i] = redisArgs[i].length;
	        tmp[i + redisArgs.length] = redisArgs[i];
	    }
	    return tmp.join('_');
	}
	class ClientSideCacheEntryBase {
	    #invalidated = false;
	    #expireTime;
	    constructor(ttl) {
	        if (ttl == 0) {
	            this.#expireTime = 0;
	        }
	        else {
	            this.#expireTime = Date.now() + ttl;
	        }
	    }
	    invalidate() {
	        this.#invalidated = true;
	    }
	    validate() {
	        return !this.#invalidated && (this.#expireTime == 0 || (Date.now() < this.#expireTime));
	    }
	}
	class ClientSideCacheEntryValue extends ClientSideCacheEntryBase {
	    #value;
	    get value() {
	        return this.#value;
	    }
	    constructor(ttl, value) {
	        super(ttl);
	        this.#value = value;
	    }
	}
	class ClientSideCacheEntryPromise extends ClientSideCacheEntryBase {
	    #sendCommandPromise;
	    get promise() {
	        return this.#sendCommandPromise;
	    }
	    constructor(ttl, sendCommandPromise) {
	        super(ttl);
	        this.#sendCommandPromise = sendCommandPromise;
	    }
	}
	class ClientSideCacheProvider extends stream_1.EventEmitter {
	}
	cache.ClientSideCacheProvider = ClientSideCacheProvider;
	class BasicClientSideCache extends ClientSideCacheProvider {
	    #cacheKeyToEntryMap;
	    #keyToCacheKeySetMap;
	    ttl;
	    maxEntries;
	    lru;
	    #statsCounter;
	    recordEvictions(count) {
	        this.#statsCounter.recordEvictions(count);
	    }
	    recordHits(count) {
	        this.#statsCounter.recordHits(count);
	    }
	    recordMisses(count) {
	        this.#statsCounter.recordMisses(count);
	    }
	    constructor(config) {
	        super();
	        this.#cacheKeyToEntryMap = new Map();
	        this.#keyToCacheKeySetMap = new Map();
	        this.ttl = config?.ttl ?? 0;
	        this.maxEntries = config?.maxEntries ?? 0;
	        this.lru = config?.evictPolicy !== "FIFO";
	        const recordStats = config?.recordStats !== false;
	        this.#statsCounter = recordStats ? DefaultStatsCounter.create() : disabledStatsCounter();
	    }
	    /* logic of how caching works:
	  
	    1. commands use a CommandParser
	      it enables us to define/retrieve
	        cacheKey - a unique key that corresponds to this command and its arguments
	        redisKeys - an array of redis keys as strings that if the key is modified, will cause redis to invalidate this result when cached
	    2. check if cacheKey is in our cache
	      2b1. if its a value cacheEntry - return it
	      2b2. if it's a promise cache entry - wait on promise and then go to 3c.
	    3. if cacheEntry is not in cache
	      3a. send the command save the promise into a a cacheEntry and then wait on result
	      3b. transform reply (if required) based on transformReply
	      3b. check the cacheEntry is still valid - in cache and hasn't been deleted)
	      3c. if valid - overwrite with value entry
	    4. return previously non cached result
	    */
	    async handleCache(client, parser, fn, transformReply, typeMapping) {
	        let reply;
	        const cacheKey = generateCacheKey(parser.redisArgs);
	        // "2"
	        let cacheEntry = this.get(cacheKey);
	        if (cacheEntry) {
	            // If instanceof is "too slow", can add a "type" and then use an "as" cast to call proper getters.
	            if (cacheEntry instanceof ClientSideCacheEntryValue) { // "2b1"
	                this.#statsCounter.recordHits(1);
	                return structuredClone(cacheEntry.value);
	            }
	            else if (cacheEntry instanceof ClientSideCacheEntryPromise) { // 2b2
	                // This counts as a miss since the value hasn't been fully loaded yet.
	                this.#statsCounter.recordMisses(1);
	                reply = await cacheEntry.promise;
	            }
	            else {
	                throw new Error("unknown cache entry type");
	            }
	        }
	        else { // 3/3a
	            this.#statsCounter.recordMisses(1);
	            const startTime = performance.now();
	            const promise = fn();
	            cacheEntry = this.createPromiseEntry(client, promise);
	            this.set(cacheKey, cacheEntry, parser.keys);
	            try {
	                reply = await promise;
	                const loadTime = performance.now() - startTime;
	                this.#statsCounter.recordLoadSuccess(loadTime);
	            }
	            catch (err) {
	                const loadTime = performance.now() - startTime;
	                this.#statsCounter.recordLoadFailure(loadTime);
	                if (cacheEntry.validate()) {
	                    this.delete(cacheKey);
	                }
	                throw err;
	            }
	        }
	        // 3b
	        let val;
	        if (transformReply) {
	            val = transformReply(reply, parser.preserve, typeMapping);
	        }
	        else {
	            val = reply;
	        }
	        // 3c
	        if (cacheEntry.validate()) { // revalidating promise entry (dont save value, if promise entry has been invalidated)
	            // 3d
	            cacheEntry = this.createValueEntry(client, val);
	            this.set(cacheKey, cacheEntry, parser.keys);
	            this.emit("cached-key", cacheKey);
	        }
	        return structuredClone(val);
	    }
	    trackingOn() {
	        return ['CLIENT', 'TRACKING', 'ON'];
	    }
	    invalidate(key) {
	        if (key === null) {
	            this.clear(false);
	            this.emit("invalidate", key);
	            return;
	        }
	        const keySet = this.#keyToCacheKeySetMap.get(key.toString());
	        if (keySet) {
	            for (const cacheKey of keySet) {
	                const entry = this.#cacheKeyToEntryMap.get(cacheKey);
	                if (entry) {
	                    entry.invalidate();
	                }
	                this.#cacheKeyToEntryMap.delete(cacheKey);
	            }
	            this.#keyToCacheKeySetMap.delete(key.toString());
	        }
	        this.emit('invalidate', key);
	    }
	    clear(resetStats = true) {
	        const oldSize = this.#cacheKeyToEntryMap.size;
	        this.#cacheKeyToEntryMap.clear();
	        this.#keyToCacheKeySetMap.clear();
	        if (resetStats) {
	            if (!(this.#statsCounter instanceof DisabledStatsCounter)) {
	                this.#statsCounter = DefaultStatsCounter.create();
	            }
	        }
	        else {
	            // If old entries were evicted due to clear, record them as evictions
	            if (oldSize > 0) {
	                this.#statsCounter.recordEvictions(oldSize);
	            }
	        }
	    }
	    get(cacheKey) {
	        const val = this.#cacheKeyToEntryMap.get(cacheKey);
	        if (val && !val.validate()) {
	            this.delete(cacheKey);
	            this.#statsCounter.recordEvictions(1);
	            this.emit("cache-evict", cacheKey);
	            return undefined;
	        }
	        if (val !== undefined && this.lru) {
	            this.#cacheKeyToEntryMap.delete(cacheKey);
	            this.#cacheKeyToEntryMap.set(cacheKey, val);
	        }
	        return val;
	    }
	    delete(cacheKey) {
	        const entry = this.#cacheKeyToEntryMap.get(cacheKey);
	        if (entry) {
	            entry.invalidate();
	            this.#cacheKeyToEntryMap.delete(cacheKey);
	        }
	    }
	    has(cacheKey) {
	        return this.#cacheKeyToEntryMap.has(cacheKey);
	    }
	    set(cacheKey, cacheEntry, keys) {
	        let count = this.#cacheKeyToEntryMap.size;
	        const oldEntry = this.#cacheKeyToEntryMap.get(cacheKey);
	        if (oldEntry) {
	            count--; // overwriting, so not incrementig
	            oldEntry.invalidate();
	        }
	        if (this.maxEntries > 0 && count >= this.maxEntries) {
	            this.deleteOldest();
	            this.#statsCounter.recordEvictions(1);
	        }
	        this.#cacheKeyToEntryMap.set(cacheKey, cacheEntry);
	        for (const key of keys) {
	            if (!this.#keyToCacheKeySetMap.has(key.toString())) {
	                this.#keyToCacheKeySetMap.set(key.toString(), new Set());
	            }
	            const cacheKeySet = this.#keyToCacheKeySetMap.get(key.toString());
	            cacheKeySet.add(cacheKey);
	        }
	    }
	    size() {
	        return this.#cacheKeyToEntryMap.size;
	    }
	    createValueEntry(client, value) {
	        return new ClientSideCacheEntryValue(this.ttl, value);
	    }
	    createPromiseEntry(client, sendCommandPromise) {
	        return new ClientSideCacheEntryPromise(this.ttl, sendCommandPromise);
	    }
	    stats() {
	        return this.#statsCounter.snapshot();
	    }
	    onError() {
	        this.clear();
	    }
	    onClose() {
	        this.clear();
	    }
	    /**
	     * @internal
	     */
	    deleteOldest() {
	        const it = this.#cacheKeyToEntryMap[Symbol.iterator]();
	        const n = it.next();
	        if (!n.done) {
	            const key = n.value[0];
	            const entry = this.#cacheKeyToEntryMap.get(key);
	            if (entry) {
	                entry.invalidate();
	            }
	            this.#cacheKeyToEntryMap.delete(key);
	        }
	    }
	    /**
	     * Get cache entries for debugging
	     * @internal
	     */
	    entryEntries() {
	        return this.#cacheKeyToEntryMap.entries();
	    }
	    /**
	     * Get key set entries for debugging
	     * @internal
	     */
	    keySetEntries() {
	        return this.#keyToCacheKeySetMap.entries();
	    }
	}
	cache.BasicClientSideCache = BasicClientSideCache;
	class PooledClientSideCacheProvider extends BasicClientSideCache {
	    #disabled = false;
	    disable() {
	        this.#disabled = true;
	    }
	    enable() {
	        this.#disabled = false;
	    }
	    get(cacheKey) {
	        if (this.#disabled) {
	            return undefined;
	        }
	        return super.get(cacheKey);
	    }
	    has(cacheKey) {
	        if (this.#disabled) {
	            return false;
	        }
	        return super.has(cacheKey);
	    }
	    onPoolClose() {
	        this.clear();
	    }
	}
	cache.PooledClientSideCacheProvider = PooledClientSideCacheProvider;
	class BasicPooledClientSideCache extends PooledClientSideCacheProvider {
	    onError() {
	        this.clear(false);
	    }
	    onClose() {
	        this.clear(false);
	    }
	}
	cache.BasicPooledClientSideCache = BasicPooledClientSideCache;
	class PooledClientSideCacheEntryValue extends ClientSideCacheEntryValue {
	    #creator;
	    constructor(ttl, creator, value) {
	        super(ttl, value);
	        this.#creator = creator;
	    }
	    validate() {
	        let ret = super.validate();
	        if (this.#creator) {
	            ret = ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
	        }
	        return ret;
	    }
	}
	class PooledClientSideCacheEntryPromise extends ClientSideCacheEntryPromise {
	    #creator;
	    constructor(ttl, creator, sendCommandPromise) {
	        super(ttl, sendCommandPromise);
	        this.#creator = creator;
	    }
	    validate() {
	        let ret = super.validate();
	        return ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
	    }
	}
	class PooledNoRedirectClientSideCache extends BasicPooledClientSideCache {
	    createValueEntry(client, value) {
	        const creator = {
	            epoch: client.socketEpoch,
	            client: client
	        };
	        return new PooledClientSideCacheEntryValue(this.ttl, creator, value);
	    }
	    createPromiseEntry(client, sendCommandPromise) {
	        const creator = {
	            epoch: client.socketEpoch,
	            client: client
	        };
	        return new PooledClientSideCacheEntryPromise(this.ttl, creator, sendCommandPromise);
	    }
	    onError() { }
	    onClose() { }
	}
	cache.PooledNoRedirectClientSideCache = PooledNoRedirectClientSideCache;
	
	return cache;
}

var singleEntryCache = {};

var hasRequiredSingleEntryCache;

function requireSingleEntryCache () {
	if (hasRequiredSingleEntryCache) return singleEntryCache;
	hasRequiredSingleEntryCache = 1;
	Object.defineProperty(singleEntryCache, "__esModule", { value: true });
	class SingleEntryCache {
	    #cached;
	    #serializedKey;
	    /**
	     * Retrieves an instance from the cache based on the provided key object.
	     *
	     * @param keyObj - The key object to look up in the cache.
	     * @returns The cached instance if found, undefined otherwise.
	     *
	     * @remarks
	     * This method uses JSON.stringify for comparison, which may not work correctly
	     * if the properties in the key object are rearranged or reordered.
	     */
	    get(keyObj) {
	        return JSON.stringify(keyObj, makeCircularReplacer()) === this.#serializedKey ? this.#cached : undefined;
	    }
	    set(keyObj, obj) {
	        this.#cached = obj;
	        this.#serializedKey = JSON.stringify(keyObj, makeCircularReplacer());
	    }
	}
	singleEntryCache.default = SingleEntryCache;
	function makeCircularReplacer() {
	    const seen = new WeakSet();
	    return function serialize(_, value) {
	        if (value && typeof value === 'object') {
	            if (seen.has(value)) {
	                return 'circular';
	            }
	            seen.add(value);
	            return value;
	        }
	        return value;
	    };
	}
	
	return singleEntryCache;
}

var hasRequiredPool;

function requirePool () {
	if (hasRequiredPool) return pool;
	hasRequiredPool = 1;
	var __importDefault = (pool && pool.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(pool, "__esModule", { value: true });
	pool.RedisClientPool = void 0;
	const commands_1 = __importDefault(requireCommands$5());
	const _1 = __importDefault(requireClient());
	const node_events_1 = require$$0$5;
	const linked_list_1 = requireLinkedList();
	const errors_1 = requireErrors$1();
	const commander_1 = requireCommander();
	const multi_command_1 = __importDefault(requireMultiCommand$1());
	const cache_1 = requireCache();
	const parser_1 = requireParser();
	const single_entry_cache_1 = __importDefault(requireSingleEntryCache());
	class RedisClientPool extends node_events_1.EventEmitter {
	    static #createCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            return this.execute(client => client._executeCommand(command, parser, this._commandOptions, transformReply));
	        };
	    }
	    static #createModuleCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            return this._self.execute(client => client._executeCommand(command, parser, this._self._commandOptions, transformReply));
	        };
	    }
	    static #createFunctionCommand(name, fn, resp) {
	        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
	        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            parser.push(...prefix);
	            fn.parseCommand(parser, ...args);
	            return this._self.execute(client => client._executeCommand(fn, parser, this._self._commandOptions, transformReply));
	        };
	    }
	    static #createScriptCommand(script, resp) {
	        const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
	        const transformReply = (0, commander_1.getTransformReply)(script, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            parser.pushVariadic(prefix);
	            script.parseCommand(parser, ...args);
	            return this.execute(client => client._executeScript(script, parser, this._commandOptions, transformReply));
	        };
	    }
	    static #SingleEntryCache = new single_entry_cache_1.default();
	    static create(clientOptions, options) {
	        let Pool = RedisClientPool.#SingleEntryCache.get(clientOptions);
	        if (!Pool) {
	            Pool = (0, commander_1.attachConfig)({
	                BaseClass: RedisClientPool,
	                commands: commands_1.default,
	                createCommand: RedisClientPool.#createCommand,
	                createModuleCommand: RedisClientPool.#createModuleCommand,
	                createFunctionCommand: RedisClientPool.#createFunctionCommand,
	                createScriptCommand: RedisClientPool.#createScriptCommand,
	                config: clientOptions
	            });
	            Pool.prototype.Multi = multi_command_1.default.extend(clientOptions);
	            RedisClientPool.#SingleEntryCache.set(clientOptions, Pool);
	        }
	        // returning a "proxy" to prevent the namespaces._self to leak between "proxies"
	        return Object.create(new Pool(clientOptions, options));
	    }
	    // TODO: defaults
	    static #DEFAULTS = {
	        minimum: 1,
	        maximum: 100,
	        acquireTimeout: 3000,
	        cleanupDelay: 3000
	    };
	    #clientFactory;
	    #options;
	    #idleClients = new linked_list_1.SinglyLinkedList();
	    /**
	     * The number of idle clients.
	     */
	    get idleClients() {
	        return this._self.#idleClients.length;
	    }
	    #clientsInUse = new linked_list_1.DoublyLinkedList();
	    /**
	     * The number of clients in use.
	     */
	    get clientsInUse() {
	        return this._self.#clientsInUse.length;
	    }
	    /**
	     * The total number of clients in the pool (including connecting, idle, and in use).
	     */
	    get totalClients() {
	        return this._self.#idleClients.length + this._self.#clientsInUse.length;
	    }
	    #tasksQueue = new linked_list_1.SinglyLinkedList();
	    /**
	     * The number of tasks waiting for a client to become available.
	     */
	    get tasksQueueLength() {
	        return this._self.#tasksQueue.length;
	    }
	    #isOpen = false;
	    /**
	     * Whether the pool is open (either connecting or connected).
	     */
	    get isOpen() {
	        return this._self.#isOpen;
	    }
	    #isClosing = false;
	    /**
	     * Whether the pool is closing (*not* closed).
	     */
	    get isClosing() {
	        return this._self.#isClosing;
	    }
	    #clientSideCache;
	    get clientSideCache() {
	        return this._self.#clientSideCache;
	    }
	    /**
	     * You are probably looking for {@link RedisClient.createPool `RedisClient.createPool`},
	     * {@link RedisClientPool.fromClient `RedisClientPool.fromClient`},
	     * or {@link RedisClientPool.fromOptions `RedisClientPool.fromOptions`}...
	     */
	    constructor(clientOptions, options) {
	        super();
	        this.#options = {
	            ...RedisClientPool.#DEFAULTS,
	            ...options
	        };
	        if (options?.clientSideCache) {
	            if (clientOptions === undefined) {
	                clientOptions = {};
	            }
	            if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
	                this.#clientSideCache = clientOptions.clientSideCache = options.clientSideCache;
	            }
	            else {
	                const cscConfig = options.clientSideCache;
	                this.#clientSideCache = clientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
	                //        this.#clientSideCache = clientOptions.clientSideCache = new PooledNoRedirectClientSideCache(cscConfig);
	            }
	        }
	        this.#clientFactory = _1.default.factory(clientOptions).bind(undefined, clientOptions);
	    }
	    _self = this;
	    _commandOptions;
	    withCommandOptions(options) {
	        const proxy = Object.create(this._self);
	        proxy._commandOptions = options;
	        return proxy;
	    }
	    #commandOptionsProxy(key, value) {
	        const proxy = Object.create(this._self);
	        proxy._commandOptions = Object.create(this._commandOptions ?? null);
	        proxy._commandOptions[key] = value;
	        return proxy;
	    }
	    /**
	     * Override the `typeMapping` command option
	     */
	    withTypeMapping(typeMapping) {
	        return this._self.#commandOptionsProxy('typeMapping', typeMapping);
	    }
	    /**
	     * Override the `abortSignal` command option
	     */
	    withAbortSignal(abortSignal) {
	        return this._self.#commandOptionsProxy('abortSignal', abortSignal);
	    }
	    /**
	     * Override the `asap` command option to `true`
	     * TODO: remove?
	     */
	    asap() {
	        return this._self.#commandOptionsProxy('asap', true);
	    }
	    async connect() {
	        if (this._self.#isOpen)
	            return; // TODO: throw error?
	        this._self.#isOpen = true;
	        const promises = [];
	        while (promises.length < this._self.#options.minimum) {
	            promises.push(this._self.#create());
	        }
	        try {
	            await Promise.all(promises);
	        }
	        catch (err) {
	            this.destroy();
	            throw err;
	        }
	        return this;
	    }
	    async #create() {
	        const node = this._self.#clientsInUse.push(this._self.#clientFactory()
	            .on('error', (err) => this.emit('error', err)));
	        try {
	            const client = node.value;
	            await client.connect();
	        }
	        catch (err) {
	            this._self.#clientsInUse.remove(node);
	            throw err;
	        }
	        this._self.#returnClient(node);
	    }
	    execute(fn) {
	        return new Promise((resolve, reject) => {
	            const client = this._self.#idleClients.shift(), { tail } = this._self.#tasksQueue;
	            if (!client) {
	                let timeout;
	                if (this._self.#options.acquireTimeout > 0) {
	                    timeout = setTimeout(() => {
	                        this._self.#tasksQueue.remove(task, tail);
	                        reject(new errors_1.TimeoutError('Timeout waiting for a client')); // TODO: message
	                    }, this._self.#options.acquireTimeout);
	                }
	                const task = this._self.#tasksQueue.push({
	                    timeout,
	                    // @ts-ignore
	                    resolve,
	                    reject,
	                    fn
	                });
	                if (this.totalClients < this._self.#options.maximum) {
	                    this._self.#create();
	                }
	                return;
	            }
	            const node = this._self.#clientsInUse.push(client);
	            // @ts-ignore
	            this._self.#executeTask(node, resolve, reject, fn);
	        });
	    }
	    #executeTask(node, resolve, reject, fn) {
	        const result = fn(node.value);
	        if (result instanceof Promise) {
	            result.then(resolve, reject);
	            result.finally(() => this.#returnClient(node));
	        }
	        else {
	            resolve(result);
	            this.#returnClient(node);
	        }
	    }
	    #returnClient(node) {
	        const task = this.#tasksQueue.shift();
	        if (task) {
	            clearTimeout(task.timeout);
	            this.#executeTask(node, task.resolve, task.reject, task.fn);
	            return;
	        }
	        this.#clientsInUse.remove(node);
	        this.#idleClients.push(node.value);
	        this.#scheduleCleanup();
	    }
	    cleanupTimeout;
	    #scheduleCleanup() {
	        if (this.totalClients <= this.#options.minimum)
	            return;
	        clearTimeout(this.cleanupTimeout);
	        this.cleanupTimeout = setTimeout(() => this.#cleanup(), this.#options.cleanupDelay);
	    }
	    #cleanup() {
	        const toDestroy = Math.min(this.#idleClients.length, this.totalClients - this.#options.minimum);
	        for (let i = 0; i < toDestroy; i++) {
	            // TODO: shift vs pop
	            const client = this.#idleClients.shift();
	            client.destroy();
	        }
	    }
	    sendCommand(args, options) {
	        return this.execute(client => client.sendCommand(args, options));
	    }
	    MULTI() {
	        return new this.Multi((commands, selectedDB) => this.execute(client => client._executeMulti(commands, selectedDB)), commands => this.execute(client => client._executePipeline(commands)), this._commandOptions?.typeMapping);
	    }
	    multi = this.MULTI;
	    async close() {
	        if (this._self.#isClosing)
	            return; // TODO: throw err?
	        if (!this._self.#isOpen)
	            return; // TODO: throw err?
	        this._self.#isClosing = true;
	        try {
	            const promises = [];
	            for (const client of this._self.#idleClients) {
	                promises.push(client.close());
	            }
	            for (const client of this._self.#clientsInUse) {
	                promises.push(client.close());
	            }
	            await Promise.all(promises);
	            this.#clientSideCache?.onPoolClose();
	            this._self.#idleClients.reset();
	            this._self.#clientsInUse.reset();
	        }
	        catch (err) {
	        }
	        finally {
	            this._self.#isClosing = false;
	        }
	    }
	    destroy() {
	        for (const client of this._self.#idleClients) {
	            client.destroy();
	        }
	        this._self.#idleClients.reset();
	        for (const client of this._self.#clientsInUse) {
	            client.destroy();
	        }
	        this._self.#clientSideCache?.onPoolClose();
	        this._self.#clientsInUse.reset();
	        this._self.#isOpen = false;
	    }
	}
	pool.RedisClientPool = RedisClientPool;
	
	return pool;
}

var version = "5.6.0";
var require$$17 = {
	version: version};

var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client;
	hasRequiredClient = 1;
	var __importDefault = (client && client.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	var _a;
	Object.defineProperty(client, "__esModule", { value: true });
	const commands_1 = __importDefault(requireCommands$5());
	const socket_1 = __importDefault(requireSocket());
	const authx_1 = requireAuthx();
	const commands_queue_1 = __importDefault(requireCommandsQueue());
	const node_events_1 = require$$0$5;
	const commander_1 = requireCommander();
	const errors_1 = requireErrors$1();
	const node_url_1 = require$$7$1;
	const pub_sub_1 = requirePubSub();
	const multi_command_1 = __importDefault(requireMultiCommand$1());
	const HELLO_1 = __importDefault(requireHELLO());
	const legacy_mode_1 = requireLegacyMode();
	const pool_1 = requirePool();
	const generic_transformers_1 = requireGenericTransformers();
	const cache_1 = requireCache();
	const parser_1 = requireParser();
	const single_entry_cache_1 = __importDefault(requireSingleEntryCache());
	const package_json_1 = require$$17;
	class RedisClient extends node_events_1.EventEmitter {
	    static #createCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            return this._self._executeCommand(command, parser, this._commandOptions, transformReply);
	        };
	    }
	    static #createModuleCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            return this._self._executeCommand(command, parser, this._self._commandOptions, transformReply);
	        };
	    }
	    static #createFunctionCommand(name, fn, resp) {
	        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
	        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            parser.push(...prefix);
	            fn.parseCommand(parser, ...args);
	            return this._self._executeCommand(fn, parser, this._self._commandOptions, transformReply);
	        };
	    }
	    static #createScriptCommand(script, resp) {
	        const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
	        const transformReply = (0, commander_1.getTransformReply)(script, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            parser.push(...prefix);
	            script.parseCommand(parser, ...args);
	            return this._executeScript(script, parser, this._commandOptions, transformReply);
	        };
	    }
	    static #SingleEntryCache = new single_entry_cache_1.default();
	    static factory(config) {
	        let Client = _a.#SingleEntryCache.get(config);
	        if (!Client) {
	            Client = (0, commander_1.attachConfig)({
	                BaseClass: _a,
	                commands: commands_1.default,
	                createCommand: _a.#createCommand,
	                createModuleCommand: _a.#createModuleCommand,
	                createFunctionCommand: _a.#createFunctionCommand,
	                createScriptCommand: _a.#createScriptCommand,
	                config
	            });
	            Client.prototype.Multi = multi_command_1.default.extend(config);
	            _a.#SingleEntryCache.set(config, Client);
	        }
	        return (options) => {
	            // returning a "proxy" to prevent the namespaces._self to leak between "proxies"
	            return Object.create(new Client(options));
	        };
	    }
	    static create(options) {
	        return _a.factory(options)(options);
	    }
	    static parseURL(url) {
	        // https://www.iana.org/assignments/uri-schemes/prov/redis
	        const { hostname, port, protocol, username, password, pathname } = new node_url_1.URL(url), parsed = {
	            socket: {
	                host: hostname
	            }
	        };
	        if (protocol === 'rediss:') {
	            parsed.socket.tls = true;
	        }
	        else if (protocol !== 'redis:') {
	            throw new TypeError('Invalid protocol');
	        }
	        if (port) {
	            parsed.socket.port = Number(port);
	        }
	        if (username) {
	            parsed.username = decodeURIComponent(username);
	        }
	        if (password) {
	            parsed.password = decodeURIComponent(password);
	        }
	        if (username || password) {
	            parsed.credentialsProvider = {
	                type: 'async-credentials-provider',
	                credentials: async () => ({
	                    username: username ? decodeURIComponent(username) : undefined,
	                    password: password ? decodeURIComponent(password) : undefined
	                })
	            };
	        }
	        if (pathname.length > 1) {
	            const database = Number(pathname.substring(1));
	            if (isNaN(database)) {
	                throw new TypeError('Invalid pathname');
	            }
	            parsed.database = database;
	        }
	        return parsed;
	    }
	    #options;
	    #socket;
	    #queue;
	    #selectedDB = 0;
	    #monitorCallback;
	    _self = this;
	    _commandOptions;
	    // flag used to annotate that the client
	    // was in a watch transaction when
	    // a topology change occured
	    #dirtyWatch;
	    #watchEpoch;
	    #clientSideCache;
	    #credentialsSubscription = null;
	    get clientSideCache() {
	        return this._self.#clientSideCache;
	    }
	    get options() {
	        return this._self.#options;
	    }
	    get isOpen() {
	        return this._self.#socket.isOpen;
	    }
	    get isReady() {
	        return this._self.#socket.isReady;
	    }
	    get isPubSubActive() {
	        return this._self.#queue.isPubSubActive;
	    }
	    get socketEpoch() {
	        return this._self.#socket.socketEpoch;
	    }
	    get isWatching() {
	        return this._self.#watchEpoch !== undefined;
	    }
	    /**
	     * Indicates whether the client's WATCH command has been invalidated by a topology change.
	     * When this returns true, any transaction using WATCH will fail with a WatchError.
	     * @returns true if the watched keys have been modified, false otherwise
	     */
	    get isDirtyWatch() {
	        return this._self.#dirtyWatch !== undefined;
	    }
	    /**
	     * Marks the client's WATCH command as invalidated due to a topology change.
	     * This will cause any subsequent EXEC in a transaction to fail with a WatchError.
	     * @param msg - The error message explaining why the WATCH is dirty
	     */
	    setDirtyWatch(msg) {
	        this._self.#dirtyWatch = msg;
	    }
	    constructor(options) {
	        super();
	        this.#validateOptions(options);
	        this.#options = this.#initiateOptions(options);
	        this.#queue = this.#initiateQueue();
	        this.#socket = this.#initiateSocket();
	        if (options?.clientSideCache) {
	            if (options.clientSideCache instanceof cache_1.ClientSideCacheProvider) {
	                this.#clientSideCache = options.clientSideCache;
	            }
	            else {
	                const cscConfig = options.clientSideCache;
	                this.#clientSideCache = new cache_1.BasicClientSideCache(cscConfig);
	            }
	            this.#queue.setInvalidateCallback(this.#clientSideCache.invalidate.bind(this.#clientSideCache));
	        }
	    }
	    #validateOptions(options) {
	        if (options?.clientSideCache && options?.RESP !== 3) {
	            throw new Error('Client Side Caching is only supported with RESP3');
	        }
	    }
	    #initiateOptions(options) {
	        // Convert username/password to credentialsProvider if no credentialsProvider is already in place
	        if (!options?.credentialsProvider && (options?.username || options?.password)) {
	            options.credentialsProvider = {
	                type: 'async-credentials-provider',
	                credentials: async () => ({
	                    username: options.username,
	                    password: options.password
	                })
	            };
	        }
	        if (options?.url) {
	            const parsed = _a.parseURL(options.url);
	            if (options.socket) {
	                parsed.socket = Object.assign(options.socket, parsed.socket);
	            }
	            Object.assign(options, parsed);
	        }
	        if (options?.database) {
	            this._self.#selectedDB = options.database;
	        }
	        if (options?.commandOptions) {
	            this._commandOptions = options.commandOptions;
	        }
	        return options;
	    }
	    #initiateQueue() {
	        return new commands_queue_1.default(this.#options?.RESP ?? 2, this.#options?.commandsQueueMaxLength, (channel, listeners) => this.emit('sharded-channel-moved', channel, listeners));
	    }
	    /**
	     * @param credentials
	     */
	    reAuthenticate = async (credentials) => {
	        // Re-authentication is not supported on RESP2 with PubSub active
	        if (!(this.isPubSubActive && !this.#options?.RESP)) {
	            await this.sendCommand((0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
	                username: credentials.username,
	                password: credentials.password ?? ''
	            }));
	        }
	    };
	    #subscribeForStreamingCredentials(cp) {
	        return cp.subscribe({
	            onNext: credentials => {
	                this.reAuthenticate(credentials).catch(error => {
	                    const errorMessage = error instanceof Error ? error.message : String(error);
	                    cp.onReAuthenticationError(new authx_1.CredentialsError(errorMessage));
	                });
	            },
	            onError: (e) => {
	                const errorMessage = `Error from streaming credentials provider: ${e.message}`;
	                cp.onReAuthenticationError(new authx_1.UnableToObtainNewCredentialsError(errorMessage));
	            }
	        });
	    }
	    async #handshake(chainId, asap) {
	        const promises = [];
	        const commandsWithErrorHandlers = await this.#getHandshakeCommands();
	        if (asap)
	            commandsWithErrorHandlers.reverse();
	        for (const { cmd, errorHandler } of commandsWithErrorHandlers) {
	            promises.push(this.#queue
	                .addCommand(cmd, {
	                chainId,
	                asap
	            })
	                .catch(errorHandler));
	        }
	        return promises;
	    }
	    async #getHandshakeCommands() {
	        const commands = [];
	        const cp = this.#options?.credentialsProvider;
	        if (this.#options?.RESP) {
	            const hello = {};
	            if (cp && cp.type === 'async-credentials-provider') {
	                const credentials = await cp.credentials();
	                if (credentials.password) {
	                    hello.AUTH = {
	                        username: credentials.username ?? 'default',
	                        password: credentials.password
	                    };
	                }
	            }
	            if (cp && cp.type === 'streaming-credentials-provider') {
	                const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
	                this.#credentialsSubscription = disposable;
	                if (credentials.password) {
	                    hello.AUTH = {
	                        username: credentials.username ?? 'default',
	                        password: credentials.password
	                    };
	                }
	            }
	            if (this.#options.name) {
	                hello.SETNAME = this.#options.name;
	            }
	            commands.push({ cmd: (0, generic_transformers_1.parseArgs)(HELLO_1.default, this.#options.RESP, hello) });
	        }
	        else {
	            if (cp && cp.type === 'async-credentials-provider') {
	                const credentials = await cp.credentials();
	                if (credentials.username || credentials.password) {
	                    commands.push({
	                        cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
	                            username: credentials.username,
	                            password: credentials.password ?? ''
	                        })
	                    });
	                }
	            }
	            if (cp && cp.type === 'streaming-credentials-provider') {
	                const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
	                this.#credentialsSubscription = disposable;
	                if (credentials.username || credentials.password) {
	                    commands.push({
	                        cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
	                            username: credentials.username,
	                            password: credentials.password ?? ''
	                        })
	                    });
	                }
	            }
	            if (this.#options?.name) {
	                commands.push({
	                    cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.CLIENT_SETNAME, this.#options.name)
	                });
	            }
	        }
	        if (this.#selectedDB !== 0) {
	            commands.push({ cmd: ['SELECT', this.#selectedDB.toString()] });
	        }
	        if (this.#options?.readonly) {
	            commands.push({ cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.READONLY) });
	        }
	        if (!this.#options?.disableClientInfo) {
	            commands.push({
	                cmd: ['CLIENT', 'SETINFO', 'LIB-VER', package_json_1.version],
	                errorHandler: () => {
	                    // Client libraries are expected to pipeline this command
	                    // after authentication on all connections and ignore failures
	                    // since they could be connected to an older version that doesn't support them.
	                }
	            });
	            commands.push({
	                cmd: [
	                    'CLIENT',
	                    'SETINFO',
	                    'LIB-NAME',
	                    this.#options?.clientInfoTag
	                        ? `node-redis(${this.#options.clientInfoTag})`
	                        : 'node-redis'
	                ],
	                errorHandler: () => {
	                    // Client libraries are expected to pipeline this command
	                    // after authentication on all connections and ignore failures
	                    // since they could be connected to an older version that doesn't support them.
	                }
	            });
	        }
	        if (this.#clientSideCache) {
	            commands.push({ cmd: this.#clientSideCache.trackingOn() });
	        }
	        return commands;
	    }
	    #initiateSocket() {
	        const socketInitiator = async () => {
	            const promises = [], chainId = Symbol('Socket Initiator');
	            const resubscribePromise = this.#queue.resubscribe(chainId);
	            if (resubscribePromise) {
	                promises.push(resubscribePromise);
	            }
	            if (this.#monitorCallback) {
	                promises.push(this.#queue.monitor(this.#monitorCallback, {
	                    typeMapping: this._commandOptions?.typeMapping,
	                    chainId,
	                    asap: true
	                }));
	            }
	            promises.push(...(await this.#handshake(chainId, true)));
	            if (promises.length) {
	                this.#write();
	                return Promise.all(promises);
	            }
	        };
	        return new socket_1.default(socketInitiator, this.#options?.socket)
	            .on('data', chunk => {
	            try {
	                this.#queue.decoder.write(chunk);
	            }
	            catch (err) {
	                this.#queue.resetDecoder();
	                this.emit('error', err);
	            }
	        })
	            .on('error', err => {
	            this.emit('error', err);
	            this.#clientSideCache?.onError();
	            if (this.#socket.isOpen && !this.#options?.disableOfflineQueue) {
	                this.#queue.flushWaitingForReply(err);
	            }
	            else {
	                this.#queue.flushAll(err);
	            }
	        })
	            .on('connect', () => this.emit('connect'))
	            .on('ready', () => {
	            this.emit('ready');
	            this.#setPingTimer();
	            this.#maybeScheduleWrite();
	        })
	            .on('reconnecting', () => this.emit('reconnecting'))
	            .on('drain', () => this.#maybeScheduleWrite())
	            .on('end', () => this.emit('end'));
	    }
	    #pingTimer;
	    #setPingTimer() {
	        if (!this.#options?.pingInterval || !this.#socket.isReady)
	            return;
	        clearTimeout(this.#pingTimer);
	        this.#pingTimer = setTimeout(() => {
	            if (!this.#socket.isReady)
	                return;
	            this.sendCommand(['PING'])
	                .then(reply => this.emit('ping-interval', reply))
	                .catch(err => this.emit('error', err))
	                .finally(() => this.#setPingTimer());
	        }, this.#options.pingInterval);
	    }
	    withCommandOptions(options) {
	        const proxy = Object.create(this._self);
	        proxy._commandOptions = options;
	        return proxy;
	    }
	    _commandOptionsProxy(key, value) {
	        const proxy = Object.create(this._self);
	        proxy._commandOptions = Object.create(this._commandOptions ?? null);
	        proxy._commandOptions[key] = value;
	        return proxy;
	    }
	    /**
	     * Override the `typeMapping` command option
	     */
	    withTypeMapping(typeMapping) {
	        return this._commandOptionsProxy('typeMapping', typeMapping);
	    }
	    /**
	     * Override the `abortSignal` command option
	     */
	    withAbortSignal(abortSignal) {
	        return this._commandOptionsProxy('abortSignal', abortSignal);
	    }
	    /**
	     * Override the `asap` command option to `true`
	     */
	    asap() {
	        return this._commandOptionsProxy('asap', true);
	    }
	    /**
	     * Create the "legacy" (v3/callback) interface
	     */
	    legacy() {
	        return new legacy_mode_1.RedisLegacyClient(this);
	    }
	    /**
	     * Create {@link RedisClientPool `RedisClientPool`} using this client as a prototype
	     */
	    createPool(options) {
	        return pool_1.RedisClientPool.create(this._self.#options, options);
	    }
	    duplicate(overrides) {
	        return new (Object.getPrototypeOf(this).constructor)({
	            ...this._self.#options,
	            commandOptions: this._commandOptions,
	            ...overrides
	        });
	    }
	    async connect() {
	        await this._self.#socket.connect();
	        return this;
	    }
	    /**
	     * @internal
	     */
	    async _executeCommand(command, parser, commandOptions, transformReply) {
	        const csc = this._self.#clientSideCache;
	        const defaultTypeMapping = this._self.#options?.commandOptions === commandOptions;
	        const fn = () => { return this.sendCommand(parser.redisArgs, commandOptions); };
	        if (csc && command.CACHEABLE && defaultTypeMapping) {
	            return await csc.handleCache(this._self, parser, fn, transformReply, commandOptions?.typeMapping);
	        }
	        else {
	            const reply = await fn();
	            if (transformReply) {
	                return transformReply(reply, parser.preserve, commandOptions?.typeMapping);
	            }
	            return reply;
	        }
	    }
	    /**
	     * @internal
	     */
	    async _executeScript(script, parser, options, transformReply) {
	        const args = parser.redisArgs;
	        let reply;
	        try {
	            reply = await this.sendCommand(args, options);
	        }
	        catch (err) {
	            if (!err?.message?.startsWith?.('NOSCRIPT'))
	                throw err;
	            args[0] = 'EVAL';
	            args[1] = script.SCRIPT;
	            reply = await this.sendCommand(args, options);
	        }
	        return transformReply ?
	            transformReply(reply, parser.preserve, options?.typeMapping) :
	            reply;
	    }
	    sendCommand(args, options) {
	        if (!this._self.#socket.isOpen) {
	            return Promise.reject(new errors_1.ClientClosedError());
	        }
	        else if (!this._self.#socket.isReady && this._self.#options?.disableOfflineQueue) {
	            return Promise.reject(new errors_1.ClientOfflineError());
	        }
	        // Merge global options with provided options
	        const opts = {
	            ...this._self._commandOptions,
	            ...options
	        };
	        const promise = this._self.#queue.addCommand(args, opts);
	        this._self.#scheduleWrite();
	        return promise;
	    }
	    async SELECT(db) {
	        await this.sendCommand(['SELECT', db.toString()]);
	        this._self.#selectedDB = db;
	    }
	    select = this.SELECT;
	    #pubSubCommand(promise) {
	        if (promise === undefined)
	            return Promise.resolve();
	        this.#scheduleWrite();
	        return promise;
	    }
	    SUBSCRIBE(channels, listener, bufferMode) {
	        return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
	    }
	    subscribe = this.SUBSCRIBE;
	    UNSUBSCRIBE(channels, listener, bufferMode) {
	        return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
	    }
	    unsubscribe = this.UNSUBSCRIBE;
	    PSUBSCRIBE(patterns, listener, bufferMode) {
	        return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
	    }
	    pSubscribe = this.PSUBSCRIBE;
	    PUNSUBSCRIBE(patterns, listener, bufferMode) {
	        return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
	    }
	    pUnsubscribe = this.PUNSUBSCRIBE;
	    SSUBSCRIBE(channels, listener, bufferMode) {
	        return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
	    }
	    sSubscribe = this.SSUBSCRIBE;
	    SUNSUBSCRIBE(channels, listener, bufferMode) {
	        return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
	    }
	    sUnsubscribe = this.SUNSUBSCRIBE;
	    async WATCH(key) {
	        const reply = await this._self.sendCommand((0, generic_transformers_1.pushVariadicArguments)(['WATCH'], key));
	        this._self.#watchEpoch ??= this._self.socketEpoch;
	        return reply;
	    }
	    watch = this.WATCH;
	    async UNWATCH() {
	        const reply = await this._self.sendCommand(['UNWATCH']);
	        this._self.#watchEpoch = undefined;
	        return reply;
	    }
	    unwatch = this.UNWATCH;
	    getPubSubListeners(type) {
	        return this._self.#queue.getPubSubListeners(type);
	    }
	    extendPubSubChannelListeners(type, channel, listeners) {
	        return this._self.#pubSubCommand(this._self.#queue.extendPubSubChannelListeners(type, channel, listeners));
	    }
	    extendPubSubListeners(type, listeners) {
	        return this._self.#pubSubCommand(this._self.#queue.extendPubSubListeners(type, listeners));
	    }
	    #write() {
	        this.#socket.write(this.#queue.commandsToWrite());
	    }
	    #scheduledWrite;
	    #scheduleWrite() {
	        if (!this.#socket.isReady || this.#scheduledWrite)
	            return;
	        this.#scheduledWrite = setImmediate(() => {
	            this.#write();
	            this.#scheduledWrite = undefined;
	        });
	    }
	    #maybeScheduleWrite() {
	        if (!this.#queue.isWaitingToWrite())
	            return;
	        this.#scheduleWrite();
	    }
	    /**
	     * @internal
	     */
	    async _executePipeline(commands, selectedDB) {
	        if (!this._self.#socket.isOpen) {
	            return Promise.reject(new errors_1.ClientClosedError());
	        }
	        const chainId = Symbol('Pipeline Chain'), promise = Promise.all(commands.map(({ args }) => this._self.#queue.addCommand(args, {
	            chainId,
	            typeMapping: this._commandOptions?.typeMapping
	        })));
	        this._self.#scheduleWrite();
	        const result = await promise;
	        if (selectedDB !== undefined) {
	            this._self.#selectedDB = selectedDB;
	        }
	        return result;
	    }
	    /**
	     * @internal
	     */
	    async _executeMulti(commands, selectedDB) {
	        const dirtyWatch = this._self.#dirtyWatch;
	        this._self.#dirtyWatch = undefined;
	        const watchEpoch = this._self.#watchEpoch;
	        this._self.#watchEpoch = undefined;
	        if (!this._self.#socket.isOpen) {
	            throw new errors_1.ClientClosedError();
	        }
	        if (dirtyWatch) {
	            throw new errors_1.WatchError(dirtyWatch);
	        }
	        if (watchEpoch && watchEpoch !== this._self.socketEpoch) {
	            throw new errors_1.WatchError('Client reconnected after WATCH');
	        }
	        const typeMapping = this._commandOptions?.typeMapping;
	        const chainId = Symbol('MULTI Chain');
	        const promises = [
	            this._self.#queue.addCommand(['MULTI'], { chainId }),
	        ];
	        for (const { args } of commands) {
	            promises.push(this._self.#queue.addCommand(args, {
	                chainId,
	                typeMapping
	            }));
	        }
	        promises.push(this._self.#queue.addCommand(['EXEC'], { chainId }));
	        this._self.#scheduleWrite();
	        const results = await Promise.all(promises), execResult = results[results.length - 1];
	        if (execResult === null) {
	            throw new errors_1.WatchError();
	        }
	        if (selectedDB !== undefined) {
	            this._self.#selectedDB = selectedDB;
	        }
	        return execResult;
	    }
	    MULTI() {
	        return new this.Multi(this._executeMulti.bind(this), this._executePipeline.bind(this), this._commandOptions?.typeMapping);
	    }
	    multi = this.MULTI;
	    async *scanIterator(options) {
	        let cursor = options?.cursor ?? '0';
	        do {
	            const reply = await this.scan(cursor, options);
	            cursor = reply.cursor;
	            yield reply.keys;
	        } while (cursor !== '0');
	    }
	    async *hScanIterator(key, options) {
	        let cursor = options?.cursor ?? '0';
	        do {
	            const reply = await this.hScan(key, cursor, options);
	            cursor = reply.cursor;
	            yield reply.entries;
	        } while (cursor !== '0');
	    }
	    async *hScanValuesIterator(key, options) {
	        let cursor = options?.cursor ?? '0';
	        do {
	            const reply = await this.hScanNoValues(key, cursor, options);
	            cursor = reply.cursor;
	            yield reply.fields;
	        } while (cursor !== '0');
	    }
	    async *hScanNoValuesIterator(key, options) {
	        let cursor = options?.cursor ?? '0';
	        do {
	            const reply = await this.hScanNoValues(key, cursor, options);
	            cursor = reply.cursor;
	            yield reply.fields;
	        } while (cursor !== '0');
	    }
	    async *sScanIterator(key, options) {
	        let cursor = options?.cursor ?? '0';
	        do {
	            const reply = await this.sScan(key, cursor, options);
	            cursor = reply.cursor;
	            yield reply.members;
	        } while (cursor !== '0');
	    }
	    async *zScanIterator(key, options) {
	        let cursor = options?.cursor ?? '0';
	        do {
	            const reply = await this.zScan(key, cursor, options);
	            cursor = reply.cursor;
	            yield reply.members;
	        } while (cursor !== '0');
	    }
	    async MONITOR(callback) {
	        const promise = this._self.#queue.monitor(callback, {
	            typeMapping: this._commandOptions?.typeMapping
	        });
	        this._self.#scheduleWrite();
	        await promise;
	        this._self.#monitorCallback = callback;
	    }
	    monitor = this.MONITOR;
	    /**
	     * Reset the client to its default state (i.e. stop PubSub, stop monitoring, select default DB, etc.)
	     */
	    async reset() {
	        const chainId = Symbol('Reset Chain'), promises = [this._self.#queue.reset(chainId)], selectedDB = this._self.#options?.database ?? 0;
	        this._self.#credentialsSubscription?.dispose();
	        this._self.#credentialsSubscription = null;
	        promises.push(...(await this._self.#handshake(chainId, false)));
	        this._self.#scheduleWrite();
	        await Promise.all(promises);
	        this._self.#selectedDB = selectedDB;
	        this._self.#monitorCallback = undefined;
	        this._self.#dirtyWatch = undefined;
	        this._self.#watchEpoch = undefined;
	    }
	    /**
	     * If the client has state, reset it.
	     * An internal function to be used by wrapper class such as `RedisClientPool`.
	     * @internal
	     */
	    resetIfDirty() {
	        let shouldReset = false;
	        if (this._self.#selectedDB !== (this._self.#options?.database ?? 0)) {
	            console.warn('Returning a client with a different selected DB');
	            shouldReset = true;
	        }
	        if (this._self.#monitorCallback) {
	            console.warn('Returning a client with active MONITOR');
	            shouldReset = true;
	        }
	        if (this._self.#queue.isPubSubActive) {
	            console.warn('Returning a client with active PubSub');
	            shouldReset = true;
	        }
	        if (this._self.#dirtyWatch || this._self.#watchEpoch) {
	            console.warn('Returning a client with active WATCH');
	            shouldReset = true;
	        }
	        if (shouldReset) {
	            return this.reset();
	        }
	    }
	    /**
	     * @deprecated use .close instead
	     */
	    QUIT() {
	        this._self.#credentialsSubscription?.dispose();
	        this._self.#credentialsSubscription = null;
	        return this._self.#socket.quit(async () => {
	            clearTimeout(this._self.#pingTimer);
	            const quitPromise = this._self.#queue.addCommand(['QUIT']);
	            this._self.#scheduleWrite();
	            return quitPromise;
	        });
	    }
	    quit = this.QUIT;
	    /**
	     * @deprecated use .destroy instead
	     */
	    disconnect() {
	        return Promise.resolve(this.destroy());
	    }
	    /**
	     * Close the client. Wait for pending commands.
	     */
	    close() {
	        return new Promise(resolve => {
	            clearTimeout(this._self.#pingTimer);
	            this._self.#socket.close();
	            this._self.#clientSideCache?.onClose();
	            if (this._self.#queue.isEmpty()) {
	                this._self.#socket.destroySocket();
	                return resolve();
	            }
	            const maybeClose = () => {
	                if (!this._self.#queue.isEmpty())
	                    return;
	                this._self.#socket.off('data', maybeClose);
	                this._self.#socket.destroySocket();
	                resolve();
	            };
	            this._self.#socket.on('data', maybeClose);
	            this._self.#credentialsSubscription?.dispose();
	            this._self.#credentialsSubscription = null;
	        });
	    }
	    /**
	     * Destroy the client. Rejects all commands immediately.
	     */
	    destroy() {
	        clearTimeout(this._self.#pingTimer);
	        this._self.#queue.flushAll(new errors_1.DisconnectsClientError());
	        this._self.#socket.destroy();
	        this._self.#clientSideCache?.onClose();
	        this._self.#credentialsSubscription?.dispose();
	        this._self.#credentialsSubscription = null;
	    }
	    ref() {
	        this._self.#socket.ref();
	    }
	    unref() {
	        this._self.#socket.unref();
	    }
	}
	_a = RedisClient;
	client.default = RedisClient;
	
	return client;
}

var cluster = {};

var clusterSlots = {};

var lib$4 = {exports: {}};

/*
 * Copyright 2001-2010 Georges Menie (www.menie.org)
 * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)
 * Copyright 2015 Zihua Li (http://zihua.li) (ported to JavaScript)
 * Copyright 2016 Mike Diarmid (http://github.com/salakar) (re-write for performance, ~700% perf inc)
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the University of California, Berkeley nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var hasRequiredLib$4;

function requireLib$4 () {
	if (hasRequiredLib$4) return lib$4.exports;
	hasRequiredLib$4 = 1;
	/* CRC16 implementation according to CCITT standards.
	 *
	 * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the
	 * following parameters:
	 *
	 * Name                       : "XMODEM", also known as "ZMODEM", "CRC-16/ACORN"
	 * Width                      : 16 bit
	 * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)
	 * Initialization             : 0000
	 * Reflect Input byte         : False
	 * Reflect Output CRC         : False
	 * Xor constant to output CRC : 0000
	 * Output for "123456789"     : 31C3
	 */

	var lookup = [
	  0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
	  0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
	  0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
	  0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
	  0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
	  0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
	  0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
	  0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
	  0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
	  0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
	  0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
	  0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
	  0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
	  0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
	  0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
	  0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
	  0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
	  0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
	  0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
	  0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
	  0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
	  0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
	  0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
	  0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
	  0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
	  0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
	  0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
	  0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
	  0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
	  0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
	  0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
	  0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
	];

	/**
	 * Convert a string to a UTF8 array - faster than via buffer
	 * @param str
	 * @returns {Array}
	 */
	var toUTF8Array = function toUTF8Array(str) {
	  var char;
	  var i = 0;
	  var p = 0;
	  var utf8 = [];
	  var len = str.length;

	  for (; i < len; i++) {
	    char = str.charCodeAt(i);
	    if (char < 128) {
	      utf8[p++] = char;
	    } else if (char < 2048) {
	      utf8[p++] = (char >> 6) | 192;
	      utf8[p++] = (char & 63) | 128;
	    } else if (
	        ((char & 0xFC00) === 0xD800) && (i + 1) < str.length &&
	        ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {
	      char = 0x10000 + ((char & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF);
	      utf8[p++] = (char >> 18) | 240;
	      utf8[p++] = ((char >> 12) & 63) | 128;
	      utf8[p++] = ((char >> 6) & 63) | 128;
	      utf8[p++] = (char & 63) | 128;
	    } else {
	      utf8[p++] = (char >> 12) | 224;
	      utf8[p++] = ((char >> 6) & 63) | 128;
	      utf8[p++] = (char & 63) | 128;
	    }
	  }

	  return utf8;
	};

	/**
	 * Convert a string into a redis slot hash.
	 * @param str
	 * @returns {number}
	 */
	var generate = lib$4.exports = function generate(str) {
	  var char;
	  var i = 0;
	  var start = -1;
	  var result = 0;
	  var resultHash = 0;
	  var utf8 = typeof str === 'string' ? toUTF8Array(str) : str;
	  var len = utf8.length;

	  while (i < len) {
	    char = utf8[i++];
	    if (start === -1) {
	      if (char === 0x7B) {
	        start = i;
	      }
	    } else if (char !== 0x7D) {
	      resultHash = lookup[(char ^ (resultHash >> 8)) & 0xFF] ^ (resultHash << 8);
	    } else if (i - 1 !== start) {
	      return resultHash & 0x3FFF;
	    }

	    result = lookup[(char ^ (result >> 8)) & 0xFF] ^ (result << 8);
	  }

	  return result & 0x3FFF;
	};

	/**
	 * Convert an array of multiple strings into a redis slot hash.
	 * Returns -1 if one of the keys is not for the same slot as the others
	 * @param keys
	 * @returns {number}
	 */
	lib$4.exports.generateMulti = function generateMulti(keys) {
	  var i = 1;
	  var len = keys.length;
	  var base = generate(keys[0]);

	  while (i < len) {
	    if (generate(keys[i++]) !== base) return -1;
	  }

	  return base;
	};
	return lib$4.exports;
}

var hasRequiredClusterSlots;

function requireClusterSlots () {
	if (hasRequiredClusterSlots) return clusterSlots;
	hasRequiredClusterSlots = 1;
	var __importDefault = (clusterSlots && clusterSlots.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	var _a;
	Object.defineProperty(clusterSlots, "__esModule", { value: true });
	const errors_1 = requireErrors$1();
	const client_1 = __importDefault(requireClient());
	const pub_sub_1 = requirePubSub();
	const cluster_key_slot_1 = __importDefault(requireLib$4());
	const cache_1 = requireCache();
	class RedisClusterSlots {
	    static #SLOTS = 16384;
	    #options;
	    #clientFactory;
	    #emit;
	    slots = new Array(_a.#SLOTS);
	    masters = new Array();
	    replicas = new Array();
	    nodeByAddress = new Map();
	    pubSubNode;
	    clientSideCache;
	    #isOpen = false;
	    get isOpen() {
	        return this.#isOpen;
	    }
	    #validateOptions(options) {
	        if (options?.clientSideCache && options?.RESP !== 3) {
	            throw new Error('Client Side Caching is only supported with RESP3');
	        }
	    }
	    constructor(options, emit) {
	        this.#validateOptions(options);
	        this.#options = options;
	        if (options?.clientSideCache) {
	            if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
	                this.clientSideCache = options.clientSideCache;
	            }
	            else {
	                this.clientSideCache = new cache_1.BasicPooledClientSideCache(options.clientSideCache);
	            }
	        }
	        this.#clientFactory = client_1.default.factory(this.#options);
	        this.#emit = emit;
	    }
	    async connect() {
	        if (this.#isOpen) {
	            throw new Error('Cluster already open');
	        }
	        this.#isOpen = true;
	        try {
	            await this.#discoverWithRootNodes();
	        }
	        catch (err) {
	            this.#isOpen = false;
	            throw err;
	        }
	    }
	    async #discoverWithRootNodes() {
	        let start = Math.floor(Math.random() * this.#options.rootNodes.length);
	        for (let i = start; i < this.#options.rootNodes.length; i++) {
	            if (!this.#isOpen)
	                throw new Error('Cluster closed');
	            if (await this.#discover(this.#options.rootNodes[i]))
	                return;
	        }
	        for (let i = 0; i < start; i++) {
	            if (!this.#isOpen)
	                throw new Error('Cluster closed');
	            if (await this.#discover(this.#options.rootNodes[i]))
	                return;
	        }
	        throw new errors_1.RootNodesUnavailableError();
	    }
	    #resetSlots() {
	        this.slots = new Array(_a.#SLOTS);
	        this.masters = [];
	        this.replicas = [];
	        this._randomNodeIterator = undefined;
	    }
	    async #discover(rootNode) {
	        this.clientSideCache?.clear();
	        this.clientSideCache?.disable();
	        try {
	            const addressesInUse = new Set(), promises = [], eagerConnect = this.#options.minimizeConnections !== true;
	            const shards = await this.#getShards(rootNode);
	            this.#resetSlots(); // Reset slots AFTER shards have been fetched to prevent a race condition
	            for (const { from, to, master, replicas } of shards) {
	                const shard = {
	                    master: this.#initiateSlotNode(master, false, eagerConnect, addressesInUse, promises)
	                };
	                if (this.#options.useReplicas) {
	                    shard.replicas = replicas.map(replica => this.#initiateSlotNode(replica, true, eagerConnect, addressesInUse, promises));
	                }
	                for (let i = from; i <= to; i++) {
	                    this.slots[i] = shard;
	                }
	            }
	            if (this.pubSubNode && !addressesInUse.has(this.pubSubNode.address)) {
	                const channelsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS), patternsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS);
	                this.pubSubNode.client.destroy();
	                if (channelsListeners.size || patternsListeners.size) {
	                    promises.push(this.#initiatePubSubClient({
	                        [pub_sub_1.PUBSUB_TYPE.CHANNELS]: channelsListeners,
	                        [pub_sub_1.PUBSUB_TYPE.PATTERNS]: patternsListeners
	                    }));
	                }
	            }
	            for (const [address, node] of this.nodeByAddress.entries()) {
	                if (addressesInUse.has(address))
	                    continue;
	                if (node.client) {
	                    node.client.destroy();
	                }
	                const { pubSub } = node;
	                if (pubSub) {
	                    pubSub.client.destroy();
	                }
	                this.nodeByAddress.delete(address);
	            }
	            await Promise.all(promises);
	            this.clientSideCache?.enable();
	            return true;
	        }
	        catch (err) {
	            this.#emit('error', err);
	            return false;
	        }
	    }
	    async #getShards(rootNode) {
	        const options = this.#clientOptionsDefaults(rootNode);
	        options.socket ??= {};
	        options.socket.reconnectStrategy = false;
	        options.RESP = this.#options.RESP;
	        options.commandOptions = undefined;
	        // TODO: find a way to avoid type casting
	        const client = await this.#clientFactory(options)
	            .on('error', err => this.#emit('error', err))
	            .connect();
	        try {
	            // switch to `CLUSTER SHARDS` when Redis 7.0 will be the minimum supported version
	            return await client.clusterSlots();
	        }
	        finally {
	            client.destroy();
	        }
	    }
	    #getNodeAddress(address) {
	        switch (typeof this.#options.nodeAddressMap) {
	            case 'object':
	                return this.#options.nodeAddressMap[address];
	            case 'function':
	                return this.#options.nodeAddressMap(address);
	        }
	    }
	    #clientOptionsDefaults(options) {
	        if (!this.#options.defaults)
	            return options;
	        let socket;
	        if (this.#options.defaults.socket) {
	            socket = {
	                ...this.#options.defaults.socket,
	                ...options?.socket
	            };
	        }
	        else {
	            socket = options?.socket;
	        }
	        return {
	            ...this.#options.defaults,
	            ...options,
	            socket: socket
	        };
	    }
	    #initiateSlotNode(shard, readonly, eagerConnent, addressesInUse, promises) {
	        const address = `${shard.host}:${shard.port}`;
	        let node = this.nodeByAddress.get(address);
	        if (!node) {
	            node = {
	                ...shard,
	                address,
	                readonly,
	                client: undefined,
	                connectPromise: undefined
	            };
	            if (eagerConnent) {
	                promises.push(this.#createNodeClient(node));
	            }
	            this.nodeByAddress.set(address, node);
	        }
	        if (!addressesInUse.has(address)) {
	            addressesInUse.add(address);
	            (readonly ? this.replicas : this.masters).push(node);
	        }
	        return node;
	    }
	    #createClient(node, readonly = node.readonly) {
	        return this.#clientFactory(this.#clientOptionsDefaults({
	            clientSideCache: this.clientSideCache,
	            RESP: this.#options.RESP,
	            socket: this.#getNodeAddress(node.address) ?? {
	                host: node.host,
	                port: node.port
	            },
	            readonly
	        })).on('error', err => console.error(err));
	    }
	    #createNodeClient(node, readonly) {
	        const client = node.client = this.#createClient(node, readonly);
	        return node.connectPromise = client.connect()
	            .finally(() => node.connectPromise = undefined);
	    }
	    nodeClient(node) {
	        return (node.connectPromise ?? // if the node is connecting
	            node.client ?? // if the node is connected
	            this.#createNodeClient(node) // if the not is disconnected
	        );
	    }
	    #runningRediscoverPromise;
	    async rediscover(startWith) {
	        this.#runningRediscoverPromise ??= this.#rediscover(startWith)
	            .finally(() => this.#runningRediscoverPromise = undefined);
	        return this.#runningRediscoverPromise;
	    }
	    async #rediscover(startWith) {
	        if (await this.#discover(startWith.options))
	            return;
	        return this.#discoverWithRootNodes();
	    }
	    /**
	     * @deprecated Use `close` instead.
	     */
	    quit() {
	        return this.#destroy(client => client.quit());
	    }
	    /**
	     * @deprecated Use `destroy` instead.
	     */
	    disconnect() {
	        return this.#destroy(client => client.disconnect());
	    }
	    close() {
	        return this.#destroy(client => client.close());
	    }
	    destroy() {
	        this.#isOpen = false;
	        for (const client of this.#clients()) {
	            client.destroy();
	        }
	        if (this.pubSubNode) {
	            this.pubSubNode.client.destroy();
	            this.pubSubNode = undefined;
	        }
	        this.#resetSlots();
	        this.nodeByAddress.clear();
	    }
	    *#clients() {
	        for (const master of this.masters) {
	            if (master.client) {
	                yield master.client;
	            }
	            if (master.pubSub) {
	                yield master.pubSub.client;
	            }
	        }
	        for (const replica of this.replicas) {
	            if (replica.client) {
	                yield replica.client;
	            }
	        }
	    }
	    async #destroy(fn) {
	        this.#isOpen = false;
	        const promises = [];
	        for (const client of this.#clients()) {
	            promises.push(fn(client));
	        }
	        if (this.pubSubNode) {
	            promises.push(fn(this.pubSubNode.client));
	            this.pubSubNode = undefined;
	        }
	        this.#resetSlots();
	        this.nodeByAddress.clear();
	        await Promise.allSettled(promises);
	    }
	    getClient(firstKey, isReadonly) {
	        if (!firstKey) {
	            return this.nodeClient(this.getRandomNode());
	        }
	        const slotNumber = (0, cluster_key_slot_1.default)(firstKey);
	        if (!isReadonly) {
	            return this.nodeClient(this.slots[slotNumber].master);
	        }
	        return this.nodeClient(this.getSlotRandomNode(slotNumber));
	    }
	    *#iterateAllNodes() {
	        let i = Math.floor(Math.random() * (this.masters.length + this.replicas.length));
	        if (i < this.masters.length) {
	            do {
	                yield this.masters[i];
	            } while (++i < this.masters.length);
	            for (const replica of this.replicas) {
	                yield replica;
	            }
	        }
	        else {
	            i -= this.masters.length;
	            do {
	                yield this.replicas[i];
	            } while (++i < this.replicas.length);
	        }
	        while (true) {
	            for (const master of this.masters) {
	                yield master;
	            }
	            for (const replica of this.replicas) {
	                yield replica;
	            }
	        }
	    }
	    _randomNodeIterator;
	    getRandomNode() {
	        this._randomNodeIterator ??= this.#iterateAllNodes();
	        return this._randomNodeIterator.next().value;
	    }
	    *#slotNodesIterator(slot) {
	        let i = Math.floor(Math.random() * (1 + slot.replicas.length));
	        if (i < slot.replicas.length) {
	            do {
	                yield slot.replicas[i];
	            } while (++i < slot.replicas.length);
	        }
	        while (true) {
	            yield slot.master;
	            for (const replica of slot.replicas) {
	                yield replica;
	            }
	        }
	    }
	    getSlotRandomNode(slotNumber) {
	        const slot = this.slots[slotNumber];
	        if (!slot.replicas?.length) {
	            return slot.master;
	        }
	        slot.nodesIterator ??= this.#slotNodesIterator(slot);
	        return slot.nodesIterator.next().value;
	    }
	    getMasterByAddress(address) {
	        const master = this.nodeByAddress.get(address);
	        if (!master)
	            return;
	        return this.nodeClient(master);
	    }
	    getPubSubClient() {
	        if (!this.pubSubNode)
	            return this.#initiatePubSubClient();
	        return this.pubSubNode.connectPromise ?? this.pubSubNode.client;
	    }
	    async #initiatePubSubClient(toResubscribe) {
	        const index = Math.floor(Math.random() * (this.masters.length + this.replicas.length)), node = index < this.masters.length ?
	            this.masters[index] :
	            this.replicas[index - this.masters.length], client = this.#createClient(node, false);
	        this.pubSubNode = {
	            address: node.address,
	            client,
	            connectPromise: client.connect()
	                .then(async (client) => {
	                if (toResubscribe) {
	                    await Promise.all([
	                        client.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, toResubscribe[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
	                        client.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, toResubscribe[pub_sub_1.PUBSUB_TYPE.PATTERNS])
	                    ]);
	                }
	                this.pubSubNode.connectPromise = undefined;
	                return client;
	            })
	                .catch(err => {
	                this.pubSubNode = undefined;
	                throw err;
	            })
	        };
	        return this.pubSubNode.connectPromise;
	    }
	    async executeUnsubscribeCommand(unsubscribe) {
	        const client = await this.getPubSubClient();
	        await unsubscribe(client);
	        if (!client.isPubSubActive) {
	            client.destroy();
	            this.pubSubNode = undefined;
	        }
	    }
	    getShardedPubSubClient(channel) {
	        const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
	        if (!master.pubSub)
	            return this.#initiateShardedPubSubClient(master);
	        return master.pubSub.connectPromise ?? master.pubSub.client;
	    }
	    async #initiateShardedPubSubClient(master) {
	        const client = this.#createClient(master, false)
	            .on('server-sunsubscribe', async (channel, listeners) => {
	            try {
	                await this.rediscover(client);
	                const redirectTo = await this.getShardedPubSubClient(channel);
	                await redirectTo.extendPubSubChannelListeners(pub_sub_1.PUBSUB_TYPE.SHARDED, channel, listeners);
	            }
	            catch (err) {
	                this.#emit('sharded-shannel-moved-error', err, channel, listeners);
	            }
	        });
	        master.pubSub = {
	            client,
	            connectPromise: client.connect()
	                .then(client => {
	                master.pubSub.connectPromise = undefined;
	                return client;
	            })
	                .catch(err => {
	                master.pubSub = undefined;
	                throw err;
	            })
	        };
	        return master.pubSub.connectPromise;
	    }
	    async executeShardedUnsubscribeCommand(channel, unsubscribe) {
	        const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
	        if (!master.pubSub)
	            return;
	        const client = master.pubSub.connectPromise ?
	            await master.pubSub.connectPromise :
	            master.pubSub.client;
	        await unsubscribe(client);
	        if (!client.isPubSubActive) {
	            client.destroy();
	            master.pubSub = undefined;
	        }
	    }
	}
	_a = RedisClusterSlots;
	clusterSlots.default = RedisClusterSlots;
	
	return clusterSlots;
}

var multiCommand = {};

var hasRequiredMultiCommand;

function requireMultiCommand () {
	if (hasRequiredMultiCommand) return multiCommand;
	hasRequiredMultiCommand = 1;
	var __importDefault = (multiCommand && multiCommand.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(multiCommand, "__esModule", { value: true });
	const commands_1 = __importDefault(requireCommands$5());
	const multi_command_1 = __importDefault(requireMultiCommand$2());
	const commander_1 = requireCommander();
	const parser_1 = requireParser();
	class RedisClusterMultiCommand {
	    static #createCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            const firstKey = parser.firstKey;
	            return this.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
	        };
	    }
	    static #createModuleCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            const firstKey = parser.firstKey;
	            return this._self.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
	        };
	    }
	    static #createFunctionCommand(name, fn, resp) {
	        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
	        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            parser.push(...prefix);
	            fn.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            const firstKey = parser.firstKey;
	            return this._self.addCommand(firstKey, fn.IS_READ_ONLY, redisArgs, transformReply);
	        };
	    }
	    static #createScriptCommand(script, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(script, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            script.parseCommand(parser, ...args);
	            const scriptArgs = parser.redisArgs;
	            scriptArgs.preserve = parser.preserve;
	            const firstKey = parser.firstKey;
	            return this.#addScript(firstKey, script.IS_READ_ONLY, script, scriptArgs, transformReply);
	        };
	    }
	    static extend(config) {
	        return (0, commander_1.attachConfig)({
	            BaseClass: RedisClusterMultiCommand,
	            commands: commands_1.default,
	            createCommand: RedisClusterMultiCommand.#createCommand,
	            createModuleCommand: RedisClusterMultiCommand.#createModuleCommand,
	            createFunctionCommand: RedisClusterMultiCommand.#createFunctionCommand,
	            createScriptCommand: RedisClusterMultiCommand.#createScriptCommand,
	            config
	        });
	    }
	    #multi;
	    #executeMulti;
	    #executePipeline;
	    #firstKey;
	    #isReadonly = true;
	    constructor(executeMulti, executePipeline, routing, typeMapping) {
	        this.#multi = new multi_command_1.default(typeMapping);
	        this.#executeMulti = executeMulti;
	        this.#executePipeline = executePipeline;
	        this.#firstKey = routing;
	    }
	    #setState(firstKey, isReadonly) {
	        this.#firstKey ??= firstKey;
	        this.#isReadonly &&= isReadonly;
	    }
	    addCommand(firstKey, isReadonly, args, transformReply) {
	        this.#setState(firstKey, isReadonly);
	        this.#multi.addCommand(args, transformReply);
	        return this;
	    }
	    #addScript(firstKey, isReadonly, script, args, transformReply) {
	        this.#setState(firstKey, isReadonly);
	        this.#multi.addScript(script, args, transformReply);
	        return this;
	    }
	    async exec(execAsPipeline = false) {
	        if (execAsPipeline)
	            return this.execAsPipeline();
	        return this.#multi.transformReplies(await this.#executeMulti(this.#firstKey, this.#isReadonly, this.#multi.queue));
	    }
	    EXEC = this.exec;
	    execTyped(execAsPipeline = false) {
	        return this.exec(execAsPipeline);
	    }
	    async execAsPipeline() {
	        if (this.#multi.queue.length === 0)
	            return [];
	        return this.#multi.transformReplies(await this.#executePipeline(this.#firstKey, this.#isReadonly, this.#multi.queue));
	    }
	    execAsPipelineTyped() {
	        return this.execAsPipeline();
	    }
	}
	multiCommand.default = RedisClusterMultiCommand;
	
	return multiCommand;
}

var hasRequiredCluster;

function requireCluster () {
	if (hasRequiredCluster) return cluster;
	hasRequiredCluster = 1;
	var __importDefault = (cluster && cluster.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(cluster, "__esModule", { value: true });
	const commands_1 = __importDefault(requireCommands$5());
	const node_events_1 = require$$0$5;
	const commander_1 = requireCommander();
	const cluster_slots_1 = __importDefault(requireClusterSlots());
	const multi_command_1 = __importDefault(requireMultiCommand());
	const errors_1 = requireErrors$1();
	const parser_1 = requireParser();
	const ASKING_1 = requireASKING();
	const single_entry_cache_1 = __importDefault(requireSingleEntryCache());
	class RedisCluster extends node_events_1.EventEmitter {
	    static #createCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
	        };
	    }
	    static #createModuleCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
	        };
	    }
	    static #createFunctionCommand(name, fn, resp) {
	        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
	        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            parser.push(...prefix);
	            fn.parseCommand(parser, ...args);
	            return this._self._execute(parser.firstKey, fn.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(fn, parser, opts, transformReply));
	        };
	    }
	    static #createScriptCommand(script, resp) {
	        const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
	        const transformReply = (0, commander_1.getTransformReply)(script, resp);
	        return async function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            parser.push(...prefix);
	            script.parseCommand(parser, ...args);
	            return this._self._execute(parser.firstKey, script.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeScript(script, parser, opts, transformReply));
	        };
	    }
	    static #SingleEntryCache = new single_entry_cache_1.default();
	    static factory(config) {
	        let Cluster = RedisCluster.#SingleEntryCache.get(config);
	        if (!Cluster) {
	            Cluster = (0, commander_1.attachConfig)({
	                BaseClass: RedisCluster,
	                commands: commands_1.default,
	                createCommand: RedisCluster.#createCommand,
	                createModuleCommand: RedisCluster.#createModuleCommand,
	                createFunctionCommand: RedisCluster.#createFunctionCommand,
	                createScriptCommand: RedisCluster.#createScriptCommand,
	                config
	            });
	            Cluster.prototype.Multi = multi_command_1.default.extend(config);
	            RedisCluster.#SingleEntryCache.set(config, Cluster);
	        }
	        return (options) => {
	            // returning a "proxy" to prevent the namespaces._self to leak between "proxies"
	            return Object.create(new Cluster(options));
	        };
	    }
	    static create(options) {
	        return RedisCluster.factory(options)(options);
	    }
	    _options;
	    _slots;
	    _self = this;
	    _commandOptions;
	    /**
	     * An array of the cluster slots, each slot contain its `master` and `replicas`.
	     * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific node (master or replica).
	     */
	    get slots() {
	        return this._self._slots.slots;
	    }
	    get clientSideCache() {
	        return this._self._slots.clientSideCache;
	    }
	    /**
	     * An array of the cluster masters.
	     * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific master node.
	     */
	    get masters() {
	        return this._self._slots.masters;
	    }
	    /**
	     * An array of the cluster replicas.
	     * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific replica node.
	     */
	    get replicas() {
	        return this._self._slots.replicas;
	    }
	    /**
	     * A map form a node address (`<host>:<port>`) to its shard, each shard contain its `master` and `replicas`.
	     * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific node (master or replica).
	     */
	    get nodeByAddress() {
	        return this._self._slots.nodeByAddress;
	    }
	    /**
	     * The current pub/sub node.
	     */
	    get pubSubNode() {
	        return this._self._slots.pubSubNode;
	    }
	    get isOpen() {
	        return this._self._slots.isOpen;
	    }
	    constructor(options) {
	        super();
	        this._options = options;
	        this._slots = new cluster_slots_1.default(options, this.emit.bind(this));
	        if (options?.commandOptions) {
	            this._commandOptions = options.commandOptions;
	        }
	    }
	    duplicate(overrides) {
	        return new (Object.getPrototypeOf(this).constructor)({
	            ...this._self._options,
	            commandOptions: this._commandOptions,
	            ...overrides
	        });
	    }
	    async connect() {
	        await this._self._slots.connect();
	        return this;
	    }
	    withCommandOptions(options) {
	        const proxy = Object.create(this);
	        proxy._commandOptions = options;
	        return proxy;
	    }
	    _commandOptionsProxy(key, value) {
	        const proxy = Object.create(this);
	        proxy._commandOptions = Object.create(this._commandOptions ?? null);
	        proxy._commandOptions[key] = value;
	        return proxy;
	    }
	    /**
	     * Override the `typeMapping` command option
	     */
	    withTypeMapping(typeMapping) {
	        return this._commandOptionsProxy('typeMapping', typeMapping);
	    }
	    // /**
	    //  * Override the `policies` command option
	    //  * TODO
	    //  */
	    // withPolicies<POLICIES extends CommandPolicies> (policies: POLICIES) {
	    //   return this._commandOptionsProxy('policies', policies);
	    // }
	    _handleAsk(fn) {
	        return async (client, options) => {
	            const chainId = Symbol("asking chain");
	            const opts = options ? { ...options } : {};
	            opts.chainId = chainId;
	            const ret = await Promise.all([
	                client.sendCommand([ASKING_1.ASKING_CMD], { chainId: chainId }),
	                fn(client, opts)
	            ]);
	            return ret[1];
	        };
	    }
	    async _execute(firstKey, isReadonly, options, fn) {
	        const maxCommandRedirections = this._options.maxCommandRedirections ?? 16;
	        let client = await this._slots.getClient(firstKey, isReadonly);
	        let i = 0;
	        let myFn = fn;
	        while (true) {
	            try {
	                return await myFn(client, options);
	            }
	            catch (err) {
	                myFn = fn;
	                // TODO: error class
	                if (++i > maxCommandRedirections || !(err instanceof Error)) {
	                    throw err;
	                }
	                if (err.message.startsWith('ASK')) {
	                    const address = err.message.substring(err.message.lastIndexOf(' ') + 1);
	                    let redirectTo = await this._slots.getMasterByAddress(address);
	                    if (!redirectTo) {
	                        await this._slots.rediscover(client);
	                        redirectTo = await this._slots.getMasterByAddress(address);
	                    }
	                    if (!redirectTo) {
	                        throw new Error(`Cannot find node ${address}`);
	                    }
	                    client = redirectTo;
	                    myFn = this._handleAsk(fn);
	                    continue;
	                }
	                if (err.message.startsWith('MOVED')) {
	                    await this._slots.rediscover(client);
	                    client = await this._slots.getClient(firstKey, isReadonly);
	                    continue;
	                }
	                throw err;
	            }
	        }
	    }
	    async sendCommand(firstKey, isReadonly, args, options) {
	        // Merge global options with local options
	        const opts = {
	            ...this._self._commandOptions,
	            ...options
	        };
	        return this._self._execute(firstKey, isReadonly, opts, (client, opts) => client.sendCommand(args, opts));
	    }
	    MULTI(routing) {
	        return new this.Multi(async (firstKey, isReadonly, commands) => {
	            const client = await this._self._slots.getClient(firstKey, isReadonly);
	            return client._executeMulti(commands);
	        }, async (firstKey, isReadonly, commands) => {
	            const client = await this._self._slots.getClient(firstKey, isReadonly);
	            return client._executePipeline(commands);
	        }, routing, this._commandOptions?.typeMapping);
	    }
	    multi = this.MULTI;
	    async SUBSCRIBE(channels, listener, bufferMode) {
	        return (await this._self._slots.getPubSubClient())
	            .SUBSCRIBE(channels, listener, bufferMode);
	    }
	    subscribe = this.SUBSCRIBE;
	    async UNSUBSCRIBE(channels, listener, bufferMode) {
	        return this._self._slots.executeUnsubscribeCommand(client => client.UNSUBSCRIBE(channels, listener, bufferMode));
	    }
	    unsubscribe = this.UNSUBSCRIBE;
	    async PSUBSCRIBE(patterns, listener, bufferMode) {
	        return (await this._self._slots.getPubSubClient())
	            .PSUBSCRIBE(patterns, listener, bufferMode);
	    }
	    pSubscribe = this.PSUBSCRIBE;
	    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
	        return this._self._slots.executeUnsubscribeCommand(client => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
	    }
	    pUnsubscribe = this.PUNSUBSCRIBE;
	    async SSUBSCRIBE(channels, listener, bufferMode) {
	        const maxCommandRedirections = this._self._options.maxCommandRedirections ?? 16, firstChannel = Array.isArray(channels) ? channels[0] : channels;
	        let client = await this._self._slots.getShardedPubSubClient(firstChannel);
	        for (let i = 0;; i++) {
	            try {
	                return await client.SSUBSCRIBE(channels, listener, bufferMode);
	            }
	            catch (err) {
	                if (++i > maxCommandRedirections || !(err instanceof errors_1.ErrorReply)) {
	                    throw err;
	                }
	                if (err.message.startsWith('MOVED')) {
	                    await this._self._slots.rediscover(client);
	                    client = await this._self._slots.getShardedPubSubClient(firstChannel);
	                    continue;
	                }
	                throw err;
	            }
	        }
	    }
	    sSubscribe = this.SSUBSCRIBE;
	    SUNSUBSCRIBE(channels, listener, bufferMode) {
	        return this._self._slots.executeShardedUnsubscribeCommand(Array.isArray(channels) ? channels[0] : channels, client => client.SUNSUBSCRIBE(channels, listener, bufferMode));
	    }
	    sUnsubscribe = this.SUNSUBSCRIBE;
	    /**
	     * @deprecated Use `close` instead.
	     */
	    quit() {
	        return this._self._slots.quit();
	    }
	    /**
	     * @deprecated Use `destroy` instead.
	     */
	    disconnect() {
	        return this._self._slots.disconnect();
	    }
	    close() {
	        this._self._slots.clientSideCache?.onPoolClose();
	        return this._self._slots.close();
	    }
	    destroy() {
	        this._self._slots.clientSideCache?.onPoolClose();
	        return this._self._slots.destroy();
	    }
	    nodeClient(node) {
	        return this._self._slots.nodeClient(node);
	    }
	    /**
	     * Returns a random node from the cluster.
	     * Userful for running "forward" commands (like PUBLISH) on a random node.
	     */
	    getRandomNode() {
	        return this._self._slots.getRandomNode();
	    }
	    /**
	     * Get a random node from a slot.
	     * Useful for running readonly commands on a slot.
	     */
	    getSlotRandomNode(slot) {
	        return this._self._slots.getSlotRandomNode(slot);
	    }
	    /**
	     * @deprecated use `.masters` instead
	     * TODO
	     */
	    getMasters() {
	        return this.masters;
	    }
	    /**
	     * @deprecated use `.slots[<SLOT>]` instead
	     * TODO
	     */
	    getSlotMaster(slot) {
	        return this.slots[slot].master;
	    }
	}
	cluster.default = RedisCluster;
	
	return cluster;
}

var sentinel = {};

var utils$1 = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	Object.defineProperty(utils$1, "__esModule", { value: true });
	utils$1.createScriptCommand = utils$1.createModuleCommand = utils$1.createFunctionCommand = utils$1.createCommand = utils$1.clientSocketToNode = utils$1.createNodeList = utils$1.parseNode = void 0;
	const parser_1 = requireParser();
	const commander_1 = requireCommander();
	/* TODO: should use map interface, would need a transform reply probably? as resp2 is list form, which this depends on */
	function parseNode(node) {
	    if (node.flags.includes("s_down") || node.flags.includes("disconnected") || node.flags.includes("failover_in_progress")) {
	        return undefined;
	    }
	    return { host: node.ip, port: Number(node.port) };
	}
	utils$1.parseNode = parseNode;
	function createNodeList(nodes) {
	    var nodeList = [];
	    for (const nodeData of nodes) {
	        const node = parseNode(nodeData);
	        if (node === undefined) {
	            continue;
	        }
	        nodeList.push(node);
	    }
	    return nodeList;
	}
	utils$1.createNodeList = createNodeList;
	function clientSocketToNode(socket) {
	    const s = socket;
	    return {
	        host: s.host,
	        port: s.port
	    };
	}
	utils$1.clientSocketToNode = clientSocketToNode;
	function createCommand(command, resp) {
	    const transformReply = (0, commander_1.getTransformReply)(command, resp);
	    return async function (...args) {
	        const parser = new parser_1.BasicCommandParser();
	        command.parseCommand(parser, ...args);
	        return this._self._execute(command.IS_READ_ONLY, client => client._executeCommand(command, parser, this.commandOptions, transformReply));
	    };
	}
	utils$1.createCommand = createCommand;
	function createFunctionCommand(name, fn, resp) {
	    const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
	    const transformReply = (0, commander_1.getTransformReply)(fn, resp);
	    return async function (...args) {
	        const parser = new parser_1.BasicCommandParser();
	        parser.push(...prefix);
	        fn.parseCommand(parser, ...args);
	        return this._self._execute(fn.IS_READ_ONLY, client => client._executeCommand(fn, parser, this._self.commandOptions, transformReply));
	    };
	}
	utils$1.createFunctionCommand = createFunctionCommand;
	function createModuleCommand(command, resp) {
	    const transformReply = (0, commander_1.getTransformReply)(command, resp);
	    return async function (...args) {
	        const parser = new parser_1.BasicCommandParser();
	        command.parseCommand(parser, ...args);
	        return this._self._execute(command.IS_READ_ONLY, client => client._executeCommand(command, parser, this._self.commandOptions, transformReply));
	    };
	}
	utils$1.createModuleCommand = createModuleCommand;
	function createScriptCommand(script, resp) {
	    const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
	    const transformReply = (0, commander_1.getTransformReply)(script, resp);
	    return async function (...args) {
	        const parser = new parser_1.BasicCommandParser();
	        parser.push(...prefix);
	        script.parseCommand(parser, ...args);
	        return this._self._execute(script.IS_READ_ONLY, client => client._executeScript(script, parser, this.commandOptions, transformReply));
	    };
	}
	utils$1.createScriptCommand = createScriptCommand;
	
	return utils$1;
}

var multiCommands = {};

var hasRequiredMultiCommands;

function requireMultiCommands () {
	if (hasRequiredMultiCommands) return multiCommands;
	hasRequiredMultiCommands = 1;
	var __importDefault = (multiCommands && multiCommands.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(multiCommands, "__esModule", { value: true });
	const commands_1 = __importDefault(requireCommands$5());
	const multi_command_1 = __importDefault(requireMultiCommand$2());
	const commander_1 = requireCommander();
	const parser_1 = requireParser();
	class RedisSentinelMultiCommand {
	    static _createCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            return this.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
	        };
	    }
	    static _createModuleCommand(command, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(command, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            command.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            return this._self.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
	        };
	    }
	    static _createFunctionCommand(name, fn, resp) {
	        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
	        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            parser.push(...prefix);
	            fn.parseCommand(parser, ...args);
	            const redisArgs = parser.redisArgs;
	            redisArgs.preserve = parser.preserve;
	            return this._self.addCommand(fn.IS_READ_ONLY, redisArgs, transformReply);
	        };
	    }
	    static _createScriptCommand(script, resp) {
	        const transformReply = (0, commander_1.getTransformReply)(script, resp);
	        return function (...args) {
	            const parser = new parser_1.BasicCommandParser();
	            script.parseCommand(parser, ...args);
	            const scriptArgs = parser.redisArgs;
	            scriptArgs.preserve = parser.preserve;
	            return this.#addScript(script.IS_READ_ONLY, script, scriptArgs, transformReply);
	        };
	    }
	    static extend(config) {
	        return (0, commander_1.attachConfig)({
	            BaseClass: RedisSentinelMultiCommand,
	            commands: commands_1.default,
	            createCommand: RedisSentinelMultiCommand._createCommand,
	            createModuleCommand: RedisSentinelMultiCommand._createModuleCommand,
	            createFunctionCommand: RedisSentinelMultiCommand._createFunctionCommand,
	            createScriptCommand: RedisSentinelMultiCommand._createScriptCommand,
	            config
	        });
	    }
	    #multi = new multi_command_1.default();
	    #sentinel;
	    #isReadonly = true;
	    constructor(sentinel, typeMapping) {
	        this.#multi = new multi_command_1.default(typeMapping);
	        this.#sentinel = sentinel;
	    }
	    #setState(isReadonly) {
	        this.#isReadonly &&= isReadonly;
	    }
	    addCommand(isReadonly, args, transformReply) {
	        this.#setState(isReadonly);
	        this.#multi.addCommand(args, transformReply);
	        return this;
	    }
	    #addScript(isReadonly, script, args, transformReply) {
	        this.#setState(isReadonly);
	        this.#multi.addScript(script, args, transformReply);
	        return this;
	    }
	    async exec(execAsPipeline = false) {
	        if (execAsPipeline)
	            return this.execAsPipeline();
	        return this.#multi.transformReplies(await this.#sentinel._executeMulti(this.#isReadonly, this.#multi.queue));
	    }
	    EXEC = this.exec;
	    execTyped(execAsPipeline = false) {
	        return this.exec(execAsPipeline);
	    }
	    async execAsPipeline() {
	        if (this.#multi.queue.length === 0)
	            return [];
	        return this.#multi.transformReplies(await this.#sentinel._executePipeline(this.#isReadonly, this.#multi.queue));
	    }
	    execAsPipelineTyped() {
	        return this.execAsPipeline();
	    }
	}
	multiCommands.default = RedisSentinelMultiCommand;
	
	return multiCommands;
}

var pubSubProxy = {};

var hasRequiredPubSubProxy;

function requirePubSubProxy () {
	if (hasRequiredPubSubProxy) return pubSubProxy;
	hasRequiredPubSubProxy = 1;
	var __importDefault = (pubSubProxy && pubSubProxy.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(pubSubProxy, "__esModule", { value: true });
	pubSubProxy.PubSubProxy = void 0;
	const node_events_1 = __importDefault(require$$0$5);
	const pub_sub_1 = requirePubSub();
	const client_1 = __importDefault(requireClient());
	class PubSubProxy extends node_events_1.default {
	    #clientOptions;
	    #onError;
	    #node;
	    #state;
	    #subscriptions;
	    constructor(clientOptions, onError) {
	        super();
	        this.#clientOptions = clientOptions;
	        this.#onError = onError;
	    }
	    #createClient() {
	        if (this.#node === undefined) {
	            throw new Error("pubSubProxy: didn't define node to do pubsub against");
	        }
	        return new client_1.default({
	            ...this.#clientOptions,
	            socket: {
	                ...this.#clientOptions.socket,
	                host: this.#node.host,
	                port: this.#node.port
	            }
	        });
	    }
	    async #initiatePubSubClient(withSubscriptions = false) {
	        const client = this.#createClient()
	            .on('error', this.#onError);
	        const connectPromise = client.connect()
	            .then(async (client) => {
	            if (this.#state?.client !== client) {
	                // if pubsub was deactivated while connecting (`this.#pubSubClient === undefined`)
	                // or if the node changed (`this.#pubSubClient.client !== client`)
	                client.destroy();
	                return this.#state?.connectPromise;
	            }
	            if (withSubscriptions && this.#subscriptions) {
	                await Promise.all([
	                    client.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
	                    client.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.PATTERNS])
	                ]);
	            }
	            if (this.#state.client !== client) {
	                // if the node changed (`this.#pubSubClient.client !== client`)
	                client.destroy();
	                return this.#state?.connectPromise;
	            }
	            this.#state.connectPromise = undefined;
	            return client;
	        })
	            .catch(err => {
	            this.#state = undefined;
	            throw err;
	        });
	        this.#state = {
	            client,
	            connectPromise
	        };
	        return connectPromise;
	    }
	    #getPubSubClient() {
	        if (!this.#state)
	            return this.#initiatePubSubClient();
	        return (this.#state.connectPromise ??
	            this.#state.client);
	    }
	    async changeNode(node) {
	        this.#node = node;
	        if (!this.#state)
	            return;
	        // if `connectPromise` is undefined, `this.#subscriptions` is already set
	        // and `this.#state.client` might not have the listeners set yet
	        if (this.#state.connectPromise === undefined) {
	            this.#subscriptions = {
	                [pub_sub_1.PUBSUB_TYPE.CHANNELS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS),
	                [pub_sub_1.PUBSUB_TYPE.PATTERNS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS)
	            };
	            this.#state.client.destroy();
	        }
	        await this.#initiatePubSubClient(true);
	    }
	    #executeCommand(fn) {
	        const client = this.#getPubSubClient();
	        if (client instanceof client_1.default) {
	            return fn(client);
	        }
	        return client.then(client => {
	            // if pubsub was deactivated while connecting
	            if (client === undefined)
	                return;
	            return fn(client);
	        }).catch(err => {
	            if (this.#state?.client.isPubSubActive) {
	                this.#state.client.destroy();
	                this.#state = undefined;
	            }
	            throw err;
	        });
	    }
	    subscribe(channels, listener, bufferMode) {
	        return this.#executeCommand(client => client.SUBSCRIBE(channels, listener, bufferMode));
	    }
	    #unsubscribe(fn) {
	        return this.#executeCommand(async (client) => {
	            const reply = await fn(client);
	            if (!client.isPubSubActive) {
	                client.destroy();
	                this.#state = undefined;
	            }
	            return reply;
	        });
	    }
	    async unsubscribe(channels, listener, bufferMode) {
	        return this.#unsubscribe(client => client.UNSUBSCRIBE(channels, listener, bufferMode));
	    }
	    async pSubscribe(patterns, listener, bufferMode) {
	        return this.#executeCommand(client => client.PSUBSCRIBE(patterns, listener, bufferMode));
	    }
	    async pUnsubscribe(patterns, listener, bufferMode) {
	        return this.#unsubscribe(client => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
	    }
	    destroy() {
	        this.#subscriptions = undefined;
	        if (this.#state === undefined)
	            return;
	        // `connectPromise` already handles the case of `this.#pubSubState = undefined`
	        if (!this.#state.connectPromise) {
	            this.#state.client.destroy();
	        }
	        this.#state = undefined;
	    }
	}
	pubSubProxy.PubSubProxy = PubSubProxy;
	
	return pubSubProxy;
}

var module = {};

var commands$4 = {};

var SENTINEL_MASTER = {};

var hasRequiredSENTINEL_MASTER;

function requireSENTINEL_MASTER () {
	if (hasRequiredSENTINEL_MASTER) return SENTINEL_MASTER;
	hasRequiredSENTINEL_MASTER = 1;
	Object.defineProperty(SENTINEL_MASTER, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	SENTINEL_MASTER.default = {
	    /**
	     * Returns information about the specified master.
	     * @param parser - The Redis command parser.
	     * @param dbname - Name of the master.
	     */
	    parseCommand(parser, dbname) {
	        parser.push('SENTINEL', 'MASTER', dbname);
	    },
	    transformReply: {
	        2: (generic_transformers_1.transformTuplesReply),
	        3: undefined
	    }
	};
	
	return SENTINEL_MASTER;
}

var SENTINEL_MONITOR = {};

var hasRequiredSENTINEL_MONITOR;

function requireSENTINEL_MONITOR () {
	if (hasRequiredSENTINEL_MONITOR) return SENTINEL_MONITOR;
	hasRequiredSENTINEL_MONITOR = 1;
	Object.defineProperty(SENTINEL_MONITOR, "__esModule", { value: true });
	SENTINEL_MONITOR.default = {
	    /**
	     * Instructs a Sentinel to monitor a new master with the specified parameters.
	     * @param parser - The Redis command parser.
	     * @param dbname - Name that identifies the master.
	     * @param host - Host of the master.
	     * @param port - Port of the master.
	     * @param quorum - Number of Sentinels that need to agree to trigger a failover.
	     */
	    parseCommand(parser, dbname, host, port, quorum) {
	        parser.push('SENTINEL', 'MONITOR', dbname, host, port, quorum);
	    },
	    transformReply: undefined
	};
	
	return SENTINEL_MONITOR;
}

var SENTINEL_REPLICAS = {};

var hasRequiredSENTINEL_REPLICAS;

function requireSENTINEL_REPLICAS () {
	if (hasRequiredSENTINEL_REPLICAS) return SENTINEL_REPLICAS;
	hasRequiredSENTINEL_REPLICAS = 1;
	Object.defineProperty(SENTINEL_REPLICAS, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	SENTINEL_REPLICAS.default = {
	    /**
	     * Returns a list of replicas for the specified master.
	     * @param parser - The Redis command parser.
	     * @param dbname - Name of the master.
	     */
	    parseCommand(parser, dbname) {
	        parser.push('SENTINEL', 'REPLICAS', dbname);
	    },
	    transformReply: {
	        2: (reply, preserve, typeMapping) => {
	            const inferred = reply;
	            const initial = [];
	            return inferred.reduce((sentinels, x) => {
	                sentinels.push((0, generic_transformers_1.transformTuplesReply)(x, undefined, typeMapping));
	                return sentinels;
	            }, initial);
	        },
	        3: undefined
	    }
	};
	
	return SENTINEL_REPLICAS;
}

var SENTINEL_SENTINELS = {};

var hasRequiredSENTINEL_SENTINELS;

function requireSENTINEL_SENTINELS () {
	if (hasRequiredSENTINEL_SENTINELS) return SENTINEL_SENTINELS;
	hasRequiredSENTINEL_SENTINELS = 1;
	Object.defineProperty(SENTINEL_SENTINELS, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	SENTINEL_SENTINELS.default = {
	    /**
	     * Returns a list of Sentinel instances for the specified master.
	     * @param parser - The Redis command parser.
	     * @param dbname - Name of the master.
	     */
	    parseCommand(parser, dbname) {
	        parser.push('SENTINEL', 'SENTINELS', dbname);
	    },
	    transformReply: {
	        2: (reply, preserve, typeMapping) => {
	            const inferred = reply;
	            const initial = [];
	            return inferred.reduce((sentinels, x) => {
	                sentinels.push((0, generic_transformers_1.transformTuplesReply)(x, undefined, typeMapping));
	                return sentinels;
	            }, initial);
	        },
	        3: undefined
	    }
	};
	
	return SENTINEL_SENTINELS;
}

var SENTINEL_SET = {};

var hasRequiredSENTINEL_SET;

function requireSENTINEL_SET () {
	if (hasRequiredSENTINEL_SET) return SENTINEL_SET;
	hasRequiredSENTINEL_SET = 1;
	Object.defineProperty(SENTINEL_SET, "__esModule", { value: true });
	SENTINEL_SET.default = {
	    /**
	     * Sets configuration parameters for a specific master.
	     * @param parser - The Redis command parser.
	     * @param dbname - Name of the master.
	     * @param options - Configuration options to set as option-value pairs.
	     */
	    parseCommand(parser, dbname, options) {
	        parser.push('SENTINEL', 'SET', dbname);
	        for (const option of options) {
	            parser.push(option.option, option.value);
	        }
	    },
	    transformReply: undefined
	};
	
	return SENTINEL_SET;
}

var hasRequiredCommands$4;

function requireCommands$4 () {
	if (hasRequiredCommands$4) return commands$4;
	hasRequiredCommands$4 = 1;
	var __importDefault = (commands$4 && commands$4.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(commands$4, "__esModule", { value: true });
	const SENTINEL_MASTER_1 = __importDefault(requireSENTINEL_MASTER());
	const SENTINEL_MONITOR_1 = __importDefault(requireSENTINEL_MONITOR());
	const SENTINEL_REPLICAS_1 = __importDefault(requireSENTINEL_REPLICAS());
	const SENTINEL_SENTINELS_1 = __importDefault(requireSENTINEL_SENTINELS());
	const SENTINEL_SET_1 = __importDefault(requireSENTINEL_SET());
	commands$4.default = {
	    SENTINEL_SENTINELS: SENTINEL_SENTINELS_1.default,
	    sentinelSentinels: SENTINEL_SENTINELS_1.default,
	    SENTINEL_MASTER: SENTINEL_MASTER_1.default,
	    sentinelMaster: SENTINEL_MASTER_1.default,
	    SENTINEL_REPLICAS: SENTINEL_REPLICAS_1.default,
	    sentinelReplicas: SENTINEL_REPLICAS_1.default,
	    SENTINEL_MONITOR: SENTINEL_MONITOR_1.default,
	    sentinelMonitor: SENTINEL_MONITOR_1.default,
	    SENTINEL_SET: SENTINEL_SET_1.default,
	    sentinelSet: SENTINEL_SET_1.default
	};
	
	return commands$4;
}

var hasRequiredModule;

function requireModule () {
	if (hasRequiredModule) return module;
	hasRequiredModule = 1;
	var __importDefault = (module && module.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(module, "__esModule", { value: true });
	const commands_1 = __importDefault(requireCommands$4());
	module.default = {
	    sentinel: commands_1.default
	};
	
	return module;
}

var waitQueue = {};

var hasRequiredWaitQueue;

function requireWaitQueue () {
	if (hasRequiredWaitQueue) return waitQueue;
	hasRequiredWaitQueue = 1;
	Object.defineProperty(waitQueue, "__esModule", { value: true });
	waitQueue.WaitQueue = void 0;
	const linked_list_1 = requireLinkedList();
	class WaitQueue {
	    #list = new linked_list_1.SinglyLinkedList();
	    #queue = new linked_list_1.SinglyLinkedList();
	    push(value) {
	        const resolve = this.#queue.shift();
	        if (resolve !== undefined) {
	            resolve(value);
	            return;
	        }
	        this.#list.push(value);
	    }
	    shift() {
	        return this.#list.shift();
	    }
	    wait() {
	        return new Promise(resolve => this.#queue.push(resolve));
	    }
	}
	waitQueue.WaitQueue = WaitQueue;
	
	return waitQueue;
}

var hasRequiredSentinel;

function requireSentinel () {
	if (hasRequiredSentinel) return sentinel;
	hasRequiredSentinel = 1;
	var __importDefault = (sentinel && sentinel.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(sentinel, "__esModule", { value: true });
	sentinel.RedisSentinelFactory = sentinel.RedisSentinelClient = void 0;
	const node_events_1 = require$$0$5;
	const client_1 = __importDefault(requireClient());
	const commander_1 = requireCommander();
	const commands_1 = __importDefault(requireCommands$5());
	const utils_1 = requireUtils$1();
	const multi_commands_1 = __importDefault(requireMultiCommands());
	const pub_sub_proxy_1 = requirePubSubProxy();
	const promises_1 = require$$4$1;
	const module_1 = __importDefault(requireModule());
	const wait_queue_1 = requireWaitQueue();
	const cache_1 = requireCache();
	class RedisSentinelClient {
	    #clientInfo;
	    #internal;
	    _self;
	    /**
	     * Indicates if the client connection is open
	     *
	     * @returns `true` if the client connection is open, `false` otherwise
	     */
	    get isOpen() {
	        return this._self.#internal.isOpen;
	    }
	    /**
	     * Indicates if the client connection is ready to accept commands
	     *
	     * @returns `true` if the client connection is ready, `false` otherwise
	     */
	    get isReady() {
	        return this._self.#internal.isReady;
	    }
	    /**
	     * Gets the command options configured for this client
	     *
	     * @returns The command options for this client or `undefined` if none were set
	     */
	    get commandOptions() {
	        return this._self.#commandOptions;
	    }
	    #commandOptions;
	    constructor(internal, clientInfo, commandOptions) {
	        this._self = this;
	        this.#internal = internal;
	        this.#clientInfo = clientInfo;
	        this.#commandOptions = commandOptions;
	    }
	    static factory(config) {
	        const SentinelClient = (0, commander_1.attachConfig)({
	            BaseClass: RedisSentinelClient,
	            commands: commands_1.default,
	            createCommand: (utils_1.createCommand),
	            createModuleCommand: (utils_1.createModuleCommand),
	            createFunctionCommand: (utils_1.createFunctionCommand),
	            createScriptCommand: (utils_1.createScriptCommand),
	            config
	        });
	        SentinelClient.prototype.Multi = multi_commands_1.default.extend(config);
	        return (internal, clientInfo, commandOptions) => {
	            // returning a "proxy" to prevent the namespaces._self to leak between "proxies"
	            return Object.create(new SentinelClient(internal, clientInfo, commandOptions));
	        };
	    }
	    static create(options, internal, clientInfo, commandOptions) {
	        return RedisSentinelClient.factory(options)(internal, clientInfo, commandOptions);
	    }
	    withCommandOptions(options) {
	        const proxy = Object.create(this);
	        proxy._commandOptions = options;
	        return proxy;
	    }
	    _commandOptionsProxy(key, value) {
	        const proxy = Object.create(this);
	        proxy._commandOptions = Object.create(this._self.#commandOptions ?? null);
	        proxy._commandOptions[key] = value;
	        return proxy;
	    }
	    /**
	     * Override the `typeMapping` command option
	     */
	    withTypeMapping(typeMapping) {
	        return this._commandOptionsProxy('typeMapping', typeMapping);
	    }
	    async _execute(isReadonly, fn) {
	        if (this._self.#clientInfo === undefined) {
	            throw new Error("Attempted execution on released RedisSentinelClient lease");
	        }
	        return await this._self.#internal.execute(fn, this._self.#clientInfo);
	    }
	    async sendCommand(isReadonly, args, options) {
	        return this._execute(isReadonly, client => client.sendCommand(args, options));
	    }
	    /**
	     * @internal
	     */
	    async _executePipeline(isReadonly, commands) {
	        return this._execute(isReadonly, client => client._executePipeline(commands));
	    }
	    /**f
	      * @internal
	      */
	    async _executeMulti(isReadonly, commands) {
	        return this._execute(isReadonly, client => client._executeMulti(commands));
	    }
	    MULTI() {
	        return new this.Multi(this);
	    }
	    multi = this.MULTI;
	    WATCH(key) {
	        if (this._self.#clientInfo === undefined) {
	            throw new Error("Attempted execution on released RedisSentinelClient lease");
	        }
	        return this._execute(false, client => client.watch(key));
	    }
	    watch = this.WATCH;
	    UNWATCH() {
	        if (this._self.#clientInfo === undefined) {
	            throw new Error('Attempted execution on released RedisSentinelClient lease');
	        }
	        return this._execute(false, client => client.unwatch());
	    }
	    unwatch = this.UNWATCH;
	    /**
	     * Releases the client lease back to the pool
	     *
	     * After calling this method, the client instance should no longer be used as it
	     * will be returned to the client pool and may be given to other operations.
	     *
	     * @returns A promise that resolves when the client is ready to be reused, or undefined
	     *          if the client was immediately ready
	     * @throws Error if the lease has already been released
	     */
	    release() {
	        if (this._self.#clientInfo === undefined) {
	            throw new Error('RedisSentinelClient lease already released');
	        }
	        const result = this._self.#internal.releaseClientLease(this._self.#clientInfo);
	        this._self.#clientInfo = undefined;
	        return result;
	    }
	}
	sentinel.RedisSentinelClient = RedisSentinelClient;
	class RedisSentinel extends node_events_1.EventEmitter {
	    _self;
	    #internal;
	    #options;
	    /**
	     * Indicates if the sentinel connection is open
	     *
	     * @returns `true` if the sentinel connection is open, `false` otherwise
	     */
	    get isOpen() {
	        return this._self.#internal.isOpen;
	    }
	    /**
	     * Indicates if the sentinel connection is ready to accept commands
	     *
	     * @returns `true` if the sentinel connection is ready, `false` otherwise
	     */
	    get isReady() {
	        return this._self.#internal.isReady;
	    }
	    get commandOptions() {
	        return this._self.#commandOptions;
	    }
	    #commandOptions;
	    #trace = () => { };
	    #reservedClientInfo;
	    #masterClientCount = 0;
	    #masterClientInfo;
	    get clientSideCache() {
	        return this._self.#internal.clientSideCache;
	    }
	    constructor(options) {
	        super();
	        this._self = this;
	        this.#options = options;
	        if (options.commandOptions) {
	            this.#commandOptions = options.commandOptions;
	        }
	        this.#internal = new RedisSentinelInternal(options);
	        this.#internal.on('error', err => this.emit('error', err));
	        /* pass through underling events */
	        /* TODO: perhaps make this a struct and one vent, instead of multiple events */
	        this.#internal.on('topology-change', (event) => {
	            if (!this.emit('topology-change', event)) {
	                this._self.#trace(`RedisSentinel: re-emit for topology-change for ${event.type} event returned false`);
	            }
	        });
	    }
	    static factory(config) {
	        const Sentinel = (0, commander_1.attachConfig)({
	            BaseClass: RedisSentinel,
	            commands: commands_1.default,
	            createCommand: (utils_1.createCommand),
	            createModuleCommand: (utils_1.createModuleCommand),
	            createFunctionCommand: (utils_1.createFunctionCommand),
	            createScriptCommand: (utils_1.createScriptCommand),
	            config
	        });
	        Sentinel.prototype.Multi = multi_commands_1.default.extend(config);
	        return (options) => {
	            // returning a "proxy" to prevent the namespaces.self to leak between "proxies"
	            return Object.create(new Sentinel(options));
	        };
	    }
	    static create(options) {
	        return RedisSentinel.factory(options)(options);
	    }
	    withCommandOptions(options) {
	        const proxy = Object.create(this);
	        proxy._commandOptions = options;
	        return proxy;
	    }
	    _commandOptionsProxy(key, value) {
	        const proxy = Object.create(this);
	        // Create new commandOptions object with the inherited properties
	        proxy._self.#commandOptions = {
	            ...(this._self.#commandOptions || {}),
	            [key]: value
	        };
	        return proxy;
	    }
	    /**
	     * Override the `typeMapping` command option
	     */
	    withTypeMapping(typeMapping) {
	        return this._commandOptionsProxy('typeMapping', typeMapping);
	    }
	    async connect() {
	        await this._self.#internal.connect();
	        if (this._self.#options.reserveClient) {
	            this._self.#reservedClientInfo = await this._self.#internal.getClientLease();
	        }
	        return this;
	    }
	    async _execute(isReadonly, fn) {
	        let clientInfo;
	        if (!isReadonly || !this._self.#internal.useReplicas) {
	            if (this._self.#reservedClientInfo) {
	                clientInfo = this._self.#reservedClientInfo;
	            }
	            else {
	                this._self.#masterClientInfo ??= await this._self.#internal.getClientLease();
	                clientInfo = this._self.#masterClientInfo;
	                this._self.#masterClientCount++;
	            }
	        }
	        try {
	            return await this._self.#internal.execute(fn, clientInfo);
	        }
	        finally {
	            if (clientInfo !== undefined &&
	                clientInfo === this._self.#masterClientInfo &&
	                --this._self.#masterClientCount === 0) {
	                const promise = this._self.#internal.releaseClientLease(clientInfo);
	                this._self.#masterClientInfo = undefined;
	                if (promise)
	                    await promise;
	            }
	        }
	    }
	    async use(fn) {
	        const clientInfo = await this._self.#internal.getClientLease();
	        try {
	            return await fn(RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions));
	        }
	        finally {
	            const promise = this._self.#internal.releaseClientLease(clientInfo);
	            if (promise)
	                await promise;
	        }
	    }
	    async sendCommand(isReadonly, args, options) {
	        return this._execute(isReadonly, client => client.sendCommand(args, options));
	    }
	    /**
	     * @internal
	     */
	    async _executePipeline(isReadonly, commands) {
	        return this._execute(isReadonly, client => client._executePipeline(commands));
	    }
	    /**f
	      * @internal
	      */
	    async _executeMulti(isReadonly, commands) {
	        return this._execute(isReadonly, client => client._executeMulti(commands));
	    }
	    MULTI() {
	        return new this.Multi(this);
	    }
	    multi = this.MULTI;
	    async close() {
	        return this._self.#internal.close();
	    }
	    destroy() {
	        return this._self.#internal.destroy();
	    }
	    async SUBSCRIBE(channels, listener, bufferMode) {
	        return this._self.#internal.subscribe(channels, listener, bufferMode);
	    }
	    subscribe = this.SUBSCRIBE;
	    async UNSUBSCRIBE(channels, listener, bufferMode) {
	        return this._self.#internal.unsubscribe(channels, listener, bufferMode);
	    }
	    unsubscribe = this.UNSUBSCRIBE;
	    async PSUBSCRIBE(patterns, listener, bufferMode) {
	        return this._self.#internal.pSubscribe(patterns, listener, bufferMode);
	    }
	    pSubscribe = this.PSUBSCRIBE;
	    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
	        return this._self.#internal.pUnsubscribe(patterns, listener, bufferMode);
	    }
	    pUnsubscribe = this.PUNSUBSCRIBE;
	    /**
	     * Acquires a master client lease for exclusive operations
	     *
	     * Used when multiple commands need to run on an exclusive client (for example, using `WATCH/MULTI/EXEC`).
	     * The returned client must be released after use with the `release()` method.
	     *
	     * @returns A promise that resolves to a Redis client connected to the master node
	     * @example
	     * ```javascript
	     * const clientLease = await sentinel.acquire();
	     *
	     * try {
	     *   await clientLease.watch('key');
	     *   const resp = await clientLease.multi()
	     *     .get('key')
	     *     .exec();
	     * } finally {
	     *   clientLease.release();
	     * }
	     * ```
	     */
	    async acquire() {
	        const clientInfo = await this._self.#internal.getClientLease();
	        return RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions);
	    }
	    getSentinelNode() {
	        return this._self.#internal.getSentinelNode();
	    }
	    getMasterNode() {
	        return this._self.#internal.getMasterNode();
	    }
	    getReplicaNodes() {
	        return this._self.#internal.getReplicaNodes();
	    }
	    setTracer(tracer) {
	        if (tracer) {
	            this._self.#trace = (msg) => { tracer.push(msg); };
	        }
	        else {
	            this._self.#trace = () => { };
	        }
	        this._self.#internal.setTracer(tracer);
	    }
	}
	sentinel.default = RedisSentinel;
	class RedisSentinelInternal extends node_events_1.EventEmitter {
	    #isOpen = false;
	    get isOpen() {
	        return this.#isOpen;
	    }
	    #isReady = false;
	    get isReady() {
	        return this.#isReady;
	    }
	    #name;
	    #nodeClientOptions;
	    #sentinelClientOptions;
	    #scanInterval;
	    #passthroughClientErrorEvents;
	    #RESP;
	    #anotherReset = false;
	    #configEpoch = 0;
	    #sentinelRootNodes;
	    #sentinelClient;
	    #masterClients = [];
	    #masterClientQueue;
	    #masterPoolSize;
	    #replicaClients = [];
	    #replicaClientsIdx = 0;
	    #replicaPoolSize;
	    get useReplicas() {
	        return this.#replicaPoolSize > 0;
	    }
	    #connectPromise;
	    #maxCommandRediscovers;
	    #pubSubProxy;
	    #scanTimer;
	    #destroy = false;
	    #trace = () => { };
	    #clientSideCache;
	    get clientSideCache() {
	        return this.#clientSideCache;
	    }
	    #validateOptions(options) {
	        if (options?.clientSideCache && options?.RESP !== 3) {
	            throw new Error('Client Side Caching is only supported with RESP3');
	        }
	    }
	    constructor(options) {
	        super();
	        this.#validateOptions(options);
	        this.#name = options.name;
	        this.#RESP = options.RESP;
	        this.#sentinelRootNodes = Array.from(options.sentinelRootNodes);
	        this.#maxCommandRediscovers = options.maxCommandRediscovers ?? 16;
	        this.#masterPoolSize = options.masterPoolSize ?? 1;
	        this.#replicaPoolSize = options.replicaPoolSize ?? 0;
	        this.#scanInterval = options.scanInterval ?? 0;
	        this.#passthroughClientErrorEvents = options.passthroughClientErrorEvents ?? false;
	        this.#nodeClientOptions = (options.nodeClientOptions ? { ...options.nodeClientOptions } : {});
	        if (this.#nodeClientOptions.url !== undefined) {
	            throw new Error("invalid nodeClientOptions for Sentinel");
	        }
	        if (options.clientSideCache) {
	            if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
	                this.#clientSideCache = this.#nodeClientOptions.clientSideCache = options.clientSideCache;
	            }
	            else {
	                const cscConfig = options.clientSideCache;
	                this.#clientSideCache = this.#nodeClientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
	                //        this.#clientSideCache = this.#nodeClientOptions.clientSideCache = new PooledNoRedirectClientSideCache(cscConfig);
	            }
	        }
	        this.#sentinelClientOptions = options.sentinelClientOptions ? Object.assign({}, options.sentinelClientOptions) : {};
	        this.#sentinelClientOptions.modules = module_1.default;
	        if (this.#sentinelClientOptions.url !== undefined) {
	            throw new Error("invalid sentinelClientOptions for Sentinel");
	        }
	        this.#masterClientQueue = new wait_queue_1.WaitQueue();
	        for (let i = 0; i < this.#masterPoolSize; i++) {
	            this.#masterClientQueue.push(i);
	        }
	        /* persistent object for life of sentinel object */
	        this.#pubSubProxy = new pub_sub_proxy_1.PubSubProxy(this.#nodeClientOptions, err => this.emit('error', err));
	    }
	    #createClient(node, clientOptions, reconnectStrategy) {
	        return client_1.default.create({
	            //first take the globally set RESP
	            RESP: this.#RESP,
	            //then take the client options, which can in theory overwrite it
	            ...clientOptions,
	            socket: {
	                ...clientOptions.socket,
	                host: node.host,
	                port: node.port,
	                reconnectStrategy
	            }
	        });
	    }
	    /**
	     * Gets a client lease from the master client pool
	     *
	     * @returns A client info object or a promise that resolves to a client info object
	     *          when a client becomes available
	     */
	    getClientLease() {
	        const id = this.#masterClientQueue.shift();
	        if (id !== undefined) {
	            return { id };
	        }
	        return this.#masterClientQueue.wait().then(id => ({ id }));
	    }
	    /**
	     * Releases a client lease back to the pool
	     *
	     * If the client was used for a transaction that might have left it in a dirty state,
	     * it will be reset before being returned to the pool.
	     *
	     * @param clientInfo The client info object representing the client to release
	     * @returns A promise that resolves when the client is ready to be reused, or undefined
	     *          if the client was immediately ready or no longer exists
	     */
	    releaseClientLease(clientInfo) {
	        const client = this.#masterClients[clientInfo.id];
	        // client can be undefined if releasing in middle of a reconfigure
	        if (client !== undefined) {
	            const dirtyPromise = client.resetIfDirty();
	            if (dirtyPromise) {
	                return dirtyPromise
	                    .then(() => this.#masterClientQueue.push(clientInfo.id));
	            }
	        }
	        this.#masterClientQueue.push(clientInfo.id);
	    }
	    async connect() {
	        if (this.#isOpen) {
	            throw new Error("already attempting to open");
	        }
	        try {
	            this.#isOpen = true;
	            this.#connectPromise = this.#connect();
	            await this.#connectPromise;
	            this.#isReady = true;
	        }
	        finally {
	            this.#connectPromise = undefined;
	            if (this.#scanInterval > 0) {
	                this.#scanTimer = setInterval(this.#reset.bind(this), this.#scanInterval);
	            }
	        }
	    }
	    async #connect() {
	        let count = 0;
	        while (true) {
	            this.#trace("starting connect loop");
	            count += 1;
	            if (this.#destroy) {
	                this.#trace("in #connect and want to destroy");
	                return;
	            }
	            try {
	                this.#anotherReset = false;
	                await this.transform(this.analyze(await this.observe()));
	                if (this.#anotherReset) {
	                    this.#trace("#connect: anotherReset is true, so continuing");
	                    continue;
	                }
	                this.#trace("#connect: returning");
	                return;
	            }
	            catch (e) {
	                this.#trace(`#connect: exception ${e.message}`);
	                if (!this.#isReady && count > this.#maxCommandRediscovers) {
	                    throw e;
	                }
	                if (e.message !== 'no valid master node') {
	                    console.log(e);
	                }
	                await (0, promises_1.setTimeout)(1000);
	            }
	            finally {
	                this.#trace("finished connect");
	            }
	        }
	    }
	    async execute(fn, clientInfo) {
	        let iter = 0;
	        while (true) {
	            if (this.#connectPromise !== undefined) {
	                await this.#connectPromise;
	            }
	            const client = this.#getClient(clientInfo);
	            if (!client.isReady) {
	                await this.#reset();
	                continue;
	            }
	            const sockOpts = client.options?.socket;
	            this.#trace("attemping to send command to " + sockOpts?.host + ":" + sockOpts?.port);
	            try {
	                /*
	                        // force testing of READONLY errors
	                        if (clientInfo !== undefined) {
	                          if (Math.floor(Math.random() * 10) < 1) {
	                            console.log("throwing READONLY error");
	                            throw new Error("READONLY You can't write against a read only replica.");
	                          }
	                        }
	                */
	                return await fn(client);
	            }
	            catch (err) {
	                if (++iter > this.#maxCommandRediscovers || !(err instanceof Error)) {
	                    throw err;
	                }
	                /*
	                  rediscover and retry if doing a command against a "master"
	                  a) READONLY error (topology has changed) but we haven't been notified yet via pubsub
	                  b) client is "not ready" (disconnected), which means topology might have changed, but sentinel might not see it yet
	                */
	                if (clientInfo !== undefined && (err.message.startsWith('READONLY') || !client.isReady)) {
	                    await this.#reset();
	                    continue;
	                }
	                throw err;
	            }
	        }
	    }
	    async #createPubSub(client) {
	        /* Whenever sentinels or slaves get added, or when slave configuration changes, reconfigure */
	        await client.pSubscribe(['switch-master', '[-+]sdown', '+slave', '+sentinel', '[-+]odown', '+slave-reconf-done'], (message, channel) => {
	            this.#handlePubSubControlChannel(channel, message);
	        }, true);
	        return client;
	    }
	    async #handlePubSubControlChannel(channel, message) {
	        this.#trace("pubsub control channel message on " + channel);
	        this.#reset();
	    }
	    // if clientInfo is defined, it corresponds to a master client in the #masterClients array, otherwise loop around replicaClients
	    #getClient(clientInfo) {
	        if (clientInfo !== undefined) {
	            return this.#masterClients[clientInfo.id];
	        }
	        if (this.#replicaClientsIdx >= this.#replicaClients.length) {
	            this.#replicaClientsIdx = 0;
	        }
	        if (this.#replicaClients.length == 0) {
	            throw new Error("no replicas available for read");
	        }
	        return this.#replicaClients[this.#replicaClientsIdx++];
	    }
	    async #reset() {
	        /* closing / don't reset */
	        if (this.#isReady == false || this.#destroy == true) {
	            return;
	        }
	        // already in #connect()
	        if (this.#connectPromise !== undefined) {
	            this.#anotherReset = true;
	            return await this.#connectPromise;
	        }
	        try {
	            this.#connectPromise = this.#connect();
	            return await this.#connectPromise;
	        }
	        finally {
	            this.#trace("finished reconfgure");
	            this.#connectPromise = undefined;
	        }
	    }
	    async close() {
	        this.#destroy = true;
	        if (this.#connectPromise != undefined) {
	            await this.#connectPromise;
	        }
	        this.#isReady = false;
	        this.#clientSideCache?.onPoolClose();
	        if (this.#scanTimer) {
	            clearInterval(this.#scanTimer);
	            this.#scanTimer = undefined;
	        }
	        const promises = [];
	        if (this.#sentinelClient !== undefined) {
	            if (this.#sentinelClient.isOpen) {
	                promises.push(this.#sentinelClient.close());
	            }
	            this.#sentinelClient = undefined;
	        }
	        for (const client of this.#masterClients) {
	            if (client.isOpen) {
	                promises.push(client.close());
	            }
	        }
	        this.#masterClients = [];
	        for (const client of this.#replicaClients) {
	            if (client.isOpen) {
	                promises.push(client.close());
	            }
	        }
	        this.#replicaClients = [];
	        await Promise.all(promises);
	        this.#pubSubProxy.destroy();
	        this.#isOpen = false;
	    }
	    // destroy has to be async because its stopping others async events, timers and the like
	    // and shouldn't return until its finished.
	    async destroy() {
	        this.#destroy = true;
	        if (this.#connectPromise != undefined) {
	            await this.#connectPromise;
	        }
	        this.#isReady = false;
	        this.#clientSideCache?.onPoolClose();
	        if (this.#scanTimer) {
	            clearInterval(this.#scanTimer);
	            this.#scanTimer = undefined;
	        }
	        if (this.#sentinelClient !== undefined) {
	            if (this.#sentinelClient.isOpen) {
	                this.#sentinelClient.destroy();
	            }
	            this.#sentinelClient = undefined;
	        }
	        for (const client of this.#masterClients) {
	            if (client.isOpen) {
	                client.destroy();
	            }
	        }
	        this.#masterClients = [];
	        for (const client of this.#replicaClients) {
	            if (client.isOpen) {
	                client.destroy();
	            }
	        }
	        this.#replicaClients = [];
	        this.#pubSubProxy.destroy();
	        this.#isOpen = false;
	        this.#destroy = false;
	    }
	    async subscribe(channels, listener, bufferMode) {
	        return this.#pubSubProxy.subscribe(channels, listener, bufferMode);
	    }
	    async unsubscribe(channels, listener, bufferMode) {
	        return this.#pubSubProxy.unsubscribe(channels, listener, bufferMode);
	    }
	    async pSubscribe(patterns, listener, bufferMode) {
	        return this.#pubSubProxy.pSubscribe(patterns, listener, bufferMode);
	    }
	    async pUnsubscribe(patterns, listener, bufferMode) {
	        return this.#pubSubProxy.pUnsubscribe(patterns, listener, bufferMode);
	    }
	    // observe/analyze/transform remediation functions
	    async observe() {
	        for (const node of this.#sentinelRootNodes) {
	            let client;
	            try {
	                this.#trace(`observe: trying to connect to sentinel: ${node.host}:${node.port}`);
	                client = this.#createClient(node, this.#sentinelClientOptions, false);
	                client.on('error', (err) => this.emit('error', `obseve client error: ${err}`));
	                await client.connect();
	                this.#trace(`observe: connected to sentinel`);
	                const [sentinelData, masterData, replicaData] = await Promise.all([
	                    client.sentinel.sentinelSentinels(this.#name),
	                    client.sentinel.sentinelMaster(this.#name),
	                    client.sentinel.sentinelReplicas(this.#name)
	                ]);
	                this.#trace("observe: got all sentinel data");
	                const ret = {
	                    sentinelConnected: node,
	                    sentinelData: sentinelData,
	                    masterData: masterData,
	                    replicaData: replicaData,
	                    currentMaster: this.getMasterNode(),
	                    currentReplicas: this.getReplicaNodes(),
	                    currentSentinel: this.getSentinelNode(),
	                    replicaPoolSize: this.#replicaPoolSize,
	                    useReplicas: this.useReplicas
	                };
	                return ret;
	            }
	            catch (err) {
	                this.#trace(`observe: error ${err}`);
	                this.emit('error', err);
	            }
	            finally {
	                if (client !== undefined && client.isOpen) {
	                    this.#trace(`observe: destroying sentinel client`);
	                    client.destroy();
	                }
	            }
	        }
	        this.#trace(`observe: none of the sentinels are available`);
	        throw new Error('None of the sentinels are available');
	    }
	    analyze(observed) {
	        let master = (0, utils_1.parseNode)(observed.masterData);
	        if (master === undefined) {
	            this.#trace(`analyze: no valid master node because ${observed.masterData.flags}`);
	            throw new Error("no valid master node");
	        }
	        if (master.host === observed.currentMaster?.host && master.port === observed.currentMaster?.port) {
	            this.#trace(`analyze: master node hasn't changed from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
	            master = undefined;
	        }
	        else {
	            this.#trace(`analyze: master node has changed to ${master.host}:${master.port} from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
	        }
	        let sentinel = observed.sentinelConnected;
	        if (sentinel.host === observed.currentSentinel?.host && sentinel.port === observed.currentSentinel.port) {
	            this.#trace(`analyze: sentinel node hasn't changed`);
	            sentinel = undefined;
	        }
	        else {
	            this.#trace(`analyze: sentinel node has changed to ${sentinel.host}:${sentinel.port}`);
	        }
	        const replicasToClose = [];
	        const replicasToOpen = new Map();
	        const desiredSet = new Set();
	        const seen = new Set();
	        if (observed.useReplicas) {
	            const replicaList = (0, utils_1.createNodeList)(observed.replicaData);
	            for (const node of replicaList) {
	                desiredSet.add(JSON.stringify(node));
	            }
	            for (const [node, value] of observed.currentReplicas) {
	                if (!desiredSet.has(JSON.stringify(node))) {
	                    replicasToClose.push(node);
	                    this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToClose`);
	                }
	                else {
	                    seen.add(JSON.stringify(node));
	                    if (value != observed.replicaPoolSize) {
	                        replicasToOpen.set(node, observed.replicaPoolSize - value);
	                        this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
	                    }
	                }
	            }
	            for (const node of replicaList) {
	                if (!seen.has(JSON.stringify(node))) {
	                    replicasToOpen.set(node, observed.replicaPoolSize);
	                    this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
	                }
	            }
	        }
	        const ret = {
	            sentinelList: [observed.sentinelConnected].concat((0, utils_1.createNodeList)(observed.sentinelData)),
	            epoch: Number(observed.masterData['config-epoch']),
	            sentinelToOpen: sentinel,
	            masterToOpen: master,
	            replicasToClose: replicasToClose,
	            replicasToOpen: replicasToOpen,
	        };
	        return ret;
	    }
	    async transform(analyzed) {
	        this.#trace("transform: enter");
	        let promises = [];
	        if (analyzed.sentinelToOpen) {
	            this.#trace(`transform: opening a new sentinel`);
	            if (this.#sentinelClient !== undefined && this.#sentinelClient.isOpen) {
	                this.#trace(`transform: destroying old sentinel as open`);
	                this.#sentinelClient.destroy();
	                this.#sentinelClient = undefined;
	            }
	            else {
	                this.#trace(`transform: not destroying old sentinel as not open`);
	            }
	            this.#trace(`transform: creating new sentinel to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
	            const node = analyzed.sentinelToOpen;
	            const client = this.#createClient(analyzed.sentinelToOpen, this.#sentinelClientOptions, false);
	            client.on('error', (err) => {
	                if (this.#passthroughClientErrorEvents) {
	                    this.emit('error', new Error(`Sentinel Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
	                }
	                const event = {
	                    type: 'SENTINEL',
	                    node: (0, utils_1.clientSocketToNode)(client.options.socket),
	                    error: err
	                };
	                this.emit('client-error', event);
	                this.#reset();
	            });
	            this.#sentinelClient = client;
	            this.#trace(`transform: adding sentinel client connect() to promise list`);
	            const promise = this.#sentinelClient.connect().then((client) => { return this.#createPubSub(client); });
	            promises.push(promise);
	            this.#trace(`created sentinel client to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
	            const event = {
	                type: "SENTINEL_CHANGE",
	                node: analyzed.sentinelToOpen
	            };
	            this.#trace(`transform: emiting topology-change event for sentinel_change`);
	            if (!this.emit('topology-change', event)) {
	                this.#trace(`transform: emit for topology-change for sentinel_change returned false`);
	            }
	        }
	        if (analyzed.masterToOpen) {
	            this.#trace(`transform: opening a new master`);
	            const masterPromises = [];
	            const masterWatches = [];
	            this.#trace(`transform: destroying old masters if open`);
	            for (const client of this.#masterClients) {
	                masterWatches.push(client.isWatching || client.isDirtyWatch);
	                if (client.isOpen) {
	                    client.destroy();
	                }
	            }
	            this.#masterClients = [];
	            this.#trace(`transform: creating all master clients and adding connect promises`);
	            for (let i = 0; i < this.#masterPoolSize; i++) {
	                const node = analyzed.masterToOpen;
	                const client = this.#createClient(analyzed.masterToOpen, this.#nodeClientOptions);
	                client.on('error', (err) => {
	                    if (this.#passthroughClientErrorEvents) {
	                        this.emit('error', new Error(`Master Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
	                    }
	                    const event = {
	                        type: "MASTER",
	                        node: (0, utils_1.clientSocketToNode)(client.options.socket),
	                        error: err
	                    };
	                    this.emit('client-error', event);
	                });
	                if (masterWatches[i]) {
	                    client.setDirtyWatch("sentinel config changed in middle of a WATCH Transaction");
	                }
	                this.#masterClients.push(client);
	                masterPromises.push(client.connect());
	                this.#trace(`created master client to ${analyzed.masterToOpen.host}:${analyzed.masterToOpen.port}`);
	            }
	            this.#trace(`transform: adding promise to change #pubSubProxy node`);
	            masterPromises.push(this.#pubSubProxy.changeNode(analyzed.masterToOpen));
	            promises.push(...masterPromises);
	            const event = {
	                type: "MASTER_CHANGE",
	                node: analyzed.masterToOpen
	            };
	            this.#trace(`transform: emiting topology-change event for master_change`);
	            if (!this.emit('topology-change', event)) {
	                this.#trace(`transform: emit for topology-change for master_change returned false`);
	            }
	            this.#configEpoch++;
	        }
	        const replicaCloseSet = new Set();
	        for (const node of analyzed.replicasToClose) {
	            const str = JSON.stringify(node);
	            replicaCloseSet.add(str);
	        }
	        const newClientList = [];
	        const removedSet = new Set();
	        for (const replica of this.#replicaClients) {
	            const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
	            const str = JSON.stringify(node);
	            if (replicaCloseSet.has(str) || !replica.isOpen) {
	                if (replica.isOpen) {
	                    const sockOpts = replica.options?.socket;
	                    this.#trace(`destroying replica client to ${sockOpts?.host}:${sockOpts?.port}`);
	                    replica.destroy();
	                }
	                if (!removedSet.has(str)) {
	                    const event = {
	                        type: "REPLICA_REMOVE",
	                        node: node
	                    };
	                    this.emit('topology-change', event);
	                    removedSet.add(str);
	                }
	            }
	            else {
	                newClientList.push(replica);
	            }
	        }
	        this.#replicaClients = newClientList;
	        if (analyzed.replicasToOpen.size != 0) {
	            for (const [node, size] of analyzed.replicasToOpen) {
	                for (let i = 0; i < size; i++) {
	                    const client = this.#createClient(node, this.#nodeClientOptions);
	                    client.on('error', (err) => {
	                        if (this.#passthroughClientErrorEvents) {
	                            this.emit('error', new Error(`Replica Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
	                        }
	                        const event = {
	                            type: "REPLICA",
	                            node: (0, utils_1.clientSocketToNode)(client.options.socket),
	                            error: err
	                        };
	                        this.emit('client-error', event);
	                    });
	                    this.#replicaClients.push(client);
	                    promises.push(client.connect());
	                    this.#trace(`created replica client to ${node.host}:${node.port}`);
	                }
	                const event = {
	                    type: "REPLICA_ADD",
	                    node: node
	                };
	                this.emit('topology-change', event);
	            }
	        }
	        if (analyzed.sentinelList.length != this.#sentinelRootNodes.length) {
	            this.#sentinelRootNodes = analyzed.sentinelList;
	            const event = {
	                type: "SENTINE_LIST_CHANGE",
	                size: analyzed.sentinelList.length
	            };
	            this.emit('topology-change', event);
	        }
	        await Promise.all(promises);
	        this.#trace("transform: exit");
	    }
	    // introspection functions
	    getMasterNode() {
	        if (this.#masterClients.length == 0) {
	            return undefined;
	        }
	        for (const master of this.#masterClients) {
	            if (master.isReady) {
	                return (0, utils_1.clientSocketToNode)(master.options.socket);
	            }
	        }
	        return undefined;
	    }
	    getSentinelNode() {
	        if (this.#sentinelClient === undefined) {
	            return undefined;
	        }
	        return (0, utils_1.clientSocketToNode)(this.#sentinelClient.options.socket);
	    }
	    getReplicaNodes() {
	        const ret = new Map();
	        const initialMap = new Map();
	        for (const replica of this.#replicaClients) {
	            const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
	            const hash = JSON.stringify(node);
	            if (replica.isReady) {
	                initialMap.set(hash, (initialMap.get(hash) ?? 0) + 1);
	            }
	            else {
	                if (!initialMap.has(hash)) {
	                    initialMap.set(hash, 0);
	                }
	            }
	        }
	        for (const [key, value] of initialMap) {
	            ret.set(JSON.parse(key), value);
	        }
	        return ret;
	    }
	    setTracer(tracer) {
	        if (tracer) {
	            this.#trace = (msg) => { tracer.push(msg); };
	        }
	        else {
	            // empty function is faster than testing if something is defined or not
	            this.#trace = () => { };
	        }
	    }
	}
	class RedisSentinelFactory extends node_events_1.EventEmitter {
	    options;
	    #sentinelRootNodes;
	    #replicaIdx = -1;
	    constructor(options) {
	        super();
	        this.options = options;
	        this.#sentinelRootNodes = options.sentinelRootNodes;
	    }
	    async updateSentinelRootNodes() {
	        for (const node of this.#sentinelRootNodes) {
	            const client = client_1.default.create({
	                ...this.options.sentinelClientOptions,
	                socket: {
	                    ...this.options.sentinelClientOptions?.socket,
	                    host: node.host,
	                    port: node.port,
	                    reconnectStrategy: false
	                },
	                modules: module_1.default
	            }).on('error', (err) => this.emit(`updateSentinelRootNodes: ${err}`));
	            try {
	                await client.connect();
	            }
	            catch {
	                if (client.isOpen) {
	                    client.destroy();
	                }
	                continue;
	            }
	            try {
	                const sentinelData = await client.sentinel.sentinelSentinels(this.options.name);
	                this.#sentinelRootNodes = [node].concat((0, utils_1.createNodeList)(sentinelData));
	                return;
	            }
	            finally {
	                client.destroy();
	            }
	        }
	        throw new Error("Couldn't connect to any sentinel node");
	    }
	    async getMasterNode() {
	        let connected = false;
	        for (const node of this.#sentinelRootNodes) {
	            const client = client_1.default.create({
	                ...this.options.sentinelClientOptions,
	                socket: {
	                    ...this.options.sentinelClientOptions?.socket,
	                    host: node.host,
	                    port: node.port,
	                    reconnectStrategy: false
	                },
	                modules: module_1.default
	            }).on('error', err => this.emit(`getMasterNode: ${err}`));
	            try {
	                await client.connect();
	            }
	            catch {
	                if (client.isOpen) {
	                    client.destroy();
	                }
	                continue;
	            }
	            connected = true;
	            try {
	                const masterData = await client.sentinel.sentinelMaster(this.options.name);
	                let master = (0, utils_1.parseNode)(masterData);
	                if (master === undefined) {
	                    continue;
	                }
	                return master;
	            }
	            finally {
	                client.destroy();
	            }
	        }
	        if (connected) {
	            throw new Error("Master Node Not Enumerated");
	        }
	        throw new Error("couldn't connect to any sentinels");
	    }
	    async getMasterClient() {
	        const master = await this.getMasterNode();
	        return client_1.default.create({
	            ...this.options.nodeClientOptions,
	            socket: {
	                ...this.options.nodeClientOptions?.socket,
	                host: master.host,
	                port: master.port
	            }
	        });
	    }
	    async getReplicaNodes() {
	        let connected = false;
	        for (const node of this.#sentinelRootNodes) {
	            const client = client_1.default.create({
	                ...this.options.sentinelClientOptions,
	                socket: {
	                    ...this.options.sentinelClientOptions?.socket,
	                    host: node.host,
	                    port: node.port,
	                    reconnectStrategy: false
	                },
	                modules: module_1.default
	            }).on('error', err => this.emit(`getReplicaNodes: ${err}`));
	            try {
	                await client.connect();
	            }
	            catch {
	                if (client.isOpen) {
	                    client.destroy();
	                }
	                continue;
	            }
	            connected = true;
	            try {
	                const replicaData = await client.sentinel.sentinelReplicas(this.options.name);
	                const replicas = (0, utils_1.createNodeList)(replicaData);
	                if (replicas.length == 0) {
	                    continue;
	                }
	                return replicas;
	            }
	            finally {
	                client.destroy();
	            }
	        }
	        if (connected) {
	            throw new Error("No Replicas Nodes Enumerated");
	        }
	        throw new Error("couldn't connect to any sentinels");
	    }
	    async getReplicaClient() {
	        const replicas = await this.getReplicaNodes();
	        if (replicas.length == 0) {
	            throw new Error("no available replicas");
	        }
	        this.#replicaIdx++;
	        if (this.#replicaIdx >= replicas.length) {
	            this.#replicaIdx = 0;
	        }
	        return client_1.default.create({
	            ...this.options.nodeClientOptions,
	            socket: {
	                ...this.options.nodeClientOptions?.socket,
	                host: replicas[this.#replicaIdx].host,
	                port: replicas[this.#replicaIdx].port
	            }
	        });
	    }
	}
	sentinel.RedisSentinelFactory = RedisSentinelFactory;
	
	return sentinel;
}

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist;
	hasRequiredDist$1 = 1;
	(function (exports) {
		var __createBinding = (dist && dist.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (dist && dist.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		var __importDefault = (dist && dist.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.BasicPooledClientSideCache = exports.BasicClientSideCache = exports.REDIS_FLUSH_MODES = exports.GEO_REPLY_WITH = exports.createSentinel = exports.createCluster = exports.createClientPool = exports.createClient = exports.defineScript = exports.VerbatimString = exports.RESP_TYPES = void 0;
		var decoder_1 = requireDecoder();
		Object.defineProperty(exports, "RESP_TYPES", { enumerable: true, get: function () { return decoder_1.RESP_TYPES; } });
		var verbatim_string_1 = requireVerbatimString();
		Object.defineProperty(exports, "VerbatimString", { enumerable: true, get: function () { return verbatim_string_1.VerbatimString; } });
		var lua_script_1 = requireLuaScript();
		Object.defineProperty(exports, "defineScript", { enumerable: true, get: function () { return lua_script_1.defineScript; } });
		__exportStar(requireErrors$1(), exports);
		const client_1 = __importDefault(requireClient());
		exports.createClient = client_1.default.create;
		const pool_1 = requirePool();
		exports.createClientPool = pool_1.RedisClientPool.create;
		const cluster_1 = __importDefault(requireCluster());
		exports.createCluster = cluster_1.default.create;
		const sentinel_1 = __importDefault(requireSentinel());
		exports.createSentinel = sentinel_1.default.create;
		var GEOSEARCH_WITH_1 = requireGEOSEARCH_WITH();
		Object.defineProperty(exports, "GEO_REPLY_WITH", { enumerable: true, get: function () { return GEOSEARCH_WITH_1.GEO_REPLY_WITH; } });
		var FLUSHALL_1 = requireFLUSHALL();
		Object.defineProperty(exports, "REDIS_FLUSH_MODES", { enumerable: true, get: function () { return FLUSHALL_1.REDIS_FLUSH_MODES; } });
		var cache_1 = requireCache();
		Object.defineProperty(exports, "BasicClientSideCache", { enumerable: true, get: function () { return cache_1.BasicClientSideCache; } });
		Object.defineProperty(exports, "BasicPooledClientSideCache", { enumerable: true, get: function () { return cache_1.BasicPooledClientSideCache; } });
		
	} (dist));
	return dist;
}

var lib$3 = {};

var commands$3 = {};

var bloom = {};

var ADD$4 = {};

var hasRequiredADD$4;

function requireADD$4 () {
	if (hasRequiredADD$4) return ADD$4;
	hasRequiredADD$4 = 1;
	Object.defineProperty(ADD$4, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ADD$4.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds an item to a Bloom Filter
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter
	     * @param item - The item to add to the filter
	     */
	    parseCommand(parser, key, item) {
	        parser.push('BF.ADD');
	        parser.pushKey(key);
	        parser.push(item);
	    },
	    transformReply: generic_transformers_1.transformBooleanReply
	};
	
	return ADD$4;
}

var CARD = {};

var hasRequiredCARD;

function requireCARD () {
	if (hasRequiredCARD) return CARD;
	hasRequiredCARD = 1;
	Object.defineProperty(CARD, "__esModule", { value: true });
	CARD.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the cardinality (number of items) in a Bloom Filter
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter to query
	     */
	    parseCommand(parser, key) {
	        parser.push('BF.CARD');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return CARD;
}

var EXISTS$1 = {};

var hasRequiredEXISTS$1;

function requireEXISTS$1 () {
	if (hasRequiredEXISTS$1) return EXISTS$1;
	hasRequiredEXISTS$1 = 1;
	Object.defineProperty(EXISTS$1, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	EXISTS$1.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Checks if an item exists in a Bloom Filter
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter
	     * @param item - The item to check for existence
	     */
	    parseCommand(parser, key, item) {
	        parser.push('BF.EXISTS');
	        parser.pushKey(key);
	        parser.push(item);
	    },
	    transformReply: generic_transformers_1.transformBooleanReply
	};
	
	return EXISTS$1;
}

var INFO$6 = {};

var helpers$1 = {};

var hasRequiredHelpers$1;

function requireHelpers$1 () {
	if (hasRequiredHelpers$1) return helpers$1;
	hasRequiredHelpers$1 = 1;
	Object.defineProperty(helpers$1, "__esModule", { value: true });
	helpers$1.transformInfoV2Reply = void 0;
	const client_1 = requireDist$1();
	function transformInfoV2Reply(reply, typeMapping) {
	    const mapType = typeMapping ? typeMapping[client_1.RESP_TYPES.MAP] : undefined;
	    switch (mapType) {
	        case Array: {
	            return reply;
	        }
	        case Map: {
	            const ret = new Map();
	            for (let i = 0; i < reply.length; i += 2) {
	                ret.set(reply[i].toString(), reply[i + 1]);
	            }
	            return ret;
	        }
	        default: {
	            const ret = Object.create(null);
	            for (let i = 0; i < reply.length; i += 2) {
	                ret[reply[i].toString()] = reply[i + 1];
	            }
	            return ret;
	        }
	    }
	}
	helpers$1.transformInfoV2Reply = transformInfoV2Reply;
	
	return helpers$1;
}

var hasRequiredINFO$6;

function requireINFO$6 () {
	if (hasRequiredINFO$6) return INFO$6;
	hasRequiredINFO$6 = 1;
	Object.defineProperty(INFO$6, "__esModule", { value: true });
	const helpers_1 = requireHelpers$1();
	INFO$6.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns information about a Bloom Filter, including capacity, size, number of filters, items inserted, and expansion rate
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter to get information about
	     */
	    parseCommand(parser, key) {
	        parser.push('BF.INFO');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        2: (reply, _, typeMapping) => {
	            return (0, helpers_1.transformInfoV2Reply)(reply, typeMapping);
	        },
	        3: undefined
	    }
	};
	
	return INFO$6;
}

var INSERT$1 = {};

var hasRequiredINSERT$1;

function requireINSERT$1 () {
	if (hasRequiredINSERT$1) return INSERT$1;
	hasRequiredINSERT$1 = 1;
	Object.defineProperty(INSERT$1, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	INSERT$1.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds one or more items to a Bloom Filter, creating it if it does not exist
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter
	     * @param items - One or more items to add to the filter
	     * @param options - Optional parameters for filter creation
	     * @param options.CAPACITY - Desired capacity for a new filter
	     * @param options.ERROR - Desired error rate for a new filter
	     * @param options.EXPANSION - Expansion rate for a new filter
	     * @param options.NOCREATE - If true, prevents automatic filter creation
	     * @param options.NONSCALING - Prevents the filter from creating additional sub-filters
	     */
	    parseCommand(parser, key, items, options) {
	        parser.push('BF.INSERT');
	        parser.pushKey(key);
	        if (options?.CAPACITY !== undefined) {
	            parser.push('CAPACITY', options.CAPACITY.toString());
	        }
	        if (options?.ERROR !== undefined) {
	            parser.push('ERROR', options.ERROR.toString());
	        }
	        if (options?.EXPANSION !== undefined) {
	            parser.push('EXPANSION', options.EXPANSION.toString());
	        }
	        if (options?.NOCREATE) {
	            parser.push('NOCREATE');
	        }
	        if (options?.NONSCALING) {
	            parser.push('NONSCALING');
	        }
	        parser.push('ITEMS');
	        parser.pushVariadic(items);
	    },
	    transformReply: generic_transformers_1.transformBooleanArrayReply
	};
	
	return INSERT$1;
}

var LOADCHUNK$1 = {};

var hasRequiredLOADCHUNK$1;

function requireLOADCHUNK$1 () {
	if (hasRequiredLOADCHUNK$1) return LOADCHUNK$1;
	hasRequiredLOADCHUNK$1 = 1;
	Object.defineProperty(LOADCHUNK$1, "__esModule", { value: true });
	LOADCHUNK$1.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Restores a Bloom Filter chunk previously saved using SCANDUMP
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter to restore
	     * @param iterator - Iterator value from the SCANDUMP command
	     * @param chunk - Data chunk from the SCANDUMP command
	     */
	    parseCommand(parser, key, iterator, chunk) {
	        parser.push('BF.LOADCHUNK');
	        parser.pushKey(key);
	        parser.push(iterator.toString(), chunk);
	    },
	    transformReply: undefined
	};
	
	return LOADCHUNK$1;
}

var MADD$1 = {};

var hasRequiredMADD$1;

function requireMADD$1 () {
	if (hasRequiredMADD$1) return MADD$1;
	hasRequiredMADD$1 = 1;
	Object.defineProperty(MADD$1, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	MADD$1.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds multiple items to a Bloom Filter in a single call
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter
	     * @param items - One or more items to add to the filter
	     */
	    parseCommand(parser, key, items) {
	        parser.push('BF.MADD');
	        parser.pushKey(key);
	        parser.pushVariadic(items);
	    },
	    transformReply: generic_transformers_1.transformBooleanArrayReply
	};
	
	return MADD$1;
}

var MEXISTS = {};

var hasRequiredMEXISTS;

function requireMEXISTS () {
	if (hasRequiredMEXISTS) return MEXISTS;
	hasRequiredMEXISTS = 1;
	Object.defineProperty(MEXISTS, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	MEXISTS.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Checks if multiple items exist in a Bloom Filter in a single call
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter
	     * @param items - One or more items to check for existence
	     */
	    parseCommand(parser, key, items) {
	        parser.push('BF.MEXISTS');
	        parser.pushKey(key);
	        parser.pushVariadic(items);
	    },
	    transformReply: generic_transformers_1.transformBooleanArrayReply
	};
	
	return MEXISTS;
}

var RESERVE$2 = {};

var hasRequiredRESERVE$2;

function requireRESERVE$2 () {
	if (hasRequiredRESERVE$2) return RESERVE$2;
	hasRequiredRESERVE$2 = 1;
	Object.defineProperty(RESERVE$2, "__esModule", { value: true });
	RESERVE$2.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Creates an empty Bloom Filter with a given desired error ratio and initial capacity
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter to create
	     * @param errorRate - The desired probability for false positives (between 0 and 1)
	     * @param capacity - The number of entries intended to be added to the filter
	     * @param options - Optional parameters to tune the filter
	     * @param options.EXPANSION - Expansion rate for the filter
	     * @param options.NONSCALING - Prevents the filter from creating additional sub-filters
	     */
	    parseCommand(parser, key, errorRate, capacity, options) {
	        parser.push('BF.RESERVE');
	        parser.pushKey(key);
	        parser.push(errorRate.toString(), capacity.toString());
	        if (options?.EXPANSION) {
	            parser.push('EXPANSION', options.EXPANSION.toString());
	        }
	        if (options?.NONSCALING) {
	            parser.push('NONSCALING');
	        }
	    },
	    transformReply: undefined
	};
	
	return RESERVE$2;
}

var SCANDUMP$1 = {};

var hasRequiredSCANDUMP$1;

function requireSCANDUMP$1 () {
	if (hasRequiredSCANDUMP$1) return SCANDUMP$1;
	hasRequiredSCANDUMP$1 = 1;
	Object.defineProperty(SCANDUMP$1, "__esModule", { value: true });
	SCANDUMP$1.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Begins an incremental save of a Bloom Filter. This is useful for large filters that can't be saved at once
	     * @param parser - The command parser
	     * @param key - The name of the Bloom filter to save
	     * @param iterator - Iterator value; Start at 0, and use the iterator from the response for the next chunk
	     */
	    parseCommand(parser, key, iterator) {
	        parser.push('BF.SCANDUMP');
	        parser.pushKey(key);
	        parser.push(iterator.toString());
	    },
	    transformReply(reply) {
	        return {
	            iterator: reply[0],
	            chunk: reply[1]
	        };
	    }
	};
	
	return SCANDUMP$1;
}

var hasRequiredBloom;

function requireBloom () {
	if (hasRequiredBloom) return bloom;
	hasRequiredBloom = 1;
	(function (exports) {
		var __createBinding = (bloom && bloom.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (bloom && bloom.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		var __importDefault = (bloom && bloom.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		const ADD_1 = __importDefault(requireADD$4());
		const CARD_1 = __importDefault(requireCARD());
		const EXISTS_1 = __importDefault(requireEXISTS$1());
		const INFO_1 = __importDefault(requireINFO$6());
		const INSERT_1 = __importDefault(requireINSERT$1());
		const LOADCHUNK_1 = __importDefault(requireLOADCHUNK$1());
		const MADD_1 = __importDefault(requireMADD$1());
		const MEXISTS_1 = __importDefault(requireMEXISTS());
		const RESERVE_1 = __importDefault(requireRESERVE$2());
		const SCANDUMP_1 = __importDefault(requireSCANDUMP$1());
		__exportStar(requireHelpers$1(), exports);
		exports.default = {
		    ADD: ADD_1.default,
		    add: ADD_1.default,
		    CARD: CARD_1.default,
		    card: CARD_1.default,
		    EXISTS: EXISTS_1.default,
		    exists: EXISTS_1.default,
		    INFO: INFO_1.default,
		    info: INFO_1.default,
		    INSERT: INSERT_1.default,
		    insert: INSERT_1.default,
		    LOADCHUNK: LOADCHUNK_1.default,
		    loadChunk: LOADCHUNK_1.default,
		    MADD: MADD_1.default,
		    mAdd: MADD_1.default,
		    MEXISTS: MEXISTS_1.default,
		    mExists: MEXISTS_1.default,
		    RESERVE: RESERVE_1.default,
		    reserve: RESERVE_1.default,
		    SCANDUMP: SCANDUMP_1.default,
		    scanDump: SCANDUMP_1.default
		};
		
	} (bloom));
	return bloom;
}

var countMinSketch = {};

var INCRBY$2 = {};

var hasRequiredINCRBY$2;

function requireINCRBY$2 () {
	if (hasRequiredINCRBY$2) return INCRBY$2;
	hasRequiredINCRBY$2 = 1;
	Object.defineProperty(INCRBY$2, "__esModule", { value: true });
	INCRBY$2.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Increases the count of one or more items in a Count-Min Sketch
	     * @param parser - The command parser
	     * @param key - The name of the sketch
	     * @param items - A single item or array of items to increment, each with an item and increment value
	     */
	    parseCommand(parser, key, items) {
	        parser.push('CMS.INCRBY');
	        parser.pushKey(key);
	        if (Array.isArray(items)) {
	            for (const item of items) {
	                pushIncrByItem(parser, item);
	            }
	        }
	        else {
	            pushIncrByItem(parser, items);
	        }
	    },
	    transformReply: undefined
	};
	function pushIncrByItem(parser, { item, incrementBy }) {
	    parser.push(item, incrementBy.toString());
	}
	
	return INCRBY$2;
}

var INFO$5 = {};

var hasRequiredINFO$5;

function requireINFO$5 () {
	if (hasRequiredINFO$5) return INFO$5;
	hasRequiredINFO$5 = 1;
	Object.defineProperty(INFO$5, "__esModule", { value: true });
	const bloom_1 = requireBloom();
	INFO$5.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns width, depth, and total count of items in a Count-Min Sketch
	     * @param parser - The command parser
	     * @param key - The name of the sketch to get information about
	     */
	    parseCommand(parser, key) {
	        parser.push('CMS.INFO');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        2: (reply, _, typeMapping) => {
	            return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
	        },
	        3: undefined
	    }
	};
	
	return INFO$5;
}

var INITBYDIM = {};

var hasRequiredINITBYDIM;

function requireINITBYDIM () {
	if (hasRequiredINITBYDIM) return INITBYDIM;
	hasRequiredINITBYDIM = 1;
	Object.defineProperty(INITBYDIM, "__esModule", { value: true });
	INITBYDIM.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Initialize a Count-Min Sketch using width and depth parameters
	     * @param parser - The command parser
	     * @param key - The name of the sketch
	     * @param width - Number of counters in each array (must be a multiple of 2)
	     * @param depth - Number of counter arrays (determines accuracy of estimates)
	     */
	    parseCommand(parser, key, width, depth) {
	        parser.push('CMS.INITBYDIM');
	        parser.pushKey(key);
	        parser.push(width.toString(), depth.toString());
	    },
	    transformReply: undefined
	};
	
	return INITBYDIM;
}

var INITBYPROB = {};

var hasRequiredINITBYPROB;

function requireINITBYPROB () {
	if (hasRequiredINITBYPROB) return INITBYPROB;
	hasRequiredINITBYPROB = 1;
	Object.defineProperty(INITBYPROB, "__esModule", { value: true });
	INITBYPROB.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Initialize a Count-Min Sketch using error rate and probability parameters
	     * @param parser - The command parser
	     * @param key - The name of the sketch
	     * @param error - Estimate error, as a decimal between 0 and 1
	     * @param probability - The desired probability for inflated count, as a decimal between 0 and 1
	     */
	    parseCommand(parser, key, error, probability) {
	        parser.push('CMS.INITBYPROB');
	        parser.pushKey(key);
	        parser.push(error.toString(), probability.toString());
	    },
	    transformReply: undefined
	};
	
	return INITBYPROB;
}

var MERGE$2 = {};

var hasRequiredMERGE$2;

function requireMERGE$2 () {
	if (hasRequiredMERGE$2) return MERGE$2;
	hasRequiredMERGE$2 = 1;
	Object.defineProperty(MERGE$2, "__esModule", { value: true });
	MERGE$2.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Merges multiple Count-Min Sketches into a single sketch, with optional weights
	     * @param parser - The command parser
	     * @param destination - The name of the destination sketch
	     * @param source - Array of sketch names or array of sketches with weights
	     */
	    parseCommand(parser, destination, source) {
	        parser.push('CMS.MERGE');
	        parser.pushKey(destination);
	        parser.push(source.length.toString());
	        if (isPlainSketches(source)) {
	            parser.pushVariadic(source);
	        }
	        else {
	            for (let i = 0; i < source.length; i++) {
	                parser.push(source[i].name);
	            }
	            parser.push('WEIGHTS');
	            for (let i = 0; i < source.length; i++) {
	                parser.push(source[i].weight.toString());
	            }
	        }
	    },
	    transformReply: undefined
	};
	function isPlainSketches(src) {
	    return typeof src[0] === 'string' || src[0] instanceof Buffer;
	}
	
	return MERGE$2;
}

var QUERY$1 = {};

var hasRequiredQUERY$1;

function requireQUERY$1 () {
	if (hasRequiredQUERY$1) return QUERY$1;
	hasRequiredQUERY$1 = 1;
	Object.defineProperty(QUERY$1, "__esModule", { value: true });
	QUERY$1.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the count for one or more items in a Count-Min Sketch
	     * @param parser - The command parser
	     * @param key - The name of the sketch
	     * @param items - One or more items to get counts for
	     */
	    parseCommand(parser, key, items) {
	        parser.push('CMS.QUERY');
	        parser.pushKey(key);
	        parser.pushVariadic(items);
	    },
	    transformReply: undefined
	};
	
	return QUERY$1;
}

var hasRequiredCountMinSketch;

function requireCountMinSketch () {
	if (hasRequiredCountMinSketch) return countMinSketch;
	hasRequiredCountMinSketch = 1;
	var __importDefault = (countMinSketch && countMinSketch.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(countMinSketch, "__esModule", { value: true });
	const INCRBY_1 = __importDefault(requireINCRBY$2());
	const INFO_1 = __importDefault(requireINFO$5());
	const INITBYDIM_1 = __importDefault(requireINITBYDIM());
	const INITBYPROB_1 = __importDefault(requireINITBYPROB());
	const MERGE_1 = __importDefault(requireMERGE$2());
	const QUERY_1 = __importDefault(requireQUERY$1());
	countMinSketch.default = {
	    INCRBY: INCRBY_1.default,
	    incrBy: INCRBY_1.default,
	    INFO: INFO_1.default,
	    info: INFO_1.default,
	    INITBYDIM: INITBYDIM_1.default,
	    initByDim: INITBYDIM_1.default,
	    INITBYPROB: INITBYPROB_1.default,
	    initByProb: INITBYPROB_1.default,
	    MERGE: MERGE_1.default,
	    merge: MERGE_1.default,
	    QUERY: QUERY_1.default,
	    query: QUERY_1.default
	};
	
	return countMinSketch;
}

var cuckoo = {};

var ADD$3 = {};

var hasRequiredADD$3;

function requireADD$3 () {
	if (hasRequiredADD$3) return ADD$3;
	hasRequiredADD$3 = 1;
	Object.defineProperty(ADD$3, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ADD$3.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds an item to a Cuckoo Filter, creating the filter if it does not exist
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter
	     * @param item - The item to add to the filter
	     */
	    parseCommand(parser, key, item) {
	        parser.push('CF.ADD');
	        parser.pushKey(key);
	        parser.push(item);
	    },
	    transformReply: generic_transformers_1.transformBooleanReply
	};
	
	return ADD$3;
}

var ADDNX = {};

var hasRequiredADDNX;

function requireADDNX () {
	if (hasRequiredADDNX) return ADDNX;
	hasRequiredADDNX = 1;
	Object.defineProperty(ADDNX, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ADDNX.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds an item to a Cuckoo Filter only if it does not exist
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter
	     * @param item - The item to add to the filter if it doesn't exist
	     */
	    parseCommand(parser, key, item) {
	        parser.push('CF.ADDNX');
	        parser.pushKey(key);
	        parser.push(item);
	    },
	    transformReply: generic_transformers_1.transformBooleanReply
	};
	
	return ADDNX;
}

var COUNT$1 = {};

var hasRequiredCOUNT$1;

function requireCOUNT$1 () {
	if (hasRequiredCOUNT$1) return COUNT$1;
	hasRequiredCOUNT$1 = 1;
	Object.defineProperty(COUNT$1, "__esModule", { value: true });
	COUNT$1.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the number of times an item appears in a Cuckoo Filter
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter
	     * @param item - The item to count occurrences of
	     */
	    parseCommand(parser, key, item) {
	        parser.push('CF.COUNT');
	        parser.pushKey(key);
	        parser.push(item);
	    },
	    transformReply: undefined
	};
	
	return COUNT$1;
}

var DEL$2 = {};

var hasRequiredDEL$2;

function requireDEL$2 () {
	if (hasRequiredDEL$2) return DEL$2;
	hasRequiredDEL$2 = 1;
	Object.defineProperty(DEL$2, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	DEL$2.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes an item from a Cuckoo Filter if it exists
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter
	     * @param item - The item to remove from the filter
	     */
	    parseCommand(parser, key, item) {
	        parser.push('CF.DEL');
	        parser.pushKey(key);
	        parser.push(item);
	    },
	    transformReply: generic_transformers_1.transformBooleanReply
	};
	
	return DEL$2;
}

var EXISTS = {};

var hasRequiredEXISTS;

function requireEXISTS () {
	if (hasRequiredEXISTS) return EXISTS;
	hasRequiredEXISTS = 1;
	Object.defineProperty(EXISTS, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	EXISTS.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Checks if an item exists in a Cuckoo Filter
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter
	     * @param item - The item to check for existence
	     */
	    parseCommand(parser, key, item) {
	        parser.push('CF.EXISTS');
	        parser.pushKey(key);
	        parser.push(item);
	    },
	    transformReply: generic_transformers_1.transformBooleanReply
	};
	
	return EXISTS;
}

var INFO$4 = {};

var hasRequiredINFO$4;

function requireINFO$4 () {
	if (hasRequiredINFO$4) return INFO$4;
	hasRequiredINFO$4 = 1;
	Object.defineProperty(INFO$4, "__esModule", { value: true });
	const bloom_1 = requireBloom();
	INFO$4.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns detailed information about a Cuckoo Filter including size, buckets, filters count, items statistics and configuration
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter to get information about
	     */
	    parseCommand(parser, key) {
	        parser.push('CF.INFO');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        2: (reply, _, typeMapping) => {
	            return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
	        },
	        3: undefined
	    }
	};
	
	return INFO$4;
}

var INSERT = {};

var hasRequiredINSERT;

function requireINSERT () {
	if (hasRequiredINSERT) return INSERT;
	hasRequiredINSERT = 1;
	Object.defineProperty(INSERT, "__esModule", { value: true });
	INSERT.parseCfInsertArguments = void 0;
	const generic_transformers_1 = requireGenericTransformers();
	function parseCfInsertArguments(parser, key, items, options) {
	    parser.pushKey(key);
	    if (options?.CAPACITY !== undefined) {
	        parser.push('CAPACITY', options.CAPACITY.toString());
	    }
	    if (options?.NOCREATE) {
	        parser.push('NOCREATE');
	    }
	    parser.push('ITEMS');
	    parser.pushVariadic(items);
	}
	INSERT.parseCfInsertArguments = parseCfInsertArguments;
	INSERT.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds one or more items to a Cuckoo Filter, creating it if it does not exist
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter
	     * @param items - One or more items to add to the filter
	     * @param options - Optional parameters for filter creation
	     * @param options.CAPACITY - The number of entries intended to be added to the filter
	     * @param options.NOCREATE - If true, prevents automatic filter creation
	     */
	    parseCommand(...args) {
	        args[0].push('CF.INSERT');
	        parseCfInsertArguments(...args);
	    },
	    transformReply: generic_transformers_1.transformBooleanArrayReply
	};
	
	return INSERT;
}

var INSERTNX = {};

var hasRequiredINSERTNX;

function requireINSERTNX () {
	if (hasRequiredINSERTNX) return INSERTNX;
	hasRequiredINSERTNX = 1;
	var __createBinding = (INSERTNX && INSERTNX.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (INSERTNX && INSERTNX.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (INSERTNX && INSERTNX.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(INSERTNX, "__esModule", { value: true });
	const INSERT_1 = __importStar(requireINSERT());
	/**
	 * Adds one or more items to a Cuckoo Filter only if they do not exist yet, creating the filter if needed
	 * @param parser - The command parser
	 * @param key - The name of the Cuckoo filter
	 * @param items - One or more items to add to the filter
	 * @param options - Optional parameters for filter creation
	 * @param options.CAPACITY - The number of entries intended to be added to the filter
	 * @param options.NOCREATE - If true, prevents automatic filter creation
	 */
	INSERTNX.default = {
	    IS_READ_ONLY: INSERT_1.default.IS_READ_ONLY,
	    parseCommand(...args) {
	        args[0].push('CF.INSERTNX');
	        (0, INSERT_1.parseCfInsertArguments)(...args);
	    },
	    transformReply: INSERT_1.default.transformReply
	};
	
	return INSERTNX;
}

var LOADCHUNK = {};

var hasRequiredLOADCHUNK;

function requireLOADCHUNK () {
	if (hasRequiredLOADCHUNK) return LOADCHUNK;
	hasRequiredLOADCHUNK = 1;
	Object.defineProperty(LOADCHUNK, "__esModule", { value: true });
	LOADCHUNK.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Restores a Cuckoo Filter chunk previously saved using SCANDUMP
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter to restore
	     * @param iterator - Iterator value from the SCANDUMP command
	     * @param chunk - Data chunk from the SCANDUMP command
	     */
	    parseCommand(parser, key, iterator, chunk) {
	        parser.push('CF.LOADCHUNK');
	        parser.pushKey(key);
	        parser.push(iterator.toString(), chunk);
	    },
	    transformReply: undefined
	};
	
	return LOADCHUNK;
}

var RESERVE$1 = {};

var hasRequiredRESERVE$1;

function requireRESERVE$1 () {
	if (hasRequiredRESERVE$1) return RESERVE$1;
	hasRequiredRESERVE$1 = 1;
	Object.defineProperty(RESERVE$1, "__esModule", { value: true });
	RESERVE$1.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Creates an empty Cuckoo Filter with specified capacity and parameters
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter to create
	     * @param capacity - The number of entries intended to be added to the filter
	     * @param options - Optional parameters to tune the filter
	     * @param options.BUCKETSIZE - Number of items in each bucket
	     * @param options.MAXITERATIONS - Maximum number of iterations before declaring filter full
	     * @param options.EXPANSION - Number of additional buckets per expansion
	     */
	    parseCommand(parser, key, capacity, options) {
	        parser.push('CF.RESERVE');
	        parser.pushKey(key);
	        parser.push(capacity.toString());
	        if (options?.BUCKETSIZE !== undefined) {
	            parser.push('BUCKETSIZE', options.BUCKETSIZE.toString());
	        }
	        if (options?.MAXITERATIONS !== undefined) {
	            parser.push('MAXITERATIONS', options.MAXITERATIONS.toString());
	        }
	        if (options?.EXPANSION !== undefined) {
	            parser.push('EXPANSION', options.EXPANSION.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return RESERVE$1;
}

var SCANDUMP = {};

var hasRequiredSCANDUMP;

function requireSCANDUMP () {
	if (hasRequiredSCANDUMP) return SCANDUMP;
	hasRequiredSCANDUMP = 1;
	Object.defineProperty(SCANDUMP, "__esModule", { value: true });
	SCANDUMP.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Begins an incremental save of a Cuckoo Filter. This is useful for large filters that can't be saved at once
	     * @param parser - The command parser
	     * @param key - The name of the Cuckoo filter to save
	     * @param iterator - Iterator value; Start at 0, and use the iterator from the response for the next chunk
	     */
	    parseCommand(parser, key, iterator) {
	        parser.push('CF.SCANDUMP');
	        parser.pushKey(key);
	        parser.push(iterator.toString());
	    },
	    transformReply(reply) {
	        return {
	            iterator: reply[0],
	            chunk: reply[1]
	        };
	    }
	};
	
	return SCANDUMP;
}

var hasRequiredCuckoo;

function requireCuckoo () {
	if (hasRequiredCuckoo) return cuckoo;
	hasRequiredCuckoo = 1;
	var __importDefault = (cuckoo && cuckoo.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(cuckoo, "__esModule", { value: true });
	const ADD_1 = __importDefault(requireADD$3());
	const ADDNX_1 = __importDefault(requireADDNX());
	const COUNT_1 = __importDefault(requireCOUNT$1());
	const DEL_1 = __importDefault(requireDEL$2());
	const EXISTS_1 = __importDefault(requireEXISTS());
	const INFO_1 = __importDefault(requireINFO$4());
	const INSERT_1 = __importDefault(requireINSERT());
	const INSERTNX_1 = __importDefault(requireINSERTNX());
	const LOADCHUNK_1 = __importDefault(requireLOADCHUNK());
	const RESERVE_1 = __importDefault(requireRESERVE$1());
	const SCANDUMP_1 = __importDefault(requireSCANDUMP());
	cuckoo.default = {
	    ADD: ADD_1.default,
	    add: ADD_1.default,
	    ADDNX: ADDNX_1.default,
	    addNX: ADDNX_1.default,
	    COUNT: COUNT_1.default,
	    count: COUNT_1.default,
	    DEL: DEL_1.default,
	    del: DEL_1.default,
	    EXISTS: EXISTS_1.default,
	    exists: EXISTS_1.default,
	    INFO: INFO_1.default,
	    info: INFO_1.default,
	    INSERT: INSERT_1.default,
	    insert: INSERT_1.default,
	    INSERTNX: INSERTNX_1.default,
	    insertNX: INSERTNX_1.default,
	    LOADCHUNK: LOADCHUNK_1.default,
	    loadChunk: LOADCHUNK_1.default,
	    RESERVE: RESERVE_1.default,
	    reserve: RESERVE_1.default,
	    SCANDUMP: SCANDUMP_1.default,
	    scanDump: SCANDUMP_1.default
	};
	
	return cuckoo;
}

var tDigest = {};

var ADD$2 = {};

var hasRequiredADD$2;

function requireADD$2 () {
	if (hasRequiredADD$2) return ADD$2;
	hasRequiredADD$2 = 1;
	Object.defineProperty(ADD$2, "__esModule", { value: true });
	ADD$2.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds one or more observations to a t-digest sketch
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch
	     * @param values - Array of numeric values to add to the sketch
	     */
	    parseCommand(parser, key, values) {
	        parser.push('TDIGEST.ADD');
	        parser.pushKey(key);
	        for (const value of values) {
	            parser.push(value.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return ADD$2;
}

var BYRANK = {};

var hasRequiredBYRANK;

function requireBYRANK () {
	if (hasRequiredBYRANK) return BYRANK;
	hasRequiredBYRANK = 1;
	Object.defineProperty(BYRANK, "__esModule", { value: true });
	BYRANK.transformByRankArguments = void 0;
	const generic_transformers_1 = requireGenericTransformers();
	function transformByRankArguments(parser, key, ranks) {
	    parser.pushKey(key);
	    for (const rank of ranks) {
	        parser.push(rank.toString());
	    }
	}
	BYRANK.transformByRankArguments = transformByRankArguments;
	BYRANK.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns value estimates for one or more ranks in a t-digest sketch
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch
	     * @param ranks - Array of ranks to get value estimates for (ascending order)
	     */
	    parseCommand(...args) {
	        args[0].push('TDIGEST.BYRANK');
	        transformByRankArguments(...args);
	    },
	    transformReply: generic_transformers_1.transformDoubleArrayReply
	};
	
	return BYRANK;
}

var BYREVRANK = {};

var hasRequiredBYREVRANK;

function requireBYREVRANK () {
	if (hasRequiredBYREVRANK) return BYREVRANK;
	hasRequiredBYREVRANK = 1;
	var __createBinding = (BYREVRANK && BYREVRANK.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (BYREVRANK && BYREVRANK.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (BYREVRANK && BYREVRANK.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(BYREVRANK, "__esModule", { value: true });
	const BYRANK_1 = __importStar(requireBYRANK());
	/**
	 * Returns value estimates for one or more ranks in a t-digest sketch, starting from highest rank
	 * @param parser - The command parser
	 * @param key - The name of the t-digest sketch
	 * @param ranks - Array of ranks to get value estimates for (descending order)
	 */
	BYREVRANK.default = {
	    IS_READ_ONLY: BYRANK_1.default.IS_READ_ONLY,
	    parseCommand(...args) {
	        args[0].push('TDIGEST.BYREVRANK');
	        (0, BYRANK_1.transformByRankArguments)(...args);
	    },
	    transformReply: BYRANK_1.default.transformReply
	};
	
	return BYREVRANK;
}

var CDF = {};

var hasRequiredCDF;

function requireCDF () {
	if (hasRequiredCDF) return CDF;
	hasRequiredCDF = 1;
	Object.defineProperty(CDF, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	CDF.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Estimates the cumulative distribution function for values in a t-digest sketch
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch
	     * @param values - Array of values to get CDF estimates for
	     */
	    parseCommand(parser, key, values) {
	        parser.push('TDIGEST.CDF');
	        parser.pushKey(key);
	        for (const item of values) {
	            parser.push(item.toString());
	        }
	    },
	    transformReply: generic_transformers_1.transformDoubleArrayReply
	};
	
	return CDF;
}

var CREATE$2 = {};

var hasRequiredCREATE$2;

function requireCREATE$2 () {
	if (hasRequiredCREATE$2) return CREATE$2;
	hasRequiredCREATE$2 = 1;
	Object.defineProperty(CREATE$2, "__esModule", { value: true });
	CREATE$2.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Creates a new t-digest sketch for storing distributions
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch
	     * @param options - Optional parameters for sketch creation
	     * @param options.COMPRESSION - Compression parameter that affects performance and accuracy
	     */
	    parseCommand(parser, key, options) {
	        parser.push('TDIGEST.CREATE');
	        parser.pushKey(key);
	        if (options?.COMPRESSION !== undefined) {
	            parser.push('COMPRESSION', options.COMPRESSION.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return CREATE$2;
}

var INFO$3 = {};

var hasRequiredINFO$3;

function requireINFO$3 () {
	if (hasRequiredINFO$3) return INFO$3;
	hasRequiredINFO$3 = 1;
	Object.defineProperty(INFO$3, "__esModule", { value: true });
	const bloom_1 = requireBloom();
	INFO$3.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns information about a t-digest sketch including compression, capacity, nodes, weights, observations and memory usage
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch to get information about
	     */
	    parseCommand(parser, key) {
	        parser.push('TDIGEST.INFO');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        2: (reply, _, typeMapping) => {
	            return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
	        },
	        3: undefined
	    }
	};
	
	return INFO$3;
}

var MAX = {};

var hasRequiredMAX;

function requireMAX () {
	if (hasRequiredMAX) return MAX;
	hasRequiredMAX = 1;
	Object.defineProperty(MAX, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	MAX.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the maximum value from a t-digest sketch
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch
	     */
	    parseCommand(parser, key) {
	        parser.push('TDIGEST.MAX');
	        parser.pushKey(key);
	    },
	    transformReply: generic_transformers_1.transformDoubleReply
	};
	
	return MAX;
}

var MERGE$1 = {};

var hasRequiredMERGE$1;

function requireMERGE$1 () {
	if (hasRequiredMERGE$1) return MERGE$1;
	hasRequiredMERGE$1 = 1;
	Object.defineProperty(MERGE$1, "__esModule", { value: true });
	MERGE$1.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Merges multiple t-digest sketches into one, with optional compression and override settings
	     * @param parser - The command parser
	     * @param destination - The name of the destination t-digest sketch
	     * @param source - One or more source sketch names to merge from
	     * @param options - Optional parameters for merge operation
	     * @param options.COMPRESSION - New compression value for merged sketch
	     * @param options.OVERRIDE - If true, override destination sketch if it exists
	     */
	    parseCommand(parser, destination, source, options) {
	        parser.push('TDIGEST.MERGE');
	        parser.pushKey(destination);
	        parser.pushKeysLength(source);
	        if (options?.COMPRESSION !== undefined) {
	            parser.push('COMPRESSION', options.COMPRESSION.toString());
	        }
	        if (options?.OVERRIDE) {
	            parser.push('OVERRIDE');
	        }
	    },
	    transformReply: undefined
	};
	
	return MERGE$1;
}

var MIN = {};

var hasRequiredMIN;

function requireMIN () {
	if (hasRequiredMIN) return MIN;
	hasRequiredMIN = 1;
	Object.defineProperty(MIN, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	MIN.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the minimum value from a t-digest sketch
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch
	     */
	    parseCommand(parser, key) {
	        parser.push('TDIGEST.MIN');
	        parser.pushKey(key);
	    },
	    transformReply: generic_transformers_1.transformDoubleReply
	};
	
	return MIN;
}

var QUANTILE = {};

var hasRequiredQUANTILE;

function requireQUANTILE () {
	if (hasRequiredQUANTILE) return QUANTILE;
	hasRequiredQUANTILE = 1;
	Object.defineProperty(QUANTILE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	QUANTILE.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns value estimates at requested quantiles from a t-digest sketch
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch
	     * @param quantiles - Array of quantiles (between 0 and 1) to get value estimates for
	     */
	    parseCommand(parser, key, quantiles) {
	        parser.push('TDIGEST.QUANTILE');
	        parser.pushKey(key);
	        for (const quantile of quantiles) {
	            parser.push(quantile.toString());
	        }
	    },
	    transformReply: generic_transformers_1.transformDoubleArrayReply
	};
	
	return QUANTILE;
}

var RANK = {};

var hasRequiredRANK;

function requireRANK () {
	if (hasRequiredRANK) return RANK;
	hasRequiredRANK = 1;
	Object.defineProperty(RANK, "__esModule", { value: true });
	RANK.transformRankArguments = void 0;
	function transformRankArguments(parser, key, values) {
	    parser.pushKey(key);
	    for (const value of values) {
	        parser.push(value.toString());
	    }
	}
	RANK.transformRankArguments = transformRankArguments;
	RANK.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the rank of one or more values in a t-digest sketch (number of values that are lower than each value)
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch
	     * @param values - Array of values to get ranks for
	     */
	    parseCommand(...args) {
	        args[0].push('TDIGEST.RANK');
	        transformRankArguments(...args);
	    },
	    transformReply: undefined
	};
	
	return RANK;
}

var RESET = {};

var hasRequiredRESET;

function requireRESET () {
	if (hasRequiredRESET) return RESET;
	hasRequiredRESET = 1;
	Object.defineProperty(RESET, "__esModule", { value: true });
	RESET.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Resets a t-digest sketch, clearing all previously added observations
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch to reset
	     */
	    parseCommand(parser, key) {
	        parser.push('TDIGEST.RESET');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return RESET;
}

var REVRANK = {};

var hasRequiredREVRANK;

function requireREVRANK () {
	if (hasRequiredREVRANK) return REVRANK;
	hasRequiredREVRANK = 1;
	var __createBinding = (REVRANK && REVRANK.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (REVRANK && REVRANK.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (REVRANK && REVRANK.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(REVRANK, "__esModule", { value: true });
	const RANK_1 = __importStar(requireRANK());
	/**
	 * Returns the reverse rank of one or more values in a t-digest sketch (number of values that are higher than each value)
	 * @param parser - The command parser
	 * @param key - The name of the t-digest sketch
	 * @param values - Array of values to get reverse ranks for
	 */
	REVRANK.default = {
	    IS_READ_ONLY: RANK_1.default.IS_READ_ONLY,
	    parseCommand(...args) {
	        args[0].push('TDIGEST.REVRANK');
	        (0, RANK_1.transformRankArguments)(...args);
	    },
	    transformReply: RANK_1.default.transformReply
	};
	
	return REVRANK;
}

var TRIMMED_MEAN = {};

var hasRequiredTRIMMED_MEAN;

function requireTRIMMED_MEAN () {
	if (hasRequiredTRIMMED_MEAN) return TRIMMED_MEAN;
	hasRequiredTRIMMED_MEAN = 1;
	Object.defineProperty(TRIMMED_MEAN, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	TRIMMED_MEAN.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the mean value from a t-digest sketch after trimming values at specified percentiles
	     * @param parser - The command parser
	     * @param key - The name of the t-digest sketch
	     * @param lowCutPercentile - Lower percentile cutoff (between 0 and 100)
	     * @param highCutPercentile - Higher percentile cutoff (between 0 and 100)
	     */
	    parseCommand(parser, key, lowCutPercentile, highCutPercentile) {
	        parser.push('TDIGEST.TRIMMED_MEAN');
	        parser.pushKey(key);
	        parser.push(lowCutPercentile.toString(), highCutPercentile.toString());
	    },
	    transformReply: generic_transformers_1.transformDoubleReply
	};
	
	return TRIMMED_MEAN;
}

var hasRequiredTDigest;

function requireTDigest () {
	if (hasRequiredTDigest) return tDigest;
	hasRequiredTDigest = 1;
	var __importDefault = (tDigest && tDigest.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(tDigest, "__esModule", { value: true });
	const ADD_1 = __importDefault(requireADD$2());
	const BYRANK_1 = __importDefault(requireBYRANK());
	const BYREVRANK_1 = __importDefault(requireBYREVRANK());
	const CDF_1 = __importDefault(requireCDF());
	const CREATE_1 = __importDefault(requireCREATE$2());
	const INFO_1 = __importDefault(requireINFO$3());
	const MAX_1 = __importDefault(requireMAX());
	const MERGE_1 = __importDefault(requireMERGE$1());
	const MIN_1 = __importDefault(requireMIN());
	const QUANTILE_1 = __importDefault(requireQUANTILE());
	const RANK_1 = __importDefault(requireRANK());
	const RESET_1 = __importDefault(requireRESET());
	const REVRANK_1 = __importDefault(requireREVRANK());
	const TRIMMED_MEAN_1 = __importDefault(requireTRIMMED_MEAN());
	tDigest.default = {
	    ADD: ADD_1.default,
	    add: ADD_1.default,
	    BYRANK: BYRANK_1.default,
	    byRank: BYRANK_1.default,
	    BYREVRANK: BYREVRANK_1.default,
	    byRevRank: BYREVRANK_1.default,
	    CDF: CDF_1.default,
	    cdf: CDF_1.default,
	    CREATE: CREATE_1.default,
	    create: CREATE_1.default,
	    INFO: INFO_1.default,
	    info: INFO_1.default,
	    MAX: MAX_1.default,
	    max: MAX_1.default,
	    MERGE: MERGE_1.default,
	    merge: MERGE_1.default,
	    MIN: MIN_1.default,
	    min: MIN_1.default,
	    QUANTILE: QUANTILE_1.default,
	    quantile: QUANTILE_1.default,
	    RANK: RANK_1.default,
	    rank: RANK_1.default,
	    RESET: RESET_1.default,
	    reset: RESET_1.default,
	    REVRANK: REVRANK_1.default,
	    revRank: REVRANK_1.default,
	    TRIMMED_MEAN: TRIMMED_MEAN_1.default,
	    trimmedMean: TRIMMED_MEAN_1.default
	};
	
	return tDigest;
}

var topK = {};

var ADD$1 = {};

var hasRequiredADD$1;

function requireADD$1 () {
	if (hasRequiredADD$1) return ADD$1;
	hasRequiredADD$1 = 1;
	Object.defineProperty(ADD$1, "__esModule", { value: true });
	ADD$1.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds one or more items to a Top-K filter and returns items dropped from the top-K list
	     * @param parser - The command parser
	     * @param key - The name of the Top-K filter
	     * @param items - One or more items to add to the filter
	     */
	    parseCommand(parser, key, items) {
	        parser.push('TOPK.ADD');
	        parser.pushKey(key);
	        parser.pushVariadic(items);
	    },
	    transformReply: undefined
	};
	
	return ADD$1;
}

var COUNT = {};

var hasRequiredCOUNT;

function requireCOUNT () {
	if (hasRequiredCOUNT) return COUNT;
	hasRequiredCOUNT = 1;
	Object.defineProperty(COUNT, "__esModule", { value: true });
	COUNT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the count of occurrences for one or more items in a Top-K filter
	     * @param parser - The command parser
	     * @param key - The name of the Top-K filter
	     * @param items - One or more items to get counts for
	     */
	    parseCommand(parser, key, items) {
	        parser.push('TOPK.COUNT');
	        parser.pushKey(key);
	        parser.pushVariadic(items);
	    },
	    transformReply: undefined
	};
	
	return COUNT;
}

var INCRBY$1 = {};

var hasRequiredINCRBY$1;

function requireINCRBY$1 () {
	if (hasRequiredINCRBY$1) return INCRBY$1;
	hasRequiredINCRBY$1 = 1;
	Object.defineProperty(INCRBY$1, "__esModule", { value: true });
	function pushIncrByItem(parser, { item, incrementBy }) {
	    parser.push(item, incrementBy.toString());
	}
	INCRBY$1.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Increases the score of one or more items in a Top-K filter by specified increments
	     * @param parser - The command parser
	     * @param key - The name of the Top-K filter
	     * @param items - A single item or array of items to increment, each with an item name and increment value
	     */
	    parseCommand(parser, key, items) {
	        parser.push('TOPK.INCRBY');
	        parser.pushKey(key);
	        if (Array.isArray(items)) {
	            for (const item of items) {
	                pushIncrByItem(parser, item);
	            }
	        }
	        else {
	            pushIncrByItem(parser, items);
	        }
	    },
	    transformReply: undefined
	};
	
	return INCRBY$1;
}

var INFO$2 = {};

var hasRequiredINFO$2;

function requireINFO$2 () {
	if (hasRequiredINFO$2) return INFO$2;
	hasRequiredINFO$2 = 1;
	Object.defineProperty(INFO$2, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const bloom_1 = requireBloom();
	INFO$2.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns configuration and statistics of a Top-K filter, including k, width, depth, and decay parameters
	     * @param parser - The command parser
	     * @param key - The name of the Top-K filter to get information about
	     */
	    parseCommand(parser, key) {
	        parser.push('TOPK.INFO');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        2: (reply, preserve, typeMapping) => {
	            reply[7] = generic_transformers_1.transformDoubleReply[2](reply[7], preserve, typeMapping);
	            return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
	        },
	        3: undefined
	    }
	};
	
	return INFO$2;
}

var LIST_WITHCOUNT = {};

var hasRequiredLIST_WITHCOUNT;

function requireLIST_WITHCOUNT () {
	if (hasRequiredLIST_WITHCOUNT) return LIST_WITHCOUNT;
	hasRequiredLIST_WITHCOUNT = 1;
	Object.defineProperty(LIST_WITHCOUNT, "__esModule", { value: true });
	LIST_WITHCOUNT.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns all items in a Top-K filter with their respective counts
	     * @param parser - The command parser
	     * @param key - The name of the Top-K filter
	     */
	    parseCommand(parser, key) {
	        parser.push('TOPK.LIST');
	        parser.pushKey(key);
	        parser.push('WITHCOUNT');
	    },
	    transformReply(rawReply) {
	        const reply = [];
	        for (let i = 0; i < rawReply.length; i++) {
	            reply.push({
	                item: rawReply[i],
	                count: rawReply[++i]
	            });
	        }
	        return reply;
	    }
	};
	
	return LIST_WITHCOUNT;
}

var LIST = {};

var hasRequiredLIST;

function requireLIST () {
	if (hasRequiredLIST) return LIST;
	hasRequiredLIST = 1;
	Object.defineProperty(LIST, "__esModule", { value: true });
	LIST.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns all items in a Top-K filter
	     * @param parser - The command parser
	     * @param key - The name of the Top-K filter
	     */
	    parseCommand(parser, key) {
	        parser.push('TOPK.LIST');
	        parser.pushKey(key);
	    },
	    transformReply: undefined
	};
	
	return LIST;
}

var QUERY = {};

var hasRequiredQUERY;

function requireQUERY () {
	if (hasRequiredQUERY) return QUERY;
	hasRequiredQUERY = 1;
	Object.defineProperty(QUERY, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	QUERY.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Checks if one or more items are in the Top-K list
	     * @param parser - The command parser
	     * @param key - The name of the Top-K filter
	     * @param items - One or more items to check in the filter
	     */
	    parseCommand(parser, key, items) {
	        parser.push('TOPK.QUERY');
	        parser.pushKey(key);
	        parser.pushVariadic(items);
	    },
	    transformReply: generic_transformers_1.transformBooleanArrayReply
	};
	
	return QUERY;
}

var RESERVE = {};

var hasRequiredRESERVE;

function requireRESERVE () {
	if (hasRequiredRESERVE) return RESERVE;
	hasRequiredRESERVE = 1;
	Object.defineProperty(RESERVE, "__esModule", { value: true });
	RESERVE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Creates a new Top-K filter with specified parameters
	     * @param parser - The command parser
	     * @param key - The name of the Top-K filter
	     * @param topK - Number of top occurring items to keep
	     * @param options - Optional parameters for filter configuration
	     * @param options.width - Number of counters in each array
	     * @param options.depth - Number of counter-arrays
	     * @param options.decay - Counter decay factor
	     */
	    parseCommand(parser, key, topK, options) {
	        parser.push('TOPK.RESERVE');
	        parser.pushKey(key);
	        parser.push(topK.toString());
	        if (options) {
	            parser.push(options.width.toString(), options.depth.toString(), options.decay.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return RESERVE;
}

var hasRequiredTopK;

function requireTopK () {
	if (hasRequiredTopK) return topK;
	hasRequiredTopK = 1;
	var __importDefault = (topK && topK.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(topK, "__esModule", { value: true });
	const ADD_1 = __importDefault(requireADD$1());
	const COUNT_1 = __importDefault(requireCOUNT());
	const INCRBY_1 = __importDefault(requireINCRBY$1());
	const INFO_1 = __importDefault(requireINFO$2());
	const LIST_WITHCOUNT_1 = __importDefault(requireLIST_WITHCOUNT());
	const LIST_1 = __importDefault(requireLIST());
	const QUERY_1 = __importDefault(requireQUERY());
	const RESERVE_1 = __importDefault(requireRESERVE());
	topK.default = {
	    ADD: ADD_1.default,
	    add: ADD_1.default,
	    COUNT: COUNT_1.default,
	    count: COUNT_1.default,
	    INCRBY: INCRBY_1.default,
	    incrBy: INCRBY_1.default,
	    INFO: INFO_1.default,
	    info: INFO_1.default,
	    LIST_WITHCOUNT: LIST_WITHCOUNT_1.default,
	    listWithCount: LIST_WITHCOUNT_1.default,
	    LIST: LIST_1.default,
	    list: LIST_1.default,
	    QUERY: QUERY_1.default,
	    query: QUERY_1.default,
	    RESERVE: RESERVE_1.default,
	    reserve: RESERVE_1.default
	};
	
	return topK;
}

var hasRequiredCommands$3;

function requireCommands$3 () {
	if (hasRequiredCommands$3) return commands$3;
	hasRequiredCommands$3 = 1;
	var __importDefault = (commands$3 && commands$3.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(commands$3, "__esModule", { value: true });
	const bloom_1 = __importDefault(requireBloom());
	const count_min_sketch_1 = __importDefault(requireCountMinSketch());
	const cuckoo_1 = __importDefault(requireCuckoo());
	const t_digest_1 = __importDefault(requireTDigest());
	const top_k_1 = __importDefault(requireTopK());
	commands$3.default = {
	    bf: bloom_1.default,
	    cms: count_min_sketch_1.default,
	    cf: cuckoo_1.default,
	    tDigest: t_digest_1.default,
	    topK: top_k_1.default
	};
	
	return commands$3;
}

var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$3;
	hasRequiredLib$3 = 1;
	(function (exports) {
		var __importDefault = (lib$3 && lib$3.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = void 0;
		var commands_1 = requireCommands$3();
		Object.defineProperty(exports, "default", { enumerable: true, get: function () { return __importDefault(commands_1).default; } });
		
	} (lib$3));
	return lib$3;
}

var lib$2 = {};

var commands$2 = {};

var ARRAPPEND = {};

var hasRequiredARRAPPEND;

function requireARRAPPEND () {
	if (hasRequiredARRAPPEND) return ARRAPPEND;
	hasRequiredARRAPPEND = 1;
	Object.defineProperty(ARRAPPEND, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ARRAPPEND.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Appends one or more values to the end of an array in a JSON document.
	     * Returns the new array length after append, or null if the path does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key to append to
	     * @param path - Path to the array in the JSON document
	     * @param json - The first value to append
	     * @param jsons - Additional values to append
	     */
	    parseCommand(parser, key, path, json, ...jsons) {
	        parser.push('JSON.ARRAPPEND');
	        parser.pushKey(key);
	        parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(json));
	        for (let i = 0; i < jsons.length; i++) {
	            parser.push((0, generic_transformers_1.transformRedisJsonArgument)(jsons[i]));
	        }
	    },
	    transformReply: undefined
	};
	
	return ARRAPPEND;
}

var ARRINDEX = {};

var hasRequiredARRINDEX;

function requireARRINDEX () {
	if (hasRequiredARRINDEX) return ARRINDEX;
	hasRequiredARRINDEX = 1;
	Object.defineProperty(ARRINDEX, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ARRINDEX.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the index of the first occurrence of a value in a JSON array.
	     * If the specified value is not found, it returns -1, or null if the path does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the array
	     * @param path - Path to the array in the JSON document
	     * @param json - The value to search for
	     * @param options - Optional range parameters for the search
	     * @param options.range.start - Starting index for the search
	     * @param options.range.stop - Optional ending index for the search
	     */
	    parseCommand(parser, key, path, json, options) {
	        parser.push('JSON.ARRINDEX');
	        parser.pushKey(key);
	        parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(json));
	        if (options?.range) {
	            parser.push(options.range.start.toString());
	            if (options.range.stop !== undefined) {
	                parser.push(options.range.stop.toString());
	            }
	        }
	    },
	    transformReply: undefined
	};
	
	return ARRINDEX;
}

var ARRINSERT = {};

var hasRequiredARRINSERT;

function requireARRINSERT () {
	if (hasRequiredARRINSERT) return ARRINSERT;
	hasRequiredARRINSERT = 1;
	Object.defineProperty(ARRINSERT, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ARRINSERT.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Inserts one or more values into an array at the specified index.
	     * Returns the new array length after insert, or null if the path does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the array
	     * @param path - Path to the array in the JSON document
	     * @param index - The position where to insert the values
	     * @param json - The first value to insert
	     * @param jsons - Additional values to insert
	     */
	    parseCommand(parser, key, path, index, json, ...jsons) {
	        parser.push('JSON.ARRINSERT');
	        parser.pushKey(key);
	        parser.push(path, index.toString(), (0, generic_transformers_1.transformRedisJsonArgument)(json));
	        for (let i = 0; i < jsons.length; i++) {
	            parser.push((0, generic_transformers_1.transformRedisJsonArgument)(jsons[i]));
	        }
	    },
	    transformReply: undefined
	};
	
	return ARRINSERT;
}

var ARRLEN = {};

var hasRequiredARRLEN;

function requireARRLEN () {
	if (hasRequiredARRLEN) return ARRLEN;
	hasRequiredARRLEN = 1;
	Object.defineProperty(ARRLEN, "__esModule", { value: true });
	ARRLEN.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the length of an array in a JSON document.
	     * Returns null if the path does not exist or the value is not an array.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the array
	     * @param options - Optional parameters
	     * @param options.path - Path to the array in the JSON document
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.ARRLEN');
	        parser.pushKey(key);
	        if (options?.path !== undefined) {
	            parser.push(options.path);
	        }
	    },
	    transformReply: undefined
	};
	
	return ARRLEN;
}

var ARRPOP = {};

var hasRequiredARRPOP;

function requireARRPOP () {
	if (hasRequiredARRPOP) return ARRPOP;
	hasRequiredARRPOP = 1;
	Object.defineProperty(ARRPOP, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	ARRPOP.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Removes and returns an element from an array in a JSON document.
	     * Returns null if the path does not exist or the value is not an array.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the array
	     * @param options - Optional parameters
	     * @param options.path - Path to the array in the JSON document
	     * @param options.index - Optional index to pop from. Default is -1 (last element)
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.ARRPOP');
	        parser.pushKey(key);
	        if (options) {
	            parser.push(options.path);
	            if (options.index !== undefined) {
	                parser.push(options.index.toString());
	            }
	        }
	    },
	    transformReply(reply) {
	        return (0, generic_transformers_1.isArrayReply)(reply) ?
	            reply.map(item => (0, generic_transformers_1.transformRedisJsonNullReply)(item)) :
	            (0, generic_transformers_1.transformRedisJsonNullReply)(reply);
	    }
	};
	
	return ARRPOP;
}

var ARRTRIM = {};

var hasRequiredARRTRIM;

function requireARRTRIM () {
	if (hasRequiredARRTRIM) return ARRTRIM;
	hasRequiredARRTRIM = 1;
	Object.defineProperty(ARRTRIM, "__esModule", { value: true });
	ARRTRIM.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Trims an array in a JSON document to include only elements within the specified range.
	     * Returns the new array length after trimming, or null if the path does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the array
	     * @param path - Path to the array in the JSON document
	     * @param start - Starting index (inclusive)
	     * @param stop - Ending index (inclusive)
	     */
	    parseCommand(parser, key, path, start, stop) {
	        parser.push('JSON.ARRTRIM');
	        parser.pushKey(key);
	        parser.push(path, start.toString(), stop.toString());
	    },
	    transformReply: undefined
	};
	
	return ARRTRIM;
}

var CLEAR = {};

var hasRequiredCLEAR;

function requireCLEAR () {
	if (hasRequiredCLEAR) return CLEAR;
	hasRequiredCLEAR = 1;
	Object.defineProperty(CLEAR, "__esModule", { value: true });
	CLEAR.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Clears container values (arrays/objects) in a JSON document.
	     * Returns the number of values cleared (0 or 1), or null if the path does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param options - Optional parameters
	     * @param options.path - Path to the container to clear
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.CLEAR');
	        parser.pushKey(key);
	        if (options?.path !== undefined) {
	            parser.push(options.path);
	        }
	    },
	    transformReply: undefined
	};
	
	return CLEAR;
}

var DEBUG_MEMORY = {};

var hasRequiredDEBUG_MEMORY;

function requireDEBUG_MEMORY () {
	if (hasRequiredDEBUG_MEMORY) return DEBUG_MEMORY;
	hasRequiredDEBUG_MEMORY = 1;
	Object.defineProperty(DEBUG_MEMORY, "__esModule", { value: true });
	DEBUG_MEMORY.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Reports memory usage details for a JSON document value.
	     * Returns size in bytes of the value, or null if the key or path does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param options - Optional parameters
	     * @param options.path - Path to the value to examine
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.DEBUG', 'MEMORY');
	        parser.pushKey(key);
	        if (options?.path !== undefined) {
	            parser.push(options.path);
	        }
	    },
	    transformReply: undefined
	};
	
	return DEBUG_MEMORY;
}

var DEL$1 = {};

var hasRequiredDEL$1;

function requireDEL$1 () {
	if (hasRequiredDEL$1) return DEL$1;
	hasRequiredDEL$1 = 1;
	Object.defineProperty(DEL$1, "__esModule", { value: true });
	DEL$1.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Deletes a value from a JSON document.
	     * Returns the number of paths deleted (0 or 1), or null if the key does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param options - Optional parameters
	     * @param options.path - Path to the value to delete
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.DEL');
	        parser.pushKey(key);
	        if (options?.path !== undefined) {
	            parser.push(options.path);
	        }
	    },
	    transformReply: undefined
	};
	
	return DEL$1;
}

var FORGET = {};

var hasRequiredFORGET;

function requireFORGET () {
	if (hasRequiredFORGET) return FORGET;
	hasRequiredFORGET = 1;
	Object.defineProperty(FORGET, "__esModule", { value: true });
	FORGET.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Alias for JSON.DEL - Deletes a value from a JSON document.
	     * Returns the number of paths deleted (0 or 1), or null if the key does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param options - Optional parameters
	     * @param options.path - Path to the value to delete
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.FORGET');
	        parser.pushKey(key);
	        if (options?.path !== undefined) {
	            parser.push(options.path);
	        }
	    },
	    transformReply: undefined
	};
	
	return FORGET;
}

var GET$1 = {};

var hasRequiredGET$1;

function requireGET$1 () {
	if (hasRequiredGET$1) return GET$1;
	hasRequiredGET$1 = 1;
	Object.defineProperty(GET$1, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	GET$1.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Gets values from a JSON document.
	     * Returns the value at the specified path, or null if the key or path does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param options - Optional parameters
	     * @param options.path - Path(s) to the value(s) to retrieve
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.GET');
	        parser.pushKey(key);
	        if (options?.path !== undefined) {
	            parser.pushVariadic(options.path);
	        }
	    },
	    transformReply: generic_transformers_1.transformRedisJsonNullReply
	};
	
	return GET$1;
}

var MERGE = {};

var hasRequiredMERGE;

function requireMERGE () {
	if (hasRequiredMERGE) return MERGE;
	hasRequiredMERGE = 1;
	Object.defineProperty(MERGE, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	MERGE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Merges a given JSON value into a JSON document.
	     * Returns OK on success, or null if the key does not exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param path - Path to merge into
	     * @param value - JSON value to merge
	     */
	    parseCommand(parser, key, path, value) {
	        parser.push('JSON.MERGE');
	        parser.pushKey(key);
	        parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(value));
	    },
	    transformReply: undefined
	};
	
	return MERGE;
}

var MGET$1 = {};

var hasRequiredMGET$1;

function requireMGET$1 () {
	if (hasRequiredMGET$1) return MGET$1;
	hasRequiredMGET$1 = 1;
	Object.defineProperty(MGET$1, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	MGET$1.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets values at a specific path from multiple JSON documents.
	     * Returns an array of values at the path from each key, null for missing keys/paths.
	     *
	     * @param parser - The Redis command parser
	     * @param keys - Array of keys containing JSON documents
	     * @param path - Path to retrieve from each document
	     */
	    parseCommand(parser, keys, path) {
	        parser.push('JSON.MGET');
	        parser.pushKeys(keys);
	        parser.push(path);
	    },
	    transformReply(reply) {
	        return reply.map(json => (0, generic_transformers_1.transformRedisJsonNullReply)(json));
	    }
	};
	
	return MGET$1;
}

var MSET = {};

var hasRequiredMSET;

function requireMSET () {
	if (hasRequiredMSET) return MSET;
	hasRequiredMSET = 1;
	Object.defineProperty(MSET, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	MSET.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Sets multiple JSON values in multiple documents.
	     * Returns OK on success.
	     *
	     * @param parser - The Redis command parser
	     * @param items - Array of objects containing key, path, and value to set
	     * @param items[].key - The key containing the JSON document
	     * @param items[].path - Path in the document to set
	     * @param items[].value - JSON value to set at the path
	     */
	    parseCommand(parser, items) {
	        parser.push('JSON.MSET');
	        for (let i = 0; i < items.length; i++) {
	            parser.pushKey(items[i].key);
	            parser.push(items[i].path, (0, generic_transformers_1.transformRedisJsonArgument)(items[i].value));
	        }
	    },
	    transformReply: undefined
	};
	
	return MSET;
}

var NUMINCRBY = {};

var hasRequiredNUMINCRBY;

function requireNUMINCRBY () {
	if (hasRequiredNUMINCRBY) return NUMINCRBY;
	hasRequiredNUMINCRBY = 1;
	Object.defineProperty(NUMINCRBY, "__esModule", { value: true });
	NUMINCRBY.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Increments a numeric value stored in a JSON document by a given number.
	     * Returns the value after increment, or null if the key/path doesn't exist or value is not numeric.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param path - Path to the numeric value
	     * @param by - Amount to increment by
	     */
	    parseCommand(parser, key, path, by) {
	        parser.push('JSON.NUMINCRBY');
	        parser.pushKey(key);
	        parser.push(path, by.toString());
	    },
	    transformReply: {
	        2: (reply) => {
	            return JSON.parse(reply.toString());
	        },
	        3: undefined
	    }
	};
	
	return NUMINCRBY;
}

var NUMMULTBY = {};

var hasRequiredNUMMULTBY;

function requireNUMMULTBY () {
	if (hasRequiredNUMMULTBY) return NUMMULTBY;
	hasRequiredNUMMULTBY = 1;
	var __importDefault = (NUMMULTBY && NUMMULTBY.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(NUMMULTBY, "__esModule", { value: true });
	const NUMINCRBY_1 = __importDefault(requireNUMINCRBY());
	NUMMULTBY.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Multiplies a numeric value stored in a JSON document by a given number.
	     * Returns the value after multiplication, or null if the key/path doesn't exist or value is not numeric.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param path - Path to the numeric value
	     * @param by - Amount to multiply by
	     */
	    parseCommand(parser, key, path, by) {
	        parser.push('JSON.NUMMULTBY');
	        parser.pushKey(key);
	        parser.push(path, by.toString());
	    },
	    transformReply: NUMINCRBY_1.default.transformReply
	};
	
	return NUMMULTBY;
}

var OBJKEYS = {};

var hasRequiredOBJKEYS;

function requireOBJKEYS () {
	if (hasRequiredOBJKEYS) return OBJKEYS;
	hasRequiredOBJKEYS = 1;
	Object.defineProperty(OBJKEYS, "__esModule", { value: true });
	OBJKEYS.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Returns the keys in the object stored in a JSON document.
	     * Returns array of keys, array of arrays for multiple paths, or null if path doesn't exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param options - Optional parameters
	     * @param options.path - Path to the object to examine
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.OBJKEYS');
	        parser.pushKey(key);
	        if (options?.path !== undefined) {
	            parser.push(options.path);
	        }
	    },
	    transformReply: undefined
	};
	
	return OBJKEYS;
}

var OBJLEN = {};

var hasRequiredOBJLEN;

function requireOBJLEN () {
	if (hasRequiredOBJLEN) return OBJLEN;
	hasRequiredOBJLEN = 1;
	Object.defineProperty(OBJLEN, "__esModule", { value: true });
	OBJLEN.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the number of keys in the object stored in a JSON document.
	     * Returns length of object, array of lengths for multiple paths, or null if path doesn't exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param options - Optional parameters
	     * @param options.path - Path to the object to examine
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.OBJLEN');
	        parser.pushKey(key);
	        if (options?.path !== undefined) {
	            parser.push(options.path);
	        }
	    },
	    transformReply: undefined
	};
	
	return OBJLEN;
}

var SET = {};

var hasRequiredSET;

function requireSET () {
	if (hasRequiredSET) return SET;
	hasRequiredSET = 1;
	Object.defineProperty(SET, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	SET.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Sets a JSON value at a specific path in a JSON document.
	     * Returns OK on success, or null if condition (NX/XX) is not met.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param path - Path in the document to set
	     * @param json - JSON value to set at the path
	     * @param options - Optional parameters
	     * @param options.condition - Set condition: NX (only if doesn't exist) or XX (only if exists)
	     * @deprecated options.NX - Use options.condition instead
	     * @deprecated options.XX - Use options.condition instead
	     */
	    parseCommand(parser, key, path, json, options) {
	        parser.push('JSON.SET');
	        parser.pushKey(key);
	        parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(json));
	        if (options?.condition) {
	            parser.push(options?.condition);
	        }
	        else if (options?.NX) {
	            parser.push('NX');
	        }
	        else if (options?.XX) {
	            parser.push('XX');
	        }
	    },
	    transformReply: undefined
	};
	
	return SET;
}

var STRAPPEND = {};

var hasRequiredSTRAPPEND;

function requireSTRAPPEND () {
	if (hasRequiredSTRAPPEND) return STRAPPEND;
	hasRequiredSTRAPPEND = 1;
	Object.defineProperty(STRAPPEND, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	STRAPPEND.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Appends a string to a string value stored in a JSON document.
	     * Returns new string length after append, or null if the path doesn't exist or value is not a string.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param append - String to append
	     * @param options - Optional parameters
	     * @param options.path - Path to the string value
	     */
	    parseCommand(parser, key, append, options) {
	        parser.push('JSON.STRAPPEND');
	        parser.pushKey(key);
	        if (options?.path !== undefined) {
	            parser.push(options.path);
	        }
	        parser.push((0, generic_transformers_1.transformRedisJsonArgument)(append));
	    },
	    transformReply: undefined
	};
	
	return STRAPPEND;
}

var STRLEN = {};

var hasRequiredSTRLEN;

function requireSTRLEN () {
	if (hasRequiredSTRLEN) return STRLEN;
	hasRequiredSTRLEN = 1;
	Object.defineProperty(STRLEN, "__esModule", { value: true });
	STRLEN.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the length of a string value stored in a JSON document.
	     * Returns string length, array of lengths for multiple paths, or null if path doesn't exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param options - Optional parameters
	     * @param options.path - Path to the string value
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.STRLEN');
	        parser.pushKey(key);
	        if (options?.path) {
	            parser.push(options.path);
	        }
	    },
	    transformReply: undefined
	};
	
	return STRLEN;
}

var TOGGLE = {};

var hasRequiredTOGGLE;

function requireTOGGLE () {
	if (hasRequiredTOGGLE) return TOGGLE;
	hasRequiredTOGGLE = 1;
	Object.defineProperty(TOGGLE, "__esModule", { value: true });
	TOGGLE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Toggles a boolean value stored in a JSON document.
	     * Returns 1 if value was toggled to true, 0 if toggled to false, or null if path doesn't exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param path - Path to the boolean value
	     */
	    parseCommand(parser, key, path) {
	        parser.push('JSON.TOGGLE');
	        parser.pushKey(key);
	        parser.push(path);
	    },
	    transformReply: undefined
	};
	
	return TOGGLE;
}

var TYPE = {};

var hasRequiredTYPE;

function requireTYPE () {
	if (hasRequiredTYPE) return TYPE;
	hasRequiredTYPE = 1;
	Object.defineProperty(TYPE, "__esModule", { value: true });
	TYPE.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Returns the type of JSON value at a specific path in a JSON document.
	     * Returns the type as a string, array of types for multiple paths, or null if path doesn't exist.
	     *
	     * @param parser - The Redis command parser
	     * @param key - The key containing the JSON document
	     * @param options - Optional parameters
	     * @param options.path - Path to examine
	     */
	    parseCommand(parser, key, options) {
	        parser.push('JSON.TYPE');
	        parser.pushKey(key);
	        if (options?.path) {
	            parser.push(options.path);
	        }
	    },
	    transformReply: {
	        2: undefined,
	        // TODO: RESP3 wraps the response in another array, but only returns 1 
	        3: (reply) => {
	            return reply[0];
	        }
	    },
	};
	
	return TYPE;
}

var hasRequiredCommands$2;

function requireCommands$2 () {
	if (hasRequiredCommands$2) return commands$2;
	hasRequiredCommands$2 = 1;
	(function (exports) {
		var __importDefault = (commands$2 && commands$2.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = void 0;
		const ARRAPPEND_1 = __importDefault(requireARRAPPEND());
		const ARRINDEX_1 = __importDefault(requireARRINDEX());
		const ARRINSERT_1 = __importDefault(requireARRINSERT());
		const ARRLEN_1 = __importDefault(requireARRLEN());
		const ARRPOP_1 = __importDefault(requireARRPOP());
		const ARRTRIM_1 = __importDefault(requireARRTRIM());
		const CLEAR_1 = __importDefault(requireCLEAR());
		const DEBUG_MEMORY_1 = __importDefault(requireDEBUG_MEMORY());
		const DEL_1 = __importDefault(requireDEL$1());
		const FORGET_1 = __importDefault(requireFORGET());
		const GET_1 = __importDefault(requireGET$1());
		const MERGE_1 = __importDefault(requireMERGE());
		const MGET_1 = __importDefault(requireMGET$1());
		const MSET_1 = __importDefault(requireMSET());
		const NUMINCRBY_1 = __importDefault(requireNUMINCRBY());
		const NUMMULTBY_1 = __importDefault(requireNUMMULTBY());
		const OBJKEYS_1 = __importDefault(requireOBJKEYS());
		const OBJLEN_1 = __importDefault(requireOBJLEN());
		// import RESP from './RESP';
		const SET_1 = __importDefault(requireSET());
		const STRAPPEND_1 = __importDefault(requireSTRAPPEND());
		const STRLEN_1 = __importDefault(requireSTRLEN());
		const TOGGLE_1 = __importDefault(requireTOGGLE());
		const TYPE_1 = __importDefault(requireTYPE());
		var generic_transformers_1 = requireGenericTransformers();
		Object.defineProperty(exports, "transformRedisJsonArgument", { enumerable: true, get: function () { return generic_transformers_1.transformRedisJsonArgument; } });
		Object.defineProperty(exports, "transformRedisJsonReply", { enumerable: true, get: function () { return generic_transformers_1.transformRedisJsonReply; } });
		Object.defineProperty(exports, "transformRedisJsonNullReply", { enumerable: true, get: function () { return generic_transformers_1.transformRedisJsonNullReply; } });
		exports.default = {
		    ARRAPPEND: ARRAPPEND_1.default,
		    arrAppend: ARRAPPEND_1.default,
		    ARRINDEX: ARRINDEX_1.default,
		    arrIndex: ARRINDEX_1.default,
		    ARRINSERT: ARRINSERT_1.default,
		    arrInsert: ARRINSERT_1.default,
		    ARRLEN: ARRLEN_1.default,
		    arrLen: ARRLEN_1.default,
		    ARRPOP: ARRPOP_1.default,
		    arrPop: ARRPOP_1.default,
		    ARRTRIM: ARRTRIM_1.default,
		    arrTrim: ARRTRIM_1.default,
		    CLEAR: CLEAR_1.default,
		    clear: CLEAR_1.default,
		    DEBUG_MEMORY: DEBUG_MEMORY_1.default,
		    debugMemory: DEBUG_MEMORY_1.default,
		    DEL: DEL_1.default,
		    del: DEL_1.default,
		    FORGET: FORGET_1.default,
		    forget: FORGET_1.default,
		    GET: GET_1.default,
		    get: GET_1.default,
		    MERGE: MERGE_1.default,
		    merge: MERGE_1.default,
		    MGET: MGET_1.default,
		    mGet: MGET_1.default,
		    MSET: MSET_1.default,
		    mSet: MSET_1.default,
		    NUMINCRBY: NUMINCRBY_1.default,
		    numIncrBy: NUMINCRBY_1.default,
		    /**
		     * @deprecated since JSON version 2.0
		     */
		    NUMMULTBY: NUMMULTBY_1.default,
		    /**
		     * @deprecated since JSON version 2.0
		     */
		    numMultBy: NUMMULTBY_1.default,
		    OBJKEYS: OBJKEYS_1.default,
		    objKeys: OBJKEYS_1.default,
		    OBJLEN: OBJLEN_1.default,
		    objLen: OBJLEN_1.default,
		    // RESP,
		    // resp: RESP,
		    SET: SET_1.default,
		    set: SET_1.default,
		    STRAPPEND: STRAPPEND_1.default,
		    strAppend: STRAPPEND_1.default,
		    STRLEN: STRLEN_1.default,
		    strLen: STRLEN_1.default,
		    TOGGLE: TOGGLE_1.default,
		    toggle: TOGGLE_1.default,
		    TYPE: TYPE_1.default,
		    type: TYPE_1.default
		};
		
	} (commands$2));
	return commands$2;
}

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$2;
	hasRequiredLib$2 = 1;
	(function (exports) {
		var __importDefault = (lib$2 && lib$2.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = void 0;
		var commands_1 = requireCommands$2();
		Object.defineProperty(exports, "default", { enumerable: true, get: function () { return __importDefault(commands_1).default; } });
		
	} (lib$2));
	return lib$2;
}

var lib$1 = {};

var commands$1 = {};

var _LIST = {};

var hasRequired_LIST;

function require_LIST () {
	if (hasRequired_LIST) return _LIST;
	hasRequired_LIST = 1;
	Object.defineProperty(_LIST, "__esModule", { value: true });
	_LIST.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Lists all existing indexes in the database.
	     * @param parser - The command parser
	     */
	    parseCommand(parser) {
	        parser.push('FT._LIST');
	    },
	    transformReply: {
	        2: undefined,
	        3: undefined
	    }
	};
	
	return _LIST;
}

var ALTER$1 = {};

var CREATE$1 = {};

var hasRequiredCREATE$1;

function requireCREATE$1 () {
	if (hasRequiredCREATE$1) return CREATE$1;
	hasRequiredCREATE$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.REDISEARCH_LANGUAGE = exports.parseSchema = exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = void 0;
		const generic_transformers_1 = requireGenericTransformers();
		exports.SCHEMA_FIELD_TYPE = {
		    TEXT: 'TEXT',
		    NUMERIC: 'NUMERIC',
		    GEO: 'GEO',
		    TAG: 'TAG',
		    VECTOR: 'VECTOR',
		    GEOSHAPE: 'GEOSHAPE'
		};
		exports.SCHEMA_TEXT_FIELD_PHONETIC = {
		    DM_EN: 'dm:en',
		    DM_FR: 'dm:fr',
		    FM_PT: 'dm:pt',
		    DM_ES: 'dm:es'
		};
		exports.SCHEMA_VECTOR_FIELD_ALGORITHM = {
		    FLAT: 'FLAT',
		    HNSW: 'HNSW'
		};
		exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = {
		    SPHERICAL: 'SPHERICAL',
		    FLAT: 'FLAT'
		};
		function parseCommonSchemaFieldOptions(parser, fieldOptions) {
		    if (fieldOptions.SORTABLE) {
		        parser.push('SORTABLE');
		        if (fieldOptions.SORTABLE === 'UNF') {
		            parser.push('UNF');
		        }
		    }
		    if (fieldOptions.NOINDEX) {
		        parser.push('NOINDEX');
		    }
		}
		function parseSchema(parser, schema) {
		    for (const [field, fieldOptions] of Object.entries(schema)) {
		        parser.push(field);
		        if (typeof fieldOptions === 'string') {
		            parser.push(fieldOptions);
		            continue;
		        }
		        if (fieldOptions.AS) {
		            parser.push('AS', fieldOptions.AS);
		        }
		        parser.push(fieldOptions.type);
		        if (fieldOptions.INDEXMISSING) {
		            parser.push('INDEXMISSING');
		        }
		        switch (fieldOptions.type) {
		            case exports.SCHEMA_FIELD_TYPE.TEXT:
		                if (fieldOptions.NOSTEM) {
		                    parser.push('NOSTEM');
		                }
		                if (fieldOptions.WEIGHT) {
		                    parser.push('WEIGHT', fieldOptions.WEIGHT.toString());
		                }
		                if (fieldOptions.PHONETIC) {
		                    parser.push('PHONETIC', fieldOptions.PHONETIC);
		                }
		                if (fieldOptions.WITHSUFFIXTRIE) {
		                    parser.push('WITHSUFFIXTRIE');
		                }
		                if (fieldOptions.INDEXEMPTY) {
		                    parser.push('INDEXEMPTY');
		                }
		                parseCommonSchemaFieldOptions(parser, fieldOptions);
		                break;
		            case exports.SCHEMA_FIELD_TYPE.NUMERIC:
		            case exports.SCHEMA_FIELD_TYPE.GEO:
		                parseCommonSchemaFieldOptions(parser, fieldOptions);
		                break;
		            case exports.SCHEMA_FIELD_TYPE.TAG:
		                if (fieldOptions.SEPARATOR) {
		                    parser.push('SEPARATOR', fieldOptions.SEPARATOR);
		                }
		                if (fieldOptions.CASESENSITIVE) {
		                    parser.push('CASESENSITIVE');
		                }
		                if (fieldOptions.WITHSUFFIXTRIE) {
		                    parser.push('WITHSUFFIXTRIE');
		                }
		                if (fieldOptions.INDEXEMPTY) {
		                    parser.push('INDEXEMPTY');
		                }
		                parseCommonSchemaFieldOptions(parser, fieldOptions);
		                break;
		            case exports.SCHEMA_FIELD_TYPE.VECTOR:
		                parser.push(fieldOptions.ALGORITHM);
		                const args = [];
		                args.push('TYPE', fieldOptions.TYPE, 'DIM', fieldOptions.DIM.toString(), 'DISTANCE_METRIC', fieldOptions.DISTANCE_METRIC);
		                if (fieldOptions.INITIAL_CAP) {
		                    args.push('INITIAL_CAP', fieldOptions.INITIAL_CAP.toString());
		                }
		                switch (fieldOptions.ALGORITHM) {
		                    case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.FLAT:
		                        if (fieldOptions.BLOCK_SIZE) {
		                            args.push('BLOCK_SIZE', fieldOptions.BLOCK_SIZE.toString());
		                        }
		                        break;
		                    case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.HNSW:
		                        if (fieldOptions.M) {
		                            args.push('M', fieldOptions.M.toString());
		                        }
		                        if (fieldOptions.EF_CONSTRUCTION) {
		                            args.push('EF_CONSTRUCTION', fieldOptions.EF_CONSTRUCTION.toString());
		                        }
		                        if (fieldOptions.EF_RUNTIME) {
		                            args.push('EF_RUNTIME', fieldOptions.EF_RUNTIME.toString());
		                        }
		                        break;
		                }
		                parser.pushVariadicWithLength(args);
		                break;
		            case exports.SCHEMA_FIELD_TYPE.GEOSHAPE:
		                if (fieldOptions.COORD_SYSTEM !== undefined) {
		                    parser.push('COORD_SYSTEM', fieldOptions.COORD_SYSTEM);
		                }
		                break;
		        }
		    }
		}
		exports.parseSchema = parseSchema;
		exports.REDISEARCH_LANGUAGE = {
		    ARABIC: 'Arabic',
		    BASQUE: 'Basque',
		    CATALANA: 'Catalan',
		    DANISH: 'Danish',
		    DUTCH: 'Dutch',
		    ENGLISH: 'English',
		    FINNISH: 'Finnish',
		    FRENCH: 'French',
		    GERMAN: 'German',
		    GREEK: 'Greek',
		    HUNGARIAN: 'Hungarian',
		    INDONESAIN: 'Indonesian',
		    IRISH: 'Irish',
		    ITALIAN: 'Italian',
		    LITHUANIAN: 'Lithuanian',
		    NEPALI: 'Nepali',
		    NORWEIGAN: 'Norwegian',
		    PORTUGUESE: 'Portuguese',
		    ROMANIAN: 'Romanian',
		    RUSSIAN: 'Russian',
		    SPANISH: 'Spanish',
		    SWEDISH: 'Swedish',
		    TAMIL: 'Tamil',
		    TURKISH: 'Turkish',
		    CHINESE: 'Chinese'
		};
		exports.default = {
		    NOT_KEYED_COMMAND: true,
		    IS_READ_ONLY: true,
		    /**
		     * Creates a new search index with the given schema and options.
		     * @param parser - The command parser
		     * @param index - Name of the index to create
		     * @param schema - Index schema defining field names and types (TEXT, NUMERIC, GEO, TAG, VECTOR, GEOSHAPE)
		     * @param options - Optional parameters:
		     *   - ON: Type of container to index (HASH or JSON)
		     *   - PREFIX: Prefixes for document keys to index
		     *   - FILTER: Expression that filters indexed documents
		     *   - LANGUAGE/LANGUAGE_FIELD: Default language for indexing
		     *   - SCORE/SCORE_FIELD: Document ranking parameters
		     *   - MAXTEXTFIELDS: Index all text fields without specifying them
		     *   - TEMPORARY: Create a temporary index
		     *   - NOOFFSETS/NOHL/NOFIELDS/NOFREQS: Index optimization flags
		     *   - STOPWORDS: Custom stopword list
		     */
		    parseCommand(parser, index, schema, options) {
		        parser.push('FT.CREATE', index);
		        if (options?.ON) {
		            parser.push('ON', options.ON);
		        }
		        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, 'PREFIX', options?.PREFIX);
		        if (options?.FILTER) {
		            parser.push('FILTER', options.FILTER);
		        }
		        if (options?.LANGUAGE) {
		            parser.push('LANGUAGE', options.LANGUAGE);
		        }
		        if (options?.LANGUAGE_FIELD) {
		            parser.push('LANGUAGE_FIELD', options.LANGUAGE_FIELD);
		        }
		        if (options?.SCORE) {
		            parser.push('SCORE', options.SCORE.toString());
		        }
		        if (options?.SCORE_FIELD) {
		            parser.push('SCORE_FIELD', options.SCORE_FIELD);
		        }
		        // if (options?.PAYLOAD_FIELD) {
		        //     parser.push('PAYLOAD_FIELD', options.PAYLOAD_FIELD);
		        // }
		        if (options?.MAXTEXTFIELDS) {
		            parser.push('MAXTEXTFIELDS');
		        }
		        if (options?.TEMPORARY) {
		            parser.push('TEMPORARY', options.TEMPORARY.toString());
		        }
		        if (options?.NOOFFSETS) {
		            parser.push('NOOFFSETS');
		        }
		        if (options?.NOHL) {
		            parser.push('NOHL');
		        }
		        if (options?.NOFIELDS) {
		            parser.push('NOFIELDS');
		        }
		        if (options?.NOFREQS) {
		            parser.push('NOFREQS');
		        }
		        if (options?.SKIPINITIALSCAN) {
		            parser.push('SKIPINITIALSCAN');
		        }
		        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, 'STOPWORDS', options?.STOPWORDS);
		        parser.push('SCHEMA');
		        parseSchema(parser, schema);
		    },
		    transformReply: undefined
		};
		
	} (CREATE$1));
	return CREATE$1;
}

var hasRequiredALTER$1;

function requireALTER$1 () {
	if (hasRequiredALTER$1) return ALTER$1;
	hasRequiredALTER$1 = 1;
	Object.defineProperty(ALTER$1, "__esModule", { value: true });
	const CREATE_1 = requireCREATE$1();
	ALTER$1.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Alters an existing RediSearch index schema by adding new fields.
	     * @param parser - The command parser
	     * @param index - The index to alter
	     * @param schema - The schema definition containing new fields to add
	     */
	    parseCommand(parser, index, schema) {
	        parser.push('FT.ALTER', index, 'SCHEMA', 'ADD');
	        (0, CREATE_1.parseSchema)(parser, schema);
	    },
	    transformReply: undefined
	};
	
	return ALTER$1;
}

var AGGREGATE_WITHCURSOR = {};

var AGGREGATE = {};

var SEARCH = {};

var _default = {};

var hasRequired_default;

function require_default () {
	if (hasRequired_default) return _default;
	hasRequired_default = 1;
	Object.defineProperty(_default, "__esModule", { value: true });
	_default.DEFAULT_DIALECT = void 0;
	_default.DEFAULT_DIALECT = '2';
	
	return _default;
}

var hasRequiredSEARCH;

function requireSEARCH () {
	if (hasRequiredSEARCH) return SEARCH;
	hasRequiredSEARCH = 1;
	Object.defineProperty(SEARCH, "__esModule", { value: true });
	SEARCH.parseSearchOptions = SEARCH.parseParamsArgument = void 0;
	const generic_transformers_1 = requireGenericTransformers();
	const default_1 = require_default();
	function parseParamsArgument(parser, params) {
	    if (params) {
	        parser.push('PARAMS');
	        const args = [];
	        for (const key in params) {
	            if (!Object.hasOwn(params, key))
	                continue;
	            const value = params[key];
	            args.push(key, typeof value === 'number' ? value.toString() : value);
	        }
	        parser.pushVariadicWithLength(args);
	    }
	}
	SEARCH.parseParamsArgument = parseParamsArgument;
	function parseSearchOptions(parser, options) {
	    if (options?.VERBATIM) {
	        parser.push('VERBATIM');
	    }
	    if (options?.NOSTOPWORDS) {
	        parser.push('NOSTOPWORDS');
	    }
	    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, 'INKEYS', options?.INKEYS);
	    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, 'INFIELDS', options?.INFIELDS);
	    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, 'RETURN', options?.RETURN);
	    if (options?.SUMMARIZE) {
	        parser.push('SUMMARIZE');
	        if (typeof options.SUMMARIZE === 'object') {
	            (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, 'FIELDS', options.SUMMARIZE.FIELDS);
	            if (options.SUMMARIZE.FRAGS !== undefined) {
	                parser.push('FRAGS', options.SUMMARIZE.FRAGS.toString());
	            }
	            if (options.SUMMARIZE.LEN !== undefined) {
	                parser.push('LEN', options.SUMMARIZE.LEN.toString());
	            }
	            if (options.SUMMARIZE.SEPARATOR !== undefined) {
	                parser.push('SEPARATOR', options.SUMMARIZE.SEPARATOR);
	            }
	        }
	    }
	    if (options?.HIGHLIGHT) {
	        parser.push('HIGHLIGHT');
	        if (typeof options.HIGHLIGHT === 'object') {
	            (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, 'FIELDS', options.HIGHLIGHT.FIELDS);
	            if (options.HIGHLIGHT.TAGS) {
	                parser.push('TAGS', options.HIGHLIGHT.TAGS.open, options.HIGHLIGHT.TAGS.close);
	            }
	        }
	    }
	    if (options?.SLOP !== undefined) {
	        parser.push('SLOP', options.SLOP.toString());
	    }
	    if (options?.TIMEOUT !== undefined) {
	        parser.push('TIMEOUT', options.TIMEOUT.toString());
	    }
	    if (options?.INORDER) {
	        parser.push('INORDER');
	    }
	    if (options?.LANGUAGE) {
	        parser.push('LANGUAGE', options.LANGUAGE);
	    }
	    if (options?.EXPANDER) {
	        parser.push('EXPANDER', options.EXPANDER);
	    }
	    if (options?.SCORER) {
	        parser.push('SCORER', options.SCORER);
	    }
	    if (options?.SORTBY) {
	        parser.push('SORTBY');
	        if (typeof options.SORTBY === 'string' || options.SORTBY instanceof Buffer) {
	            parser.push(options.SORTBY);
	        }
	        else {
	            parser.push(options.SORTBY.BY);
	            if (options.SORTBY.DIRECTION) {
	                parser.push(options.SORTBY.DIRECTION);
	            }
	        }
	    }
	    if (options?.LIMIT) {
	        parser.push('LIMIT', options.LIMIT.from.toString(), options.LIMIT.size.toString());
	    }
	    parseParamsArgument(parser, options?.PARAMS);
	    if (options?.DIALECT) {
	        parser.push('DIALECT', options.DIALECT.toString());
	    }
	    else {
	        parser.push('DIALECT', default_1.DEFAULT_DIALECT);
	    }
	}
	SEARCH.parseSearchOptions = parseSearchOptions;
	SEARCH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Searches a RediSearch index with the given query.
	     * @param parser - The command parser
	     * @param index - The index name to search
	     * @param query - The text query to search. For syntax, see https://redis.io/docs/stack/search/reference/query_syntax
	     * @param options - Optional search parameters including:
	     *   - VERBATIM: do not try to use stemming for query expansion
	     *   - NOSTOPWORDS: do not filter stopwords from the query
	     *   - INKEYS/INFIELDS: restrict the search to specific keys/fields
	     *   - RETURN: limit which fields are returned
	     *   - SUMMARIZE/HIGHLIGHT: create search result highlights
	     *   - LIMIT: pagination control
	     *   - SORTBY: sort results by a specific field
	     *   - PARAMS: bind parameters to the query
	     */
	    parseCommand(parser, index, query, options) {
	        parser.push('FT.SEARCH', index, query);
	        parseSearchOptions(parser, options);
	    },
	    transformReply: {
	        2: (reply) => {
	            const withoutDocuments = (reply[0] + 1 == reply.length);
	            const documents = [];
	            let i = 1;
	            while (i < reply.length) {
	                documents.push({
	                    id: reply[i++],
	                    value: withoutDocuments ? Object.create(null) : documentValue(reply[i++])
	                });
	            }
	            return {
	                total: reply[0],
	                documents
	            };
	        },
	        3: undefined
	    },
	    unstableResp3: true
	};
	function documentValue(tuples) {
	    const message = Object.create(null);
	    if (!tuples) {
	        return message;
	    }
	    let i = 0;
	    while (i < tuples.length) {
	        const key = tuples[i++], value = tuples[i++];
	        if (key === '$') { // might be a JSON reply
	            try {
	                Object.assign(message, JSON.parse(value));
	                continue;
	            }
	            catch {
	                // set as a regular property if not a valid JSON
	            }
	        }
	        message[key] = value;
	    }
	    return message;
	}
	
	return SEARCH;
}

var hasRequiredAGGREGATE;

function requireAGGREGATE () {
	if (hasRequiredAGGREGATE) return AGGREGATE;
	hasRequiredAGGREGATE = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.parseAggregateOptions = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.FT_AGGREGATE_STEPS = void 0;
		const SEARCH_1 = requireSEARCH();
		const generic_transformers_1 = requireGenericTransformers();
		const default_1 = require_default();
		exports.FT_AGGREGATE_STEPS = {
		    GROUPBY: 'GROUPBY',
		    SORTBY: 'SORTBY',
		    APPLY: 'APPLY',
		    LIMIT: 'LIMIT',
		    FILTER: 'FILTER'
		};
		exports.FT_AGGREGATE_GROUP_BY_REDUCERS = {
		    COUNT: 'COUNT',
		    COUNT_DISTINCT: 'COUNT_DISTINCT',
		    COUNT_DISTINCTISH: 'COUNT_DISTINCTISH',
		    SUM: 'SUM',
		    MIN: 'MIN',
		    MAX: 'MAX',
		    AVG: 'AVG',
		    STDDEV: 'STDDEV',
		    QUANTILE: 'QUANTILE',
		    TOLIST: 'TOLIST',
		    FIRST_VALUE: 'FIRST_VALUE',
		    RANDOM_SAMPLE: 'RANDOM_SAMPLE'
		};
		exports.default = {
		    NOT_KEYED_COMMAND: true,
		    IS_READ_ONLY: false,
		    /**
		     * Performs an aggregation query on a RediSearch index.
		     * @param parser - The command parser
		     * @param index - The index name to query
		     * @param query - The text query to use as filter, use * to indicate no filtering
		     * @param options - Optional parameters for aggregation:
		     *   - VERBATIM: disable stemming in query evaluation
		     *   - LOAD: specify fields to load from documents
		     *   - STEPS: sequence of aggregation steps (GROUPBY, SORTBY, APPLY, LIMIT, FILTER)
		     *   - PARAMS: bind parameters for query evaluation
		     *   - TIMEOUT: maximum time to run the query
		     */
		    parseCommand(parser, index, query, options) {
		        parser.push('FT.AGGREGATE', index, query);
		        return parseAggregateOptions(parser, options);
		    },
		    transformReply: {
		        2: (rawReply, preserve, typeMapping) => {
		            const results = [];
		            for (let i = 1; i < rawReply.length; i++) {
		                results.push((0, generic_transformers_1.transformTuplesReply)(rawReply[i], preserve, typeMapping));
		            }
		            return {
		                //  https://redis.io/docs/latest/commands/ft.aggregate/#return
		                //  FT.AGGREGATE returns an array reply where each row is an array reply and represents a single aggregate result.
		                // The integer reply at position 1 does not represent a valid value.
		                total: Number(rawReply[0]),
		                results
		            };
		        },
		        3: undefined
		    },
		    unstableResp3: true
		};
		function parseAggregateOptions(parser, options) {
		    if (options?.VERBATIM) {
		        parser.push('VERBATIM');
		    }
		    if (options?.ADDSCORES) {
		        parser.push('ADDSCORES');
		    }
		    if (options?.LOAD) {
		        const args = [];
		        if (Array.isArray(options.LOAD)) {
		            for (const load of options.LOAD) {
		                pushLoadField(args, load);
		            }
		        }
		        else {
		            pushLoadField(args, options.LOAD);
		        }
		        parser.push('LOAD');
		        parser.pushVariadicWithLength(args);
		    }
		    if (options?.TIMEOUT !== undefined) {
		        parser.push('TIMEOUT', options.TIMEOUT.toString());
		    }
		    if (options?.STEPS) {
		        for (const step of options.STEPS) {
		            parser.push(step.type);
		            switch (step.type) {
		                case exports.FT_AGGREGATE_STEPS.GROUPBY:
		                    if (!step.properties) {
		                        parser.push('0');
		                    }
		                    else {
		                        parser.pushVariadicWithLength(step.properties);
		                    }
		                    if (Array.isArray(step.REDUCE)) {
		                        for (const reducer of step.REDUCE) {
		                            parseGroupByReducer(parser, reducer);
		                        }
		                    }
		                    else {
		                        parseGroupByReducer(parser, step.REDUCE);
		                    }
		                    break;
		                case exports.FT_AGGREGATE_STEPS.SORTBY:
		                    const args = [];
		                    if (Array.isArray(step.BY)) {
		                        for (const by of step.BY) {
		                            pushSortByProperty(args, by);
		                        }
		                    }
		                    else {
		                        pushSortByProperty(args, step.BY);
		                    }
		                    if (step.MAX) {
		                        args.push('MAX', step.MAX.toString());
		                    }
		                    parser.pushVariadicWithLength(args);
		                    break;
		                case exports.FT_AGGREGATE_STEPS.APPLY:
		                    parser.push(step.expression, 'AS', step.AS);
		                    break;
		                case exports.FT_AGGREGATE_STEPS.LIMIT:
		                    parser.push(step.from.toString(), step.size.toString());
		                    break;
		                case exports.FT_AGGREGATE_STEPS.FILTER:
		                    parser.push(step.expression);
		                    break;
		            }
		        }
		    }
		    (0, SEARCH_1.parseParamsArgument)(parser, options?.PARAMS);
		    if (options?.DIALECT) {
		        parser.push('DIALECT', options.DIALECT.toString());
		    }
		    else {
		        parser.push('DIALECT', default_1.DEFAULT_DIALECT);
		    }
		}
		exports.parseAggregateOptions = parseAggregateOptions;
		function pushLoadField(args, toLoad) {
		    if (typeof toLoad === 'string' || toLoad instanceof Buffer) {
		        args.push(toLoad);
		    }
		    else {
		        args.push(toLoad.identifier);
		        if (toLoad.AS) {
		            args.push('AS', toLoad.AS);
		        }
		    }
		}
		function parseGroupByReducer(parser, reducer) {
		    parser.push('REDUCE', reducer.type);
		    switch (reducer.type) {
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT:
		            parser.push('0');
		            break;
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCT:
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCTISH:
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.SUM:
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MIN:
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MAX:
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.AVG:
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.STDDEV:
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.TOLIST:
		            parser.push('1', reducer.property);
		            break;
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.QUANTILE:
		            parser.push('2', reducer.property, reducer.quantile.toString());
		            break;
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.FIRST_VALUE: {
		            const args = [reducer.property];
		            if (reducer.BY) {
		                args.push('BY');
		                if (typeof reducer.BY === 'string' || reducer.BY instanceof Buffer) {
		                    args.push(reducer.BY);
		                }
		                else {
		                    args.push(reducer.BY.property);
		                    if (reducer.BY.direction) {
		                        args.push(reducer.BY.direction);
		                    }
		                }
		            }
		            parser.pushVariadicWithLength(args);
		            break;
		        }
		        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.RANDOM_SAMPLE:
		            parser.push('2', reducer.property, reducer.sampleSize.toString());
		            break;
		    }
		    if (reducer.AS) {
		        parser.push('AS', reducer.AS);
		    }
		}
		function pushSortByProperty(args, sortBy) {
		    if (typeof sortBy === 'string' || sortBy instanceof Buffer) {
		        args.push(sortBy);
		    }
		    else {
		        args.push(sortBy.BY);
		        if (sortBy.DIRECTION) {
		            args.push(sortBy.DIRECTION);
		        }
		    }
		}
		
	} (AGGREGATE));
	return AGGREGATE;
}

var hasRequiredAGGREGATE_WITHCURSOR;

function requireAGGREGATE_WITHCURSOR () {
	if (hasRequiredAGGREGATE_WITHCURSOR) return AGGREGATE_WITHCURSOR;
	hasRequiredAGGREGATE_WITHCURSOR = 1;
	var __importDefault = (AGGREGATE_WITHCURSOR && AGGREGATE_WITHCURSOR.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(AGGREGATE_WITHCURSOR, "__esModule", { value: true });
	const AGGREGATE_1 = __importDefault(requireAGGREGATE());
	AGGREGATE_WITHCURSOR.default = {
	    IS_READ_ONLY: AGGREGATE_1.default.IS_READ_ONLY,
	    /**
	     * Performs an aggregation with a cursor for retrieving large result sets.
	     * @param parser - The command parser
	     * @param index - Name of the index to query
	     * @param query - The aggregation query
	     * @param options - Optional parameters:
	     *   - All options supported by FT.AGGREGATE
	     *   - COUNT: Number of results to return per cursor fetch
	     *   - MAXIDLE: Maximum idle time for cursor in milliseconds
	     */
	    parseCommand(parser, index, query, options) {
	        AGGREGATE_1.default.parseCommand(parser, index, query, options);
	        parser.push('WITHCURSOR');
	        if (options?.COUNT !== undefined) {
	            parser.push('COUNT', options.COUNT.toString());
	        }
	        if (options?.MAXIDLE !== undefined) {
	            parser.push('MAXIDLE', options.MAXIDLE.toString());
	        }
	    },
	    transformReply: {
	        2: (reply) => {
	            return {
	                ...AGGREGATE_1.default.transformReply[2](reply[0]),
	                cursor: reply[1]
	            };
	        },
	        3: undefined
	    },
	    unstableResp3: true
	};
	
	return AGGREGATE_WITHCURSOR;
}

var ALIASADD = {};

var hasRequiredALIASADD;

function requireALIASADD () {
	if (hasRequiredALIASADD) return ALIASADD;
	hasRequiredALIASADD = 1;
	Object.defineProperty(ALIASADD, "__esModule", { value: true });
	ALIASADD.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Adds an alias to a RediSearch index.
	     * @param parser - The command parser
	     * @param alias - The alias to add
	     * @param index - The index name to alias
	     */
	    parseCommand(parser, alias, index) {
	        parser.push('FT.ALIASADD', alias, index);
	    },
	    transformReply: undefined
	};
	
	return ALIASADD;
}

var ALIASDEL = {};

var hasRequiredALIASDEL;

function requireALIASDEL () {
	if (hasRequiredALIASDEL) return ALIASDEL;
	hasRequiredALIASDEL = 1;
	Object.defineProperty(ALIASDEL, "__esModule", { value: true });
	ALIASDEL.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Removes an existing alias from a RediSearch index.
	     * @param parser - The command parser
	     * @param alias - The alias to remove
	     */
	    parseCommand(parser, alias) {
	        parser.push('FT.ALIASDEL', alias);
	    },
	    transformReply: undefined
	};
	
	return ALIASDEL;
}

var ALIASUPDATE = {};

var hasRequiredALIASUPDATE;

function requireALIASUPDATE () {
	if (hasRequiredALIASUPDATE) return ALIASUPDATE;
	hasRequiredALIASUPDATE = 1;
	Object.defineProperty(ALIASUPDATE, "__esModule", { value: true });
	ALIASUPDATE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Updates the index pointed to by an existing alias.
	     * @param parser - The command parser
	     * @param alias - The existing alias to update
	     * @param index - The new index name that the alias should point to
	     */
	    parseCommand(parser, alias, index) {
	        parser.push('FT.ALIASUPDATE', alias, index);
	    },
	    transformReply: undefined
	};
	
	return ALIASUPDATE;
}

var CONFIG_GET = {};

var hasRequiredCONFIG_GET;

function requireCONFIG_GET () {
	if (hasRequiredCONFIG_GET) return CONFIG_GET;
	hasRequiredCONFIG_GET = 1;
	Object.defineProperty(CONFIG_GET, "__esModule", { value: true });
	CONFIG_GET.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets a RediSearch configuration option value.
	     * @param parser - The command parser
	     * @param option - The name of the configuration option to retrieve
	     */
	    parseCommand(parser, option) {
	        parser.push('FT.CONFIG', 'GET', option);
	    },
	    transformReply(reply) {
	        const transformedReply = Object.create(null);
	        for (const item of reply) {
	            const [key, value] = item;
	            transformedReply[key.toString()] = value;
	        }
	        return transformedReply;
	    }
	};
	
	return CONFIG_GET;
}

var CONFIG_SET = {};

var hasRequiredCONFIG_SET;

function requireCONFIG_SET () {
	if (hasRequiredCONFIG_SET) return CONFIG_SET;
	hasRequiredCONFIG_SET = 1;
	Object.defineProperty(CONFIG_SET, "__esModule", { value: true });
	CONFIG_SET.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Sets a RediSearch configuration option value.
	     * @param parser - The command parser
	     * @param property - The name of the configuration option to set
	     * @param value - The value to set for the configuration option
	     */
	    parseCommand(parser, property, value) {
	        parser.push('FT.CONFIG', 'SET', property, value);
	    },
	    transformReply: undefined
	};
	
	return CONFIG_SET;
}

var CURSOR_DEL = {};

var hasRequiredCURSOR_DEL;

function requireCURSOR_DEL () {
	if (hasRequiredCURSOR_DEL) return CURSOR_DEL;
	hasRequiredCURSOR_DEL = 1;
	Object.defineProperty(CURSOR_DEL, "__esModule", { value: true });
	CURSOR_DEL.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Deletes a cursor from an index.
	     * @param parser - The command parser
	     * @param index - The index name that contains the cursor
	     * @param cursorId - The cursor ID to delete
	     */
	    parseCommand(parser, index, cursorId) {
	        parser.push('FT.CURSOR', 'DEL', index, cursorId.toString());
	    },
	    transformReply: undefined
	};
	
	return CURSOR_DEL;
}

var CURSOR_READ = {};

var hasRequiredCURSOR_READ;

function requireCURSOR_READ () {
	if (hasRequiredCURSOR_READ) return CURSOR_READ;
	hasRequiredCURSOR_READ = 1;
	var __importDefault = (CURSOR_READ && CURSOR_READ.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(CURSOR_READ, "__esModule", { value: true });
	const AGGREGATE_WITHCURSOR_1 = __importDefault(requireAGGREGATE_WITHCURSOR());
	CURSOR_READ.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Reads from an existing cursor to get more results from an index.
	     * @param parser - The command parser
	     * @param index - The index name that contains the cursor
	     * @param cursor - The cursor ID to read from
	     * @param options - Optional parameters:
	     *   - COUNT: Maximum number of results to return
	     */
	    parseCommand(parser, index, cursor, options) {
	        parser.push('FT.CURSOR', 'READ', index, cursor.toString());
	        if (options?.COUNT !== undefined) {
	            parser.push('COUNT', options.COUNT.toString());
	        }
	    },
	    transformReply: AGGREGATE_WITHCURSOR_1.default.transformReply,
	    unstableResp3: true
	};
	
	return CURSOR_READ;
}

var DICTADD = {};

var hasRequiredDICTADD;

function requireDICTADD () {
	if (hasRequiredDICTADD) return DICTADD;
	hasRequiredDICTADD = 1;
	Object.defineProperty(DICTADD, "__esModule", { value: true });
	DICTADD.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Adds terms to a dictionary.
	     * @param parser - The command parser
	     * @param dictionary - Name of the dictionary to add terms to
	     * @param term - One or more terms to add to the dictionary
	     */
	    parseCommand(parser, dictionary, term) {
	        parser.push('FT.DICTADD', dictionary);
	        parser.pushVariadic(term);
	    },
	    transformReply: undefined
	};
	
	return DICTADD;
}

var DICTDEL = {};

var hasRequiredDICTDEL;

function requireDICTDEL () {
	if (hasRequiredDICTDEL) return DICTDEL;
	hasRequiredDICTDEL = 1;
	Object.defineProperty(DICTDEL, "__esModule", { value: true });
	DICTDEL.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Deletes terms from a dictionary.
	     * @param parser - The command parser
	     * @param dictionary - Name of the dictionary to remove terms from
	     * @param term - One or more terms to delete from the dictionary
	     */
	    parseCommand(parser, dictionary, term) {
	        parser.push('FT.DICTDEL', dictionary);
	        parser.pushVariadic(term);
	    },
	    transformReply: undefined
	};
	
	return DICTDEL;
}

var DICTDUMP = {};

var hasRequiredDICTDUMP;

function requireDICTDUMP () {
	if (hasRequiredDICTDUMP) return DICTDUMP;
	hasRequiredDICTDUMP = 1;
	Object.defineProperty(DICTDUMP, "__esModule", { value: true });
	DICTDUMP.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns all terms in a dictionary.
	     * @param parser - The command parser
	     * @param dictionary - Name of the dictionary to dump
	     */
	    parseCommand(parser, dictionary) {
	        parser.push('FT.DICTDUMP', dictionary);
	    },
	    transformReply: {
	        2: undefined,
	        3: undefined
	    }
	};
	
	return DICTDUMP;
}

var DROPINDEX = {};

var hasRequiredDROPINDEX;

function requireDROPINDEX () {
	if (hasRequiredDROPINDEX) return DROPINDEX;
	hasRequiredDROPINDEX = 1;
	Object.defineProperty(DROPINDEX, "__esModule", { value: true });
	DROPINDEX.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Deletes an index and all associated documents.
	     * @param parser - The command parser
	     * @param index - Name of the index to delete
	     * @param options - Optional parameters:
	     *   - DD: Also delete the indexed documents themselves
	     */
	    parseCommand(parser, index, options) {
	        parser.push('FT.DROPINDEX', index);
	        if (options?.DD) {
	            parser.push('DD');
	        }
	    },
	    transformReply: {
	        2: undefined,
	        3: undefined
	    }
	};
	
	return DROPINDEX;
}

var EXPLAIN = {};

var hasRequiredEXPLAIN;

function requireEXPLAIN () {
	if (hasRequiredEXPLAIN) return EXPLAIN;
	hasRequiredEXPLAIN = 1;
	Object.defineProperty(EXPLAIN, "__esModule", { value: true });
	const SEARCH_1 = requireSEARCH();
	const default_1 = require_default();
	EXPLAIN.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the execution plan for a complex query.
	     * @param parser - The command parser
	     * @param index - Name of the index to explain query against
	     * @param query - The query string to explain
	     * @param options - Optional parameters:
	     *   - PARAMS: Named parameters to use in the query
	     *   - DIALECT: Version of query dialect to use (defaults to 1)
	     */
	    parseCommand(parser, index, query, options) {
	        parser.push('FT.EXPLAIN', index, query);
	        (0, SEARCH_1.parseParamsArgument)(parser, options?.PARAMS);
	        if (options?.DIALECT) {
	            parser.push('DIALECT', options.DIALECT.toString());
	        }
	        else {
	            parser.push('DIALECT', default_1.DEFAULT_DIALECT);
	        }
	    },
	    transformReply: undefined
	};
	
	return EXPLAIN;
}

var EXPLAINCLI = {};

var hasRequiredEXPLAINCLI;

function requireEXPLAINCLI () {
	if (hasRequiredEXPLAINCLI) return EXPLAINCLI;
	hasRequiredEXPLAINCLI = 1;
	Object.defineProperty(EXPLAINCLI, "__esModule", { value: true });
	const default_1 = require_default();
	EXPLAINCLI.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the execution plan for a complex query in a more verbose format than FT.EXPLAIN.
	     * @param parser - The command parser
	     * @param index - Name of the index to explain query against
	     * @param query - The query string to explain
	     * @param options - Optional parameters:
	     *   - DIALECT: Version of query dialect to use (defaults to 1)
	     */
	    parseCommand(parser, index, query, options) {
	        parser.push('FT.EXPLAINCLI', index, query);
	        if (options?.DIALECT) {
	            parser.push('DIALECT', options.DIALECT.toString());
	        }
	        else {
	            parser.push('DIALECT', default_1.DEFAULT_DIALECT);
	        }
	    },
	    transformReply: undefined
	};
	
	return EXPLAINCLI;
}

var INFO$1 = {};

var hasRequiredINFO$1;

function requireINFO$1 () {
	if (hasRequiredINFO$1) return INFO$1;
	hasRequiredINFO$1 = 1;
	Object.defineProperty(INFO$1, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	INFO$1.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns information and statistics about an index.
	     * @param parser - The command parser
	     * @param index - Name of the index to get information about
	     */
	    parseCommand(parser, index) {
	        parser.push('FT.INFO', index);
	    },
	    transformReply: {
	        2: transformV2Reply,
	        3: undefined
	    },
	    unstableResp3: true
	};
	function transformV2Reply(reply, preserve, typeMapping) {
	    const myTransformFunc = (0, generic_transformers_1.createTransformTuplesReplyFunc)(preserve, typeMapping);
	    const ret = {};
	    for (let i = 0; i < reply.length; i += 2) {
	        const key = reply[i].toString();
	        switch (key) {
	            case 'index_name':
	            case 'index_options':
	            case 'num_docs':
	            case 'max_doc_id':
	            case 'num_terms':
	            case 'num_records':
	            case 'total_inverted_index_blocks':
	            case 'hash_indexing_failures':
	            case 'indexing':
	            case 'number_of_uses':
	            case 'cleaning':
	            case 'stopwords_list':
	                ret[key] = reply[i + 1];
	                break;
	            case 'inverted_sz_mb':
	            case 'vector_index_sz_mb':
	            case 'offset_vectors_sz_mb':
	            case 'doc_table_size_mb':
	            case 'sortable_values_size_mb':
	            case 'key_table_size_mb':
	            case 'text_overhead_sz_mb':
	            case 'tag_overhead_sz_mb':
	            case 'total_index_memory_sz_mb':
	            case 'geoshapes_sz_mb':
	            case 'records_per_doc_avg':
	            case 'bytes_per_record_avg':
	            case 'offsets_per_term_avg':
	            case 'offset_bits_per_record_avg':
	            case 'total_indexing_time':
	            case 'percent_indexed':
	                ret[key] = generic_transformers_1.transformDoubleReply[2](reply[i + 1], undefined, typeMapping);
	                break;
	            case 'index_definition':
	                ret[key] = myTransformFunc(reply[i + 1]);
	                break;
	            case 'attributes':
	                ret[key] = reply[i + 1].map(attribute => myTransformFunc(attribute));
	                break;
	            case 'gc_stats': {
	                const innerRet = {};
	                const array = reply[i + 1];
	                for (let i = 0; i < array.length; i += 2) {
	                    const innerKey = array[i].toString();
	                    switch (innerKey) {
	                        case 'bytes_collected':
	                        case 'total_ms_run':
	                        case 'total_cycles':
	                        case 'average_cycle_time_ms':
	                        case 'last_run_time_ms':
	                        case 'gc_numeric_trees_missed':
	                        case 'gc_blocks_denied':
	                            innerRet[innerKey] = generic_transformers_1.transformDoubleReply[2](array[i + 1], undefined, typeMapping);
	                            break;
	                    }
	                }
	                ret[key] = innerRet;
	                break;
	            }
	            case 'cursor_stats': {
	                const innerRet = {};
	                const array = reply[i + 1];
	                for (let i = 0; i < array.length; i += 2) {
	                    const innerKey = array[i].toString();
	                    switch (innerKey) {
	                        case 'global_idle':
	                        case 'global_total':
	                        case 'index_capacity':
	                        case 'index_total':
	                            innerRet[innerKey] = array[i + 1];
	                            break;
	                    }
	                }
	                ret[key] = innerRet;
	                break;
	            }
	        }
	    }
	    return ret;
	}
	
	return INFO$1;
}

var PROFILE_SEARCH = {};

var hasRequiredPROFILE_SEARCH;

function requirePROFILE_SEARCH () {
	if (hasRequiredPROFILE_SEARCH) return PROFILE_SEARCH;
	hasRequiredPROFILE_SEARCH = 1;
	var __createBinding = (PROFILE_SEARCH && PROFILE_SEARCH.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (PROFILE_SEARCH && PROFILE_SEARCH.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (PROFILE_SEARCH && PROFILE_SEARCH.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(PROFILE_SEARCH, "__esModule", { value: true });
	const SEARCH_1 = __importStar(requireSEARCH());
	PROFILE_SEARCH.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Profiles the execution of a search query for performance analysis.
	     * @param parser - The command parser
	     * @param index - Name of the index to profile query against
	     * @param query - The search query to profile
	     * @param options - Optional parameters:
	     *   - LIMITED: Collect limited timing information only
	     *   - All options supported by FT.SEARCH command
	     */
	    parseCommand(parser, index, query, options) {
	        parser.push('FT.PROFILE', index, 'SEARCH');
	        if (options?.LIMITED) {
	            parser.push('LIMITED');
	        }
	        parser.push('QUERY', query);
	        (0, SEARCH_1.parseSearchOptions)(parser, options);
	    },
	    transformReply: {
	        2: (reply) => {
	            return {
	                results: SEARCH_1.default.transformReply[2](reply[0]),
	                profile: reply[1]
	            };
	        },
	        3: (reply) => reply
	    },
	    unstableResp3: true
	};
	
	return PROFILE_SEARCH;
}

var PROFILE_AGGREGATE = {};

var hasRequiredPROFILE_AGGREGATE;

function requirePROFILE_AGGREGATE () {
	if (hasRequiredPROFILE_AGGREGATE) return PROFILE_AGGREGATE;
	hasRequiredPROFILE_AGGREGATE = 1;
	var __createBinding = (PROFILE_AGGREGATE && PROFILE_AGGREGATE.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (PROFILE_AGGREGATE && PROFILE_AGGREGATE.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (PROFILE_AGGREGATE && PROFILE_AGGREGATE.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(PROFILE_AGGREGATE, "__esModule", { value: true });
	const AGGREGATE_1 = __importStar(requireAGGREGATE());
	PROFILE_AGGREGATE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Profiles the execution of an aggregation query for performance analysis.
	     * @param parser - The command parser
	     * @param index - Name of the index to profile query against
	     * @param query - The aggregation query to profile
	     * @param options - Optional parameters:
	     *   - LIMITED: Collect limited timing information only
	     *   - All options supported by FT.AGGREGATE command
	     */
	    parseCommand(parser, index, query, options) {
	        parser.push('FT.PROFILE', index, 'AGGREGATE');
	        if (options?.LIMITED) {
	            parser.push('LIMITED');
	        }
	        parser.push('QUERY', query);
	        (0, AGGREGATE_1.parseAggregateOptions)(parser, options);
	    },
	    transformReply: {
	        2: (reply) => {
	            return {
	                results: AGGREGATE_1.default.transformReply[2](reply[0]),
	                profile: reply[1]
	            };
	        },
	        3: (reply) => reply
	    },
	    unstableResp3: true
	};
	
	return PROFILE_AGGREGATE;
}

var SEARCH_NOCONTENT = {};

var hasRequiredSEARCH_NOCONTENT;

function requireSEARCH_NOCONTENT () {
	if (hasRequiredSEARCH_NOCONTENT) return SEARCH_NOCONTENT;
	hasRequiredSEARCH_NOCONTENT = 1;
	var __importDefault = (SEARCH_NOCONTENT && SEARCH_NOCONTENT.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(SEARCH_NOCONTENT, "__esModule", { value: true });
	const SEARCH_1 = __importDefault(requireSEARCH());
	SEARCH_NOCONTENT.default = {
	    NOT_KEYED_COMMAND: SEARCH_1.default.NOT_KEYED_COMMAND,
	    IS_READ_ONLY: SEARCH_1.default.IS_READ_ONLY,
	    /**
	     * Performs a search query but returns only document ids without their contents.
	     * @param args - Same parameters as FT.SEARCH:
	     *   - parser: The command parser
	     *   - index: Name of the index to search
	     *   - query: The text query to search
	     *   - options: Optional search parameters
	     */
	    parseCommand(...args) {
	        SEARCH_1.default.parseCommand(...args);
	        args[0].push('NOCONTENT');
	    },
	    transformReply: {
	        2: (reply) => {
	            return {
	                total: reply[0],
	                documents: reply.slice(1)
	            };
	        },
	        3: undefined
	    },
	    unstableResp3: true
	};
	
	return SEARCH_NOCONTENT;
}

var SPELLCHECK = {};

var hasRequiredSPELLCHECK;

function requireSPELLCHECK () {
	if (hasRequiredSPELLCHECK) return SPELLCHECK;
	hasRequiredSPELLCHECK = 1;
	Object.defineProperty(SPELLCHECK, "__esModule", { value: true });
	const default_1 = require_default();
	SPELLCHECK.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Performs spelling correction on a search query.
	     * @param parser - The command parser
	     * @param index - Name of the index to use for spelling corrections
	     * @param query - The search query to check for spelling
	     * @param options - Optional parameters:
	     *   - DISTANCE: Maximum Levenshtein distance for spelling suggestions
	     *   - TERMS: Custom dictionary terms to include/exclude
	     *   - DIALECT: Version of query dialect to use (defaults to 1)
	     */
	    parseCommand(parser, index, query, options) {
	        parser.push('FT.SPELLCHECK', index, query);
	        if (options?.DISTANCE) {
	            parser.push('DISTANCE', options.DISTANCE.toString());
	        }
	        if (options?.TERMS) {
	            if (Array.isArray(options.TERMS)) {
	                for (const term of options.TERMS) {
	                    parseTerms(parser, term);
	                }
	            }
	            else {
	                parseTerms(parser, options.TERMS);
	            }
	        }
	        if (options?.DIALECT) {
	            parser.push('DIALECT', options.DIALECT.toString());
	        }
	        else {
	            parser.push('DIALECT', default_1.DEFAULT_DIALECT);
	        }
	    },
	    transformReply: {
	        2: (rawReply) => {
	            return rawReply.map(([, term, suggestions]) => ({
	                term,
	                suggestions: suggestions.map(([score, suggestion]) => ({
	                    score: Number(score),
	                    suggestion
	                }))
	            }));
	        },
	        3: undefined,
	    },
	    unstableResp3: true
	};
	function parseTerms(parser, { mode, dictionary }) {
	    parser.push('TERMS', mode, dictionary);
	}
	
	return SPELLCHECK;
}

var SUGADD = {};

var hasRequiredSUGADD;

function requireSUGADD () {
	if (hasRequiredSUGADD) return SUGADD;
	hasRequiredSUGADD = 1;
	Object.defineProperty(SUGADD, "__esModule", { value: true });
	SUGADD.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Adds a suggestion string to an auto-complete suggestion dictionary.
	     * @param parser - The command parser
	     * @param key - The suggestion dictionary key
	     * @param string - The suggestion string to add
	     * @param score - The suggestion score used for sorting
	     * @param options - Optional parameters:
	     *   - INCR: If true, increment the existing entry's score
	     *   - PAYLOAD: Optional payload to associate with the suggestion
	     */
	    parseCommand(parser, key, string, score, options) {
	        parser.push('FT.SUGADD');
	        parser.pushKey(key);
	        parser.push(string, score.toString());
	        if (options?.INCR) {
	            parser.push('INCR');
	        }
	        if (options?.PAYLOAD) {
	            parser.push('PAYLOAD', options.PAYLOAD);
	        }
	    },
	    transformReply: undefined
	};
	
	return SUGADD;
}

var SUGDEL = {};

var hasRequiredSUGDEL;

function requireSUGDEL () {
	if (hasRequiredSUGDEL) return SUGDEL;
	hasRequiredSUGDEL = 1;
	Object.defineProperty(SUGDEL, "__esModule", { value: true });
	SUGDEL.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Deletes a string from a suggestion dictionary.
	     * @param parser - The command parser
	     * @param key - The suggestion dictionary key
	     * @param string - The suggestion string to delete
	     */
	    parseCommand(parser, key, string) {
	        parser.push('FT.SUGDEL');
	        parser.pushKey(key);
	        parser.push(string);
	    },
	    transformReply: undefined
	};
	
	return SUGDEL;
}

var SUGGET_WITHPAYLOADS = {};

var SUGGET = {};

var hasRequiredSUGGET;

function requireSUGGET () {
	if (hasRequiredSUGGET) return SUGGET;
	hasRequiredSUGGET = 1;
	Object.defineProperty(SUGGET, "__esModule", { value: true });
	SUGGET.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets completion suggestions for a prefix from a suggestion dictionary.
	     * @param parser - The command parser
	     * @param key - The suggestion dictionary key
	     * @param prefix - The prefix to get completion suggestions for
	     * @param options - Optional parameters:
	     *   - FUZZY: Enable fuzzy prefix matching
	     *   - MAX: Maximum number of results to return
	     */
	    parseCommand(parser, key, prefix, options) {
	        parser.push('FT.SUGGET');
	        parser.pushKey(key);
	        parser.push(prefix);
	        if (options?.FUZZY) {
	            parser.push('FUZZY');
	        }
	        if (options?.MAX !== undefined) {
	            parser.push('MAX', options.MAX.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return SUGGET;
}

var hasRequiredSUGGET_WITHPAYLOADS;

function requireSUGGET_WITHPAYLOADS () {
	if (hasRequiredSUGGET_WITHPAYLOADS) return SUGGET_WITHPAYLOADS;
	hasRequiredSUGGET_WITHPAYLOADS = 1;
	var __importDefault = (SUGGET_WITHPAYLOADS && SUGGET_WITHPAYLOADS.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(SUGGET_WITHPAYLOADS, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const SUGGET_1 = __importDefault(requireSUGGET());
	SUGGET_WITHPAYLOADS.default = {
	    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
	    /**
	     * Gets completion suggestions with their payloads from a suggestion dictionary.
	     * @param args - Same parameters as FT.SUGGET:
	     *   - parser: The command parser
	     *   - key: The suggestion dictionary key
	     *   - prefix: The prefix to get completion suggestions for
	     *   - options: Optional parameters for fuzzy matching and max results
	     */
	    parseCommand(...args) {
	        SUGGET_1.default.parseCommand(...args);
	        args[0].push('WITHPAYLOADS');
	    },
	    transformReply(reply) {
	        if ((0, generic_transformers_1.isNullReply)(reply))
	            return null;
	        const transformedReply = new Array(reply.length / 2);
	        let replyIndex = 0, arrIndex = 0;
	        while (replyIndex < reply.length) {
	            transformedReply[arrIndex++] = {
	                suggestion: reply[replyIndex++],
	                payload: reply[replyIndex++]
	            };
	        }
	        return transformedReply;
	    }
	};
	
	return SUGGET_WITHPAYLOADS;
}

var SUGGET_WITHSCORES_WITHPAYLOADS = {};

var hasRequiredSUGGET_WITHSCORES_WITHPAYLOADS;

function requireSUGGET_WITHSCORES_WITHPAYLOADS () {
	if (hasRequiredSUGGET_WITHSCORES_WITHPAYLOADS) return SUGGET_WITHSCORES_WITHPAYLOADS;
	hasRequiredSUGGET_WITHSCORES_WITHPAYLOADS = 1;
	var __importDefault = (SUGGET_WITHSCORES_WITHPAYLOADS && SUGGET_WITHSCORES_WITHPAYLOADS.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(SUGGET_WITHSCORES_WITHPAYLOADS, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const SUGGET_1 = __importDefault(requireSUGGET());
	SUGGET_WITHSCORES_WITHPAYLOADS.default = {
	    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
	    /**
	     * Gets completion suggestions with their scores and payloads from a suggestion dictionary.
	     * @param args - Same parameters as FT.SUGGET:
	     *   - parser: The command parser
	     *   - key: The suggestion dictionary key
	     *   - prefix: The prefix to get completion suggestions for
	     *   - options: Optional parameters for fuzzy matching and max results
	     */
	    parseCommand(...args) {
	        SUGGET_1.default.parseCommand(...args);
	        args[0].push('WITHSCORES', 'WITHPAYLOADS');
	    },
	    transformReply: {
	        2: (reply, preserve, typeMapping) => {
	            if ((0, generic_transformers_1.isNullReply)(reply))
	                return null;
	            const transformedReply = new Array(reply.length / 3);
	            let replyIndex = 0, arrIndex = 0;
	            while (replyIndex < reply.length) {
	                transformedReply[arrIndex++] = {
	                    suggestion: reply[replyIndex++],
	                    score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping),
	                    payload: reply[replyIndex++]
	                };
	            }
	            return transformedReply;
	        },
	        3: (reply) => {
	            if ((0, generic_transformers_1.isNullReply)(reply))
	                return null;
	            const transformedReply = new Array(reply.length / 3);
	            let replyIndex = 0, arrIndex = 0;
	            while (replyIndex < reply.length) {
	                transformedReply[arrIndex++] = {
	                    suggestion: reply[replyIndex++],
	                    score: reply[replyIndex++],
	                    payload: reply[replyIndex++]
	                };
	            }
	            return transformedReply;
	        }
	    }
	};
	
	return SUGGET_WITHSCORES_WITHPAYLOADS;
}

var SUGGET_WITHSCORES = {};

var hasRequiredSUGGET_WITHSCORES;

function requireSUGGET_WITHSCORES () {
	if (hasRequiredSUGGET_WITHSCORES) return SUGGET_WITHSCORES;
	hasRequiredSUGGET_WITHSCORES = 1;
	var __importDefault = (SUGGET_WITHSCORES && SUGGET_WITHSCORES.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(SUGGET_WITHSCORES, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	const SUGGET_1 = __importDefault(requireSUGGET());
	SUGGET_WITHSCORES.default = {
	    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
	    /**
	     * Gets completion suggestions with their scores from a suggestion dictionary.
	     * @param args - Same parameters as FT.SUGGET:
	     *   - parser: The command parser
	     *   - key: The suggestion dictionary key
	     *   - prefix: The prefix to get completion suggestions for
	     *   - options: Optional parameters for fuzzy matching and max results
	     */
	    parseCommand(...args) {
	        SUGGET_1.default.parseCommand(...args);
	        args[0].push('WITHSCORES');
	    },
	    transformReply: {
	        2: (reply, preserve, typeMapping) => {
	            if ((0, generic_transformers_1.isNullReply)(reply))
	                return null;
	            const transformedReply = new Array(reply.length / 2);
	            let replyIndex = 0, arrIndex = 0;
	            while (replyIndex < reply.length) {
	                transformedReply[arrIndex++] = {
	                    suggestion: reply[replyIndex++],
	                    score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping)
	                };
	            }
	            return transformedReply;
	        },
	        3: (reply) => {
	            if ((0, generic_transformers_1.isNullReply)(reply))
	                return null;
	            const transformedReply = new Array(reply.length / 2);
	            let replyIndex = 0, arrIndex = 0;
	            while (replyIndex < reply.length) {
	                transformedReply[arrIndex++] = {
	                    suggestion: reply[replyIndex++],
	                    score: reply[replyIndex++]
	                };
	            }
	            return transformedReply;
	        }
	    }
	};
	
	return SUGGET_WITHSCORES;
}

var SUGLEN = {};

var hasRequiredSUGLEN;

function requireSUGLEN () {
	if (hasRequiredSUGLEN) return SUGLEN;
	hasRequiredSUGLEN = 1;
	Object.defineProperty(SUGLEN, "__esModule", { value: true });
	SUGLEN.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets the size of a suggestion dictionary.
	     * @param parser - The command parser
	     * @param key - The suggestion dictionary key
	     */
	    parseCommand(parser, key) {
	        parser.push('FT.SUGLEN', key);
	    },
	    transformReply: undefined
	};
	
	return SUGLEN;
}

var SYNDUMP = {};

var hasRequiredSYNDUMP;

function requireSYNDUMP () {
	if (hasRequiredSYNDUMP) return SYNDUMP;
	hasRequiredSYNDUMP = 1;
	Object.defineProperty(SYNDUMP, "__esModule", { value: true });
	SYNDUMP.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Dumps the contents of a synonym group.
	     * @param parser - The command parser
	     * @param index - Name of the index that contains the synonym group
	     */
	    parseCommand(parser, index) {
	        parser.push('FT.SYNDUMP', index);
	    },
	    transformReply: {
	        2: (reply) => {
	            const result = {};
	            let i = 0;
	            while (i < reply.length) {
	                const key = reply[i++].toString(), value = reply[i++];
	                result[key] = value;
	            }
	            return result;
	        },
	        3: undefined
	    }
	};
	
	return SYNDUMP;
}

var SYNUPDATE = {};

var hasRequiredSYNUPDATE;

function requireSYNUPDATE () {
	if (hasRequiredSYNUPDATE) return SYNUPDATE;
	hasRequiredSYNUPDATE = 1;
	Object.defineProperty(SYNUPDATE, "__esModule", { value: true });
	SYNUPDATE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Updates a synonym group with new terms.
	     * @param parser - The command parser
	     * @param index - Name of the index that contains the synonym group
	     * @param groupId - ID of the synonym group to update
	     * @param terms - One or more synonym terms to add to the group
	     * @param options - Optional parameters:
	     *   - SKIPINITIALSCAN: Skip the initial scan for existing documents
	     */
	    parseCommand(parser, index, groupId, terms, options) {
	        parser.push('FT.SYNUPDATE', index, groupId);
	        if (options?.SKIPINITIALSCAN) {
	            parser.push('SKIPINITIALSCAN');
	        }
	        parser.pushVariadic(terms);
	    },
	    transformReply: undefined
	};
	
	return SYNUPDATE;
}

var TAGVALS = {};

var hasRequiredTAGVALS;

function requireTAGVALS () {
	if (hasRequiredTAGVALS) return TAGVALS;
	hasRequiredTAGVALS = 1;
	Object.defineProperty(TAGVALS, "__esModule", { value: true });
	TAGVALS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Returns the distinct values in a TAG field.
	     * @param parser - The command parser
	     * @param index - Name of the index
	     * @param fieldName - Name of the TAG field to get values from
	     */
	    parseCommand(parser, index, fieldName) {
	        parser.push('FT.TAGVALS', index, fieldName);
	    },
	    transformReply: {
	        2: undefined,
	        3: undefined
	    }
	};
	
	return TAGVALS;
}

var hasRequiredCommands$1;

function requireCommands$1 () {
	if (hasRequiredCommands$1) return commands$1;
	hasRequiredCommands$1 = 1;
	var __importDefault = (commands$1 && commands$1.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(commands$1, "__esModule", { value: true });
	const _LIST_1 = __importDefault(require_LIST());
	const ALTER_1 = __importDefault(requireALTER$1());
	const AGGREGATE_WITHCURSOR_1 = __importDefault(requireAGGREGATE_WITHCURSOR());
	const AGGREGATE_1 = __importDefault(requireAGGREGATE());
	const ALIASADD_1 = __importDefault(requireALIASADD());
	const ALIASDEL_1 = __importDefault(requireALIASDEL());
	const ALIASUPDATE_1 = __importDefault(requireALIASUPDATE());
	const CONFIG_GET_1 = __importDefault(requireCONFIG_GET());
	const CONFIG_SET_1 = __importDefault(requireCONFIG_SET());
	const CREATE_1 = __importDefault(requireCREATE$1());
	const CURSOR_DEL_1 = __importDefault(requireCURSOR_DEL());
	const CURSOR_READ_1 = __importDefault(requireCURSOR_READ());
	const DICTADD_1 = __importDefault(requireDICTADD());
	const DICTDEL_1 = __importDefault(requireDICTDEL());
	const DICTDUMP_1 = __importDefault(requireDICTDUMP());
	const DROPINDEX_1 = __importDefault(requireDROPINDEX());
	const EXPLAIN_1 = __importDefault(requireEXPLAIN());
	const EXPLAINCLI_1 = __importDefault(requireEXPLAINCLI());
	const INFO_1 = __importDefault(requireINFO$1());
	const PROFILE_SEARCH_1 = __importDefault(requirePROFILE_SEARCH());
	const PROFILE_AGGREGATE_1 = __importDefault(requirePROFILE_AGGREGATE());
	const SEARCH_NOCONTENT_1 = __importDefault(requireSEARCH_NOCONTENT());
	const SEARCH_1 = __importDefault(requireSEARCH());
	const SPELLCHECK_1 = __importDefault(requireSPELLCHECK());
	const SUGADD_1 = __importDefault(requireSUGADD());
	const SUGDEL_1 = __importDefault(requireSUGDEL());
	const SUGGET_WITHPAYLOADS_1 = __importDefault(requireSUGGET_WITHPAYLOADS());
	const SUGGET_WITHSCORES_WITHPAYLOADS_1 = __importDefault(requireSUGGET_WITHSCORES_WITHPAYLOADS());
	const SUGGET_WITHSCORES_1 = __importDefault(requireSUGGET_WITHSCORES());
	const SUGGET_1 = __importDefault(requireSUGGET());
	const SUGLEN_1 = __importDefault(requireSUGLEN());
	const SYNDUMP_1 = __importDefault(requireSYNDUMP());
	const SYNUPDATE_1 = __importDefault(requireSYNUPDATE());
	const TAGVALS_1 = __importDefault(requireTAGVALS());
	commands$1.default = {
	    _LIST: _LIST_1.default,
	    _list: _LIST_1.default,
	    ALTER: ALTER_1.default,
	    alter: ALTER_1.default,
	    AGGREGATE_WITHCURSOR: AGGREGATE_WITHCURSOR_1.default,
	    aggregateWithCursor: AGGREGATE_WITHCURSOR_1.default,
	    AGGREGATE: AGGREGATE_1.default,
	    aggregate: AGGREGATE_1.default,
	    ALIASADD: ALIASADD_1.default,
	    aliasAdd: ALIASADD_1.default,
	    ALIASDEL: ALIASDEL_1.default,
	    aliasDel: ALIASDEL_1.default,
	    ALIASUPDATE: ALIASUPDATE_1.default,
	    aliasUpdate: ALIASUPDATE_1.default,
	    /**
	     * @deprecated Redis >=8 uses the standard CONFIG command
	     */
	    CONFIG_GET: CONFIG_GET_1.default,
	    /**
	     * @deprecated Redis >=8 uses the standard CONFIG command
	     */
	    configGet: CONFIG_GET_1.default,
	    /**
	     * @deprecated Redis >=8 uses the standard CONFIG command
	     */
	    CONFIG_SET: CONFIG_SET_1.default,
	    /**
	     * @deprecated Redis >=8 uses the standard CONFIG command
	     */
	    configSet: CONFIG_SET_1.default,
	    CREATE: CREATE_1.default,
	    create: CREATE_1.default,
	    CURSOR_DEL: CURSOR_DEL_1.default,
	    cursorDel: CURSOR_DEL_1.default,
	    CURSOR_READ: CURSOR_READ_1.default,
	    cursorRead: CURSOR_READ_1.default,
	    DICTADD: DICTADD_1.default,
	    dictAdd: DICTADD_1.default,
	    DICTDEL: DICTDEL_1.default,
	    dictDel: DICTDEL_1.default,
	    DICTDUMP: DICTDUMP_1.default,
	    dictDump: DICTDUMP_1.default,
	    DROPINDEX: DROPINDEX_1.default,
	    dropIndex: DROPINDEX_1.default,
	    EXPLAIN: EXPLAIN_1.default,
	    explain: EXPLAIN_1.default,
	    EXPLAINCLI: EXPLAINCLI_1.default,
	    explainCli: EXPLAINCLI_1.default,
	    INFO: INFO_1.default,
	    info: INFO_1.default,
	    PROFILESEARCH: PROFILE_SEARCH_1.default,
	    profileSearch: PROFILE_SEARCH_1.default,
	    PROFILEAGGREGATE: PROFILE_AGGREGATE_1.default,
	    profileAggregate: PROFILE_AGGREGATE_1.default,
	    SEARCH_NOCONTENT: SEARCH_NOCONTENT_1.default,
	    searchNoContent: SEARCH_NOCONTENT_1.default,
	    SEARCH: SEARCH_1.default,
	    search: SEARCH_1.default,
	    SPELLCHECK: SPELLCHECK_1.default,
	    spellCheck: SPELLCHECK_1.default,
	    SUGADD: SUGADD_1.default,
	    sugAdd: SUGADD_1.default,
	    SUGDEL: SUGDEL_1.default,
	    sugDel: SUGDEL_1.default,
	    SUGGET_WITHPAYLOADS: SUGGET_WITHPAYLOADS_1.default,
	    sugGetWithPayloads: SUGGET_WITHPAYLOADS_1.default,
	    SUGGET_WITHSCORES_WITHPAYLOADS: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
	    sugGetWithScoresWithPayloads: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
	    SUGGET_WITHSCORES: SUGGET_WITHSCORES_1.default,
	    sugGetWithScores: SUGGET_WITHSCORES_1.default,
	    SUGGET: SUGGET_1.default,
	    sugGet: SUGGET_1.default,
	    SUGLEN: SUGLEN_1.default,
	    sugLen: SUGLEN_1.default,
	    SYNDUMP: SYNDUMP_1.default,
	    synDump: SYNDUMP_1.default,
	    SYNUPDATE: SYNUPDATE_1.default,
	    synUpdate: SYNUPDATE_1.default,
	    TAGVALS: TAGVALS_1.default,
	    tagVals: TAGVALS_1.default
	};
	
	return commands$1;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	(function (exports) {
		var __importDefault = (lib$1 && lib$1.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FT_AGGREGATE_STEPS = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = exports.REDISEARCH_LANGUAGE = exports.default = void 0;
		var commands_1 = requireCommands$1();
		Object.defineProperty(exports, "default", { enumerable: true, get: function () { return __importDefault(commands_1).default; } });
		var CREATE_1 = requireCREATE$1();
		Object.defineProperty(exports, "REDISEARCH_LANGUAGE", { enumerable: true, get: function () { return CREATE_1.REDISEARCH_LANGUAGE; } });
		Object.defineProperty(exports, "SCHEMA_FIELD_TYPE", { enumerable: true, get: function () { return CREATE_1.SCHEMA_FIELD_TYPE; } });
		Object.defineProperty(exports, "SCHEMA_TEXT_FIELD_PHONETIC", { enumerable: true, get: function () { return CREATE_1.SCHEMA_TEXT_FIELD_PHONETIC; } });
		Object.defineProperty(exports, "SCHEMA_VECTOR_FIELD_ALGORITHM", { enumerable: true, get: function () { return CREATE_1.SCHEMA_VECTOR_FIELD_ALGORITHM; } });
		var AGGREGATE_1 = requireAGGREGATE();
		Object.defineProperty(exports, "FT_AGGREGATE_GROUP_BY_REDUCERS", { enumerable: true, get: function () { return AGGREGATE_1.FT_AGGREGATE_GROUP_BY_REDUCERS; } });
		Object.defineProperty(exports, "FT_AGGREGATE_STEPS", { enumerable: true, get: function () { return AGGREGATE_1.FT_AGGREGATE_STEPS; } });
		
	} (lib$1));
	return lib$1;
}

var lib = {};

var commands = {};

var ADD = {};

var helpers = {};

var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.transformRESP2LabelsWithSources = exports.transformRESP2Labels = exports.parseSelectedLabelsArguments = exports.resp3MapToValue = exports.resp2MapToValue = exports.transformSamplesReply = exports.transformSampleReply = exports.parseLabelsArgument = exports.transformTimestampArgument = exports.parseDuplicatePolicy = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.parseChunkSizeArgument = exports.parseEncodingArgument = exports.TIME_SERIES_ENCODING = exports.parseRetentionArgument = exports.parseIgnoreArgument = void 0;
		const client_1 = requireDist$1();
		function parseIgnoreArgument(parser, ignore) {
		    if (ignore !== undefined) {
		        parser.push('IGNORE', ignore.maxTimeDiff.toString(), ignore.maxValDiff.toString());
		    }
		}
		exports.parseIgnoreArgument = parseIgnoreArgument;
		function parseRetentionArgument(parser, retention) {
		    if (retention !== undefined) {
		        parser.push('RETENTION', retention.toString());
		    }
		}
		exports.parseRetentionArgument = parseRetentionArgument;
		exports.TIME_SERIES_ENCODING = {
		    COMPRESSED: 'COMPRESSED',
		    UNCOMPRESSED: 'UNCOMPRESSED'
		};
		function parseEncodingArgument(parser, encoding) {
		    if (encoding !== undefined) {
		        parser.push('ENCODING', encoding);
		    }
		}
		exports.parseEncodingArgument = parseEncodingArgument;
		function parseChunkSizeArgument(parser, chunkSize) {
		    if (chunkSize !== undefined) {
		        parser.push('CHUNK_SIZE', chunkSize.toString());
		    }
		}
		exports.parseChunkSizeArgument = parseChunkSizeArgument;
		exports.TIME_SERIES_DUPLICATE_POLICIES = {
		    BLOCK: 'BLOCK',
		    FIRST: 'FIRST',
		    LAST: 'LAST',
		    MIN: 'MIN',
		    MAX: 'MAX',
		    SUM: 'SUM'
		};
		function parseDuplicatePolicy(parser, duplicatePolicy) {
		    if (duplicatePolicy !== undefined) {
		        parser.push('DUPLICATE_POLICY', duplicatePolicy);
		    }
		}
		exports.parseDuplicatePolicy = parseDuplicatePolicy;
		function transformTimestampArgument(timestamp) {
		    if (typeof timestamp === 'string')
		        return timestamp;
		    return (typeof timestamp === 'number' ?
		        timestamp :
		        timestamp.getTime()).toString();
		}
		exports.transformTimestampArgument = transformTimestampArgument;
		function parseLabelsArgument(parser, labels) {
		    if (labels) {
		        parser.push('LABELS');
		        for (const [label, value] of Object.entries(labels)) {
		            parser.push(label, value);
		        }
		    }
		}
		exports.parseLabelsArgument = parseLabelsArgument;
		exports.transformSampleReply = {
		    2(reply) {
		        const [timestamp, value] = reply;
		        return {
		            timestamp,
		            value: Number(value) // TODO: use double type mapping instead
		        };
		    },
		    3(reply) {
		        const [timestamp, value] = reply;
		        return {
		            timestamp,
		            value
		        };
		    }
		};
		exports.transformSamplesReply = {
		    2(reply) {
		        return reply
		            .map(sample => exports.transformSampleReply[2](sample));
		    },
		    3(reply) {
		        return reply
		            .map(sample => exports.transformSampleReply[3](sample));
		    }
		};
		// TODO: move to @redis/client?
		function resp2MapToValue(wrappedReply, parseFunc, typeMapping) {
		    const reply = wrappedReply;
		    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
		        case Map: {
		            const ret = new Map();
		            for (const wrappedTuple of reply) {
		                const tuple = wrappedTuple;
		                const key = tuple[0];
		                ret.set(key.toString(), parseFunc(tuple));
		            }
		            return ret;
		        }
		        case Array: {
		            for (const wrappedTuple of reply) {
		                const tuple = wrappedTuple;
		                tuple[1] = parseFunc(tuple);
		            }
		            return reply;
		        }
		        default: {
		            const ret = Object.create(null);
		            for (const wrappedTuple of reply) {
		                const tuple = wrappedTuple;
		                const key = tuple[0];
		                ret[key.toString()] = parseFunc(tuple);
		            }
		            return ret;
		        }
		    }
		}
		exports.resp2MapToValue = resp2MapToValue;
		function resp3MapToValue(wrappedReply, parseFunc) {
		    const reply = wrappedReply;
		    if (reply instanceof Array) {
		        for (let i = 1; i < reply.length; i += 2) {
		            reply[i] = parseFunc(reply[i]);
		        }
		    }
		    else if (reply instanceof Map) {
		        for (const [key, value] of reply.entries()) {
		            reply.set(key, parseFunc(value));
		        }
		    }
		    else {
		        for (const [key, value] of Object.entries(reply)) {
		            reply[key] = parseFunc(value);
		        }
		    }
		    return reply;
		}
		exports.resp3MapToValue = resp3MapToValue;
		function parseSelectedLabelsArguments(parser, selectedLabels) {
		    parser.push('SELECTED_LABELS');
		    parser.pushVariadic(selectedLabels);
		}
		exports.parseSelectedLabelsArguments = parseSelectedLabelsArguments;
		function transformRESP2Labels(labels, typeMapping) {
		    const unwrappedLabels = labels;
		    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
		        case Map:
		            const map = new Map();
		            for (const tuple of unwrappedLabels) {
		                const [key, value] = tuple;
		                const unwrappedKey = key;
		                map.set(unwrappedKey.toString(), value);
		            }
		            return map;
		        case Array:
		            return unwrappedLabels.flat();
		        case Object:
		        default:
		            const labelsObject = Object.create(null);
		            for (const tuple of unwrappedLabels) {
		                const [key, value] = tuple;
		                const unwrappedKey = key;
		                labelsObject[unwrappedKey.toString()] = value;
		            }
		            return labelsObject;
		    }
		}
		exports.transformRESP2Labels = transformRESP2Labels;
		function transformRESP2LabelsWithSources(labels, typeMapping) {
		    const unwrappedLabels = labels;
		    const to = unwrappedLabels.length - 2; // ignore __reducer__ and __source__
		    let transformedLabels;
		    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
		        case Map:
		            const map = new Map();
		            for (let i = 0; i < to; i++) {
		                const [key, value] = unwrappedLabels[i];
		                const unwrappedKey = key;
		                map.set(unwrappedKey.toString(), value);
		            }
		            transformedLabels = map;
		            break;
		        case Array:
		            transformedLabels = unwrappedLabels.slice(0, to).flat();
		            break;
		        case Object:
		        default:
		            const labelsObject = Object.create(null);
		            for (let i = 0; i < to; i++) {
		                const [key, value] = unwrappedLabels[i];
		                const unwrappedKey = key;
		                labelsObject[unwrappedKey.toString()] = value;
		            }
		            transformedLabels = labelsObject;
		            break;
		    }
		    const sourcesTuple = unwrappedLabels[unwrappedLabels.length - 1];
		    const unwrappedSourcesTuple = sourcesTuple;
		    // the __source__ label will never be null
		    const transformedSources = transformRESP2Sources(unwrappedSourcesTuple[1]);
		    return {
		        labels: transformedLabels,
		        sources: transformedSources
		    };
		}
		exports.transformRESP2LabelsWithSources = transformRESP2LabelsWithSources;
		function transformRESP2Sources(sourcesRaw) {
		    // if a label contains "," this function will produce incorrcet results..
		    // there is not much we can do about it, and we assume most users won't be using "," in their labels..
		    const unwrappedSources = sourcesRaw;
		    if (typeof unwrappedSources === 'string') {
		        return unwrappedSources.split(',');
		    }
		    const indexOfComma = unwrappedSources.indexOf(',');
		    if (indexOfComma === -1) {
		        return [unwrappedSources];
		    }
		    const sourcesArray = [
		        unwrappedSources.subarray(0, indexOfComma)
		    ];
		    let previousComma = indexOfComma + 1;
		    while (true) {
		        const indexOf = unwrappedSources.indexOf(',', previousComma);
		        if (indexOf === -1) {
		            sourcesArray.push(unwrappedSources.subarray(previousComma));
		            break;
		        }
		        const source = unwrappedSources.subarray(previousComma, indexOf);
		        sourcesArray.push(source);
		        previousComma = indexOf + 1;
		    }
		    return sourcesArray;
		}
		
	} (helpers));
	return helpers;
}

var hasRequiredADD;

function requireADD () {
	if (hasRequiredADD) return ADD;
	hasRequiredADD = 1;
	Object.defineProperty(ADD, "__esModule", { value: true });
	const helpers_1 = requireHelpers();
	ADD.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Creates or appends a sample to a time series
	     * @param parser - The command parser
	     * @param key - The key name for the time series
	     * @param timestamp - The timestamp of the sample
	     * @param value - The value of the sample
	     * @param options - Optional configuration parameters
	     */
	    parseCommand(parser, key, timestamp, value, options) {
	        parser.push('TS.ADD');
	        parser.pushKey(key);
	        parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
	        (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
	        (0, helpers_1.parseEncodingArgument)(parser, options?.ENCODING);
	        (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
	        if (options?.ON_DUPLICATE) {
	            parser.push('ON_DUPLICATE', options.ON_DUPLICATE);
	        }
	        (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
	        (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
	    },
	    transformReply: undefined
	};
	
	return ADD;
}

var ALTER = {};

var hasRequiredALTER;

function requireALTER () {
	if (hasRequiredALTER) return ALTER;
	hasRequiredALTER = 1;
	Object.defineProperty(ALTER, "__esModule", { value: true });
	const helpers_1 = requireHelpers();
	ALTER.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Alters the configuration of an existing time series
	     * @param parser - The command parser
	     * @param key - The key name for the time series
	     * @param options - Configuration parameters to alter
	     */
	    parseCommand(parser, key, options) {
	        parser.push('TS.ALTER');
	        parser.pushKey(key);
	        (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
	        (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
	        (0, helpers_1.parseDuplicatePolicy)(parser, options?.DUPLICATE_POLICY);
	        (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
	        (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
	    },
	    transformReply: undefined
	};
	
	return ALTER;
}

var CREATE = {};

var hasRequiredCREATE;

function requireCREATE () {
	if (hasRequiredCREATE) return CREATE;
	hasRequiredCREATE = 1;
	Object.defineProperty(CREATE, "__esModule", { value: true });
	const helpers_1 = requireHelpers();
	CREATE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Creates a new time series
	     * @param parser - The command parser
	     * @param key - The key name for the new time series
	     * @param options - Optional configuration parameters
	     */
	    parseCommand(parser, key, options) {
	        parser.push('TS.CREATE');
	        parser.pushKey(key);
	        (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
	        (0, helpers_1.parseEncodingArgument)(parser, options?.ENCODING);
	        (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
	        (0, helpers_1.parseDuplicatePolicy)(parser, options?.DUPLICATE_POLICY);
	        (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
	        (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
	    },
	    transformReply: undefined
	};
	
	return CREATE;
}

var CREATERULE = {};

var hasRequiredCREATERULE;

function requireCREATERULE () {
	if (hasRequiredCREATERULE) return CREATERULE;
	hasRequiredCREATERULE = 1;
	Object.defineProperty(CREATERULE, "__esModule", { value: true });
	CREATERULE.TIME_SERIES_AGGREGATION_TYPE = void 0;
	CREATERULE.TIME_SERIES_AGGREGATION_TYPE = {
	    AVG: 'AVG',
	    FIRST: 'FIRST',
	    LAST: 'LAST',
	    MIN: 'MIN',
	    MAX: 'MAX',
	    SUM: 'SUM',
	    RANGE: 'RANGE',
	    COUNT: 'COUNT',
	    STD_P: 'STD.P',
	    STD_S: 'STD.S',
	    VAR_P: 'VAR.P',
	    VAR_S: 'VAR.S',
	    TWA: 'TWA'
	};
	CREATERULE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Creates a compaction rule from source time series to destination time series
	     * @param parser - The command parser
	     * @param sourceKey - The source time series key
	     * @param destinationKey - The destination time series key
	     * @param aggregationType - The aggregation type to use
	     * @param bucketDuration - The duration of each bucket in milliseconds
	     * @param alignTimestamp - Optional timestamp for alignment
	     */
	    parseCommand(parser, sourceKey, destinationKey, aggregationType, bucketDuration, alignTimestamp) {
	        parser.push('TS.CREATERULE');
	        parser.pushKeys([sourceKey, destinationKey]);
	        parser.push('AGGREGATION', aggregationType, bucketDuration.toString());
	        if (alignTimestamp !== undefined) {
	            parser.push(alignTimestamp.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return CREATERULE;
}

var DECRBY = {};

var INCRBY = {};

var hasRequiredINCRBY;

function requireINCRBY () {
	if (hasRequiredINCRBY) return INCRBY;
	hasRequiredINCRBY = 1;
	Object.defineProperty(INCRBY, "__esModule", { value: true });
	INCRBY.parseIncrByArguments = void 0;
	const helpers_1 = requireHelpers();
	/**
	 * Parses arguments for incrementing a time series value
	 * @param parser - The command parser
	 * @param key - The key name of the time series
	 * @param value - The value to increment by
	 * @param options - Optional parameters for the command
	 */
	function parseIncrByArguments(parser, key, value, options) {
	    parser.pushKey(key);
	    parser.push(value.toString());
	    if (options?.TIMESTAMP !== undefined && options?.TIMESTAMP !== null) {
	        parser.push('TIMESTAMP', (0, helpers_1.transformTimestampArgument)(options.TIMESTAMP));
	    }
	    (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
	    if (options?.UNCOMPRESSED) {
	        parser.push('UNCOMPRESSED');
	    }
	    (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
	    (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
	    (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
	}
	INCRBY.parseIncrByArguments = parseIncrByArguments;
	INCRBY.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Increases the value of a time series by a given amount
	     * @param args - Arguments passed to the {@link parseIncrByArguments} function
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        parser.push('TS.INCRBY');
	        parseIncrByArguments(...args);
	    },
	    transformReply: undefined
	};
	
	return INCRBY;
}

var hasRequiredDECRBY;

function requireDECRBY () {
	if (hasRequiredDECRBY) return DECRBY;
	hasRequiredDECRBY = 1;
	var __createBinding = (DECRBY && DECRBY.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (DECRBY && DECRBY.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (DECRBY && DECRBY.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(DECRBY, "__esModule", { value: true });
	const INCRBY_1 = __importStar(requireINCRBY());
	DECRBY.default = {
	    IS_READ_ONLY: INCRBY_1.default.IS_READ_ONLY,
	    /**
	     * Decreases the value of a time series by a given amount
	     * @param args - Arguments passed to the parseIncrByArguments function
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        parser.push('TS.DECRBY');
	        (0, INCRBY_1.parseIncrByArguments)(...args);
	    },
	    transformReply: INCRBY_1.default.transformReply
	};
	
	return DECRBY;
}

var DEL = {};

var hasRequiredDEL;

function requireDEL () {
	if (hasRequiredDEL) return DEL;
	hasRequiredDEL = 1;
	Object.defineProperty(DEL, "__esModule", { value: true });
	const helpers_1 = requireHelpers();
	DEL.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Deletes samples between two timestamps from a time series
	     * @param parser - The command parser
	     * @param key - The key name of the time series
	     * @param fromTimestamp - Start timestamp to delete from
	     * @param toTimestamp - End timestamp to delete until
	     */
	    parseCommand(parser, key, fromTimestamp, toTimestamp) {
	        parser.push('TS.DEL');
	        parser.pushKey(key);
	        parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
	    },
	    transformReply: undefined
	};
	
	return DEL;
}

var DELETERULE = {};

var hasRequiredDELETERULE;

function requireDELETERULE () {
	if (hasRequiredDELETERULE) return DELETERULE;
	hasRequiredDELETERULE = 1;
	Object.defineProperty(DELETERULE, "__esModule", { value: true });
	DELETERULE.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Deletes a compaction rule between source and destination time series
	     * @param parser - The command parser
	     * @param sourceKey - The source time series key
	     * @param destinationKey - The destination time series key
	     */
	    parseCommand(parser, sourceKey, destinationKey) {
	        parser.push('TS.DELETERULE');
	        parser.pushKeys([sourceKey, destinationKey]);
	    },
	    transformReply: undefined
	};
	
	return DELETERULE;
}

var GET = {};

var hasRequiredGET;

function requireGET () {
	if (hasRequiredGET) return GET;
	hasRequiredGET = 1;
	Object.defineProperty(GET, "__esModule", { value: true });
	GET.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets the last sample of a time series
	     * @param parser - The command parser
	     * @param key - The key name of the time series
	     * @param options - Optional parameters for the command
	     */
	    parseCommand(parser, key, options) {
	        parser.push('TS.GET');
	        parser.pushKey(key);
	        if (options?.LATEST) {
	            parser.push('LATEST');
	        }
	    },
	    transformReply: {
	        2(reply) {
	            return reply.length === 0 ? null : {
	                timestamp: reply[0],
	                value: Number(reply[1])
	            };
	        },
	        3(reply) {
	            return reply.length === 0 ? null : {
	                timestamp: reply[0],
	                value: reply[1]
	            };
	        }
	    }
	};
	
	return GET;
}

var INFO_DEBUG = {};

var INFO = {};

var hasRequiredINFO;

function requireINFO () {
	if (hasRequiredINFO) return INFO;
	hasRequiredINFO = 1;
	Object.defineProperty(INFO, "__esModule", { value: true });
	const generic_transformers_1 = requireGenericTransformers();
	INFO.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets information about a time series
	     * @param parser - The command parser
	     * @param key - The key name of the time series
	     */
	    parseCommand(parser, key) {
	        parser.push('TS.INFO');
	        parser.pushKey(key);
	    },
	    transformReply: {
	        2: (reply, _, typeMapping) => {
	            const ret = {};
	            for (let i = 0; i < reply.length; i += 2) {
	                const key = reply[i].toString();
	                switch (key) {
	                    case 'totalSamples':
	                    case 'memoryUsage':
	                    case 'firstTimestamp':
	                    case 'lastTimestamp':
	                    case 'retentionTime':
	                    case 'chunkCount':
	                    case 'chunkSize':
	                    case 'chunkType':
	                    case 'duplicatePolicy':
	                    case 'sourceKey':
	                    case 'ignoreMaxTimeDiff':
	                        ret[key] = reply[i + 1];
	                        break;
	                    case 'labels':
	                        ret[key] = reply[i + 1].map(([name, value]) => ({
	                            name,
	                            value
	                        }));
	                        break;
	                    case 'rules':
	                        ret[key] = reply[i + 1].map(([key, timeBucket, aggregationType]) => ({
	                            key,
	                            timeBucket,
	                            aggregationType
	                        }));
	                        break;
	                    case 'ignoreMaxValDiff':
	                        ret[key] = generic_transformers_1.transformDoubleReply[2](reply[27], undefined, typeMapping);
	                        break;
	                }
	            }
	            return ret;
	        },
	        3: undefined
	    },
	    unstableResp3: true
	};
	
	return INFO;
}

var hasRequiredINFO_DEBUG;

function requireINFO_DEBUG () {
	if (hasRequiredINFO_DEBUG) return INFO_DEBUG;
	hasRequiredINFO_DEBUG = 1;
	var __importDefault = (INFO_DEBUG && INFO_DEBUG.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(INFO_DEBUG, "__esModule", { value: true });
	const INFO_1 = __importDefault(requireINFO());
	INFO_DEBUG.default = {
	    IS_READ_ONLY: INFO_1.default.IS_READ_ONLY,
	    /**
	     * Gets debug information about a time series
	     * @param parser - The command parser
	     * @param key - The key name of the time series
	     */
	    parseCommand(parser, key) {
	        INFO_1.default.parseCommand(parser, key);
	        parser.push('DEBUG');
	    },
	    transformReply: {
	        2: (reply, _, typeMapping) => {
	            const ret = INFO_1.default.transformReply[2](reply, _, typeMapping);
	            for (let i = 0; i < reply.length; i += 2) {
	                const key = reply[i].toString();
	                switch (key) {
	                    case 'keySelfName': {
	                        ret[key] = reply[i + 1];
	                        break;
	                    }
	                    case 'Chunks': {
	                        ret['chunks'] = reply[i + 1].map(chunk => ({
	                            startTimestamp: chunk[1],
	                            endTimestamp: chunk[3],
	                            samples: chunk[5],
	                            size: chunk[7],
	                            bytesPerSample: chunk[9]
	                        }));
	                        break;
	                    }
	                }
	            }
	            return ret;
	        },
	        3: undefined
	    },
	    unstableResp3: true
	};
	
	return INFO_DEBUG;
}

var MADD = {};

var hasRequiredMADD;

function requireMADD () {
	if (hasRequiredMADD) return MADD;
	hasRequiredMADD = 1;
	Object.defineProperty(MADD, "__esModule", { value: true });
	const helpers_1 = requireHelpers();
	MADD.default = {
	    IS_READ_ONLY: false,
	    /**
	     * Adds multiple samples to multiple time series
	     * @param parser - The command parser
	     * @param toAdd - Array of samples to add to different time series
	     */
	    parseCommand(parser, toAdd) {
	        parser.push('TS.MADD');
	        for (const { key, timestamp, value } of toAdd) {
	            parser.pushKey(key);
	            parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
	        }
	    },
	    transformReply: undefined
	};
	
	return MADD;
}

var MGET_SELECTED_LABELS = {};

var MGET = {};

var hasRequiredMGET;

function requireMGET () {
	if (hasRequiredMGET) return MGET;
	hasRequiredMGET = 1;
	Object.defineProperty(MGET, "__esModule", { value: true });
	MGET.parseFilterArgument = MGET.parseLatestArgument = void 0;
	const helpers_1 = requireHelpers();
	/**
	 * Adds LATEST argument to command if specified
	 * @param parser - The command parser
	 * @param latest - Whether to include the LATEST argument
	 */
	function parseLatestArgument(parser, latest) {
	    if (latest) {
	        parser.push('LATEST');
	    }
	}
	MGET.parseLatestArgument = parseLatestArgument;
	/**
	 * Adds FILTER argument to command
	 * @param parser - The command parser
	 * @param filter - Filter to match time series keys
	 */
	function parseFilterArgument(parser, filter) {
	    parser.push('FILTER');
	    parser.pushVariadic(filter);
	}
	MGET.parseFilterArgument = parseFilterArgument;
	MGET.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets the last samples matching a specific filter from multiple time series
	     * @param parser - The command parser
	     * @param filter - Filter to match time series keys
	     * @param options - Optional parameters for the command
	     */
	    parseCommand(parser, filter, options) {
	        parser.push('TS.MGET');
	        parseLatestArgument(parser, options?.LATEST);
	        parseFilterArgument(parser, filter);
	    },
	    transformReply: {
	        2(reply, _, typeMapping) {
	            return (0, helpers_1.resp2MapToValue)(reply, ([, , sample]) => {
	                return {
	                    sample: helpers_1.transformSampleReply[2](sample)
	                };
	            }, typeMapping);
	        },
	        3(reply) {
	            return (0, helpers_1.resp3MapToValue)(reply, ([, sample]) => {
	                return {
	                    sample: helpers_1.transformSampleReply[3](sample)
	                };
	            });
	        }
	    }
	};
	
	return MGET;
}

var MGET_WITHLABELS = {};

var hasRequiredMGET_WITHLABELS;

function requireMGET_WITHLABELS () {
	if (hasRequiredMGET_WITHLABELS) return MGET_WITHLABELS;
	hasRequiredMGET_WITHLABELS = 1;
	Object.defineProperty(MGET_WITHLABELS, "__esModule", { value: true });
	MGET_WITHLABELS.createTransformMGetLabelsReply = void 0;
	const MGET_1 = requireMGET();
	const helpers_1 = requireHelpers();
	function createTransformMGetLabelsReply() {
	    return {
	        2(reply, _, typeMapping) {
	            return (0, helpers_1.resp2MapToValue)(reply, ([, labels, sample]) => {
	                return {
	                    labels: (0, helpers_1.transformRESP2Labels)(labels),
	                    sample: helpers_1.transformSampleReply[2](sample)
	                };
	            }, typeMapping);
	        },
	        3(reply) {
	            return (0, helpers_1.resp3MapToValue)(reply, ([labels, sample]) => {
	                return {
	                    labels,
	                    sample: helpers_1.transformSampleReply[3](sample)
	                };
	            });
	        }
	    };
	}
	MGET_WITHLABELS.createTransformMGetLabelsReply = createTransformMGetLabelsReply;
	MGET_WITHLABELS.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets the last samples matching a specific filter with labels
	     * @param parser - The command parser
	     * @param filter - Filter to match time series keys
	     * @param options - Optional parameters for the command
	     */
	    parseCommand(parser, filter, options) {
	        parser.push('TS.MGET');
	        (0, MGET_1.parseLatestArgument)(parser, options?.LATEST);
	        parser.push('WITHLABELS');
	        (0, MGET_1.parseFilterArgument)(parser, filter);
	    },
	    transformReply: createTransformMGetLabelsReply(),
	};
	
	return MGET_WITHLABELS;
}

var hasRequiredMGET_SELECTED_LABELS;

function requireMGET_SELECTED_LABELS () {
	if (hasRequiredMGET_SELECTED_LABELS) return MGET_SELECTED_LABELS;
	hasRequiredMGET_SELECTED_LABELS = 1;
	Object.defineProperty(MGET_SELECTED_LABELS, "__esModule", { value: true });
	const MGET_1 = requireMGET();
	const helpers_1 = requireHelpers();
	const MGET_WITHLABELS_1 = requireMGET_WITHLABELS();
	MGET_SELECTED_LABELS.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets the last samples matching a specific filter with selected labels
	     * @param parser - The command parser
	     * @param filter - Filter to match time series keys
	     * @param selectedLabels - Labels to include in the output
	     * @param options - Optional parameters for the command
	     */
	    parseCommand(parser, filter, selectedLabels, options) {
	        parser.push('TS.MGET');
	        (0, MGET_1.parseLatestArgument)(parser, options?.LATEST);
	        (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
	        (0, MGET_1.parseFilterArgument)(parser, filter);
	    },
	    transformReply: (0, MGET_WITHLABELS_1.createTransformMGetLabelsReply)(),
	};
	
	return MGET_SELECTED_LABELS;
}

var MRANGE_GROUPBY = {};

var RANGE = {};

var hasRequiredRANGE;

function requireRANGE () {
	if (hasRequiredRANGE) return RANGE;
	hasRequiredRANGE = 1;
	Object.defineProperty(RANGE, "__esModule", { value: true });
	RANGE.transformRangeArguments = RANGE.parseRangeArguments = RANGE.TIME_SERIES_BUCKET_TIMESTAMP = void 0;
	const helpers_1 = requireHelpers();
	RANGE.TIME_SERIES_BUCKET_TIMESTAMP = {
	    LOW: '-',
	    MIDDLE: '~',
	    END: '+'
	};
	function parseRangeArguments(parser, fromTimestamp, toTimestamp, options) {
	    parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
	    if (options?.LATEST) {
	        parser.push('LATEST');
	    }
	    if (options?.FILTER_BY_TS) {
	        parser.push('FILTER_BY_TS');
	        for (const timestamp of options.FILTER_BY_TS) {
	            parser.push((0, helpers_1.transformTimestampArgument)(timestamp));
	        }
	    }
	    if (options?.FILTER_BY_VALUE) {
	        parser.push('FILTER_BY_VALUE', options.FILTER_BY_VALUE.min.toString(), options.FILTER_BY_VALUE.max.toString());
	    }
	    if (options?.COUNT !== undefined) {
	        parser.push('COUNT', options.COUNT.toString());
	    }
	    if (options?.AGGREGATION) {
	        if (options?.ALIGN !== undefined) {
	            parser.push('ALIGN', (0, helpers_1.transformTimestampArgument)(options.ALIGN));
	        }
	        parser.push('AGGREGATION', options.AGGREGATION.type, (0, helpers_1.transformTimestampArgument)(options.AGGREGATION.timeBucket));
	        if (options.AGGREGATION.BUCKETTIMESTAMP) {
	            parser.push('BUCKETTIMESTAMP', options.AGGREGATION.BUCKETTIMESTAMP);
	        }
	        if (options.AGGREGATION.EMPTY) {
	            parser.push('EMPTY');
	        }
	    }
	}
	RANGE.parseRangeArguments = parseRangeArguments;
	function transformRangeArguments(parser, key, fromTimestamp, toTimestamp, options) {
	    parser.pushKey(key);
	    parseRangeArguments(parser, fromTimestamp, toTimestamp, options);
	}
	RANGE.transformRangeArguments = transformRangeArguments;
	RANGE.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets samples from a time series within a time range
	     * @param args - Arguments passed to the {@link transformRangeArguments} function
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        parser.push('TS.RANGE');
	        transformRangeArguments(...args);
	    },
	    transformReply: {
	        2(reply) {
	            return helpers_1.transformSamplesReply[2](reply);
	        },
	        3(reply) {
	            return helpers_1.transformSamplesReply[3](reply);
	        }
	    }
	};
	
	return RANGE;
}

var hasRequiredMRANGE_GROUPBY;

function requireMRANGE_GROUPBY () {
	if (hasRequiredMRANGE_GROUPBY) return MRANGE_GROUPBY;
	hasRequiredMRANGE_GROUPBY = 1;
	Object.defineProperty(MRANGE_GROUPBY, "__esModule", { value: true });
	MRANGE_GROUPBY.extractResp3MRangeSources = MRANGE_GROUPBY.createTransformMRangeGroupByArguments = MRANGE_GROUPBY.parseGroupByArguments = MRANGE_GROUPBY.TIME_SERIES_REDUCERS = void 0;
	const helpers_1 = requireHelpers();
	const RANGE_1 = requireRANGE();
	const MGET_1 = requireMGET();
	MRANGE_GROUPBY.TIME_SERIES_REDUCERS = {
	    AVG: 'AVG',
	    SUM: 'SUM',
	    MIN: 'MIN',
	    MAX: 'MAX',
	    RANGE: 'RANGE',
	    COUNT: 'COUNT',
	    STD_P: 'STD.P',
	    STD_S: 'STD.S',
	    VAR_P: 'VAR.P',
	    VAR_S: 'VAR.S'
	};
	/**
	 * Adds GROUPBY arguments to command
	 * @param parser - The command parser
	 * @param groupBy - Group by parameters
	 */
	function parseGroupByArguments(parser, groupBy) {
	    parser.push('GROUPBY', groupBy.label, 'REDUCE', groupBy.REDUCE);
	}
	MRANGE_GROUPBY.parseGroupByArguments = parseGroupByArguments;
	/**
	 * Creates a function that parses arguments for multi-range commands with grouping
	 * @param command - The command name to use (TS.MRANGE or TS.MREVRANGE)
	 */
	function createTransformMRangeGroupByArguments(command) {
	    return (parser, fromTimestamp, toTimestamp, filter, groupBy, options) => {
	        parser.push(command);
	        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
	        (0, MGET_1.parseFilterArgument)(parser, filter);
	        parseGroupByArguments(parser, groupBy);
	    };
	}
	MRANGE_GROUPBY.createTransformMRangeGroupByArguments = createTransformMRangeGroupByArguments;
	/**
	 * Extracts source keys from RESP3 metadata reply
	 * @param raw - Raw metadata from RESP3 reply
	 */
	function extractResp3MRangeSources(raw) {
	    const unwrappedMetadata2 = raw;
	    if (unwrappedMetadata2 instanceof Map) {
	        return unwrappedMetadata2.get('sources');
	    }
	    else if (unwrappedMetadata2 instanceof Array) {
	        return unwrappedMetadata2[1];
	    }
	    else {
	        return unwrappedMetadata2.sources;
	    }
	}
	MRANGE_GROUPBY.extractResp3MRangeSources = extractResp3MRangeSources;
	MRANGE_GROUPBY.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets samples for time series matching a filter within a time range with grouping
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param filter - Filter to match time series keys
	     * @param groupBy - Group by parameters
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: createTransformMRangeGroupByArguments('TS.MRANGE'),
	    transformReply: {
	        2(reply, _, typeMapping) {
	            return (0, helpers_1.resp2MapToValue)(reply, ([_key, _labels, samples]) => {
	                return {
	                    samples: helpers_1.transformSamplesReply[2](samples)
	                };
	            }, typeMapping);
	        },
	        3(reply) {
	            return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata1, metadata2, samples]) => {
	                return {
	                    sources: extractResp3MRangeSources(metadata2),
	                    samples: helpers_1.transformSamplesReply[3](samples)
	                };
	            });
	        }
	    },
	};
	
	return MRANGE_GROUPBY;
}

var MRANGE_SELECTED_LABELS_GROUPBY = {};

var MRANGE_SELECTED_LABELS = {};

var hasRequiredMRANGE_SELECTED_LABELS;

function requireMRANGE_SELECTED_LABELS () {
	if (hasRequiredMRANGE_SELECTED_LABELS) return MRANGE_SELECTED_LABELS;
	hasRequiredMRANGE_SELECTED_LABELS = 1;
	Object.defineProperty(MRANGE_SELECTED_LABELS, "__esModule", { value: true });
	MRANGE_SELECTED_LABELS.createTransformMRangeSelectedLabelsArguments = void 0;
	const helpers_1 = requireHelpers();
	const RANGE_1 = requireRANGE();
	const MGET_1 = requireMGET();
	/**
	 * Creates a function that parses arguments for multi-range commands with selected labels
	 * @param command - The command name to use (TS.MRANGE or TS.MREVRANGE)
	 */
	function createTransformMRangeSelectedLabelsArguments(command) {
	    return (parser, fromTimestamp, toTimestamp, selectedLabels, filter, options) => {
	        parser.push(command);
	        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
	        (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
	        (0, MGET_1.parseFilterArgument)(parser, filter);
	    };
	}
	MRANGE_SELECTED_LABELS.createTransformMRangeSelectedLabelsArguments = createTransformMRangeSelectedLabelsArguments;
	MRANGE_SELECTED_LABELS.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets samples for time series matching a filter with selected labels
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param selectedLabels - Labels to include in the output
	     * @param filter - Filter to match time series keys
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: createTransformMRangeSelectedLabelsArguments('TS.MRANGE'),
	    transformReply: {
	        2(reply, _, typeMapping) {
	            return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
	                return {
	                    labels: (0, helpers_1.transformRESP2Labels)(labels, typeMapping),
	                    samples: helpers_1.transformSamplesReply[2](samples)
	                };
	            }, typeMapping);
	        },
	        3(reply) {
	            return (0, helpers_1.resp3MapToValue)(reply, ([_key, labels, samples]) => {
	                return {
	                    labels,
	                    samples: helpers_1.transformSamplesReply[3](samples)
	                };
	            });
	        }
	    },
	};
	
	return MRANGE_SELECTED_LABELS;
}

var hasRequiredMRANGE_SELECTED_LABELS_GROUPBY;

function requireMRANGE_SELECTED_LABELS_GROUPBY () {
	if (hasRequiredMRANGE_SELECTED_LABELS_GROUPBY) return MRANGE_SELECTED_LABELS_GROUPBY;
	hasRequiredMRANGE_SELECTED_LABELS_GROUPBY = 1;
	var __importDefault = (MRANGE_SELECTED_LABELS_GROUPBY && MRANGE_SELECTED_LABELS_GROUPBY.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(MRANGE_SELECTED_LABELS_GROUPBY, "__esModule", { value: true });
	MRANGE_SELECTED_LABELS_GROUPBY.createMRangeSelectedLabelsGroupByTransformArguments = void 0;
	const helpers_1 = requireHelpers();
	const RANGE_1 = requireRANGE();
	const MRANGE_GROUPBY_1 = requireMRANGE_GROUPBY();
	const MGET_1 = requireMGET();
	const MRANGE_SELECTED_LABELS_1 = __importDefault(requireMRANGE_SELECTED_LABELS());
	/**
	 * Creates a function that parses arguments for multi-range commands with selected labels and grouping
	 * @param command - The command name to use (TS.MRANGE or TS.MREVRANGE)
	 */
	function createMRangeSelectedLabelsGroupByTransformArguments(command) {
	    return (parser, fromTimestamp, toTimestamp, selectedLabels, filter, groupBy, options) => {
	        parser.push(command);
	        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
	        (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
	        (0, MGET_1.parseFilterArgument)(parser, filter);
	        (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
	    };
	}
	MRANGE_SELECTED_LABELS_GROUPBY.createMRangeSelectedLabelsGroupByTransformArguments = createMRangeSelectedLabelsGroupByTransformArguments;
	MRANGE_SELECTED_LABELS_GROUPBY.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets samples for time series matching a filter with selected labels and grouping
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param selectedLabels - Labels to include in the output
	     * @param filter - Filter to match time series keys
	     * @param groupBy - Group by parameters
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: createMRangeSelectedLabelsGroupByTransformArguments('TS.MRANGE'),
	    transformReply: {
	        2: MRANGE_SELECTED_LABELS_1.default.transformReply[2],
	        3(reply) {
	            return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
	                return {
	                    labels,
	                    sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
	                    samples: helpers_1.transformSamplesReply[3](samples)
	                };
	            });
	        }
	    },
	};
	
	return MRANGE_SELECTED_LABELS_GROUPBY;
}

var MRANGE_WITHLABELS_GROUPBY = {};

var hasRequiredMRANGE_WITHLABELS_GROUPBY;

function requireMRANGE_WITHLABELS_GROUPBY () {
	if (hasRequiredMRANGE_WITHLABELS_GROUPBY) return MRANGE_WITHLABELS_GROUPBY;
	hasRequiredMRANGE_WITHLABELS_GROUPBY = 1;
	Object.defineProperty(MRANGE_WITHLABELS_GROUPBY, "__esModule", { value: true });
	MRANGE_WITHLABELS_GROUPBY.createMRangeWithLabelsGroupByTransformArguments = void 0;
	const helpers_1 = requireHelpers();
	const RANGE_1 = requireRANGE();
	const MRANGE_GROUPBY_1 = requireMRANGE_GROUPBY();
	const MGET_1 = requireMGET();
	function createMRangeWithLabelsGroupByTransformArguments(command) {
	    return (parser, fromTimestamp, toTimestamp, filter, groupBy, options) => {
	        parser.push(command);
	        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
	        parser.push('WITHLABELS');
	        (0, MGET_1.parseFilterArgument)(parser, filter);
	        (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
	    };
	}
	MRANGE_WITHLABELS_GROUPBY.createMRangeWithLabelsGroupByTransformArguments = createMRangeWithLabelsGroupByTransformArguments;
	MRANGE_WITHLABELS_GROUPBY.default = {
	    IS_READ_ONLY: true,
	    /**
	     * Gets samples for time series matching a filter with labels and grouping
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param filter - Filter to match time series keys
	     * @param groupBy - Group by parameters
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: createMRangeWithLabelsGroupByTransformArguments('TS.MRANGE'),
	    transformReply: {
	        2(reply, _, typeMapping) {
	            return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
	                const transformed = (0, helpers_1.transformRESP2LabelsWithSources)(labels);
	                return {
	                    labels: transformed.labels,
	                    sources: transformed.sources,
	                    samples: helpers_1.transformSamplesReply[2](samples)
	                };
	            }, typeMapping);
	        },
	        3(reply) {
	            return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
	                return {
	                    labels,
	                    sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
	                    samples: helpers_1.transformSamplesReply[3](samples)
	                };
	            });
	        }
	    },
	};
	
	return MRANGE_WITHLABELS_GROUPBY;
}

var MRANGE_WITHLABELS = {};

var hasRequiredMRANGE_WITHLABELS;

function requireMRANGE_WITHLABELS () {
	if (hasRequiredMRANGE_WITHLABELS) return MRANGE_WITHLABELS;
	hasRequiredMRANGE_WITHLABELS = 1;
	Object.defineProperty(MRANGE_WITHLABELS, "__esModule", { value: true });
	MRANGE_WITHLABELS.createTransformMRangeWithLabelsArguments = void 0;
	const helpers_1 = requireHelpers();
	const RANGE_1 = requireRANGE();
	const MGET_1 = requireMGET();
	/**
	 * Creates a function that parses arguments for multi-range commands with labels
	 * @param command - The command name to use (TS.MRANGE or TS.MREVRANGE)
	 */
	function createTransformMRangeWithLabelsArguments(command) {
	    return (parser, fromTimestamp, toTimestamp, filter, options) => {
	        parser.push(command);
	        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
	        parser.push('WITHLABELS');
	        (0, MGET_1.parseFilterArgument)(parser, filter);
	    };
	}
	MRANGE_WITHLABELS.createTransformMRangeWithLabelsArguments = createTransformMRangeWithLabelsArguments;
	MRANGE_WITHLABELS.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets samples for time series matching a filter with labels
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param filter - Filter to match time series keys
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: createTransformMRangeWithLabelsArguments('TS.MRANGE'),
	    transformReply: {
	        2(reply, _, typeMapping) {
	            return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
	                const unwrappedLabels = labels;
	                // TODO: use Map type mapping for labels
	                const labelsObject = Object.create(null);
	                for (const tuple of unwrappedLabels) {
	                    const [key, value] = tuple;
	                    const unwrappedKey = key;
	                    labelsObject[unwrappedKey.toString()] = value;
	                }
	                return {
	                    labels: labelsObject,
	                    samples: helpers_1.transformSamplesReply[2](samples)
	                };
	            }, typeMapping);
	        },
	        3(reply) {
	            return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, samples]) => {
	                return {
	                    labels,
	                    samples: helpers_1.transformSamplesReply[3](samples)
	                };
	            });
	        }
	    },
	};
	
	return MRANGE_WITHLABELS;
}

var MRANGE = {};

var hasRequiredMRANGE;

function requireMRANGE () {
	if (hasRequiredMRANGE) return MRANGE;
	hasRequiredMRANGE = 1;
	Object.defineProperty(MRANGE, "__esModule", { value: true });
	MRANGE.createTransformMRangeArguments = void 0;
	const helpers_1 = requireHelpers();
	const RANGE_1 = requireRANGE();
	const MGET_1 = requireMGET();
	/**
	 * Creates a function that parses arguments for multi-range commands
	 * @param command - The command name to use (TS.MRANGE or TS.MREVRANGE)
	 */
	function createTransformMRangeArguments(command) {
	    return (parser, fromTimestamp, toTimestamp, filter, options) => {
	        parser.push(command);
	        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
	        (0, MGET_1.parseFilterArgument)(parser, filter);
	    };
	}
	MRANGE.createTransformMRangeArguments = createTransformMRangeArguments;
	MRANGE.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Gets samples for time series matching a specific filter within a time range
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param filter - Filter to match time series keys
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: createTransformMRangeArguments('TS.MRANGE'),
	    transformReply: {
	        2(reply, _, typeMapping) {
	            return (0, helpers_1.resp2MapToValue)(reply, ([_key, _labels, samples]) => {
	                return helpers_1.transformSamplesReply[2](samples);
	            }, typeMapping);
	        },
	        3(reply) {
	            return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata, samples]) => {
	                return helpers_1.transformSamplesReply[3](samples);
	            });
	        }
	    },
	};
	
	return MRANGE;
}

var MREVRANGE_GROUPBY = {};

var hasRequiredMREVRANGE_GROUPBY;

function requireMREVRANGE_GROUPBY () {
	if (hasRequiredMREVRANGE_GROUPBY) return MREVRANGE_GROUPBY;
	hasRequiredMREVRANGE_GROUPBY = 1;
	var __createBinding = (MREVRANGE_GROUPBY && MREVRANGE_GROUPBY.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (MREVRANGE_GROUPBY && MREVRANGE_GROUPBY.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (MREVRANGE_GROUPBY && MREVRANGE_GROUPBY.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(MREVRANGE_GROUPBY, "__esModule", { value: true });
	const MRANGE_GROUPBY_1 = __importStar(requireMRANGE_GROUPBY());
	MREVRANGE_GROUPBY.default = {
	    IS_READ_ONLY: MRANGE_GROUPBY_1.default.IS_READ_ONLY,
	    /**
	     * Gets samples for time series matching a filter within a time range with grouping (in reverse order)
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param filter - Filter to match time series keys
	     * @param groupBy - Group by parameters
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: (0, MRANGE_GROUPBY_1.createTransformMRangeGroupByArguments)('TS.MREVRANGE'),
	    transformReply: MRANGE_GROUPBY_1.default.transformReply,
	};
	
	return MREVRANGE_GROUPBY;
}

var MREVRANGE_SELECTED_LABELS_GROUPBY = {};

var hasRequiredMREVRANGE_SELECTED_LABELS_GROUPBY;

function requireMREVRANGE_SELECTED_LABELS_GROUPBY () {
	if (hasRequiredMREVRANGE_SELECTED_LABELS_GROUPBY) return MREVRANGE_SELECTED_LABELS_GROUPBY;
	hasRequiredMREVRANGE_SELECTED_LABELS_GROUPBY = 1;
	var __createBinding = (MREVRANGE_SELECTED_LABELS_GROUPBY && MREVRANGE_SELECTED_LABELS_GROUPBY.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (MREVRANGE_SELECTED_LABELS_GROUPBY && MREVRANGE_SELECTED_LABELS_GROUPBY.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (MREVRANGE_SELECTED_LABELS_GROUPBY && MREVRANGE_SELECTED_LABELS_GROUPBY.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(MREVRANGE_SELECTED_LABELS_GROUPBY, "__esModule", { value: true });
	const MRANGE_SELECTED_LABELS_GROUPBY_1 = __importStar(requireMRANGE_SELECTED_LABELS_GROUPBY());
	MREVRANGE_SELECTED_LABELS_GROUPBY.default = {
	    IS_READ_ONLY: MRANGE_SELECTED_LABELS_GROUPBY_1.default.IS_READ_ONLY,
	    /**
	     * Gets samples for time series matching a filter with selected labels and grouping (in reverse order)
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param selectedLabels - Labels to include in the output
	     * @param filter - Filter to match time series keys
	     * @param groupBy - Group by parameters
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: (0, MRANGE_SELECTED_LABELS_GROUPBY_1.createMRangeSelectedLabelsGroupByTransformArguments)('TS.MREVRANGE'),
	    transformReply: MRANGE_SELECTED_LABELS_GROUPBY_1.default.transformReply,
	};
	
	return MREVRANGE_SELECTED_LABELS_GROUPBY;
}

var MREVRANGE_SELECTED_LABELS = {};

var hasRequiredMREVRANGE_SELECTED_LABELS;

function requireMREVRANGE_SELECTED_LABELS () {
	if (hasRequiredMREVRANGE_SELECTED_LABELS) return MREVRANGE_SELECTED_LABELS;
	hasRequiredMREVRANGE_SELECTED_LABELS = 1;
	var __createBinding = (MREVRANGE_SELECTED_LABELS && MREVRANGE_SELECTED_LABELS.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (MREVRANGE_SELECTED_LABELS && MREVRANGE_SELECTED_LABELS.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (MREVRANGE_SELECTED_LABELS && MREVRANGE_SELECTED_LABELS.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(MREVRANGE_SELECTED_LABELS, "__esModule", { value: true });
	const MRANGE_SELECTED_LABELS_1 = __importStar(requireMRANGE_SELECTED_LABELS());
	MREVRANGE_SELECTED_LABELS.default = {
	    IS_READ_ONLY: MRANGE_SELECTED_LABELS_1.default.IS_READ_ONLY,
	    /**
	     * Gets samples for time series matching a filter with selected labels (in reverse order)
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param selectedLabels - Labels to include in the output
	     * @param filter - Filter to match time series keys
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: (0, MRANGE_SELECTED_LABELS_1.createTransformMRangeSelectedLabelsArguments)('TS.MREVRANGE'),
	    transformReply: MRANGE_SELECTED_LABELS_1.default.transformReply,
	};
	
	return MREVRANGE_SELECTED_LABELS;
}

var MREVRANGE_WITHLABELS_GROUPBY = {};

var hasRequiredMREVRANGE_WITHLABELS_GROUPBY;

function requireMREVRANGE_WITHLABELS_GROUPBY () {
	if (hasRequiredMREVRANGE_WITHLABELS_GROUPBY) return MREVRANGE_WITHLABELS_GROUPBY;
	hasRequiredMREVRANGE_WITHLABELS_GROUPBY = 1;
	var __createBinding = (MREVRANGE_WITHLABELS_GROUPBY && MREVRANGE_WITHLABELS_GROUPBY.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (MREVRANGE_WITHLABELS_GROUPBY && MREVRANGE_WITHLABELS_GROUPBY.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (MREVRANGE_WITHLABELS_GROUPBY && MREVRANGE_WITHLABELS_GROUPBY.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(MREVRANGE_WITHLABELS_GROUPBY, "__esModule", { value: true });
	const MRANGE_WITHLABELS_GROUPBY_1 = __importStar(requireMRANGE_WITHLABELS_GROUPBY());
	MREVRANGE_WITHLABELS_GROUPBY.default = {
	    IS_READ_ONLY: MRANGE_WITHLABELS_GROUPBY_1.default.IS_READ_ONLY,
	    /**
	     * Gets samples for time series matching a filter with labels and grouping (in reverse order)
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param filter - Filter to match time series keys
	     * @param groupBy - Group by parameters
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: (0, MRANGE_WITHLABELS_GROUPBY_1.createMRangeWithLabelsGroupByTransformArguments)('TS.MREVRANGE'),
	    transformReply: MRANGE_WITHLABELS_GROUPBY_1.default.transformReply,
	};
	
	return MREVRANGE_WITHLABELS_GROUPBY;
}

var MREVRANGE_WITHLABELS = {};

var hasRequiredMREVRANGE_WITHLABELS;

function requireMREVRANGE_WITHLABELS () {
	if (hasRequiredMREVRANGE_WITHLABELS) return MREVRANGE_WITHLABELS;
	hasRequiredMREVRANGE_WITHLABELS = 1;
	var __createBinding = (MREVRANGE_WITHLABELS && MREVRANGE_WITHLABELS.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (MREVRANGE_WITHLABELS && MREVRANGE_WITHLABELS.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (MREVRANGE_WITHLABELS && MREVRANGE_WITHLABELS.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(MREVRANGE_WITHLABELS, "__esModule", { value: true });
	const MRANGE_WITHLABELS_1 = __importStar(requireMRANGE_WITHLABELS());
	MREVRANGE_WITHLABELS.default = {
	    NOT_KEYED_COMMAND: MRANGE_WITHLABELS_1.default.NOT_KEYED_COMMAND,
	    IS_READ_ONLY: MRANGE_WITHLABELS_1.default.IS_READ_ONLY,
	    /**
	     * Gets samples for time series matching a filter with labels (in reverse order)
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param filter - Filter to match time series keys
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: (0, MRANGE_WITHLABELS_1.createTransformMRangeWithLabelsArguments)('TS.MREVRANGE'),
	    transformReply: MRANGE_WITHLABELS_1.default.transformReply,
	};
	
	return MREVRANGE_WITHLABELS;
}

var MREVRANGE = {};

var hasRequiredMREVRANGE;

function requireMREVRANGE () {
	if (hasRequiredMREVRANGE) return MREVRANGE;
	hasRequiredMREVRANGE = 1;
	var __createBinding = (MREVRANGE && MREVRANGE.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (MREVRANGE && MREVRANGE.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (MREVRANGE && MREVRANGE.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(MREVRANGE, "__esModule", { value: true });
	const MRANGE_1 = __importStar(requireMRANGE());
	MREVRANGE.default = {
	    NOT_KEYED_COMMAND: MRANGE_1.default.NOT_KEYED_COMMAND,
	    IS_READ_ONLY: MRANGE_1.default.IS_READ_ONLY,
	    /**
	     * Gets samples for time series matching a specific filter within a time range (in reverse order)
	     * @param parser - The command parser
	     * @param fromTimestamp - Start timestamp for range
	     * @param toTimestamp - End timestamp for range
	     * @param filter - Filter to match time series keys
	     * @param options - Optional parameters for the command
	     */
	    parseCommand: (0, MRANGE_1.createTransformMRangeArguments)('TS.MREVRANGE'),
	    transformReply: MRANGE_1.default.transformReply,
	};
	
	return MREVRANGE;
}

var QUERYINDEX = {};

var hasRequiredQUERYINDEX;

function requireQUERYINDEX () {
	if (hasRequiredQUERYINDEX) return QUERYINDEX;
	hasRequiredQUERYINDEX = 1;
	Object.defineProperty(QUERYINDEX, "__esModule", { value: true });
	QUERYINDEX.default = {
	    NOT_KEYED_COMMAND: true,
	    IS_READ_ONLY: true,
	    /**
	     * Queries the index for time series matching a specific filter
	     * @param parser - The command parser
	     * @param filter - Filter to match time series labels
	     */
	    parseCommand(parser, filter) {
	        parser.push('TS.QUERYINDEX');
	        parser.pushVariadic(filter);
	    },
	    transformReply: {
	        2: undefined,
	        3: undefined
	    }
	};
	
	return QUERYINDEX;
}

var REVRANGE = {};

var hasRequiredREVRANGE;

function requireREVRANGE () {
	if (hasRequiredREVRANGE) return REVRANGE;
	hasRequiredREVRANGE = 1;
	var __createBinding = (REVRANGE && REVRANGE.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (REVRANGE && REVRANGE.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (REVRANGE && REVRANGE.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(REVRANGE, "__esModule", { value: true });
	const RANGE_1 = __importStar(requireRANGE());
	REVRANGE.default = {
	    IS_READ_ONLY: RANGE_1.default.IS_READ_ONLY,
	    /**
	     * Gets samples from a time series within a time range (in reverse order)
	     * @param args - Arguments passed to the {@link transformRangeArguments} function
	     */
	    parseCommand(...args) {
	        const parser = args[0];
	        parser.push('TS.REVRANGE');
	        (0, RANGE_1.transformRangeArguments)(...args);
	    },
	    transformReply: RANGE_1.default.transformReply
	};
	
	return REVRANGE;
}

var hasRequiredCommands;

function requireCommands () {
	if (hasRequiredCommands) return commands;
	hasRequiredCommands = 1;
	(function (exports) {
		var __createBinding = (commands && commands.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commands && commands.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		var __importDefault = (commands && commands.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		const ADD_1 = __importDefault(requireADD());
		const ALTER_1 = __importDefault(requireALTER());
		const CREATE_1 = __importDefault(requireCREATE());
		const CREATERULE_1 = __importDefault(requireCREATERULE());
		const DECRBY_1 = __importDefault(requireDECRBY());
		const DEL_1 = __importDefault(requireDEL());
		const DELETERULE_1 = __importDefault(requireDELETERULE());
		const GET_1 = __importDefault(requireGET());
		const INCRBY_1 = __importDefault(requireINCRBY());
		const INFO_DEBUG_1 = __importDefault(requireINFO_DEBUG());
		const INFO_1 = __importDefault(requireINFO());
		const MADD_1 = __importDefault(requireMADD());
		const MGET_SELECTED_LABELS_1 = __importDefault(requireMGET_SELECTED_LABELS());
		const MGET_WITHLABELS_1 = __importDefault(requireMGET_WITHLABELS());
		const MGET_1 = __importDefault(requireMGET());
		const MRANGE_GROUPBY_1 = __importDefault(requireMRANGE_GROUPBY());
		const MRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(requireMRANGE_SELECTED_LABELS_GROUPBY());
		const MRANGE_SELECTED_LABELS_1 = __importDefault(requireMRANGE_SELECTED_LABELS());
		const MRANGE_WITHLABELS_GROUPBY_1 = __importDefault(requireMRANGE_WITHLABELS_GROUPBY());
		const MRANGE_WITHLABELS_1 = __importDefault(requireMRANGE_WITHLABELS());
		const MRANGE_1 = __importDefault(requireMRANGE());
		const MREVRANGE_GROUPBY_1 = __importDefault(requireMREVRANGE_GROUPBY());
		const MREVRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(requireMREVRANGE_SELECTED_LABELS_GROUPBY());
		const MREVRANGE_SELECTED_LABELS_1 = __importDefault(requireMREVRANGE_SELECTED_LABELS());
		const MREVRANGE_WITHLABELS_GROUPBY_1 = __importDefault(requireMREVRANGE_WITHLABELS_GROUPBY());
		const MREVRANGE_WITHLABELS_1 = __importDefault(requireMREVRANGE_WITHLABELS());
		const MREVRANGE_1 = __importDefault(requireMREVRANGE());
		const QUERYINDEX_1 = __importDefault(requireQUERYINDEX());
		const RANGE_1 = __importDefault(requireRANGE());
		const REVRANGE_1 = __importDefault(requireREVRANGE());
		__exportStar(requireHelpers(), exports);
		exports.default = {
		    ADD: ADD_1.default,
		    add: ADD_1.default,
		    ALTER: ALTER_1.default,
		    alter: ALTER_1.default,
		    CREATE: CREATE_1.default,
		    create: CREATE_1.default,
		    CREATERULE: CREATERULE_1.default,
		    createRule: CREATERULE_1.default,
		    DECRBY: DECRBY_1.default,
		    decrBy: DECRBY_1.default,
		    DEL: DEL_1.default,
		    del: DEL_1.default,
		    DELETERULE: DELETERULE_1.default,
		    deleteRule: DELETERULE_1.default,
		    GET: GET_1.default,
		    get: GET_1.default,
		    INCRBY: INCRBY_1.default,
		    incrBy: INCRBY_1.default,
		    INFO_DEBUG: INFO_DEBUG_1.default,
		    infoDebug: INFO_DEBUG_1.default,
		    INFO: INFO_1.default,
		    info: INFO_1.default,
		    MADD: MADD_1.default,
		    mAdd: MADD_1.default,
		    MGET_SELECTED_LABELS: MGET_SELECTED_LABELS_1.default,
		    mGetSelectedLabels: MGET_SELECTED_LABELS_1.default,
		    MGET_WITHLABELS: MGET_WITHLABELS_1.default,
		    mGetWithLabels: MGET_WITHLABELS_1.default,
		    MGET: MGET_1.default,
		    mGet: MGET_1.default,
		    MRANGE_GROUPBY: MRANGE_GROUPBY_1.default,
		    mRangeGroupBy: MRANGE_GROUPBY_1.default,
		    MRANGE_SELECTED_LABELS_GROUPBY: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
		    mRangeSelectedLabelsGroupBy: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
		    MRANGE_SELECTED_LABELS: MRANGE_SELECTED_LABELS_1.default,
		    mRangeSelectedLabels: MRANGE_SELECTED_LABELS_1.default,
		    MRANGE_WITHLABELS_GROUPBY: MRANGE_WITHLABELS_GROUPBY_1.default,
		    mRangeWithLabelsGroupBy: MRANGE_WITHLABELS_GROUPBY_1.default,
		    MRANGE_WITHLABELS: MRANGE_WITHLABELS_1.default,
		    mRangeWithLabels: MRANGE_WITHLABELS_1.default,
		    MRANGE: MRANGE_1.default,
		    mRange: MRANGE_1.default,
		    MREVRANGE_GROUPBY: MREVRANGE_GROUPBY_1.default,
		    mRevRangeGroupBy: MREVRANGE_GROUPBY_1.default,
		    MREVRANGE_SELECTED_LABELS_GROUPBY: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
		    mRevRangeSelectedLabelsGroupBy: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
		    MREVRANGE_SELECTED_LABELS: MREVRANGE_SELECTED_LABELS_1.default,
		    mRevRangeSelectedLabels: MREVRANGE_SELECTED_LABELS_1.default,
		    MREVRANGE_WITHLABELS_GROUPBY: MREVRANGE_WITHLABELS_GROUPBY_1.default,
		    mRevRangeWithLabelsGroupBy: MREVRANGE_WITHLABELS_GROUPBY_1.default,
		    MREVRANGE_WITHLABELS: MREVRANGE_WITHLABELS_1.default,
		    mRevRangeWithLabels: MREVRANGE_WITHLABELS_1.default,
		    MREVRANGE: MREVRANGE_1.default,
		    mRevRange: MREVRANGE_1.default,
		    QUERYINDEX: QUERYINDEX_1.default,
		    queryIndex: QUERYINDEX_1.default,
		    RANGE: RANGE_1.default,
		    range: RANGE_1.default,
		    REVRANGE: REVRANGE_1.default,
		    revRange: REVRANGE_1.default
		};
		
	} (commands));
	return commands;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	(function (exports) {
		var __importDefault = (lib && lib.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.TIME_SERIES_REDUCERS = exports.TIME_SERIES_BUCKET_TIMESTAMP = exports.TIME_SERIES_AGGREGATION_TYPE = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.TIME_SERIES_ENCODING = exports.default = void 0;
		var commands_1 = requireCommands();
		Object.defineProperty(exports, "default", { enumerable: true, get: function () { return __importDefault(commands_1).default; } });
		Object.defineProperty(exports, "TIME_SERIES_ENCODING", { enumerable: true, get: function () { return commands_1.TIME_SERIES_ENCODING; } });
		Object.defineProperty(exports, "TIME_SERIES_DUPLICATE_POLICIES", { enumerable: true, get: function () { return commands_1.TIME_SERIES_DUPLICATE_POLICIES; } });
		var CREATERULE_1 = requireCREATERULE();
		Object.defineProperty(exports, "TIME_SERIES_AGGREGATION_TYPE", { enumerable: true, get: function () { return CREATERULE_1.TIME_SERIES_AGGREGATION_TYPE; } });
		var RANGE_1 = requireRANGE();
		Object.defineProperty(exports, "TIME_SERIES_BUCKET_TIMESTAMP", { enumerable: true, get: function () { return RANGE_1.TIME_SERIES_BUCKET_TIMESTAMP; } });
		var MRANGE_GROUPBY_1 = requireMRANGE_GROUPBY();
		Object.defineProperty(exports, "TIME_SERIES_REDUCERS", { enumerable: true, get: function () { return MRANGE_GROUPBY_1.TIME_SERIES_REDUCERS; } });
		
	} (lib));
	return lib;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist$1;
	hasRequiredDist = 1;
	(function (exports) {
		var __createBinding = (dist$1 && dist$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (dist$1 && dist$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		var __importDefault = (dist$1 && dist$1.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createSentinel = exports.createCluster = exports.createClient = void 0;
		const client_1 = requireDist$1();
		const bloom_1 = __importDefault(requireLib$3());
		const json_1 = __importDefault(requireLib$2());
		const search_1 = __importDefault(requireLib$1());
		const time_series_1 = __importDefault(requireLib());
		__exportStar(requireDist$1(), exports);
		__exportStar(requireLib$3(), exports);
		__exportStar(requireLib$2(), exports);
		__exportStar(requireLib$1(), exports);
		__exportStar(requireLib(), exports);
		const modules = {
		    ...bloom_1.default,
		    json: json_1.default,
		    ft: search_1.default,
		    ts: time_series_1.default
		};
		function createClient(options) {
		    return (0, client_1.createClient)({
		        ...options,
		        modules: {
		            ...modules,
		            ...options?.modules
		        }
		    });
		}
		exports.createClient = createClient;
		function createCluster(options) {
		    return (0, client_1.createCluster)({
		        ...options,
		        modules: {
		            ...modules,
		            ...options?.modules
		        }
		    });
		}
		exports.createCluster = createCluster;
		function createSentinel(options) {
		    return (0, client_1.createSentinel)({
		        ...options,
		        modules: {
		            ...modules,
		            ...options?.modules
		        }
		    });
		}
		exports.createSentinel = createSentinel;
		
	} (dist$1));
	return dist$1;
}

var distExports = requireDist();

// eslint-disable-next-line no-warning-comments
// TODO: Use a better method when it's added to Node.js (https://github.com/nodejs/node/pull/40240)
// Lots of optionals here to support Deno.
const hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;

const format$2 = (open, close) => {
	if (!hasColors) {
		return input => input;
	}

	const openCode = `\u001B[${open}m`;
	const closeCode = `\u001B[${close}m`;

	return input => {
		const string = input + ''; // eslint-disable-line no-implicit-coercion -- This is faster.
		let index = string.indexOf(closeCode);

		if (index === -1) {
			// Note: Intentionally not using string interpolation for performance reasons.
			return openCode + string + closeCode;
		}

		// Handle nested colors.

		// We could have done this, but it's too slow (as of Node.js 22).
		// return openCode + string.replaceAll(closeCode, openCode) + closeCode;

		let result = openCode;
		let lastIndex = 0;

		while (index !== -1) {
			result += string.slice(lastIndex, index) + openCode;
			lastIndex = index + closeCode.length;
			index = string.indexOf(closeCode, lastIndex);
		}

		result += string.slice(lastIndex) + closeCode;

		return result;
	};
};
const bold = format$2(1, 22);
const italic = format$2(3, 23);
const underline = format$2(4, 24);
const red = format$2(31, 39);
const green = format$2(32, 39);
const yellow = format$2(33, 39);
const cyan = format$2(36, 39);
const gray = format$2(90, 39);
const blueBright = format$2(94, 39);

function cap(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function pad(n) {
  return n < 10 ? "0" + n : n.toString();
}
function formatDate(date) {
  const year = date.getFullYear();
  const month = pad(date.getMonth() + 1);
  const day = pad(date.getDate());
  const hours = pad(date.getHours());
  const minutes = pad(date.getMinutes());
  const seconds = pad(date.getSeconds());
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}
var severityValues = /* @__PURE__ */ ((severityValues2) => {
  severityValues2[severityValues2["debug"] = 1] = "debug";
  severityValues2[severityValues2["info"] = 2] = "info";
  severityValues2[severityValues2["warning"] = 3] = "warning";
  severityValues2[severityValues2["error"] = 4] = "error";
  severityValues2[severityValues2["special"] = 5] = "special";
  return severityValues2;
})(severityValues || {});
function severityToColor(severity, text) {
  switch (severity) {
    case "debug":
      return green(text);
    case "info":
      return blueBright(text);
    case "warning":
      return yellow(text);
    case "error":
      return red(text);
    case "special":
      return cyan(underline(text));
    default:
      console.log("Unknown severity " + severity);
      return italic(text);
  }
}
class Logger {
  logColors;
  logLevelInt;
  logSystem;
  logComponent;
  constructor(config, logSystem, logComponent) {
    this.logColors = typeof config?.logColors !== "undefined" ? config.logColors : true;
    this.logLevelInt = severityValues[config?.logLevel || "debug"];
    this.logSystem = logSystem;
    this.logComponent = logComponent;
  }
  log(severity, system, component, text, subcat) {
    if (severityValues[severity] < this.logLevelInt) {
      return;
    }
    let entryDesc = formatDate(/* @__PURE__ */ new Date()) + " [" + system + "]	";
    let logString = "";
    if (this.logColors) {
      entryDesc = severityToColor(severity, entryDesc);
      logString = entryDesc;
      if (component) {
        logString += italic("[" + component + "] ");
      }
      if (subcat) {
        logString += gray(bold("(" + subcat + ") "));
      }
      if (!component) {
        logString += text;
      } else {
        logString += gray(text);
      }
    } else {
      logString = entryDesc;
      if (component) {
        logString += "[" + component + "] ";
      }
      if (subcat) {
        logString += "(" + subcat + ") ";
      }
      logString += text;
    }
    console.log(logString);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleLog(logLevel, ...args) {
    const logSystem = this.logSystem;
    const logComponent = this.logComponent;
    if (!logSystem && args.length === 1) {
      return this.log(logLevel, cap(logLevel), logComponent, args[0]);
    }
    if (!logSystem && args.length === 2) {
      return this.log(logLevel, args[0], logComponent, args[1]);
    }
    if (logSystem && args.length === 1) {
      return this.log(logLevel, logSystem, logComponent, args[0]);
    }
    if (logSystem && args.length === 2) {
      return this.log(logLevel, logSystem, args[0], args[1]);
    }
    if (args.length === 3) {
      return this.log(logLevel, args[0], args[1], args[2]);
    }
    return this.log(logLevel, args[0], args[1], args[2], args[3]);
  }
  debug(...args) {
    this.handleLog("debug", ...args);
  }
  info(...args) {
    this.handleLog("info", ...args);
  }
  warning(...args) {
    this.handleLog("warning", ...args);
  }
  error(...args) {
    this.handleLog("error", ...args);
  }
  special(...args) {
    this.handleLog("special", ...args);
  }
}

function fromShannon(bal) {
  return parseUnits$1(bal, "gwei");
}
class BlockData {
  height;
  roundHeight;
  timestamp;
  difficulty;
  totalShares;
  uncle;
  uncleHeight;
  orphan;
  hash;
  nonce;
  powHash;
  mixDigest;
  reward;
  confirmed;
  // redis key in full string
  // candidate => "nonce:powHash:mixDigest:timestamp:diff:totalShares"
  // immature => "uncleHeight:orphan:nonce:blockHash:timestamp:diff:totalShares:rewardInWei"
  candidateKey;
  immatureKey;
  shares;
  shareRewards;
  constructor(params) {
    this.height = params.height;
    this.roundHeight = params.height;
    this.timestamp = params.timestamp;
    this.difficulty = params.difficulty;
    this.totalShares = params.totalShares;
    this.uncle = params.uncle || false;
    this.uncleHeight = params.uncleHeight || 0;
    this.orphan = params.orphan || false;
    this.hash = params.hash;
    this.nonce = params.nonce;
    this.powHash = params.powHash;
    this.mixDigest = params.mixDigest;
    this.reward = params.reward || 0n;
    this.confirmed = false;
    this.candidateKey = params.candidateKey;
    this.immatureKey = params.immatureKey;
    this.shares = {};
    this.shareRewards = {};
  }
  key() {
    const { uncleHeight, orphan, nonce, hash, timestamp, difficulty, totalShares, reward } = this;
    const orphanNum = !orphan ? 0 : 1;
    const sHash = hash || "0x0";
    return `${uncleHeight}:${orphanNum}:${nonce}:${sHash}:${timestamp}:${difficulty}:${totalShares}:${reward}`;
  }
  static parseCandidate(height, candidateKey) {
    const params = candidateKey.split(":");
    return new BlockData({
      height,
      nonce: params[0],
      powHash: params[1],
      mixDigest: params[2],
      timestamp: parseInt(params[3]),
      difficulty: BigInt(params[4]),
      totalShares: BigInt(params[5]),
      candidateKey
    });
  }
  static parseImmutable(height, immatureKey) {
    const params = immatureKey.split(":");
    const uncleHeight = Number(params[0]);
    return new BlockData({
      height,
      uncle: uncleHeight > 0,
      uncleHeight,
      orphan: Boolean(parseInt(params[1])),
      nonce: params[2],
      hash: params[3],
      timestamp: parseInt(params[4]),
      difficulty: BigInt(params[5]),
      totalShares: BigInt(params[6]),
      reward: BigInt(params[7]),
      immatureKey
    });
  }
}
async function getCandidates(unlocker) {
  await unlocker.redisConnect;
  const { redisClient, coin, depth, immatureDepth } = unlocker;
  const provider = await unlocker.provider;
  const latestBlock = await provider.getBlockNumber();
  const result = await redisClient.multi().zRangeByScoreWithScores(`${coin}:blocks:immature`, 0, latestBlock - depth).zRangeByScoreWithScores(`${coin}:blocks:candidates`, 0, latestBlock - immatureDepth).exec();
  const blocks = [
    ...result[0].map(({ score, value }) => BlockData.parseImmutable(score, value)),
    ...result[1].map(({ score, value }) => BlockData.parseCandidate(score, value))
  ];
  let sharesMulti = redisClient.multi();
  for (const block of blocks) {
    sharesMulti = sharesMulti.HGETALL(`${coin}:shares:round${block.height}:${block.nonce}`);
  }
  const shares = await sharesMulti.exec();
  const balances = {};
  blocks.forEach((block, i) => {
    Object.entries(shares[i]).forEach(([key, value]) => {
      block.shares[key] = BigInt(value);
      block.shareRewards[key] = 0n;
      balances[key] = 0n;
    });
  });
  const balKeys = Object.keys(balances);
  let balanceMulti = redisClient.multi();
  balKeys.forEach((miner) => {
    balanceMulti = balanceMulti.hGet(`${coin}:miners:${miner}`, "balance");
  });
  (await balanceMulti.exec()).forEach((bal, i) => {
    if (bal) {
      balances[balKeys[i]] = fromShannon(bal);
    }
  });
  return {
    latestBlock,
    blocks,
    balances
  };
}

const GAS_LIMIT = 42000n;
async function getTxParams(unlocker) {
  const provider = await unlocker.provider;
  const signer = await unlocker.signer;
  const [feeData, balance, nonce] = await Promise.all([
    provider.getFeeData(),
    provider.getBalance(signer.address),
    provider.getTransactionCount(signer.address, "pending")
  ]);
  const tx = {
    from: signer.address,
    nonce
  };
  let gasPrice = 0n;
  if (feeData?.maxFeePerGas) {
    tx.type = 2;
    tx.maxFeePerGas = feeData.maxFeePerGas;
    tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
    gasPrice = feeData.maxFeePerGas + feeData.maxPriorityFeePerGas;
  } else if (feeData?.gasPrice) {
    tx.type = 0;
    tx.gasPrice = feeData.gasPrice * 13n / 10n;
    gasPrice = tx.gasPrice;
  }
  const gasCost = GAS_LIMIT * gasPrice;
  return { tx, balance, gasPrice, gasCost };
}
function initMiners(balances) {
  const miners = {};
  for (const bal in balances) {
    miners[bal] = {
      immature: 0n,
      balance: 0n,
      pending: BigInt(balances[bal]),
      paid: 0n
    };
  }
  return miners;
}
async function sendPayments(unlocker, miners, txParams, poolFees) {
  const logger = new Logger(void 0, "Sender");
  const signer = await unlocker.signer;
  const addresses = [];
  const amounts = [];
  if (poolFees && unlocker.poolFeeAddress && unlocker.poolFeeAddress !== signer.address) {
    addresses.push(unlocker.poolFeeAddress);
    amounts.push(poolFees);
  }
  for (const miner in miners) {
    addresses.push(miner);
    amounts.push(miners[miner].pending);
  }
  if (addresses.length) {
    try {
      const resp = await unlocker.Sender.send(addresses, amounts, GAS_LIMIT, txParams);
      const payments = addresses.map((to, i) => {
        const amount = amounts[i];
        if (miners[to]) {
          miners[to].paid = amount;
          miners[to].pending = 0n;
        }
        logger.debug(
          `Sent ${formatEther(amount)} to ${to} (hash: ${resp.hash}, nonce: ${resp.nonce})`
        );
        return {
          timestamp: Math.floor(Date.now() / 1e3),
          hash: resp.hash,
          to,
          amount
        };
      });
      return payments;
    } catch (err) {
      logger.error("Sender expected to fail, reverting to balance");
      console.log(err);
      for (const miner in miners) {
        miners[miner].balance = BigInt(miners[miner].pending);
        miners[miner].pending = 0n;
      }
    }
  }
  return [];
}
async function processPayments(unlocker, miners, txParams, poolFees) {
  if (unlocker.Sender) {
    return sendPayments(unlocker, miners, txParams, poolFees);
  }
  const logger = new Logger(void 0, "Send");
  const provider = await unlocker.provider;
  const signer = await unlocker.signer;
  const tx = { ...txParams };
  const payments = [];
  if (poolFees && unlocker.poolFeeAddress && unlocker.poolFeeAddress !== signer.address) {
    try {
      const poolFeeAddress = getAddress(unlocker.poolFeeAddress);
      tx.to = poolFeeAddress;
      tx.value = poolFees;
      tx.gasLimit = await provider.estimateGas(tx);
      if (tx.gasLimit > GAS_LIMIT) {
        throw new Error("Gas limit exceeds limit");
      } else if (tx.gasLimit > 21000n) {
        tx.gasLimit = GAS_LIMIT;
      }
      const resp = await signer.sendTransaction(tx);
      payments.push({
        timestamp: Math.floor(Date.now() / 1e3),
        hash: resp.hash,
        to: poolFeeAddress.toLowerCase(),
        amount: tx.value
      });
      tx.nonce++;
      logger.debug(
        `Sent ${formatEther(tx.value)} to ${tx.to} (hash: ${resp.hash}, nonce: ${tx.nonce - 1})`
      );
    } catch (err) {
      logger.error("Pool fee payment failed with unknown error");
      console.log(err);
    }
  }
  for (const miner in miners) {
    if (!miners[miner].pending) {
      continue;
    }
    try {
      tx.to = getAddress(miner);
      tx.value = BigInt(miners[miner].pending);
      tx.gasLimit = await provider.estimateGas(tx);
      if (tx.gasLimit > GAS_LIMIT) {
        throw new Error("Gas limit exceeds limit");
      } else if (tx.gasLimit > 21000n) {
        tx.gasLimit = GAS_LIMIT;
      }
      const resp = await signer.sendTransaction(tx);
      payments.push({
        timestamp: Math.floor(Date.now() / 1e3),
        hash: resp.hash,
        to: miner,
        amount: tx.value
      });
      miners[miner].paid = tx.value;
      miners[miner].pending = 0n;
      tx.nonce++;
      logger.debug(
        `Sent ${formatEther(tx.value)} to ${tx.to} (hash: ${resp.hash}, nonce: ${tx.nonce - 1})`
      );
    } catch (err) {
      logger.error("Payment expected to fail, crediting payments to balance");
      console.log(err);
      miners[miner].balance = BigInt(miners[miner].pending);
      miners[miner].pending = 0n;
    }
  }
  return payments;
}
async function calculateRewards(unlocker, candidates, balances) {
  const logger = new Logger(void 0, "Rewards");
  const signer = await unlocker.signer;
  const miners = initMiners(balances);
  candidates.forEach((candidate) => {
    if (candidate.orphan) {
      return;
    }
    for (const miner in candidate.shares) {
      const share = candidate.shares[miner];
      const rewards = candidate.reward * share / candidate.totalShares;
      candidate.shareRewards[miner] = rewards;
      if (candidate.confirmed) {
        miners[miner].pending += rewards;
      } else {
        miners[miner].immature += rewards;
      }
    }
  });
  const { tx, balance: poolBalance, gasPrice, gasCost } = await getTxParams(unlocker);
  logger.debug(
    `PoolBalance: ${formatEther(poolBalance)}, GasPrice: ${formatUnits(gasPrice, "gwei")} gwei, GasCost: ${formatEther(gasCost)}`
  );
  let totalPending = 0n, totalImmature = 0n, totalBalance = 0n, totalFees = 0n;
  for (const miner in miners) {
    if (miners[miner].pending < unlocker.thresold || miners[miner].pending < gasCost) {
      miners[miner].balance = BigInt(miners[miner].pending);
      miners[miner].pending = 0n;
      continue;
    }
    const poolFees = miners[miner].pending * (unlocker.poolFee || 0n) / 100n;
    miners[miner].pending -= poolFees;
    totalFees += poolFees;
    miners[miner].pending -= gasCost;
    totalPending += miners[miner].pending;
    totalImmature += miners[miner].immature;
    totalBalance += miners[miner].balance;
    logger.debug(
      `Miner ${miner}: toPay: ${formatEther(miners[miner].pending)}, immature: ${formatEther(miners[miner].immature)}, bal: ${formatEther(miners[miner].balance)}`
    );
  }
  if (totalFees) {
    if (totalFees < gasCost) {
      logger.debug(
        `Omitting fees payment due to lower amount than gas costs ${formatEther(totalFees)}`
      );
      totalFees = 0n;
    } else {
      totalFees -= gasCost;
    }
  }
  if (poolBalance < totalPending) {
    const errMsg = `Signer ${signer.address} balance ${formatEther(poolBalance)} under payment ${formatEther(totalPending)}`;
    throw new Error(errMsg);
  }
  logger.debug(
    `Total toPay: ${formatEther(totalPending)}, immature: ${formatEther(totalImmature)}, balance: ${formatEther(totalBalance)}, poolFees: ${formatEther(totalFees)}`
  );
  const payments = totalPending ? await processPayments(unlocker, miners, tx, totalFees) : [];
  return { miners, payments, poolFees: totalFees };
}

function calculateTxFees(receipts) {
  return receipts.reduce((acc, curr) => {
    acc += curr.gasPrice * curr.gasUsed;
    return acc;
  }, 0n);
}
async function getBlock(provider, blockTag) {
  const blockHashOrNum = provider._getBlockTag(blockTag);
  const [rawBlock, rawReceipts] = await Promise.all([
    provider.send("eth_getBlockByNumber", [blockHashOrNum, false]),
    provider.send("eth_getBlockReceipts", [blockHashOrNum])
  ]);
  if (!rawBlock) {
    return null;
  }
  const rawUncles = await Promise.all(
    (rawBlock.uncles || []).map((u) => provider.send("eth_getBlockByHash", [u, false]))
  );
  const block = provider._wrapBlock(rawBlock, provider._network);
  block.uncles = rawUncles.filter((u) => u).map((r) => provider._wrapBlock(r, provider._network));
  block.receipts = (rawReceipts || []).map(
    (r) => provider._wrapTransactionReceipt(r, provider._network)
  );
  block.txFees = calculateTxFees(block.receipts);
  return block;
}

var ChainId = /* @__PURE__ */ ((ChainId2) => {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["CPUCHAIN"] = 6516853] = "CPUCHAIN";
  return ChainId2;
})(ChainId || {});
const blockRewards = {
  [1 /* MAINNET */]: {
    // homestead
    0: parseEther("5"),
    // byzantium
    437e4: parseEther("3"),
    // constantinople
    728e4: parseEther("2")
  },
  [6516853 /* CPUCHAIN */]: {
    // for debug, should get live rewards from contract
    0: parseEther("2")
  }
};
function getConstReward(chainId, height) {
  const rewardMap = Object.entries(blockRewards[chainId] || blockRewards[1 /* MAINNET */]).sort(
    ([a], [b]) => Number(b) - Number(a)
  );
  for (const [forkHeight, blockReward] of rewardMap) {
    if (height > Number(forkHeight)) {
      return blockReward;
    }
  }
  return rewardMap[rewardMap.length - 1][1];
}
function getRewardForUncle(chainId, height, uncleCount) {
  return BigInt(uncleCount) * getConstReward(chainId, height) / 32n;
}
function getUncleReward(chainId, height, uncleHeight) {
  const reward = getConstReward(chainId, height);
  const k = Math.min(height - uncleHeight, 8);
  return reward * BigInt(8 - k) / 8n;
}

function findBlocks(blocks, candidate, reorgDepth) {
  return blocks.find((b) => {
    return b && b.number < candidate.height + reorgDepth && b.number > candidate.height - reorgDepth && b.nonce === candidate.nonce;
  });
}
async function getContractRewards(unlocker, blocks) {
  if (!unlocker.ConsensusView || !unlocker.Multicall) {
    return {};
  }
  const coinbase = getAddress(unlocker.coinbase);
  const Multicall2 = unlocker.Multicall;
  const ConsensusView2 = unlocker.ConsensusView;
  return (await Multicall2.aggregate3.staticCall(
    blocks.map((b) => {
      return {
        target: ConsensusView2.target,
        callData: ConsensusView2.interface.encodeFunctionData("getBlockRewards", [b, coinbase]),
        allowFailure: false
      };
    })
  )).reduce(
    (acc, [, data], i) => {
      const block = blocks[i];
      const [, addresses, rewards] = ConsensusView2.interface.decodeFunctionResult(
        "getBlockRewards",
        data
      );
      if (!acc[block]) {
        acc[block] = 0n;
      }
      addresses.forEach((addr, j) => {
        if (addr === coinbase) {
          acc[block] += rewards[j];
        }
      });
      return acc;
    },
    {}
  );
}
async function unlockCandidates(unlocker, candidates, latestBlock) {
  const logger = new Logger(void 0, "Candidates");
  let confirmedCount = 0, blockCount = 0, uncleCount = 0, orphanCount = 0;
  const { chainId } = unlocker;
  const blockNumbers = [...new Set(candidates.map((c) => c.height))];
  const provider = await unlocker.provider;
  const rpcBlocks = await Promise.all(blockNumbers.map((b) => getBlock(provider, b)));
  const contractRewards = await getContractRewards(unlocker, blockNumbers);
  const rpcUncles = rpcBlocks.map((b) => b?.uncles || []).flat();
  candidates.forEach((candidate) => {
    const blockOnHeight = rpcBlocks.find((b) => b?.number === candidate.height);
    const otherBlock = findBlocks(rpcBlocks, candidate, unlocker.depth);
    const uncle = findBlocks(rpcUncles, candidate, unlocker.depth);
    if (!blockOnHeight) {
      orphanCount++;
      candidate.orphan = true;
      logger.warning(
        `Error while retrieving block ${candidate.height}, considering it orphaned while it could be RPC error`
      );
      return;
    }
    const isSameBlock = blockOnHeight.hash === candidate.hash || blockOnHeight.nonce === candidate.nonce;
    const isOtherBlock = !isSameBlock && otherBlock;
    if (isSameBlock || isOtherBlock) {
      const foundBlock = isSameBlock ? blockOnHeight : otherBlock;
      const blockRewards = contractRewards[foundBlock.number] || getConstReward(chainId, foundBlock.number);
      const uncleRewards = contractRewards[foundBlock.number] ? 0n : getRewardForUncle(chainId, foundBlock.number, foundBlock.uncles?.length || 0);
      const txFees = foundBlock.txFees || 0n;
      const confirmed = foundBlock.number + unlocker.depth < latestBlock;
      if (confirmed) {
        confirmedCount++;
      }
      blockCount++;
      candidate.confirmed = confirmed;
      candidate.height = foundBlock.number;
      candidate.hash = foundBlock.hash;
      candidate.reward = blockRewards + uncleRewards + txFees;
      logger.debug(
        `${confirmed ? "Confirmed" : "Mature"} ${isSameBlock ? "block" : "other block"} ${foundBlock.number} with ${Object.keys(candidate.shares).length} miners, ${foundBlock.transactions.length} txs, hash: ${foundBlock.hash} ( blockRewards: ${formatEther(blockRewards)}, uncleRewards: ${formatEther(uncleRewards)}, txFees: ${formatEther(txFees)} )`
      );
      return;
    }
    if (uncle && (uncle.hash === candidate.hash || uncle.nonce === candidate.nonce)) {
      const uncleRewards = contractRewards[candidate.height] ? 0n : getUncleReward(chainId, candidate.height, uncle.number);
      const confirmed = uncle.number + unlocker.depth < latestBlock;
      if (confirmed) {
        confirmedCount++;
      }
      uncleCount++;
      candidate.confirmed = confirmed;
      candidate.uncle = true;
      candidate.uncleHeight = uncle.number;
      candidate.hash = uncle.hash;
      candidate.reward = uncleRewards;
      logger.debug(
        `${confirmed ? "Confirmed" : "Mature"} uncle ${candidate.height}/${uncle.number} of reward ${formatEther(uncleRewards)} with hash: ${candidate.hash}`
      );
      return;
    }
    orphanCount++;
    candidate.orphan = true;
    logger.warning(`Orphaned block ${candidate.height}:${candidate.nonce}`);
  });
  logger.debug(
    `blocks: ${blockCount}, confirmed: ${confirmedCount}, uncles: ${uncleCount}, orphans: ${orphanCount}`
  );
}

function toShannon(amount) {
  return Number(formatUnits(amount, "gwei")).toFixed(0);
}
function toShannonNum(amount) {
  return Math.floor(Number(formatUnits(amount, "gwei")));
}
async function writeBlocks(unlocker, blocks, miners, payments, poolFees) {
  const logger = new Logger(void 0, "Write");
  const { coin, window, blockWindow, redisClient } = unlocker;
  const now = Math.floor(Date.now() / 1e3);
  let writeMulti = redisClient.multi().zRemRangeByScore(`${coin}:payments:all`, 0, `(${now - window}`);
  let lastCreditBlock = null;
  blocks.forEach((block) => {
    if (!block.confirmed) {
      if (block.height != block.roundHeight) {
        writeMulti = writeMulti.rename(
          `${coin}:shares:round${block.roundHeight}:${block.nonce}`,
          `${coin}:shares:round${block.height}:${block.nonce}`
        );
      }
      if (block.candidateKey) {
        writeMulti = writeMulti.zRem(`${coin}:blocks:candidates`, block.candidateKey);
      }
      if (!block.immatureKey) {
        writeMulti = writeMulti.zAdd(`${coin}:blocks:immature`, {
          score: block.height,
          value: block.key()
        });
        Object.entries(block.shareRewards).forEach(([miner, rewards]) => {
          writeMulti = writeMulti.hSetNX(
            `${coin}:credits:immature:${block.height}:${block.hash}`,
            miner,
            toShannon(rewards)
          );
        });
      }
    } else {
      if (block.height != block.roundHeight) {
        writeMulti = writeMulti.del(`${coin}:shares:round${block.roundHeight}:${block.nonce}`);
      } else {
        writeMulti = writeMulti.del(`${coin}:shares:round${block.height}:${block.nonce}`);
      }
      if (block.candidateKey) {
        writeMulti = writeMulti.zRem(`${coin}:blocks:candidates`, block.candidateKey);
      }
      if (block.immatureKey) {
        writeMulti = writeMulti.zRem(`${coin}:blocks:immature`, block.immatureKey).del(`${coin}:credits:immature:${block.height}:${block.hash}`);
      }
      writeMulti = writeMulti.zAdd(`${coin}:blocks:matured`, {
        score: block.height,
        value: block.key()
      });
      writeMulti = writeMulti.zAdd(`${coin}:credits:all`, {
        score: block.height,
        value: `${block.hash}:${block.timestamp}:${toShannon(block.reward)}`
      });
      if (!lastCreditBlock || lastCreditBlock.height > block.height) {
        lastCreditBlock = block;
      }
    }
  });
  if (lastCreditBlock) {
    writeMulti = writeMulti.zRemRangeByScore(
      `${coin}:blocks:matured`,
      "-inf",
      `(${lastCreditBlock.height - blockWindow}`
    ).zRemRangeByScore(
      `${coin}:credits:all`,
      "-inf",
      `(${lastCreditBlock.height - blockWindow}`
    );
  }
  let totalImmature = 0n, totalBalance = 0n, totalPending = 0n, totalPaid = 0n;
  Object.entries(miners).forEach(([miner, { immature, balance, pending, paid }]) => {
    totalImmature += immature;
    totalBalance += balance;
    totalPending += pending;
    totalPaid += paid;
    writeMulti = writeMulti.hSet(`${coin}:miners:${miner}`, "immature", toShannon(immature)).hSet(`${coin}:miners:${miner}`, "balance", toShannon(balance)).hSet(`${coin}:miners:${miner}`, "pending", toShannon(pending)).hIncrByFloat(`${coin}:miners:${miner}`, "paid", toShannonNum(paid));
  });
  writeMulti = writeMulti.hSet(`${coin}:finances`, "immature", toShannon(totalImmature)).hSet(`${coin}:finances`, "balance", toShannon(totalBalance)).hSet(`${coin}:finances`, "pending", toShannon(totalPending)).hIncrByFloat(`${coin}:finances`, "poolFees", toShannonNum(poolFees)).hIncrByFloat(`${coin}:finances`, "paid", toShannonNum(totalPaid)).hIncrByFloat(`${coin}:finances`, "totalMined", toShannonNum(totalPaid));
  payments.forEach(({ timestamp, hash, to, amount }) => {
    writeMulti = writeMulti.zRemRangeByScore(`${coin}:payments:${to}`, 0, `(${now - window}`).zAdd(`${coin}:payments:${to}`, { score: timestamp, value: `${hash}:${toShannon(amount)}` }).zAdd(`${coin}:payments:all`, { score: timestamp, value: `${hash}:${to}:${toShannon(amount)}` });
  });
  await writeMulti.exec();
  logger.debug(
    `Wrote ${Object.keys(blocks).length} blocks, ${Object.keys(miners).length} miners, ${payments.length} txs, paid: ${formatEther(totalPaid)}, pending: ${formatEther(totalPending)}, immature: ${formatEther(totalImmature)}, balance: ${formatEther(totalBalance)}`
  );
}

const _abi$2 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    name: "Sent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "newImplementation",
        type: "address"
      }
    ],
    name: "UpdatedImplementation",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "UpdatedOwner",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "nHeight",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "coinbase",
        type: "address"
      }
    ],
    name: "getBlockRewards",
    outputs: [
      {
        internalType: "bool",
        name: "staked",
        type: "bool"
      },
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "rewards",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "nHeight",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "coinbase",
        type: "address"
      }
    ],
    name: "getBlockRewardsRef",
    outputs: [
      {
        internalType: "bool",
        name: "staked",
        type: "bool"
      },
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "rewards",
        type: "uint256[]"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "init",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "gasLimit",
        type: "uint256"
      }
    ],
    name: "send",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      }
    ],
    name: "updateImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "updateOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
class ConsensusView__factory {
  static abi = _abi$2;
  static createInterface() {
    return new Interface(_abi$2);
  }
  static connect(address, runner) {
    return new Contract(address, _abi$2, runner);
  }
}

const _abi$1 = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate",
    outputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes[]",
        name: "returnData",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bool",
            name: "allowFailure",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Call3[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bool",
            name: "allowFailure",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Call3Value[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3Value",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "blockAndAggregate",
    outputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      },
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "getBasefee",
    outputs: [
      {
        internalType: "uint256",
        name: "basefee",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      }
    ],
    name: "getBlockHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getBlockNumber",
    outputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getChainId",
    outputs: [
      {
        internalType: "uint256",
        name: "chainid",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockCoinbase",
    outputs: [
      {
        internalType: "address",
        name: "coinbase",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockDifficulty",
    outputs: [
      {
        internalType: "uint256",
        name: "difficulty",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockGasLimit",
    outputs: [
      {
        internalType: "uint256",
        name: "gaslimit",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "addr",
        type: "address"
      }
    ],
    name: "getEthBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastBlockHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "requireSuccess",
        type: "bool"
      },
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "tryAggregate",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "requireSuccess",
        type: "bool"
      },
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "tryBlockAndAggregate",
    outputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      },
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  }
];
class Multicall__factory {
  static abi = _abi$1;
  static createInterface() {
    return new Interface(_abi$1);
  }
  static connect(address, runner) {
    return new Contract(address, _abi$1, runner);
  }
}

const _abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    name: "Sent",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "gasLimit",
        type: "uint256"
      }
    ],
    name: "send",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];
class Sender__factory {
  static abi = _abi;
  static createInterface() {
    return new Interface(_abi);
  }
  static connect(address, runner) {
    return new Contract(address, _abi, runner);
  }
}

const contracts = {
  [ChainId.CPUCHAIN]: {
    multicall: "0xcA11bde05977b3631167028862bE2a173976CA11",
    consensusView: "0x0000000000000000000000000000000000637075",
    sender: "0x0000000000000000000000000000000000637075"
  }
};
async function getCoinbase(provider) {
  return getAddress(await provider.send("eth_coinbase", []));
}
async function getProvider(unlocker) {
  const { providerUrl, providerTimeout } = unlocker;
  const request = new FetchRequest(providerUrl);
  request.timeout = providerTimeout;
  const staticNetwork = await new JsonRpcProvider(request).getNetwork();
  const chainId = Number(staticNetwork.chainId);
  const provider = new JsonRpcProvider(request, staticNetwork, {
    staticNetwork
  });
  unlocker.chainId = chainId;
  if (contracts[chainId]) {
    unlocker.Multicall = Multicall__factory.connect(contracts[chainId].multicall, provider);
    unlocker.ConsensusView = ConsensusView__factory.connect(contracts[chainId].consensusView, provider);
  }
  return provider;
}
async function getSigner(unlocker) {
  const provider = await unlocker.provider;
  const signer = new JsonRpcSigner(provider, unlocker.coinbase ||= await getCoinbase(provider));
  if (contracts[unlocker.chainId]) {
    unlocker.Sender = Sender__factory.connect(contracts[unlocker.chainId].sender, signer);
  }
  return signer;
}
async function unlockPool(unlocker) {
  const { redisClient, bgSave } = unlocker;
  const { latestBlock, blocks, balances } = await getCandidates(unlocker);
  await unlockCandidates(unlocker, blocks, latestBlock);
  const { miners, payments, poolFees } = await calculateRewards(unlocker, blocks, balances);
  await writeBlocks(unlocker, blocks, miners, payments, poolFees);
  if (bgSave) {
    await redisClient.bgSave();
  }
}
class Unlocker {
  redisClient;
  redisConnect;
  bgSave;
  provider;
  providerUrl;
  providerTimeout;
  signer;
  coin;
  poolFee;
  poolFeeAddress;
  depth;
  immatureDepth;
  window;
  blockWindow;
  interval;
  coinbase;
  thresold;
  chainId;
  Multicall;
  ConsensusView;
  Sender;
  locked;
  constructor({
    redisUrl,
    bgSave,
    providerUrl,
    providerTimeout,
    coin,
    poolFee,
    poolFeeAddress,
    depth,
    immatureDepth,
    window,
    blockWindow,
    interval,
    coinbase,
    thresold
  }) {
    this.redisClient = distExports.createClient({
      url: `redis://${redisUrl}`
    });
    this.redisConnect = this.redisClient.connect();
    this.bgSave = bgSave ?? true;
    this.providerUrl = providerUrl;
    this.providerTimeout = providerTimeout;
    this.provider = getProvider(this);
    this.signer = getSigner(this);
    this.coin = coin;
    this.poolFee = poolFee;
    this.poolFeeAddress = poolFeeAddress;
    this.depth = depth;
    this.immatureDepth = immatureDepth;
    this.window = window;
    this.blockWindow = blockWindow;
    this.interval = interval;
    this.coinbase = coinbase;
    this.thresold = thresold;
    this.chainId = 1;
    this.locked = false;
  }
  async unlock() {
    if (this.locked) {
      return;
    }
    this.locked = true;
    const logger = new Logger(void 0, "Unlocker");
    try {
      await unlockPool(this);
    } catch (err) {
      logger.error(`Error while processing pool unlock / payouts`);
      console.log(err);
    }
    this.locked = false;
  }
}

var ajv = {exports: {}};

var core$1 = {};

var validate = {};

var boolSchema = {};

var errors = {};

var codegen = {};

var code$1 = {};

var hasRequiredCode$1;

function requireCode$1 () {
	if (hasRequiredCode$1) return code$1;
	hasRequiredCode$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
		// eslint-disable-next-line @typescript-eslint/no-extraneous-class
		class _CodeOrName {
		}
		exports._CodeOrName = _CodeOrName;
		exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
		class Name extends _CodeOrName {
		    constructor(s) {
		        super();
		        if (!exports.IDENTIFIER.test(s))
		            throw new Error("CodeGen: name must be a valid identifier");
		        this.str = s;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        return false;
		    }
		    get names() {
		        return { [this.str]: 1 };
		    }
		}
		exports.Name = Name;
		class _Code extends _CodeOrName {
		    constructor(code) {
		        super();
		        this._items = typeof code === "string" ? [code] : code;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        if (this._items.length > 1)
		            return false;
		        const item = this._items[0];
		        return item === "" || item === '""';
		    }
		    get str() {
		        var _a;
		        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
		    }
		    get names() {
		        var _a;
		        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
		            if (c instanceof Name)
		                names[c.str] = (names[c.str] || 0) + 1;
		            return names;
		        }, {})));
		    }
		}
		exports._Code = _Code;
		exports.nil = new _Code("");
		function _(strs, ...args) {
		    const code = [strs[0]];
		    let i = 0;
		    while (i < args.length) {
		        addCodeArg(code, args[i]);
		        code.push(strs[++i]);
		    }
		    return new _Code(code);
		}
		exports._ = _;
		const plus = new _Code("+");
		function str(strs, ...args) {
		    const expr = [safeStringify(strs[0])];
		    let i = 0;
		    while (i < args.length) {
		        expr.push(plus);
		        addCodeArg(expr, args[i]);
		        expr.push(plus, safeStringify(strs[++i]));
		    }
		    optimize(expr);
		    return new _Code(expr);
		}
		exports.str = str;
		function addCodeArg(code, arg) {
		    if (arg instanceof _Code)
		        code.push(...arg._items);
		    else if (arg instanceof Name)
		        code.push(arg);
		    else
		        code.push(interpolate(arg));
		}
		exports.addCodeArg = addCodeArg;
		function optimize(expr) {
		    let i = 1;
		    while (i < expr.length - 1) {
		        if (expr[i] === plus) {
		            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
		            if (res !== undefined) {
		                expr.splice(i - 1, 3, res);
		                continue;
		            }
		            expr[i++] = "+";
		        }
		        i++;
		    }
		}
		function mergeExprItems(a, b) {
		    if (b === '""')
		        return a;
		    if (a === '""')
		        return b;
		    if (typeof a == "string") {
		        if (b instanceof Name || a[a.length - 1] !== '"')
		            return;
		        if (typeof b != "string")
		            return `${a.slice(0, -1)}${b}"`;
		        if (b[0] === '"')
		            return a.slice(0, -1) + b.slice(1);
		        return;
		    }
		    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
		        return `"${a}${b.slice(1)}`;
		    return;
		}
		function strConcat(c1, c2) {
		    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
		}
		exports.strConcat = strConcat;
		// TODO do not allow arrays here
		function interpolate(x) {
		    return typeof x == "number" || typeof x == "boolean" || x === null
		        ? x
		        : safeStringify(Array.isArray(x) ? x.join(",") : x);
		}
		function stringify(x) {
		    return new _Code(safeStringify(x));
		}
		exports.stringify = stringify;
		function safeStringify(x) {
		    return JSON.stringify(x)
		        .replace(/\u2028/g, "\\u2028")
		        .replace(/\u2029/g, "\\u2029");
		}
		exports.safeStringify = safeStringify;
		function getProperty(key) {
		    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
		}
		exports.getProperty = getProperty;
		//Does best effort to format the name properly
		function getEsmExportName(key) {
		    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
		        return new _Code(`${key}`);
		    }
		    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
		}
		exports.getEsmExportName = getEsmExportName;
		function regexpCode(rx) {
		    return new _Code(rx.toString());
		}
		exports.regexpCode = regexpCode;
		
	} (code$1));
	return code$1;
}

var scope = {};

var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope;
	hasRequiredScope = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
		const code_1 = requireCode$1();
		class ValueError extends Error {
		    constructor(name) {
		        super(`CodeGen: "code" for ${name} not defined`);
		        this.value = name.value;
		    }
		}
		var UsedValueState;
		(function (UsedValueState) {
		    UsedValueState[UsedValueState["Started"] = 0] = "Started";
		    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
		})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
		exports.varKinds = {
		    const: new code_1.Name("const"),
		    let: new code_1.Name("let"),
		    var: new code_1.Name("var"),
		};
		class Scope {
		    constructor({ prefixes, parent } = {}) {
		        this._names = {};
		        this._prefixes = prefixes;
		        this._parent = parent;
		    }
		    toName(nameOrPrefix) {
		        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		    }
		    name(prefix) {
		        return new code_1.Name(this._newName(prefix));
		    }
		    _newName(prefix) {
		        const ng = this._names[prefix] || this._nameGroup(prefix);
		        return `${prefix}${ng.index++}`;
		    }
		    _nameGroup(prefix) {
		        var _a, _b;
		        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
		            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
		        }
		        return (this._names[prefix] = { prefix, index: 0 });
		    }
		}
		exports.Scope = Scope;
		class ValueScopeName extends code_1.Name {
		    constructor(prefix, nameStr) {
		        super(nameStr);
		        this.prefix = prefix;
		    }
		    setValue(value, { property, itemIndex }) {
		        this.value = value;
		        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
		    }
		}
		exports.ValueScopeName = ValueScopeName;
		const line = (0, code_1._) `\n`;
		class ValueScope extends Scope {
		    constructor(opts) {
		        super(opts);
		        this._values = {};
		        this._scope = opts.scope;
		        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
		    }
		    get() {
		        return this._scope;
		    }
		    name(prefix) {
		        return new ValueScopeName(prefix, this._newName(prefix));
		    }
		    value(nameOrPrefix, value) {
		        var _a;
		        if (value.ref === undefined)
		            throw new Error("CodeGen: ref must be passed in value");
		        const name = this.toName(nameOrPrefix);
		        const { prefix } = name;
		        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
		        let vs = this._values[prefix];
		        if (vs) {
		            const _name = vs.get(valueKey);
		            if (_name)
		                return _name;
		        }
		        else {
		            vs = this._values[prefix] = new Map();
		        }
		        vs.set(valueKey, name);
		        const s = this._scope[prefix] || (this._scope[prefix] = []);
		        const itemIndex = s.length;
		        s[itemIndex] = value.ref;
		        name.setValue(value, { property: prefix, itemIndex });
		        return name;
		    }
		    getValue(prefix, keyOrRef) {
		        const vs = this._values[prefix];
		        if (!vs)
		            return;
		        return vs.get(keyOrRef);
		    }
		    scopeRefs(scopeName, values = this._values) {
		        return this._reduceValues(values, (name) => {
		            if (name.scopePath === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return (0, code_1._) `${scopeName}${name.scopePath}`;
		        });
		    }
		    scopeCode(values = this._values, usedValues, getCode) {
		        return this._reduceValues(values, (name) => {
		            if (name.value === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return name.value.code;
		        }, usedValues, getCode);
		    }
		    _reduceValues(values, valueCode, usedValues = {}, getCode) {
		        let code = code_1.nil;
		        for (const prefix in values) {
		            const vs = values[prefix];
		            if (!vs)
		                continue;
		            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
		            vs.forEach((name) => {
		                if (nameSet.has(name))
		                    return;
		                nameSet.set(name, UsedValueState.Started);
		                let c = valueCode(name);
		                if (c) {
		                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
		                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
		                }
		                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
		                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
		                }
		                else {
		                    throw new ValueError(name);
		                }
		                nameSet.set(name, UsedValueState.Completed);
		            });
		        }
		        return code;
		    }
		}
		exports.ValueScope = ValueScope;
		
	} (scope));
	return scope;
}

var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen;
	hasRequiredCodegen = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
		const code_1 = requireCode$1();
		const scope_1 = requireScope();
		var code_2 = requireCode$1();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
		Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
		Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
		Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
		var scope_2 = requireScope();
		Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
		Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
		Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
		Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
		exports.operators = {
		    GT: new code_1._Code(">"),
		    GTE: new code_1._Code(">="),
		    LT: new code_1._Code("<"),
		    LTE: new code_1._Code("<="),
		    EQ: new code_1._Code("==="),
		    NEQ: new code_1._Code("!=="),
		    NOT: new code_1._Code("!"),
		    OR: new code_1._Code("||"),
		    AND: new code_1._Code("&&"),
		    ADD: new code_1._Code("+"),
		};
		class Node {
		    optimizeNodes() {
		        return this;
		    }
		    optimizeNames(_names, _constants) {
		        return this;
		    }
		}
		class Def extends Node {
		    constructor(varKind, name, rhs) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.rhs = rhs;
		    }
		    render({ es5, _n }) {
		        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
		        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
		        return `${varKind} ${this.name}${rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (!names[this.name.str])
		            return;
		        if (this.rhs)
		            this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		    }
		}
		class Assign extends Node {
		    constructor(lhs, rhs, sideEffects) {
		        super();
		        this.lhs = lhs;
		        this.rhs = rhs;
		        this.sideEffects = sideEffects;
		    }
		    render({ _n }) {
		        return `${this.lhs} = ${this.rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
		            return;
		        this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
		        return addExprNames(names, this.rhs);
		    }
		}
		class AssignOp extends Assign {
		    constructor(lhs, op, rhs, sideEffects) {
		        super(lhs, rhs, sideEffects);
		        this.op = op;
		    }
		    render({ _n }) {
		        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		    }
		}
		class Label extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        return `${this.label}:` + _n;
		    }
		}
		class Break extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        const label = this.label ? ` ${this.label}` : "";
		        return `break${label};` + _n;
		    }
		}
		class Throw extends Node {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render({ _n }) {
		        return `throw ${this.error};` + _n;
		    }
		    get names() {
		        return this.error.names;
		    }
		}
		class AnyCode extends Node {
		    constructor(code) {
		        super();
		        this.code = code;
		    }
		    render({ _n }) {
		        return `${this.code};` + _n;
		    }
		    optimizeNodes() {
		        return `${this.code}` ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        this.code = optimizeExpr(this.code, names, constants);
		        return this;
		    }
		    get names() {
		        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		    }
		}
		class ParentNode extends Node {
		    constructor(nodes = []) {
		        super();
		        this.nodes = nodes;
		    }
		    render(opts) {
		        return this.nodes.reduce((code, n) => code + n.render(opts), "");
		    }
		    optimizeNodes() {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            const n = nodes[i].optimizeNodes();
		            if (Array.isArray(n))
		                nodes.splice(i, 1, ...n);
		            else if (n)
		                nodes[i] = n;
		            else
		                nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            // iterating backwards improves 1-pass optimization
		            const n = nodes[i];
		            if (n.optimizeNames(names, constants))
		                continue;
		            subtractNames(names, n.names);
		            nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    get names() {
		        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		    }
		}
		class BlockNode extends ParentNode {
		    render(opts) {
		        return "{" + opts._n + super.render(opts) + "}" + opts._n;
		    }
		}
		class Root extends ParentNode {
		}
		class Else extends BlockNode {
		}
		Else.kind = "else";
		class If extends BlockNode {
		    constructor(condition, nodes) {
		        super(nodes);
		        this.condition = condition;
		    }
		    render(opts) {
		        let code = `if(${this.condition})` + super.render(opts);
		        if (this.else)
		            code += "else " + this.else.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        super.optimizeNodes();
		        const cond = this.condition;
		        if (cond === true)
		            return this.nodes; // else is ignored here
		        let e = this.else;
		        if (e) {
		            const ns = e.optimizeNodes();
		            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
		        }
		        if (e) {
		            if (cond === false)
		                return e instanceof If ? e : e.nodes;
		            if (this.nodes.length)
		                return this;
		            return new If(not(cond), e instanceof If ? [e] : e.nodes);
		        }
		        if (cond === false || !this.nodes.length)
		            return undefined;
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a;
		        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        if (!(super.optimizeNames(names, constants) || this.else))
		            return;
		        this.condition = optimizeExpr(this.condition, names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        addExprNames(names, this.condition);
		        if (this.else)
		            addNames(names, this.else.names);
		        return names;
		    }
		}
		If.kind = "if";
		class For extends BlockNode {
		}
		For.kind = "for";
		class ForLoop extends For {
		    constructor(iteration) {
		        super();
		        this.iteration = iteration;
		    }
		    render(opts) {
		        return `for(${this.iteration})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iteration = optimizeExpr(this.iteration, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iteration.names);
		    }
		}
		class ForRange extends For {
		    constructor(varKind, name, from, to) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.from = from;
		        this.to = to;
		    }
		    render(opts) {
		        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
		        const { name, from, to } = this;
		        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		    }
		    get names() {
		        const names = addExprNames(super.names, this.from);
		        return addExprNames(names, this.to);
		    }
		}
		class ForIter extends For {
		    constructor(loop, varKind, name, iterable) {
		        super();
		        this.loop = loop;
		        this.varKind = varKind;
		        this.name = name;
		        this.iterable = iterable;
		    }
		    render(opts) {
		        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iterable = optimizeExpr(this.iterable, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iterable.names);
		    }
		}
		class Func extends BlockNode {
		    constructor(name, args, async) {
		        super();
		        this.name = name;
		        this.args = args;
		        this.async = async;
		    }
		    render(opts) {
		        const _async = this.async ? "async " : "";
		        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		    }
		}
		Func.kind = "func";
		class Return extends ParentNode {
		    render(opts) {
		        return "return " + super.render(opts);
		    }
		}
		Return.kind = "return";
		class Try extends BlockNode {
		    render(opts) {
		        let code = "try" + super.render(opts);
		        if (this.catch)
		            code += this.catch.render(opts);
		        if (this.finally)
		            code += this.finally.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        var _a, _b;
		        super.optimizeNodes();
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a, _b;
		        super.optimizeNames(names, constants);
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        if (this.catch)
		            addNames(names, this.catch.names);
		        if (this.finally)
		            addNames(names, this.finally.names);
		        return names;
		    }
		}
		class Catch extends BlockNode {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render(opts) {
		        return `catch(${this.error})` + super.render(opts);
		    }
		}
		Catch.kind = "catch";
		class Finally extends BlockNode {
		    render(opts) {
		        return "finally" + super.render(opts);
		    }
		}
		Finally.kind = "finally";
		class CodeGen {
		    constructor(extScope, opts = {}) {
		        this._values = {};
		        this._blockStarts = [];
		        this._constants = {};
		        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
		        this._extScope = extScope;
		        this._scope = new scope_1.Scope({ parent: extScope });
		        this._nodes = [new Root()];
		    }
		    toString() {
		        return this._root.render(this.opts);
		    }
		    // returns unique name in the internal scope
		    name(prefix) {
		        return this._scope.name(prefix);
		    }
		    // reserves unique name in the external scope
		    scopeName(prefix) {
		        return this._extScope.name(prefix);
		    }
		    // reserves unique name in the external scope and assigns value to it
		    scopeValue(prefixOrName, value) {
		        const name = this._extScope.value(prefixOrName, value);
		        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
		        vs.add(name);
		        return name;
		    }
		    getScopeValue(prefix, keyOrRef) {
		        return this._extScope.getValue(prefix, keyOrRef);
		    }
		    // return code that assigns values in the external scope to the names that are used internally
		    // (same names that were returned by gen.scopeName or gen.scopeValue)
		    scopeRefs(scopeName) {
		        return this._extScope.scopeRefs(scopeName, this._values);
		    }
		    scopeCode() {
		        return this._extScope.scopeCode(this._values);
		    }
		    _def(varKind, nameOrPrefix, rhs, constant) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (rhs !== undefined && constant)
		            this._constants[name.str] = rhs;
		        this._leafNode(new Def(varKind, name, rhs));
		        return name;
		    }
		    // `const` declaration (`var` in es5 mode)
		    const(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		    }
		    // `let` declaration with optional assignment (`var` in es5 mode)
		    let(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		    }
		    // `var` declaration with optional assignment
		    var(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		    }
		    // assignment code
		    assign(lhs, rhs, sideEffects) {
		        return this._leafNode(new Assign(lhs, rhs, sideEffects));
		    }
		    // `+=` code
		    add(lhs, rhs) {
		        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		    }
		    // appends passed SafeExpr to code or executes Block
		    code(c) {
		        if (typeof c == "function")
		            c();
		        else if (c !== code_1.nil)
		            this._leafNode(new AnyCode(c));
		        return this;
		    }
		    // returns code for object literal for the passed argument list of key-value pairs
		    object(...keyValues) {
		        const code = ["{"];
		        for (const [key, value] of keyValues) {
		            if (code.length > 1)
		                code.push(",");
		            code.push(key);
		            if (key !== value || this.opts.es5) {
		                code.push(":");
		                (0, code_1.addCodeArg)(code, value);
		            }
		        }
		        code.push("}");
		        return new code_1._Code(code);
		    }
		    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
		    if(condition, thenBody, elseBody) {
		        this._blockNode(new If(condition));
		        if (thenBody && elseBody) {
		            this.code(thenBody).else().code(elseBody).endIf();
		        }
		        else if (thenBody) {
		            this.code(thenBody).endIf();
		        }
		        else if (elseBody) {
		            throw new Error('CodeGen: "else" body without "then" body');
		        }
		        return this;
		    }
		    // `else if` clause - invalid without `if` or after `else` clauses
		    elseIf(condition) {
		        return this._elseNode(new If(condition));
		    }
		    // `else` clause - only valid after `if` or `else if` clauses
		    else() {
		        return this._elseNode(new Else());
		    }
		    // end `if` statement (needed if gen.if was used only with condition)
		    endIf() {
		        return this._endBlockNode(If, Else);
		    }
		    _for(node, forBody) {
		        this._blockNode(node);
		        if (forBody)
		            this.code(forBody).endFor();
		        return this;
		    }
		    // a generic `for` clause (or statement if `forBody` is passed)
		    for(iteration, forBody) {
		        return this._for(new ForLoop(iteration), forBody);
		    }
		    // `for` statement for a range of values
		    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		    }
		    // `for-of` statement (in es5 mode replace with a normal for loop)
		    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (this.opts.es5) {
		            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
		            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
		                this.var(name, (0, code_1._) `${arr}[${i}]`);
		                forBody(name);
		            });
		        }
		        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		    }
		    // `for-in` statement.
		    // With option `ownProperties` replaced with a `for-of` loop for object keys
		    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
		        if (this.opts.ownProperties) {
		            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
		        }
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		    }
		    // end `for` loop
		    endFor() {
		        return this._endBlockNode(For);
		    }
		    // `label` statement
		    label(label) {
		        return this._leafNode(new Label(label));
		    }
		    // `break` statement
		    break(label) {
		        return this._leafNode(new Break(label));
		    }
		    // `return` statement
		    return(value) {
		        const node = new Return();
		        this._blockNode(node);
		        this.code(value);
		        if (node.nodes.length !== 1)
		            throw new Error('CodeGen: "return" should have one node');
		        return this._endBlockNode(Return);
		    }
		    // `try` statement
		    try(tryBody, catchCode, finallyCode) {
		        if (!catchCode && !finallyCode)
		            throw new Error('CodeGen: "try" without "catch" and "finally"');
		        const node = new Try();
		        this._blockNode(node);
		        this.code(tryBody);
		        if (catchCode) {
		            const error = this.name("e");
		            this._currNode = node.catch = new Catch(error);
		            catchCode(error);
		        }
		        if (finallyCode) {
		            this._currNode = node.finally = new Finally();
		            this.code(finallyCode);
		        }
		        return this._endBlockNode(Catch, Finally);
		    }
		    // `throw` statement
		    throw(error) {
		        return this._leafNode(new Throw(error));
		    }
		    // start self-balancing block
		    block(body, nodeCount) {
		        this._blockStarts.push(this._nodes.length);
		        if (body)
		            this.code(body).endBlock(nodeCount);
		        return this;
		    }
		    // end the current self-balancing block
		    endBlock(nodeCount) {
		        const len = this._blockStarts.pop();
		        if (len === undefined)
		            throw new Error("CodeGen: not in self-balancing block");
		        const toClose = this._nodes.length - len;
		        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
		            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
		        }
		        this._nodes.length = len;
		        return this;
		    }
		    // `function` heading (or definition if funcBody is passed)
		    func(name, args = code_1.nil, async, funcBody) {
		        this._blockNode(new Func(name, args, async));
		        if (funcBody)
		            this.code(funcBody).endFunc();
		        return this;
		    }
		    // end function definition
		    endFunc() {
		        return this._endBlockNode(Func);
		    }
		    optimize(n = 1) {
		        while (n-- > 0) {
		            this._root.optimizeNodes();
		            this._root.optimizeNames(this._root.names, this._constants);
		        }
		    }
		    _leafNode(node) {
		        this._currNode.nodes.push(node);
		        return this;
		    }
		    _blockNode(node) {
		        this._currNode.nodes.push(node);
		        this._nodes.push(node);
		    }
		    _endBlockNode(N1, N2) {
		        const n = this._currNode;
		        if (n instanceof N1 || (N2 && n instanceof N2)) {
		            this._nodes.pop();
		            return this;
		        }
		        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		    }
		    _elseNode(node) {
		        const n = this._currNode;
		        if (!(n instanceof If)) {
		            throw new Error('CodeGen: "else" without "if"');
		        }
		        this._currNode = n.else = node;
		        return this;
		    }
		    get _root() {
		        return this._nodes[0];
		    }
		    get _currNode() {
		        const ns = this._nodes;
		        return ns[ns.length - 1];
		    }
		    set _currNode(node) {
		        const ns = this._nodes;
		        ns[ns.length - 1] = node;
		    }
		}
		exports.CodeGen = CodeGen;
		function addNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) + (from[n] || 0);
		    return names;
		}
		function addExprNames(names, from) {
		    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
		}
		function optimizeExpr(expr, names, constants) {
		    if (expr instanceof code_1.Name)
		        return replaceName(expr);
		    if (!canOptimize(expr))
		        return expr;
		    return new code_1._Code(expr._items.reduce((items, c) => {
		        if (c instanceof code_1.Name)
		            c = replaceName(c);
		        if (c instanceof code_1._Code)
		            items.push(...c._items);
		        else
		            items.push(c);
		        return items;
		    }, []));
		    function replaceName(n) {
		        const c = constants[n.str];
		        if (c === undefined || names[n.str] !== 1)
		            return n;
		        delete names[n.str];
		        return c;
		    }
		    function canOptimize(e) {
		        return (e instanceof code_1._Code &&
		            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
		    }
		}
		function subtractNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) - (from[n] || 0);
		}
		function not(x) {
		    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
		}
		exports.not = not;
		const andCode = mappend(exports.operators.AND);
		// boolean AND (&&) expression with the passed arguments
		function and(...args) {
		    return args.reduce(andCode);
		}
		exports.and = and;
		const orCode = mappend(exports.operators.OR);
		// boolean OR (||) expression with the passed arguments
		function or(...args) {
		    return args.reduce(orCode);
		}
		exports.or = or;
		function mappend(op) {
		    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
		}
		function par(x) {
		    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
		}
		
	} (codegen));
	return codegen;
}

var util = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	Object.defineProperty(util, "__esModule", { value: true });
	util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
	const codegen_1 = requireCodegen();
	const code_1 = requireCode$1();
	// TODO refactor to use Set
	function toHash(arr) {
	    const hash = {};
	    for (const item of arr)
	        hash[item] = true;
	    return hash;
	}
	util.toHash = toHash;
	function alwaysValidSchema(it, schema) {
	    if (typeof schema == "boolean")
	        return schema;
	    if (Object.keys(schema).length === 0)
	        return true;
	    checkUnknownRules(it, schema);
	    return !schemaHasRules(schema, it.self.RULES.all);
	}
	util.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
	    const { opts, self } = it;
	    if (!opts.strictSchema)
	        return;
	    if (typeof schema === "boolean")
	        return;
	    const rules = self.RULES.keywords;
	    for (const key in schema) {
	        if (!rules[key])
	            checkStrictMode(it, `unknown keyword: "${key}"`);
	    }
	}
	util.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (rules[key])
	            return true;
	    return false;
	}
	util.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (key !== "$ref" && RULES.all[key])
	            return true;
	    return false;
	}
	util.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
	    if (!$data) {
	        if (typeof schema == "number" || typeof schema == "boolean")
	            return schema;
	        if (typeof schema == "string")
	            return (0, codegen_1._) `${schema}`;
	    }
	    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	util.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
	    return unescapeJsonPointer(decodeURIComponent(str));
	}
	util.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
	    return encodeURIComponent(escapeJsonPointer(str));
	}
	util.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
	    if (typeof str == "number")
	        return `${str}`;
	    return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	util.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
	    return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	util.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
	    if (Array.isArray(xs)) {
	        for (const x of xs)
	            f(x);
	    }
	    else {
	        f(xs);
	    }
	}
	util.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
	    return (gen, from, to, toName) => {
	        const res = to === undefined
	            ? from
	            : to instanceof codegen_1.Name
	                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
	                : from instanceof codegen_1.Name
	                    ? (mergeToName(gen, to, from), from)
	                    : mergeValues(from, to);
	        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
	    };
	}
	util.mergeEvaluated = {
	    props: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
	            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
	        }),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
	            if (from === true) {
	                gen.assign(to, true);
	            }
	            else {
	                gen.assign(to, (0, codegen_1._) `${to} || {}`);
	                setEvaluated(gen, to, from);
	            }
	        }),
	        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
	        resultToName: evaluatedPropsToName,
	    }),
	    items: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
	        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
	        resultToName: (gen, items) => gen.var("items", items),
	    }),
	};
	function evaluatedPropsToName(gen, ps) {
	    if (ps === true)
	        return gen.var("props", true);
	    const props = gen.var("props", (0, codegen_1._) `{}`);
	    if (ps !== undefined)
	        setEvaluated(gen, props, ps);
	    return props;
	}
	util.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
	    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	util.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
	    return gen.scopeValue("func", {
	        ref: f,
	        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
	    });
	}
	util.useFunc = useFunc;
	var Type;
	(function (Type) {
	    Type[Type["Num"] = 0] = "Num";
	    Type[Type["Str"] = 1] = "Str";
	})(Type || (util.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
	    // let path
	    if (dataProp instanceof codegen_1.Name) {
	        const isNumber = dataPropType === Type.Num;
	        return jsPropertySyntax
	            ? isNumber
	                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
	                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
	            : isNumber
	                ? (0, codegen_1._) `"/" + ${dataProp}`
	                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
	    }
	    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	util.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
	    if (!mode)
	        return;
	    msg = `strict mode: ${msg}`;
	    if (mode === true)
	        throw new Error(msg);
	    it.self.logger.warn(msg);
	}
	util.checkStrictMode = checkStrictMode;
	
	return util;
}

var names = {};

var hasRequiredNames;

function requireNames () {
	if (hasRequiredNames) return names;
	hasRequiredNames = 1;
	Object.defineProperty(names, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const names$1 = {
	    // validation function arguments
	    data: new codegen_1.Name("data"), // data passed to validation function
	    // args passed from referencing schema
	    valCxt: new codegen_1.Name("valCxt"), // validation/data context - should not be used directly, it is destructured to the names below
	    instancePath: new codegen_1.Name("instancePath"),
	    parentData: new codegen_1.Name("parentData"),
	    parentDataProperty: new codegen_1.Name("parentDataProperty"),
	    rootData: new codegen_1.Name("rootData"), // root data - same as the data passed to the first/top validation function
	    dynamicAnchors: new codegen_1.Name("dynamicAnchors"), // used to support recursiveRef and dynamicRef
	    // function scoped variables
	    vErrors: new codegen_1.Name("vErrors"), // null or array of validation errors
	    errors: new codegen_1.Name("errors"), // counter of validation errors
	    this: new codegen_1.Name("this"),
	    // "globals"
	    self: new codegen_1.Name("self"),
	    scope: new codegen_1.Name("scope"),
	    // JTD serialize/parse name for JSON string and position
	    json: new codegen_1.Name("json"),
	    jsonPos: new codegen_1.Name("jsonPos"),
	    jsonLen: new codegen_1.Name("jsonLen"),
	    jsonPart: new codegen_1.Name("jsonPart"),
	};
	names.default = names$1;
	
	return names;
}

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil();
		const names_1 = requireNames();
		exports.keywordError = {
		    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
		};
		exports.keyword$DataError = {
		    message: ({ keyword, schemaType }) => schemaType
		        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
		        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
		};
		function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
		        addError(gen, errObj);
		    }
		    else {
		        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
		    }
		}
		exports.reportError = reportError;
		function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    addError(gen, errObj);
		    if (!(compositeRule || allErrors)) {
		        returnErrors(it, names_1.default.vErrors);
		    }
		}
		exports.reportExtraError = reportExtraError;
		function resetErrorsCount(gen, errsCount) {
		    gen.assign(names_1.default.errors, errsCount);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
		}
		exports.resetErrorsCount = resetErrorsCount;
		function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
		    /* istanbul ignore if */
		    if (errsCount === undefined)
		        throw new Error("ajv implementation error");
		    const err = gen.name("err");
		    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
		        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
		        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
		        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
		        if (it.opts.verbose) {
		            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
		            gen.assign((0, codegen_1._) `${err}.data`, data);
		        }
		    });
		}
		exports.extendErrors = extendErrors;
		function addError(gen, errObj) {
		    const err = gen.const("err", errObj);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
		    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
		}
		function returnErrors(it, errs) {
		    const { gen, validateName, schemaEnv } = it;
		    if (schemaEnv.$async) {
		        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
		    }
		    else {
		        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
		        gen.return(false);
		    }
		}
		const E = {
		    keyword: new codegen_1.Name("keyword"),
		    schemaPath: new codegen_1.Name("schemaPath"), // also used in JTD errors
		    params: new codegen_1.Name("params"),
		    propertyName: new codegen_1.Name("propertyName"),
		    message: new codegen_1.Name("message"),
		    schema: new codegen_1.Name("schema"),
		    parentSchema: new codegen_1.Name("parentSchema"),
		};
		function errorObjectCode(cxt, error, errorPaths) {
		    const { createErrors } = cxt.it;
		    if (createErrors === false)
		        return (0, codegen_1._) `{}`;
		    return errorObject(cxt, error, errorPaths);
		}
		function errorObject(cxt, error, errorPaths = {}) {
		    const { gen, it } = cxt;
		    const keyValues = [
		        errorInstancePath(it, errorPaths),
		        errorSchemaPath(cxt, errorPaths),
		    ];
		    extraErrorProps(cxt, error, keyValues);
		    return gen.object(...keyValues);
		}
		function errorInstancePath({ errorPath }, { instancePath }) {
		    const instPath = instancePath
		        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
		        : errorPath;
		    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
		}
		function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
		    if (schemaPath) {
		        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
		    }
		    return [E.schemaPath, schPath];
		}
		function extraErrorProps(cxt, { params, message }, keyValues) {
		    const { keyword, data, schemaValue, it } = cxt;
		    const { opts, propertyName, topSchemaRef, schemaPath } = it;
		    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
		    if (opts.messages) {
		        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		    }
		    if (opts.verbose) {
		        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
		    }
		    if (propertyName)
		        keyValues.push([E.propertyName, propertyName]);
		}
		
	} (errors));
	return errors;
}

var hasRequiredBoolSchema;

function requireBoolSchema () {
	if (hasRequiredBoolSchema) return boolSchema;
	hasRequiredBoolSchema = 1;
	Object.defineProperty(boolSchema, "__esModule", { value: true });
	boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
	const errors_1 = requireErrors();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const boolError = {
	    message: "boolean schema is false",
	};
	function topBoolOrEmptySchema(it) {
	    const { gen, schema, validateName } = it;
	    if (schema === false) {
	        falseSchemaError(it, false);
	    }
	    else if (typeof schema == "object" && schema.$async === true) {
	        gen.return(names_1.default.data);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
	        gen.return(true);
	    }
	}
	boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
	    const { gen, schema } = it;
	    if (schema === false) {
	        gen.var(valid, false); // TODO var
	        falseSchemaError(it);
	    }
	    else {
	        gen.var(valid, true); // TODO var
	    }
	}
	boolSchema.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
	    const { gen, data } = it;
	    // TODO maybe some other interface should be used for non-keyword validation errors...
	    const cxt = {
	        gen,
	        keyword: "false schema",
	        data,
	        schema: false,
	        schemaCode: false,
	        schemaValue: false,
	        params: {},
	        it,
	    };
	    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
	
	return boolSchema;
}

var dataType = {};

var rules = {};

var hasRequiredRules;

function requireRules () {
	if (hasRequiredRules) return rules;
	hasRequiredRules = 1;
	Object.defineProperty(rules, "__esModule", { value: true });
	rules.getRules = rules.isJSONType = void 0;
	const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
	const jsonTypes = new Set(_jsonTypes);
	function isJSONType(x) {
	    return typeof x == "string" && jsonTypes.has(x);
	}
	rules.isJSONType = isJSONType;
	function getRules() {
	    const groups = {
	        number: { type: "number", rules: [] },
	        string: { type: "string", rules: [] },
	        array: { type: "array", rules: [] },
	        object: { type: "object", rules: [] },
	    };
	    return {
	        types: { ...groups, integer: true, boolean: true, null: true },
	        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
	        post: { rules: [] },
	        all: {},
	        keywords: {},
	    };
	}
	rules.getRules = getRules;
	
	return rules;
}

var applicability = {};

var hasRequiredApplicability;

function requireApplicability () {
	if (hasRequiredApplicability) return applicability;
	hasRequiredApplicability = 1;
	Object.defineProperty(applicability, "__esModule", { value: true });
	applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
	function schemaHasRulesForType({ schema, self }, type) {
	    const group = self.RULES.types[type];
	    return group && group !== true && shouldUseGroup(schema, group);
	}
	applicability.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema, group) {
	    return group.rules.some((rule) => shouldUseRule(schema, rule));
	}
	applicability.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema, rule) {
	    var _a;
	    return (schema[rule.keyword] !== undefined ||
	        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
	}
	applicability.shouldUseRule = shouldUseRule;
	
	return applicability;
}

var hasRequiredDataType;

function requireDataType () {
	if (hasRequiredDataType) return dataType;
	hasRequiredDataType = 1;
	Object.defineProperty(dataType, "__esModule", { value: true });
	dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
	const rules_1 = requireRules();
	const applicability_1 = requireApplicability();
	const errors_1 = requireErrors();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	var DataType;
	(function (DataType) {
	    DataType[DataType["Correct"] = 0] = "Correct";
	    DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType || (dataType.DataType = DataType = {}));
	function getSchemaTypes(schema) {
	    const types = getJSONTypes(schema.type);
	    const hasNull = types.includes("null");
	    if (hasNull) {
	        if (schema.nullable === false)
	            throw new Error("type: null contradicts nullable: false");
	    }
	    else {
	        if (!types.length && schema.nullable !== undefined) {
	            throw new Error('"nullable" cannot be used without "type"');
	        }
	        if (schema.nullable === true)
	            types.push("null");
	    }
	    return types;
	}
	dataType.getSchemaTypes = getSchemaTypes;
	// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	function getJSONTypes(ts) {
	    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
	    if (types.every(rules_1.isJSONType))
	        return types;
	    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	dataType.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
	    const { gen, data, opts } = it;
	    const coerceTo = coerceToTypes(types, opts.coerceTypes);
	    const checkTypes = types.length > 0 &&
	        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
	    if (checkTypes) {
	        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
	        gen.if(wrongType, () => {
	            if (coerceTo.length)
	                coerceData(it, types, coerceTo);
	            else
	                reportTypeError(it);
	        });
	    }
	    return checkTypes;
	}
	dataType.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
	function coerceToTypes(types, coerceTypes) {
	    return coerceTypes
	        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
	        : [];
	}
	function coerceData(it, types, coerceTo) {
	    const { gen, data, opts } = it;
	    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
	    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
	    if (opts.coerceTypes === "array") {
	        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
	            .assign(data, (0, codegen_1._) `${data}[0]`)
	            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
	            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
	    }
	    gen.if((0, codegen_1._) `${coerced} !== undefined`);
	    for (const t of coerceTo) {
	        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
	            coerceSpecificType(t);
	        }
	    }
	    gen.else();
	    reportTypeError(it);
	    gen.endIf();
	    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
	        gen.assign(data, coerced);
	        assignParentData(it, coerced);
	    });
	    function coerceSpecificType(t) {
	        switch (t) {
	            case "string":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
	                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
	                    .elseIf((0, codegen_1._) `${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `""`);
	                return;
	            case "number":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "integer":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "boolean":
	                gen
	                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
	                    .assign(coerced, false)
	                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
	                    .assign(coerced, true);
	                return;
	            case "null":
	                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
	                gen.assign(coerced, null);
	                return;
	            case "array":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `[${data}]`);
	        }
	    }
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
	    // TODO use gen.property
	    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
	    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
	    let cond;
	    switch (dataType) {
	        case "null":
	            return (0, codegen_1._) `${data} ${EQ} null`;
	        case "array":
	            cond = (0, codegen_1._) `Array.isArray(${data})`;
	            break;
	        case "object":
	            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
	            break;
	        case "integer":
	            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
	            break;
	        case "number":
	            cond = numCond();
	            break;
	        default:
	            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
	    }
	    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
	    function numCond(_cond = codegen_1.nil) {
	        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
	    }
	}
	dataType.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
	    if (dataTypes.length === 1) {
	        return checkDataType(dataTypes[0], data, strictNums, correct);
	    }
	    let cond;
	    const types = (0, util_1.toHash)(dataTypes);
	    if (types.array && types.object) {
	        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
	        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
	        delete types.null;
	        delete types.array;
	        delete types.object;
	    }
	    else {
	        cond = codegen_1.nil;
	    }
	    if (types.number)
	        delete types.integer;
	    for (const t in types)
	        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
	    return cond;
	}
	dataType.checkDataTypes = checkDataTypes;
	const typeError = {
	    message: ({ schema }) => `must be ${schema}`,
	    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
	};
	function reportTypeError(it) {
	    const cxt = getTypeErrorContext(it);
	    (0, errors_1.reportError)(cxt, typeError);
	}
	dataType.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
	    const { gen, data, schema } = it;
	    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
	    return {
	        gen,
	        keyword: "type",
	        data,
	        schema: schema.type,
	        schemaCode,
	        schemaValue: schemaCode,
	        parentSchema: schema,
	        params: {},
	        it,
	    };
	}
	
	return dataType;
}

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	Object.defineProperty(defaults, "__esModule", { value: true });
	defaults.assignDefaults = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	function assignDefaults(it, ty) {
	    const { properties, items } = it.schema;
	    if (ty === "object" && properties) {
	        for (const key in properties) {
	            assignDefault(it, key, properties[key].default);
	        }
	    }
	    else if (ty === "array" && Array.isArray(items)) {
	        items.forEach((sch, i) => assignDefault(it, i, sch.default));
	    }
	}
	defaults.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
	    const { gen, compositeRule, data, opts } = it;
	    if (defaultValue === undefined)
	        return;
	    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
	    if (compositeRule) {
	        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
	        return;
	    }
	    let condition = (0, codegen_1._) `${childData} === undefined`;
	    if (opts.useDefaults === "empty") {
	        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
	    }
	    // `${childData} === undefined` +
	    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
	    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
	
	return defaults;
}

var keyword = {};

var code = {};

var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code;
	hasRequiredCode = 1;
	Object.defineProperty(code, "__esModule", { value: true });
	code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const names_1 = requireNames();
	const util_2 = requireUtil();
	function checkReportMissingProp(cxt, prop) {
	    const { gen, data, it } = cxt;
	    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
	        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
	        cxt.error();
	    });
	}
	code.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
	    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
	}
	code.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
	    cxt.setParams({ missingProperty: missing }, true);
	    cxt.error();
	}
	code.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
	    return gen.scopeValue("func", {
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        ref: Object.prototype.hasOwnProperty,
	        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
	    });
	}
	code.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
	    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	code.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
	    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	code.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
	    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
	}
	code.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
	    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	code.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
	    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
	}
	code.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
	    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
	    const valCxt = [
	        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
	        [names_1.default.parentData, it.parentData],
	        [names_1.default.parentDataProperty, it.parentDataProperty],
	        [names_1.default.rootData, names_1.default.rootData],
	    ];
	    if (it.opts.dynamicRef)
	        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
	    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
	    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
	}
	code.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1._) `new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
	    const u = opts.unicodeRegExp ? "u" : "";
	    const { regExp } = opts.code;
	    const rx = regExp(pattern, u);
	    return gen.scopeValue("pattern", {
	        key: rx.toString(),
	        ref: rx,
	        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
	    });
	}
	code.usePattern = usePattern;
	function validateArray(cxt) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    if (it.allErrors) {
	        const validArr = gen.let("valid", true);
	        validateItems(() => gen.assign(validArr, false));
	        return validArr;
	    }
	    gen.var(valid, true);
	    validateItems(() => gen.break());
	    return valid;
	    function validateItems(notValid) {
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        gen.forRange("i", 0, len, (i) => {
	            cxt.subschema({
	                keyword,
	                dataProp: i,
	                dataPropType: util_1.Type.Num,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), notValid);
	        });
	    }
	}
	code.validateArray = validateArray;
	function validateUnion(cxt) {
	    const { gen, schema, keyword, it } = cxt;
	    /* istanbul ignore if */
	    if (!Array.isArray(schema))
	        throw new Error("ajv implementation error");
	    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
	    if (alwaysValid && !it.opts.unevaluated)
	        return;
	    const valid = gen.let("valid", false);
	    const schValid = gen.name("_valid");
	    gen.block(() => schema.forEach((_sch, i) => {
	        const schCxt = cxt.subschema({
	            keyword,
	            schemaProp: i,
	            compositeRule: true,
	        }, schValid);
	        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
	        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
	        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
	        // or if all properties and items were evaluated (it.props === true && it.items === true)
	        if (!merged)
	            gen.if((0, codegen_1.not)(valid));
	    }));
	    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	code.validateUnion = validateUnion;
	
	return code;
}

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", { value: true });
	keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const errors_1 = requireErrors();
	function macroKeywordCode(cxt, def) {
	    const { gen, keyword, schema, parentSchema, it } = cxt;
	    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
	    const schemaRef = useKeyword(gen, keyword, macroSchema);
	    if (it.opts.validateSchema !== false)
	        it.self.validateSchema(macroSchema, true);
	    const valid = gen.name("valid");
	    cxt.subschema({
	        schema: macroSchema,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	        topSchemaRef: schemaRef,
	        compositeRule: true,
	    }, valid);
	    cxt.pass(valid, () => cxt.error(true));
	}
	keyword.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
	    var _a;
	    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
	    checkAsyncKeyword(it, def);
	    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
	    const validateRef = useKeyword(gen, keyword, validate);
	    const valid = gen.let("valid");
	    cxt.block$data(valid, validateKeyword);
	    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
	    function validateKeyword() {
	        if (def.errors === false) {
	            assignValid();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => cxt.error());
	        }
	        else {
	            const ruleErrs = def.async ? validateAsync() : validateSync();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => addErrs(cxt, ruleErrs));
	        }
	    }
	    function validateAsync() {
	        const ruleErrs = gen.let("ruleErrs", null);
	        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
	        return ruleErrs;
	    }
	    function validateSync() {
	        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
	        gen.assign(validateErrs, null);
	        assignValid(codegen_1.nil);
	        return validateErrs;
	    }
	    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
	        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
	        const passSchema = !(("compile" in def && !$data) || def.schema === false);
	        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
	    }
	    function reportErrs(errors) {
	        var _a;
	        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
	    }
	}
	keyword.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
	    const { gen, data, it } = cxt;
	    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
	    const { gen } = cxt;
	    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
	        gen
	            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
	            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	        (0, errors_1.extendErrors)(cxt);
	    }, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
	    if (def.async && !schemaEnv.$async)
	        throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
	    if (result === undefined)
	        throw new Error(`keyword "${keyword}" failed to compile`);
	    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
	    // TODO add tests
	    return (!schemaType.length ||
	        schemaType.some((st) => st === "array"
	            ? Array.isArray(schema)
	            : st === "object"
	                ? schema && typeof schema == "object" && !Array.isArray(schema)
	                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
	}
	keyword.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
	    /* istanbul ignore if */
	    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
	        throw new Error("ajv implementation error");
	    }
	    const deps = def.dependencies;
	    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
	        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
	    }
	    if (def.validateSchema) {
	        const valid = def.validateSchema(schema[keyword]);
	        if (!valid) {
	            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
	                self.errorsText(def.validateSchema.errors);
	            if (opts.validateSchema === "log")
	                self.logger.error(msg);
	            else
	                throw new Error(msg);
	        }
	    }
	}
	keyword.validateKeywordUsage = validateKeywordUsage;
	
	return keyword;
}

var subschema = {};

var hasRequiredSubschema;

function requireSubschema () {
	if (hasRequiredSubschema) return subschema;
	hasRequiredSubschema = 1;
	Object.defineProperty(subschema, "__esModule", { value: true });
	subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
	    if (keyword !== undefined && schema !== undefined) {
	        throw new Error('both "keyword" and "schema" passed, only one allowed');
	    }
	    if (keyword !== undefined) {
	        const sch = it.schema[keyword];
	        return schemaProp === undefined
	            ? {
	                schema: sch,
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	            }
	            : {
	                schema: sch[schemaProp],
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
	            };
	    }
	    if (schema !== undefined) {
	        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
	            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
	        }
	        return {
	            schema,
	            schemaPath,
	            topSchemaRef,
	            errSchemaPath,
	        };
	    }
	    throw new Error('either "keyword" or "schema" must be passed');
	}
	subschema.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
	    if (data !== undefined && dataProp !== undefined) {
	        throw new Error('both "data" and "dataProp" passed, only one allowed');
	    }
	    const { gen } = it;
	    if (dataProp !== undefined) {
	        const { errorPath, dataPathArr, opts } = it;
	        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
	        dataContextProps(nextData);
	        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
	        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
	        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
	    }
	    if (data !== undefined) {
	        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
	        dataContextProps(nextData);
	        if (propertyName !== undefined)
	            subschema.propertyName = propertyName;
	        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
	    }
	    if (dataTypes)
	        subschema.dataTypes = dataTypes;
	    function dataContextProps(_nextData) {
	        subschema.data = _nextData;
	        subschema.dataLevel = it.dataLevel + 1;
	        subschema.dataTypes = [];
	        it.definedProperties = new Set();
	        subschema.parentData = it.data;
	        subschema.dataNames = [...it.dataNames, _nextData];
	    }
	}
	subschema.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
	    if (compositeRule !== undefined)
	        subschema.compositeRule = compositeRule;
	    if (createErrors !== undefined)
	        subschema.createErrors = createErrors;
	    if (allErrors !== undefined)
	        subschema.allErrors = allErrors;
	    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
	    subschema.jtdMetadata = jtdMetadata; // not inherited
	}
	subschema.extendSubschemaMode = extendSubschemaMode;
	
	return subschema;
}

var resolve = {};

var fastDeepEqual;
var hasRequiredFastDeepEqual;

function requireFastDeepEqual () {
	if (hasRequiredFastDeepEqual) return fastDeepEqual;
	hasRequiredFastDeepEqual = 1;

	// do not edit .js files directly - edit src/index.jst



	fastDeepEqual = function equal(a, b) {
	  if (a === b) return true;

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    if (a.constructor !== b.constructor) return false;

	    var length, i, keys;
	    if (Array.isArray(a)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;)
	        if (!equal(a[i], b[i])) return false;
	      return true;
	    }



	    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
	    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
	    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

	    keys = Object.keys(a);
	    length = keys.length;
	    if (length !== Object.keys(b).length) return false;

	    for (i = length; i-- !== 0;)
	      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

	    for (i = length; i-- !== 0;) {
	      var key = keys[i];

	      if (!equal(a[key], b[key])) return false;
	    }

	    return true;
	  }

	  // true if both NaN, false otherwise
	  return a!==a && b!==b;
	};
	return fastDeepEqual;
}

var jsonSchemaTraverse = {exports: {}};

var hasRequiredJsonSchemaTraverse;

function requireJsonSchemaTraverse () {
	if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
	hasRequiredJsonSchemaTraverse = 1;

	var traverse = jsonSchemaTraverse.exports = function (schema, opts, cb) {
	  // Legacy support for v0.3.1 and earlier.
	  if (typeof opts == 'function') {
	    cb = opts;
	    opts = {};
	  }

	  cb = opts.cb || cb;
	  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
	  var post = cb.post || function() {};

	  _traverse(opts, pre, post, schema, '', schema);
	};


	traverse.keywords = {
	  additionalItems: true,
	  items: true,
	  contains: true,
	  additionalProperties: true,
	  propertyNames: true,
	  not: true,
	  if: true,
	  then: true,
	  else: true
	};

	traverse.arrayKeywords = {
	  items: true,
	  allOf: true,
	  anyOf: true,
	  oneOf: true
	};

	traverse.propsKeywords = {
	  $defs: true,
	  definitions: true,
	  properties: true,
	  patternProperties: true,
	  dependencies: true
	};

	traverse.skipKeywords = {
	  default: true,
	  enum: true,
	  const: true,
	  required: true,
	  maximum: true,
	  minimum: true,
	  exclusiveMaximum: true,
	  exclusiveMinimum: true,
	  multipleOf: true,
	  maxLength: true,
	  minLength: true,
	  pattern: true,
	  format: true,
	  maxItems: true,
	  minItems: true,
	  uniqueItems: true,
	  maxProperties: true,
	  minProperties: true
	};


	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
	    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	    for (var key in schema) {
	      var sch = schema[key];
	      if (Array.isArray(sch)) {
	        if (key in traverse.arrayKeywords) {
	          for (var i=0; i<sch.length; i++)
	            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
	        }
	      } else if (key in traverse.propsKeywords) {
	        if (sch && typeof sch == 'object') {
	          for (var prop in sch)
	            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
	        }
	      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
	        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
	      }
	    }
	    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	  }
	}


	function escapeJsonPtr(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	return jsonSchemaTraverse.exports;
}

var hasRequiredResolve;

function requireResolve () {
	if (hasRequiredResolve) return resolve;
	hasRequiredResolve = 1;
	Object.defineProperty(resolve, "__esModule", { value: true });
	resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
	const util_1 = requireUtil();
	const equal = requireFastDeepEqual();
	const traverse = requireJsonSchemaTraverse();
	// TODO refactor to use keyword definitions
	const SIMPLE_INLINED = new Set([
	    "type",
	    "format",
	    "pattern",
	    "maxLength",
	    "minLength",
	    "maxProperties",
	    "minProperties",
	    "maxItems",
	    "minItems",
	    "maximum",
	    "minimum",
	    "uniqueItems",
	    "multipleOf",
	    "required",
	    "enum",
	    "const",
	]);
	function inlineRef(schema, limit = true) {
	    if (typeof schema == "boolean")
	        return true;
	    if (limit === true)
	        return !hasRef(schema);
	    if (!limit)
	        return false;
	    return countKeys(schema) <= limit;
	}
	resolve.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
	    "$ref",
	    "$recursiveRef",
	    "$recursiveAnchor",
	    "$dynamicRef",
	    "$dynamicAnchor",
	]);
	function hasRef(schema) {
	    for (const key in schema) {
	        if (REF_KEYWORDS.has(key))
	            return true;
	        const sch = schema[key];
	        if (Array.isArray(sch) && sch.some(hasRef))
	            return true;
	        if (typeof sch == "object" && hasRef(sch))
	            return true;
	    }
	    return false;
	}
	function countKeys(schema) {
	    let count = 0;
	    for (const key in schema) {
	        if (key === "$ref")
	            return Infinity;
	        count++;
	        if (SIMPLE_INLINED.has(key))
	            continue;
	        if (typeof schema[key] == "object") {
	            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
	        }
	        if (count === Infinity)
	            return Infinity;
	    }
	    return count;
	}
	function getFullPath(resolver, id = "", normalize) {
	    if (normalize !== false)
	        id = normalizeId(id);
	    const p = resolver.parse(id);
	    return _getFullPath(resolver, p);
	}
	resolve.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
	    const serialized = resolver.serialize(p);
	    return serialized.split("#")[0] + "#";
	}
	resolve._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
	    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	resolve.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
	    id = normalizeId(id);
	    return resolver.resolve(baseId, id);
	}
	resolve.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema, baseId) {
	    if (typeof schema == "boolean")
	        return {};
	    const { schemaId, uriResolver } = this.opts;
	    const schId = normalizeId(schema[schemaId] || baseId);
	    const baseIds = { "": schId };
	    const pathPrefix = getFullPath(uriResolver, schId, false);
	    const localRefs = {};
	    const schemaRefs = new Set();
	    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
	        if (parentJsonPtr === undefined)
	            return;
	        const fullPath = pathPrefix + jsonPtr;
	        let innerBaseId = baseIds[parentJsonPtr];
	        if (typeof sch[schemaId] == "string")
	            innerBaseId = addRef.call(this, sch[schemaId]);
	        addAnchor.call(this, sch.$anchor);
	        addAnchor.call(this, sch.$dynamicAnchor);
	        baseIds[jsonPtr] = innerBaseId;
	        function addRef(ref) {
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            const _resolve = this.opts.uriResolver.resolve;
	            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
	            if (schemaRefs.has(ref))
	                throw ambiguos(ref);
	            schemaRefs.add(ref);
	            let schOrRef = this.refs[ref];
	            if (typeof schOrRef == "string")
	                schOrRef = this.refs[schOrRef];
	            if (typeof schOrRef == "object") {
	                checkAmbiguosRef(sch, schOrRef.schema, ref);
	            }
	            else if (ref !== normalizeId(fullPath)) {
	                if (ref[0] === "#") {
	                    checkAmbiguosRef(sch, localRefs[ref], ref);
	                    localRefs[ref] = sch;
	                }
	                else {
	                    this.refs[ref] = fullPath;
	                }
	            }
	            return ref;
	        }
	        function addAnchor(anchor) {
	            if (typeof anchor == "string") {
	                if (!ANCHOR.test(anchor))
	                    throw new Error(`invalid anchor "${anchor}"`);
	                addRef.call(this, `#${anchor}`);
	            }
	        }
	    });
	    return localRefs;
	    function checkAmbiguosRef(sch1, sch2, ref) {
	        if (sch2 !== undefined && !equal(sch1, sch2))
	            throw ambiguos(ref);
	    }
	    function ambiguos(ref) {
	        return new Error(`reference "${ref}" resolves to more than one schema`);
	    }
	}
	resolve.getSchemaRefs = getSchemaRefs;
	
	return resolve;
}

var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate;
	hasRequiredValidate = 1;
	Object.defineProperty(validate, "__esModule", { value: true });
	validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
	const boolSchema_1 = requireBoolSchema();
	const dataType_1 = requireDataType();
	const applicability_1 = requireApplicability();
	const dataType_2 = requireDataType();
	const defaults_1 = requireDefaults();
	const keyword_1 = requireKeyword();
	const subschema_1 = requireSubschema();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil();
	const errors_1 = requireErrors();
	// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
	function validateFunctionCode(it) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            topSchemaObjCode(it);
	            return;
	        }
	    }
	    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	validate.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
	    if (opts.code.es5) {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
	            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
	            destructureValCxtES5(gen, opts);
	            gen.code(body);
	        });
	    }
	    else {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	    }
	}
	function destructureValCxt(opts) {
	    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
	    gen.if(names_1.default.valCxt, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
	        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
	    }, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.rootData, names_1.default.data);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
	    });
	}
	function topSchemaObjCode(it) {
	    const { schema, opts, gen } = it;
	    validateFunction(it, () => {
	        if (opts.$comment && schema.$comment)
	            commentKeyword(it);
	        checkNoDefault(it);
	        gen.let(names_1.default.vErrors, null);
	        gen.let(names_1.default.errors, 0);
	        if (opts.unevaluated)
	            resetEvaluated(it);
	        typeAndKeywords(it);
	        returnResults(it);
	    });
	    return;
	}
	function resetEvaluated(it) {
	    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
	    const { gen, validateName } = it;
	    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
	}
	function funcSourceUrl(schema, opts) {
	    const schId = typeof schema == "object" && schema[opts.schemaId];
	    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	// schema compilation - this function is used recursively to generate code for sub-schemas
	function subschemaCode(it, valid) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            subSchemaObjCode(it, valid);
	            return;
	        }
	    }
	    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (self.RULES.all[key])
	            return true;
	    return false;
	}
	function isSchemaObj(it) {
	    return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
	    const { schema, gen, opts } = it;
	    if (opts.$comment && schema.$comment)
	        commentKeyword(it);
	    updateContext(it);
	    checkAsyncSchema(it);
	    const errsCount = gen.const("_errs", names_1.default.errors);
	    typeAndKeywords(it, errsCount);
	    // TODO var
	    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
	    (0, util_1.checkUnknownRules)(it);
	    checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
	    if (it.opts.jtd)
	        return schemaKeywords(it, [], false, errsCount);
	    const types = (0, dataType_1.getSchemaTypes)(it.schema);
	    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
	    schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
	    const { schema, errSchemaPath, opts, self } = it;
	    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
	        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	    }
	}
	function checkNoDefault(it) {
	    const { schema, opts } = it;
	    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
	        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
	    }
	}
	function updateContext(it) {
	    const schId = it.schema[it.opts.schemaId];
	    if (schId)
	        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
	    if (it.schema.$async && !it.schemaEnv.$async)
	        throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
	    const msg = schema.$comment;
	    if (opts.$comment === true) {
	        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
	    }
	    else if (typeof opts.$comment == "function") {
	        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
	        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
	        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
	    }
	}
	function returnResults(it) {
	    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
	    if (schemaEnv.$async) {
	        // TODO assign unevaluated
	        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
	        if (opts.unevaluated)
	            assignEvaluated(it);
	        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
	    }
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
	    if (props instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
	    if (items instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
	    const { gen, schema, data, allErrors, opts, self } = it;
	    const { RULES } = self;
	    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
	        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
	        return;
	    }
	    if (!opts.jtd)
	        checkStrictTypes(it, types);
	    gen.block(() => {
	        for (const group of RULES.rules)
	            groupKeywords(group);
	        groupKeywords(RULES.post);
	    });
	    function groupKeywords(group) {
	        if (!(0, applicability_1.shouldUseGroup)(schema, group))
	            return;
	        if (group.type) {
	            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
	            iterateKeywords(it, group);
	            if (types.length === 1 && types[0] === group.type && typeErrors) {
	                gen.else();
	                (0, dataType_2.reportTypeError)(it);
	            }
	            gen.endIf();
	        }
	        else {
	            iterateKeywords(it, group);
	        }
	        // TODO make it "ok" call?
	        if (!allErrors)
	            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
	    }
	}
	function iterateKeywords(it, group) {
	    const { gen, schema, opts: { useDefaults }, } = it;
	    if (useDefaults)
	        (0, defaults_1.assignDefaults)(it, group.type);
	    gen.block(() => {
	        for (const rule of group.rules) {
	            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
	                keywordCode(it, rule.keyword, rule.definition, group.type);
	            }
	        }
	    });
	}
	function checkStrictTypes(it, types) {
	    if (it.schemaEnv.meta || !it.opts.strictTypes)
	        return;
	    checkContextTypes(it, types);
	    if (!it.opts.allowUnionTypes)
	        checkMultipleTypes(it, types);
	    checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
	    if (!types.length)
	        return;
	    if (!it.dataTypes.length) {
	        it.dataTypes = types;
	        return;
	    }
	    types.forEach((t) => {
	        if (!includesType(it.dataTypes, t)) {
	            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
	        }
	    });
	    narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
	    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
	        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	    }
	}
	function checkKeywordTypes(it, ts) {
	    const rules = it.self.RULES.all;
	    for (const keyword in rules) {
	        const rule = rules[keyword];
	        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
	            const { type } = rule.definition;
	            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
	                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
	            }
	        }
	    }
	}
	function hasApplicableType(schTs, kwdT) {
	    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
	}
	function includesType(ts, t) {
	    return ts.includes(t) || (t === "integer" && ts.includes("number"));
	}
	function narrowSchemaTypes(it, withTypes) {
	    const ts = [];
	    for (const t of it.dataTypes) {
	        if (includesType(withTypes, t))
	            ts.push(t);
	        else if (withTypes.includes("integer") && t === "number")
	            ts.push("integer");
	    }
	    it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
	    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	    msg += ` at "${schemaPath}" (strictTypes)`;
	    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	class KeywordCxt {
	    constructor(it, def, keyword) {
	        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
	        this.gen = it.gen;
	        this.allErrors = it.allErrors;
	        this.keyword = keyword;
	        this.data = it.data;
	        this.schema = it.schema[keyword];
	        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
	        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
	        this.schemaType = def.schemaType;
	        this.parentSchema = it.schema;
	        this.params = {};
	        this.it = it;
	        this.def = def;
	        if (this.$data) {
	            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
	        }
	        else {
	            this.schemaCode = this.schemaValue;
	            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
	                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
	            }
	        }
	        if ("code" in def ? def.trackErrors : def.errors !== false) {
	            this.errsCount = it.gen.const("_errs", names_1.default.errors);
	        }
	    }
	    result(condition, successAction, failAction) {
	        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
	    }
	    failResult(condition, successAction, failAction) {
	        this.gen.if(condition);
	        if (failAction)
	            failAction();
	        else
	            this.error();
	        if (successAction) {
	            this.gen.else();
	            successAction();
	            if (this.allErrors)
	                this.gen.endIf();
	        }
	        else {
	            if (this.allErrors)
	                this.gen.endIf();
	            else
	                this.gen.else();
	        }
	    }
	    pass(condition, failAction) {
	        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
	    }
	    fail(condition) {
	        if (condition === undefined) {
	            this.error();
	            if (!this.allErrors)
	                this.gen.if(false); // this branch will be removed by gen.optimize
	            return;
	        }
	        this.gen.if(condition);
	        this.error();
	        if (this.allErrors)
	            this.gen.endIf();
	        else
	            this.gen.else();
	    }
	    fail$data(condition) {
	        if (!this.$data)
	            return this.fail(condition);
	        const { schemaCode } = this;
	        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
	    }
	    error(append, errorParams, errorPaths) {
	        if (errorParams) {
	            this.setParams(errorParams);
	            this._error(append, errorPaths);
	            this.setParams({});
	            return;
	        }
	        this._error(append, errorPaths);
	    }
	    _error(append, errorPaths) {
	        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
	    }
	    $dataError() {
	        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
	    }
	    reset() {
	        if (this.errsCount === undefined)
	            throw new Error('add "trackErrors" to keyword definition');
	        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
	    }
	    ok(cond) {
	        if (!this.allErrors)
	            this.gen.if(cond);
	    }
	    setParams(obj, assign) {
	        if (assign)
	            Object.assign(this.params, obj);
	        else
	            this.params = obj;
	    }
	    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
	        this.gen.block(() => {
	            this.check$data(valid, $dataValid);
	            codeBlock();
	        });
	    }
	    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
	        if (!this.$data)
	            return;
	        const { gen, schemaCode, schemaType, def } = this;
	        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
	        if (valid !== codegen_1.nil)
	            gen.assign(valid, true);
	        if (schemaType.length || def.validateSchema) {
	            gen.elseIf(this.invalid$data());
	            this.$dataError();
	            if (valid !== codegen_1.nil)
	                gen.assign(valid, false);
	        }
	        gen.else();
	    }
	    invalid$data() {
	        const { gen, schemaCode, schemaType, def, it } = this;
	        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
	        function wrong$DataType() {
	            if (schemaType.length) {
	                /* istanbul ignore if */
	                if (!(schemaCode instanceof codegen_1.Name))
	                    throw new Error("ajv implementation error");
	                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
	                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
	            }
	            return codegen_1.nil;
	        }
	        function invalid$DataSchema() {
	            if (def.validateSchema) {
	                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
	                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
	            }
	            return codegen_1.nil;
	        }
	    }
	    subschema(appl, valid) {
	        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
	        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
	        (0, subschema_1.extendSubschemaMode)(subschema, appl);
	        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
	        subschemaCode(nextContext, valid);
	        return nextContext;
	    }
	    mergeEvaluated(schemaCxt, toName) {
	        const { it, gen } = this;
	        if (!it.opts.unevaluated)
	            return;
	        if (it.props !== true && schemaCxt.props !== undefined) {
	            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
	        }
	        if (it.items !== true && schemaCxt.items !== undefined) {
	            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
	        }
	    }
	    mergeValidEvaluated(schemaCxt, valid) {
	        const { it, gen } = this;
	        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
	            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
	            return true;
	        }
	    }
	}
	validate.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
	    const cxt = new KeywordCxt(it, def, keyword);
	    if ("code" in def) {
	        def.code(cxt, ruleType);
	    }
	    else if (cxt.$data && def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	    else if ("macro" in def) {
	        (0, keyword_1.macroKeywordCode)(cxt, def);
	    }
	    else if (def.compile || def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
	    let jsonPointer;
	    let data;
	    if ($data === "")
	        return names_1.default.rootData;
	    if ($data[0] === "/") {
	        if (!JSON_POINTER.test($data))
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        jsonPointer = $data;
	        data = names_1.default.rootData;
	    }
	    else {
	        const matches = RELATIVE_JSON_POINTER.exec($data);
	        if (!matches)
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        const up = +matches[1];
	        jsonPointer = matches[2];
	        if (jsonPointer === "#") {
	            if (up >= dataLevel)
	                throw new Error(errorMsg("property/index", up));
	            return dataPathArr[dataLevel - up];
	        }
	        if (up > dataLevel)
	            throw new Error(errorMsg("data", up));
	        data = dataNames[dataLevel - up];
	        if (!jsonPointer)
	            return data;
	    }
	    let expr = data;
	    const segments = jsonPointer.split("/");
	    for (const segment of segments) {
	        if (segment) {
	            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
	            expr = (0, codegen_1._) `${expr} && ${data}`;
	        }
	    }
	    return expr;
	    function errorMsg(pointerType, up) {
	        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
	    }
	}
	validate.getData = getData;
	
	return validate;
}

var validation_error = {};

var hasRequiredValidation_error;

function requireValidation_error () {
	if (hasRequiredValidation_error) return validation_error;
	hasRequiredValidation_error = 1;
	Object.defineProperty(validation_error, "__esModule", { value: true });
	class ValidationError extends Error {
	    constructor(errors) {
	        super("validation failed");
	        this.errors = errors;
	        this.ajv = this.validation = true;
	    }
	}
	validation_error.default = ValidationError;
	
	return validation_error;
}

var ref_error = {};

var hasRequiredRef_error;

function requireRef_error () {
	if (hasRequiredRef_error) return ref_error;
	hasRequiredRef_error = 1;
	Object.defineProperty(ref_error, "__esModule", { value: true });
	const resolve_1 = requireResolve();
	class MissingRefError extends Error {
	    constructor(resolver, baseId, ref, msg) {
	        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
	        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
	        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
	    }
	}
	ref_error.default = MissingRefError;
	
	return ref_error;
}

var compile = {};

var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile;
	hasRequiredCompile = 1;
	Object.defineProperty(compile, "__esModule", { value: true });
	compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
	const codegen_1 = requireCodegen();
	const validation_error_1 = requireValidation_error();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil();
	const validate_1 = requireValidate();
	class SchemaEnv {
	    constructor(env) {
	        var _a;
	        this.refs = {};
	        this.dynamicAnchors = {};
	        let schema;
	        if (typeof env.schema == "object")
	            schema = env.schema;
	        this.schema = env.schema;
	        this.schemaId = env.schemaId;
	        this.root = env.root || this;
	        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
	        this.schemaPath = env.schemaPath;
	        this.localRefs = env.localRefs;
	        this.meta = env.meta;
	        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
	        this.refs = {};
	    }
	}
	compile.SchemaEnv = SchemaEnv;
	// let codeSize = 0
	// let nodeCount = 0
	// Compiles schema in SchemaEnv
	function compileSchema(sch) {
	    // TODO refactor - remove compilations
	    const _sch = getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    let _ValidationError;
	    if (sch.$async) {
	        _ValidationError = gen.scopeValue("Error", {
	            ref: validation_error_1.default,
	            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,
	        });
	    }
	    const validateName = gen.scopeName("validate");
	    sch.validateName = validateName;
	    const schemaCxt = {
	        gen,
	        allErrors: this.opts.allErrors,
	        data: names_1.default.data,
	        parentData: names_1.default.parentData,
	        parentDataProperty: names_1.default.parentDataProperty,
	        dataNames: [names_1.default.data],
	        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?
	        dataLevel: 0,
	        dataTypes: [],
	        definedProperties: new Set(),
	        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
	            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
	            : { ref: sch.schema }),
	        validateName,
	        ValidationError: _ValidationError,
	        schema: sch.schema,
	        schemaEnv: sch,
	        rootId,
	        baseId: sch.baseId || rootId,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
	        errorPath: (0, codegen_1._) `""`,
	        opts: this.opts,
	        self: this,
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        (0, validate_1.validateFunctionCode)(schemaCxt);
	        gen.optimize(this.opts.code.optimize);
	        // gen.optimize(1)
	        const validateCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
	        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
	        if (this.opts.code.process)
	            sourceCode = this.opts.code.process(sourceCode, sch);
	        // console.log("\n\n\n *** \n", sourceCode)
	        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
	        const validate = makeValidate(this, this.scope.get());
	        this.scope.value(validateName, { ref: validate });
	        validate.errors = null;
	        validate.schema = sch.schema;
	        validate.schemaEnv = sch;
	        if (sch.$async)
	            validate.$async = true;
	        if (this.opts.code.source === true) {
	            validate.source = { validateName, validateCode, scopeValues: gen._values };
	        }
	        if (this.opts.unevaluated) {
	            const { props, items } = schemaCxt;
	            validate.evaluated = {
	                props: props instanceof codegen_1.Name ? undefined : props,
	                items: items instanceof codegen_1.Name ? undefined : items,
	                dynamicProps: props instanceof codegen_1.Name,
	                dynamicItems: items instanceof codegen_1.Name,
	            };
	            if (validate.source)
	                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
	        }
	        sch.validate = validate;
	        return sch;
	    }
	    catch (e) {
	        delete sch.validate;
	        delete sch.validateName;
	        if (sourceCode)
	            this.logger.error("Error compiling schema, function code:", sourceCode);
	        // console.log("\n\n\n *** \n", sourceCode, this.opts)
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	}
	compile.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
	    var _a;
	    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
	    const schOrFunc = root.refs[ref];
	    if (schOrFunc)
	        return schOrFunc;
	    let _sch = resolve.call(this, root, ref);
	    if (_sch === undefined) {
	        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
	        const { schemaId } = this.opts;
	        if (schema)
	            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    if (_sch === undefined)
	        return;
	    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
	}
	compile.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
	    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
	        return sch.schema;
	    return sch.validate ? sch : compileSchema.call(this, sch);
	}
	// Index of schema compilation in the currently compiled list
	function getCompilingSchema(schEnv) {
	    for (const sch of this._compilations) {
	        if (sameSchemaEnv(sch, schEnv))
	            return sch;
	    }
	}
	compile.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
	    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	// resolve and compile the references ($ref)
	// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
	function resolve(root, // information about the root schema for the current schema
	ref // reference to resolve
	) {
	    let sch;
	    while (typeof (sch = this.refs[ref]) == "string")
	        ref = sch;
	    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	// Resolve schema, its root and baseId
	function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
	ref // reference to resolve
	) {
	    const p = this.opts.uriResolver.parse(ref);
	    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
	    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
	    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
	    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
	        return getJsonPointer.call(this, p, root);
	    }
	    const id = (0, resolve_1.normalizeId)(refPath);
	    const schOrRef = this.refs[id] || this.schemas[id];
	    if (typeof schOrRef == "string") {
	        const sch = resolveSchema.call(this, root, schOrRef);
	        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
	            return;
	        return getJsonPointer.call(this, p, sch);
	    }
	    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
	        return;
	    if (!schOrRef.validate)
	        compileSchema.call(this, schOrRef);
	    if (id === (0, resolve_1.normalizeId)(ref)) {
	        const { schema } = schOrRef;
	        const { schemaId } = this.opts;
	        const schId = schema[schemaId];
	        if (schId)
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        return new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    return getJsonPointer.call(this, p, schOrRef);
	}
	compile.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
	    "properties",
	    "patternProperties",
	    "enum",
	    "dependencies",
	    "definitions",
	]);
	function getJsonPointer(parsedRef, { baseId, schema, root }) {
	    var _a;
	    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
	        return;
	    for (const part of parsedRef.fragment.slice(1).split("/")) {
	        if (typeof schema === "boolean")
	            return;
	        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
	        if (partSchema === undefined)
	            return;
	        schema = partSchema;
	        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
	        const schId = typeof schema === "object" && schema[this.opts.schemaId];
	        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        }
	    }
	    let env;
	    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
	        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
	        env = resolveSchema.call(this, root, $ref);
	    }
	    // even though resolution failed we need to return SchemaEnv to throw exception
	    // so that compileAsync loads missing schema.
	    const { schemaId } = this.opts;
	    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
	    if (env.schema !== env.root.schema)
	        return env;
	    return undefined;
	}
	
	return compile;
}

var $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var type$1 = "object";
var required$1 = [
	"$data"
];
var properties$2 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties$1 = false;
var require$$9 = {
	$id: $id$1,
	description: description,
	type: type$1,
	required: required$1,
	properties: properties$2,
	additionalProperties: additionalProperties$1
};

var uri = {};

var fastUri = {exports: {}};

var scopedChars;
var hasRequiredScopedChars;

function requireScopedChars () {
	if (hasRequiredScopedChars) return scopedChars;
	hasRequiredScopedChars = 1;

	const HEX = {
	  0: 0,
	  1: 1,
	  2: 2,
	  3: 3,
	  4: 4,
	  5: 5,
	  6: 6,
	  7: 7,
	  8: 8,
	  9: 9,
	  a: 10,
	  A: 10,
	  b: 11,
	  B: 11,
	  c: 12,
	  C: 12,
	  d: 13,
	  D: 13,
	  e: 14,
	  E: 14,
	  f: 15,
	  F: 15
	};

	scopedChars = {
	  HEX
	};
	return scopedChars;
}

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	const { HEX } = requireScopedChars();

	const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;

	function normalizeIPv4 (host) {
	  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }
	  const matches = host.match(IPV4_REG) || [];
	  const [address] = matches;
	  if (address) {
	    return { host: stripLeadingZeros(address, '.'), isIPV4: true }
	  } else {
	    return { host, isIPV4: false }
	  }
	}

	/**
	 * @param {string[]} input
	 * @param {boolean} [keepZero=false]
	 * @returns {string|undefined}
	 */
	function stringArrayToHexStripped (input, keepZero = false) {
	  let acc = '';
	  let strip = true;
	  for (const c of input) {
	    if (HEX[c] === undefined) return undefined
	    if (c !== '0' && strip === true) strip = false;
	    if (!strip) acc += c;
	  }
	  if (keepZero && acc.length === 0) acc = '0';
	  return acc
	}

	function getIPV6 (input) {
	  let tokenCount = 0;
	  const output = { error: false, address: '', zone: '' };
	  const address = [];
	  const buffer = [];
	  let isZone = false;
	  let endipv6Encountered = false;
	  let endIpv6 = false;

	  function consume () {
	    if (buffer.length) {
	      if (isZone === false) {
	        const hex = stringArrayToHexStripped(buffer);
	        if (hex !== undefined) {
	          address.push(hex);
	        } else {
	          output.error = true;
	          return false
	        }
	      }
	      buffer.length = 0;
	    }
	    return true
	  }

	  for (let i = 0; i < input.length; i++) {
	    const cursor = input[i];
	    if (cursor === '[' || cursor === ']') { continue }
	    if (cursor === ':') {
	      if (endipv6Encountered === true) {
	        endIpv6 = true;
	      }
	      if (!consume()) { break }
	      tokenCount++;
	      address.push(':');
	      if (tokenCount > 7) {
	        // not valid
	        output.error = true;
	        break
	      }
	      if (i - 1 >= 0 && input[i - 1] === ':') {
	        endipv6Encountered = true;
	      }
	      continue
	    } else if (cursor === '%') {
	      if (!consume()) { break }
	      // switch to zone detection
	      isZone = true;
	    } else {
	      buffer.push(cursor);
	      continue
	    }
	  }
	  if (buffer.length) {
	    if (isZone) {
	      output.zone = buffer.join('');
	    } else if (endIpv6) {
	      address.push(buffer.join(''));
	    } else {
	      address.push(stringArrayToHexStripped(buffer));
	    }
	  }
	  output.address = address.join('');
	  return output
	}

	function normalizeIPv6 (host) {
	  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }
	  const ipv6 = getIPV6(host);

	  if (!ipv6.error) {
	    let newHost = ipv6.address;
	    let escapedHost = ipv6.address;
	    if (ipv6.zone) {
	      newHost += '%' + ipv6.zone;
	      escapedHost += '%25' + ipv6.zone;
	    }
	    return { host: newHost, escapedHost, isIPV6: true }
	  } else {
	    return { host, isIPV6: false }
	  }
	}

	function stripLeadingZeros (str, token) {
	  let out = '';
	  let skip = true;
	  const l = str.length;
	  for (let i = 0; i < l; i++) {
	    const c = str[i];
	    if (c === '0' && skip) {
	      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {
	        out += c;
	        skip = false;
	      }
	    } else {
	      if (c === token) {
	        skip = true;
	      } else {
	        skip = false;
	      }
	      out += c;
	    }
	  }
	  return out
	}

	function findToken (str, token) {
	  let ind = 0;
	  for (let i = 0; i < str.length; i++) {
	    if (str[i] === token) ind++;
	  }
	  return ind
	}

	const RDS1 = /^\.\.?\//u;
	const RDS2 = /^\/\.(?:\/|$)/u;
	const RDS3 = /^\/\.\.(?:\/|$)/u;
	const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;

	function removeDotSegments (input) {
	  const output = [];

	  while (input.length) {
	    if (input.match(RDS1)) {
	      input = input.replace(RDS1, '');
	    } else if (input.match(RDS2)) {
	      input = input.replace(RDS2, '/');
	    } else if (input.match(RDS3)) {
	      input = input.replace(RDS3, '/');
	      output.pop();
	    } else if (input === '.' || input === '..') {
	      input = '';
	    } else {
	      const im = input.match(RDS5);
	      if (im) {
	        const s = im[0];
	        input = input.slice(s.length);
	        output.push(s);
	      } else {
	        throw new Error('Unexpected dot segment condition')
	      }
	    }
	  }
	  return output.join('')
	}

	function normalizeComponentEncoding (components, esc) {
	  const func = esc !== true ? escape : unescape;
	  if (components.scheme !== undefined) {
	    components.scheme = func(components.scheme);
	  }
	  if (components.userinfo !== undefined) {
	    components.userinfo = func(components.userinfo);
	  }
	  if (components.host !== undefined) {
	    components.host = func(components.host);
	  }
	  if (components.path !== undefined) {
	    components.path = func(components.path);
	  }
	  if (components.query !== undefined) {
	    components.query = func(components.query);
	  }
	  if (components.fragment !== undefined) {
	    components.fragment = func(components.fragment);
	  }
	  return components
	}

	function recomposeAuthority (components) {
	  const uriTokens = [];

	  if (components.userinfo !== undefined) {
	    uriTokens.push(components.userinfo);
	    uriTokens.push('@');
	  }

	  if (components.host !== undefined) {
	    let host = unescape(components.host);
	    const ipV4res = normalizeIPv4(host);

	    if (ipV4res.isIPV4) {
	      host = ipV4res.host;
	    } else {
	      const ipV6res = normalizeIPv6(ipV4res.host);
	      if (ipV6res.isIPV6 === true) {
	        host = `[${ipV6res.escapedHost}]`;
	      } else {
	        host = components.host;
	      }
	    }
	    uriTokens.push(host);
	  }

	  if (typeof components.port === 'number' || typeof components.port === 'string') {
	    uriTokens.push(':');
	    uriTokens.push(String(components.port));
	  }

	  return uriTokens.length ? uriTokens.join('') : undefined
	}
	utils = {
	  recomposeAuthority,
	  normalizeComponentEncoding,
	  removeDotSegments,
	  normalizeIPv4,
	  normalizeIPv6,
	  stringArrayToHexStripped
	};
	return utils;
}

var schemes;
var hasRequiredSchemes;

function requireSchemes () {
	if (hasRequiredSchemes) return schemes;
	hasRequiredSchemes = 1;

	const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;

	function isSecure (wsComponents) {
	  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'
	}

	function httpParse (components) {
	  if (!components.host) {
	    components.error = components.error || 'HTTP URIs must have a host.';
	  }

	  return components
	}

	function httpSerialize (components) {
	  const secure = String(components.scheme).toLowerCase() === 'https';

	  // normalize the default port
	  if (components.port === (secure ? 443 : 80) || components.port === '') {
	    components.port = undefined;
	  }

	  // normalize the empty path
	  if (!components.path) {
	    components.path = '/';
	  }

	  // NOTE: We do not parse query strings for HTTP URIs
	  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,
	  // and not the HTTP spec.

	  return components
	}

	function wsParse (wsComponents) {
	// indicate if the secure flag is set
	  wsComponents.secure = isSecure(wsComponents);

	  // construct resouce name
	  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
	  wsComponents.path = undefined;
	  wsComponents.query = undefined;

	  return wsComponents
	}

	function wsSerialize (wsComponents) {
	// normalize the default port
	  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {
	    wsComponents.port = undefined;
	  }

	  // ensure scheme matches secure flag
	  if (typeof wsComponents.secure === 'boolean') {
	    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');
	    wsComponents.secure = undefined;
	  }

	  // reconstruct path from resource name
	  if (wsComponents.resourceName) {
	    const [path, query] = wsComponents.resourceName.split('?');
	    wsComponents.path = (path && path !== '/' ? path : undefined);
	    wsComponents.query = query;
	    wsComponents.resourceName = undefined;
	  }

	  // forbid fragment component
	  wsComponents.fragment = undefined;

	  return wsComponents
	}

	function urnParse (urnComponents, options) {
	  if (!urnComponents.path) {
	    urnComponents.error = 'URN can not be parsed';
	    return urnComponents
	  }
	  const matches = urnComponents.path.match(URN_REG);
	  if (matches) {
	    const scheme = options.scheme || urnComponents.scheme || 'urn';
	    urnComponents.nid = matches[1].toLowerCase();
	    urnComponents.nss = matches[2];
	    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
	    const schemeHandler = SCHEMES[urnScheme];
	    urnComponents.path = undefined;

	    if (schemeHandler) {
	      urnComponents = schemeHandler.parse(urnComponents, options);
	    }
	  } else {
	    urnComponents.error = urnComponents.error || 'URN can not be parsed.';
	  }

	  return urnComponents
	}

	function urnSerialize (urnComponents, options) {
	  const scheme = options.scheme || urnComponents.scheme || 'urn';
	  const nid = urnComponents.nid.toLowerCase();
	  const urnScheme = `${scheme}:${options.nid || nid}`;
	  const schemeHandler = SCHEMES[urnScheme];

	  if (schemeHandler) {
	    urnComponents = schemeHandler.serialize(urnComponents, options);
	  }

	  const uriComponents = urnComponents;
	  const nss = urnComponents.nss;
	  uriComponents.path = `${nid || options.nid}:${nss}`;

	  options.skipEscape = true;
	  return uriComponents
	}

	function urnuuidParse (urnComponents, options) {
	  const uuidComponents = urnComponents;
	  uuidComponents.uuid = uuidComponents.nss;
	  uuidComponents.nss = undefined;

	  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
	    uuidComponents.error = uuidComponents.error || 'UUID is not valid.';
	  }

	  return uuidComponents
	}

	function urnuuidSerialize (uuidComponents) {
	  const urnComponents = uuidComponents;
	  // normalize UUID
	  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase();
	  return urnComponents
	}

	const http = {
	  scheme: 'http',
	  domainHost: true,
	  parse: httpParse,
	  serialize: httpSerialize
	};

	const https = {
	  scheme: 'https',
	  domainHost: http.domainHost,
	  parse: httpParse,
	  serialize: httpSerialize
	};

	const ws = {
	  scheme: 'ws',
	  domainHost: true,
	  parse: wsParse,
	  serialize: wsSerialize
	};

	const wss = {
	  scheme: 'wss',
	  domainHost: ws.domainHost,
	  parse: ws.parse,
	  serialize: ws.serialize
	};

	const urn = {
	  scheme: 'urn',
	  parse: urnParse,
	  serialize: urnSerialize,
	  skipNormalize: true
	};

	const urnuuid = {
	  scheme: 'urn:uuid',
	  parse: urnuuidParse,
	  serialize: urnuuidSerialize,
	  skipNormalize: true
	};

	const SCHEMES = {
	  http,
	  https,
	  ws,
	  wss,
	  urn,
	  'urn:uuid': urnuuid
	};

	schemes = SCHEMES;
	return schemes;
}

var hasRequiredFastUri;

function requireFastUri () {
	if (hasRequiredFastUri) return fastUri.exports;
	hasRequiredFastUri = 1;

	const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = requireUtils();
	const SCHEMES = requireSchemes();

	function normalize (uri, options) {
	  if (typeof uri === 'string') {
	    uri = serialize(parse(uri, options), options);
	  } else if (typeof uri === 'object') {
	    uri = parse(serialize(uri, options), options);
	  }
	  return uri
	}

	function resolve (baseURI, relativeURI, options) {
	  const schemelessOptions = Object.assign({ scheme: 'null' }, options);
	  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
	  return serialize(resolved, { ...schemelessOptions, skipEscape: true })
	}

	function resolveComponents (base, relative, options, skipNormalization) {
	  const target = {};
	  if (!skipNormalization) {
	    base = parse(serialize(base, options), options); // normalize base components
	    relative = parse(serialize(relative, options), options); // normalize relative components
	  }
	  options = options || {};

	  if (!options.tolerant && relative.scheme) {
	    target.scheme = relative.scheme;
	    // target.authority = relative.authority;
	    target.userinfo = relative.userinfo;
	    target.host = relative.host;
	    target.port = relative.port;
	    target.path = removeDotSegments(relative.path || '');
	    target.query = relative.query;
	  } else {
	    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
	      // target.authority = relative.authority;
	      target.userinfo = relative.userinfo;
	      target.host = relative.host;
	      target.port = relative.port;
	      target.path = removeDotSegments(relative.path || '');
	      target.query = relative.query;
	    } else {
	      if (!relative.path) {
	        target.path = base.path;
	        if (relative.query !== undefined) {
	          target.query = relative.query;
	        } else {
	          target.query = base.query;
	        }
	      } else {
	        if (relative.path.charAt(0) === '/') {
	          target.path = removeDotSegments(relative.path);
	        } else {
	          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
	            target.path = '/' + relative.path;
	          } else if (!base.path) {
	            target.path = relative.path;
	          } else {
	            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path;
	          }
	          target.path = removeDotSegments(target.path);
	        }
	        target.query = relative.query;
	      }
	      // target.authority = base.authority;
	      target.userinfo = base.userinfo;
	      target.host = base.host;
	      target.port = base.port;
	    }
	    target.scheme = base.scheme;
	  }

	  target.fragment = relative.fragment;

	  return target
	}

	function equal (uriA, uriB, options) {
	  if (typeof uriA === 'string') {
	    uriA = unescape(uriA);
	    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriA === 'object') {
	    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
	  }

	  if (typeof uriB === 'string') {
	    uriB = unescape(uriB);
	    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriB === 'object') {
	    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
	  }

	  return uriA.toLowerCase() === uriB.toLowerCase()
	}

	function serialize (cmpts, opts) {
	  const components = {
	    host: cmpts.host,
	    scheme: cmpts.scheme,
	    userinfo: cmpts.userinfo,
	    port: cmpts.port,
	    path: cmpts.path,
	    query: cmpts.query,
	    nid: cmpts.nid,
	    nss: cmpts.nss,
	    uuid: cmpts.uuid,
	    fragment: cmpts.fragment,
	    reference: cmpts.reference,
	    resourceName: cmpts.resourceName,
	    secure: cmpts.secure,
	    error: ''
	  };
	  const options = Object.assign({}, opts);
	  const uriTokens = [];

	  // find scheme handler
	  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()];

	  // perform scheme specific serialization
	  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

	  if (components.path !== undefined) {
	    if (!options.skipEscape) {
	      components.path = escape(components.path);

	      if (components.scheme !== undefined) {
	        components.path = components.path.split('%3A').join(':');
	      }
	    } else {
	      components.path = unescape(components.path);
	    }
	  }

	  if (options.reference !== 'suffix' && components.scheme) {
	    uriTokens.push(components.scheme, ':');
	  }

	  const authority = recomposeAuthority(components);
	  if (authority !== undefined) {
	    if (options.reference !== 'suffix') {
	      uriTokens.push('//');
	    }

	    uriTokens.push(authority);

	    if (components.path && components.path.charAt(0) !== '/') {
	      uriTokens.push('/');
	    }
	  }
	  if (components.path !== undefined) {
	    let s = components.path;

	    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
	      s = removeDotSegments(s);
	    }

	    if (authority === undefined) {
	      s = s.replace(/^\/\//u, '/%2F'); // don't allow the path to start with "//"
	    }

	    uriTokens.push(s);
	  }

	  if (components.query !== undefined) {
	    uriTokens.push('?', components.query);
	  }

	  if (components.fragment !== undefined) {
	    uriTokens.push('#', components.fragment);
	  }
	  return uriTokens.join('')
	}

	const hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));

	function nonSimpleDomain (value) {
	  let code = 0;
	  for (let i = 0, len = value.length; i < len; ++i) {
	    code = value.charCodeAt(i);
	    if (code > 126 || hexLookUp[code]) {
	      return true
	    }
	  }
	  return false
	}

	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;

	function parse (uri, opts) {
	  const options = Object.assign({}, opts);
	  const parsed = {
	    scheme: undefined,
	    userinfo: undefined,
	    host: '',
	    port: undefined,
	    path: '',
	    query: undefined,
	    fragment: undefined
	  };
	  const gotEncoding = uri.indexOf('%') !== -1;
	  let isIP = false;
	  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri;

	  const matches = uri.match(URI_PARSE);

	  if (matches) {
	    // store each component
	    parsed.scheme = matches[1];
	    parsed.userinfo = matches[3];
	    parsed.host = matches[4];
	    parsed.port = parseInt(matches[5], 10);
	    parsed.path = matches[6] || '';
	    parsed.query = matches[7];
	    parsed.fragment = matches[8];

	    // fix port number
	    if (isNaN(parsed.port)) {
	      parsed.port = matches[5];
	    }
	    if (parsed.host) {
	      const ipv4result = normalizeIPv4(parsed.host);
	      if (ipv4result.isIPV4 === false) {
	        const ipv6result = normalizeIPv6(ipv4result.host);
	        parsed.host = ipv6result.host.toLowerCase();
	        isIP = ipv6result.isIPV6;
	      } else {
	        parsed.host = ipv4result.host;
	        isIP = true;
	      }
	    }
	    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
	      parsed.reference = 'same-document';
	    } else if (parsed.scheme === undefined) {
	      parsed.reference = 'relative';
	    } else if (parsed.fragment === undefined) {
	      parsed.reference = 'absolute';
	    } else {
	      parsed.reference = 'uri';
	    }

	    // check for reference errors
	    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {
	      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.';
	    }

	    // find scheme handler
	    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()];

	    // check if scheme can't handle IRIs
	    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
	      // if host component is a domain name
	      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {
	        // convert Unicode IDN -> ASCII IDN
	        try {
	          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
	        } catch (e) {
	          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
	        }
	      }
	      // convert IRI -> URI
	    }

	    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {
	      if (gotEncoding && parsed.scheme !== undefined) {
	        parsed.scheme = unescape(parsed.scheme);
	      }
	      if (gotEncoding && parsed.host !== undefined) {
	        parsed.host = unescape(parsed.host);
	      }
	      if (parsed.path) {
	        parsed.path = escape(unescape(parsed.path));
	      }
	      if (parsed.fragment) {
	        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
	      }
	    }

	    // perform scheme specific parsing
	    if (schemeHandler && schemeHandler.parse) {
	      schemeHandler.parse(parsed, options);
	    }
	  } else {
	    parsed.error = parsed.error || 'URI can not be parsed.';
	  }
	  return parsed
	}

	const fastUri$1 = {
	  SCHEMES,
	  normalize,
	  resolve,
	  resolveComponents,
	  equal,
	  serialize,
	  parse
	};

	fastUri.exports = fastUri$1;
	fastUri.exports.default = fastUri$1;
	fastUri.exports.fastUri = fastUri$1;
	return fastUri.exports;
}

var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;
	Object.defineProperty(uri, "__esModule", { value: true });
	const uri$1 = requireFastUri();
	uri$1.code = 'require("ajv/dist/runtime/uri").default';
	uri.default = uri$1;
	
	return uri;
}

var hasRequiredCore$1;

function requireCore$1 () {
	if (hasRequiredCore$1) return core$1;
	hasRequiredCore$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		const validation_error_1 = requireValidation_error();
		const ref_error_1 = requireRef_error();
		const rules_1 = requireRules();
		const compile_1 = requireCompile();
		const codegen_2 = requireCodegen();
		const resolve_1 = requireResolve();
		const dataType_1 = requireDataType();
		const util_1 = requireUtil();
		const $dataRefSchema = require$$9;
		const uri_1 = requireUri();
		const defaultRegExp = (str, flags) => new RegExp(str, flags);
		defaultRegExp.code = "new RegExp";
		const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
		const EXT_SCOPE_NAMES = new Set([
		    "validate",
		    "serialize",
		    "parse",
		    "wrapper",
		    "root",
		    "schema",
		    "keyword",
		    "pattern",
		    "formats",
		    "validate$data",
		    "func",
		    "obj",
		    "Error",
		]);
		const removedOptions = {
		    errorDataPath: "",
		    format: "`validateFormats: false` can be used instead.",
		    nullable: '"nullable" keyword is supported by default.',
		    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		    sourceCode: "Use option `code: {source: true}`",
		    strictDefaults: "It is default now, see option `strict`.",
		    strictKeywords: "It is default now, see option `strict`.",
		    uniqueItems: '"uniqueItems" keyword is always validated.',
		    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		    cache: "Map is used as cache, schema object as key.",
		    serialize: "Map is used as cache, schema object as key.",
		    ajvErrors: "It is default now.",
		};
		const deprecatedOptions = {
		    ignoreKeywordsWithRef: "",
		    jsPropertySyntax: "",
		    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
		};
		const MAX_EXPRESSION = 200;
		// eslint-disable-next-line complexity
		function requiredOptions(o) {
		    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		    const s = o.strict;
		    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
		    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
		    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
		    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		    return {
		        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
		        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
		        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
		        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
		        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
		        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
		        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
		        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
		        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
		        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
		        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
		        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
		        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
		        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
		        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
		        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
		        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
		        uriResolver: uriResolver,
		    };
		}
		class Ajv {
		    constructor(opts = {}) {
		        this.schemas = {};
		        this.refs = {};
		        this.formats = {};
		        this._compilations = new Set();
		        this._loading = {};
		        this._cache = new Map();
		        opts = this.opts = { ...opts, ...requiredOptions(opts) };
		        const { es5, lines } = this.opts.code;
		        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
		        this.logger = getLogger(opts.logger);
		        const formatOpt = opts.validateFormats;
		        opts.validateFormats = false;
		        this.RULES = (0, rules_1.getRules)();
		        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
		        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
		        this._metaOpts = getMetaSchemaOptions.call(this);
		        if (opts.formats)
		            addInitialFormats.call(this);
		        this._addVocabularies();
		        this._addDefaultMetaSchema();
		        if (opts.keywords)
		            addInitialKeywords.call(this, opts.keywords);
		        if (typeof opts.meta == "object")
		            this.addMetaSchema(opts.meta);
		        addInitialSchemas.call(this);
		        opts.validateFormats = formatOpt;
		    }
		    _addVocabularies() {
		        this.addKeyword("$async");
		    }
		    _addDefaultMetaSchema() {
		        const { $data, meta, schemaId } = this.opts;
		        let _dataRefSchema = $dataRefSchema;
		        if (schemaId === "id") {
		            _dataRefSchema = { ...$dataRefSchema };
		            _dataRefSchema.id = _dataRefSchema.$id;
		            delete _dataRefSchema.$id;
		        }
		        if (meta && $data)
		            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		    }
		    defaultMeta() {
		        const { meta, schemaId } = this.opts;
		        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
		    }
		    validate(schemaKeyRef, // key, ref or schema object
		    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
		    data // to be validated
		    ) {
		        let v;
		        if (typeof schemaKeyRef == "string") {
		            v = this.getSchema(schemaKeyRef);
		            if (!v)
		                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
		        }
		        else {
		            v = this.compile(schemaKeyRef);
		        }
		        const valid = v(data);
		        if (!("$async" in v))
		            this.errors = v.errors;
		        return valid;
		    }
		    compile(schema, _meta) {
		        const sch = this._addSchema(schema, _meta);
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    compileAsync(schema, meta) {
		        if (typeof this.opts.loadSchema != "function") {
		            throw new Error("options.loadSchema should be a function");
		        }
		        const { loadSchema } = this.opts;
		        return runCompileAsync.call(this, schema, meta);
		        async function runCompileAsync(_schema, _meta) {
		            await loadMetaSchema.call(this, _schema.$schema);
		            const sch = this._addSchema(_schema, _meta);
		            return sch.validate || _compileAsync.call(this, sch);
		        }
		        async function loadMetaSchema($ref) {
		            if ($ref && !this.getSchema($ref)) {
		                await runCompileAsync.call(this, { $ref }, true);
		            }
		        }
		        async function _compileAsync(sch) {
		            try {
		                return this._compileSchemaEnv(sch);
		            }
		            catch (e) {
		                if (!(e instanceof ref_error_1.default))
		                    throw e;
		                checkLoaded.call(this, e);
		                await loadMissingSchema.call(this, e.missingSchema);
		                return _compileAsync.call(this, sch);
		            }
		        }
		        function checkLoaded({ missingSchema: ref, missingRef }) {
		            if (this.refs[ref]) {
		                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
		            }
		        }
		        async function loadMissingSchema(ref) {
		            const _schema = await _loadSchema.call(this, ref);
		            if (!this.refs[ref])
		                await loadMetaSchema.call(this, _schema.$schema);
		            if (!this.refs[ref])
		                this.addSchema(_schema, ref, meta);
		        }
		        async function _loadSchema(ref) {
		            const p = this._loading[ref];
		            if (p)
		                return p;
		            try {
		                return await (this._loading[ref] = loadSchema(ref));
		            }
		            finally {
		                delete this._loading[ref];
		            }
		        }
		    }
		    // Adds schema to the instance
		    addSchema(schema, // If array is passed, `key` will be ignored
		    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
		    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
		    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
		    ) {
		        if (Array.isArray(schema)) {
		            for (const sch of schema)
		                this.addSchema(sch, undefined, _meta, _validateSchema);
		            return this;
		        }
		        let id;
		        if (typeof schema === "object") {
		            const { schemaId } = this.opts;
		            id = schema[schemaId];
		            if (id !== undefined && typeof id != "string") {
		                throw new Error(`schema ${schemaId} must be string`);
		            }
		        }
		        key = (0, resolve_1.normalizeId)(key || id);
		        this._checkUnique(key);
		        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
		        return this;
		    }
		    // Add schema that will be used to validate other schemas
		    // options in META_IGNORE_OPTIONS are alway set to false
		    addMetaSchema(schema, key, // schema key
		    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
		    ) {
		        this.addSchema(schema, key, true, _validateSchema);
		        return this;
		    }
		    //  Validate schema against its meta-schema
		    validateSchema(schema, throwOrLogError) {
		        if (typeof schema == "boolean")
		            return true;
		        let $schema;
		        $schema = schema.$schema;
		        if ($schema !== undefined && typeof $schema != "string") {
		            throw new Error("$schema must be a string");
		        }
		        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
		        if (!$schema) {
		            this.logger.warn("meta-schema not available");
		            this.errors = null;
		            return true;
		        }
		        const valid = this.validate($schema, schema);
		        if (!valid && throwOrLogError) {
		            const message = "schema is invalid: " + this.errorsText();
		            if (this.opts.validateSchema === "log")
		                this.logger.error(message);
		            else
		                throw new Error(message);
		        }
		        return valid;
		    }
		    // Get compiled schema by `key` or `ref`.
		    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
		    getSchema(keyRef) {
		        let sch;
		        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
		            keyRef = sch;
		        if (sch === undefined) {
		            const { schemaId } = this.opts;
		            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
		            sch = compile_1.resolveSchema.call(this, root, keyRef);
		            if (!sch)
		                return;
		            this.refs[keyRef] = sch;
		        }
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    // Remove cached schema(s).
		    // If no parameter is passed all schemas but meta-schemas are removed.
		    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
		    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
		    removeSchema(schemaKeyRef) {
		        if (schemaKeyRef instanceof RegExp) {
		            this._removeAllSchemas(this.schemas, schemaKeyRef);
		            this._removeAllSchemas(this.refs, schemaKeyRef);
		            return this;
		        }
		        switch (typeof schemaKeyRef) {
		            case "undefined":
		                this._removeAllSchemas(this.schemas);
		                this._removeAllSchemas(this.refs);
		                this._cache.clear();
		                return this;
		            case "string": {
		                const sch = getSchEnv.call(this, schemaKeyRef);
		                if (typeof sch == "object")
		                    this._cache.delete(sch.schema);
		                delete this.schemas[schemaKeyRef];
		                delete this.refs[schemaKeyRef];
		                return this;
		            }
		            case "object": {
		                const cacheKey = schemaKeyRef;
		                this._cache.delete(cacheKey);
		                let id = schemaKeyRef[this.opts.schemaId];
		                if (id) {
		                    id = (0, resolve_1.normalizeId)(id);
		                    delete this.schemas[id];
		                    delete this.refs[id];
		                }
		                return this;
		            }
		            default:
		                throw new Error("ajv.removeSchema: invalid parameter");
		        }
		    }
		    // add "vocabulary" - a collection of keywords
		    addVocabulary(definitions) {
		        for (const def of definitions)
		            this.addKeyword(def);
		        return this;
		    }
		    addKeyword(kwdOrDef, def // deprecated
		    ) {
		        let keyword;
		        if (typeof kwdOrDef == "string") {
		            keyword = kwdOrDef;
		            if (typeof def == "object") {
		                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
		                def.keyword = keyword;
		            }
		        }
		        else if (typeof kwdOrDef == "object" && def === undefined) {
		            def = kwdOrDef;
		            keyword = def.keyword;
		            if (Array.isArray(keyword) && !keyword.length) {
		                throw new Error("addKeywords: keyword must be string or non-empty array");
		            }
		        }
		        else {
		            throw new Error("invalid addKeywords parameters");
		        }
		        checkKeyword.call(this, keyword, def);
		        if (!def) {
		            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
		            return this;
		        }
		        keywordMetaschema.call(this, def);
		        const definition = {
		            ...def,
		            type: (0, dataType_1.getJSONTypes)(def.type),
		            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
		        };
		        (0, util_1.eachItem)(keyword, definition.type.length === 0
		            ? (k) => addRule.call(this, k, definition)
		            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
		        return this;
		    }
		    getKeyword(keyword) {
		        const rule = this.RULES.all[keyword];
		        return typeof rule == "object" ? rule.definition : !!rule;
		    }
		    // Remove keyword
		    removeKeyword(keyword) {
		        // TODO return type should be Ajv
		        const { RULES } = this;
		        delete RULES.keywords[keyword];
		        delete RULES.all[keyword];
		        for (const group of RULES.rules) {
		            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
		            if (i >= 0)
		                group.rules.splice(i, 1);
		        }
		        return this;
		    }
		    // Add format
		    addFormat(name, format) {
		        if (typeof format == "string")
		            format = new RegExp(format);
		        this.formats[name] = format;
		        return this;
		    }
		    errorsText(errors = this.errors, // optional array of validation errors
		    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
		    ) {
		        if (!errors || errors.length === 0)
		            return "No errors";
		        return errors
		            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
		            .reduce((text, msg) => text + separator + msg);
		    }
		    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
		        const rules = this.RULES.all;
		        metaSchema = JSON.parse(JSON.stringify(metaSchema));
		        for (const jsonPointer of keywordsJsonPointers) {
		            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
		            let keywords = metaSchema;
		            for (const seg of segments)
		                keywords = keywords[seg];
		            for (const key in rules) {
		                const rule = rules[key];
		                if (typeof rule != "object")
		                    continue;
		                const { $data } = rule.definition;
		                const schema = keywords[key];
		                if ($data && schema)
		                    keywords[key] = schemaOrData(schema);
		            }
		        }
		        return metaSchema;
		    }
		    _removeAllSchemas(schemas, regex) {
		        for (const keyRef in schemas) {
		            const sch = schemas[keyRef];
		            if (!regex || regex.test(keyRef)) {
		                if (typeof sch == "string") {
		                    delete schemas[keyRef];
		                }
		                else if (sch && !sch.meta) {
		                    this._cache.delete(sch.schema);
		                    delete schemas[keyRef];
		                }
		            }
		        }
		    }
		    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
		        let id;
		        const { schemaId } = this.opts;
		        if (typeof schema == "object") {
		            id = schema[schemaId];
		        }
		        else {
		            if (this.opts.jtd)
		                throw new Error("schema must be object");
		            else if (typeof schema != "boolean")
		                throw new Error("schema must be object or boolean");
		        }
		        let sch = this._cache.get(schema);
		        if (sch !== undefined)
		            return sch;
		        baseId = (0, resolve_1.normalizeId)(id || baseId);
		        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
		        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
		        this._cache.set(sch.schema, sch);
		        if (addSchema && !baseId.startsWith("#")) {
		            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
		            if (baseId)
		                this._checkUnique(baseId);
		            this.refs[baseId] = sch;
		        }
		        if (validateSchema)
		            this.validateSchema(schema, true);
		        return sch;
		    }
		    _checkUnique(id) {
		        if (this.schemas[id] || this.refs[id]) {
		            throw new Error(`schema with key or id "${id}" already exists`);
		        }
		    }
		    _compileSchemaEnv(sch) {
		        if (sch.meta)
		            this._compileMetaSchema(sch);
		        else
		            compile_1.compileSchema.call(this, sch);
		        /* istanbul ignore if */
		        if (!sch.validate)
		            throw new Error("ajv implementation error");
		        return sch.validate;
		    }
		    _compileMetaSchema(sch) {
		        const currentOpts = this.opts;
		        this.opts = this._metaOpts;
		        try {
		            compile_1.compileSchema.call(this, sch);
		        }
		        finally {
		            this.opts = currentOpts;
		        }
		    }
		}
		Ajv.ValidationError = validation_error_1.default;
		Ajv.MissingRefError = ref_error_1.default;
		exports.default = Ajv;
		function checkOptions(checkOpts, options, msg, log = "error") {
		    for (const key in checkOpts) {
		        const opt = key;
		        if (opt in options)
		            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		    }
		}
		function getSchEnv(keyRef) {
		    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
		    return this.schemas[keyRef] || this.refs[keyRef];
		}
		function addInitialSchemas() {
		    const optsSchemas = this.opts.schemas;
		    if (!optsSchemas)
		        return;
		    if (Array.isArray(optsSchemas))
		        this.addSchema(optsSchemas);
		    else
		        for (const key in optsSchemas)
		            this.addSchema(optsSchemas[key], key);
		}
		function addInitialFormats() {
		    for (const name in this.opts.formats) {
		        const format = this.opts.formats[name];
		        if (format)
		            this.addFormat(name, format);
		    }
		}
		function addInitialKeywords(defs) {
		    if (Array.isArray(defs)) {
		        this.addVocabulary(defs);
		        return;
		    }
		    this.logger.warn("keywords option as map is deprecated, pass array");
		    for (const keyword in defs) {
		        const def = defs[keyword];
		        if (!def.keyword)
		            def.keyword = keyword;
		        this.addKeyword(def);
		    }
		}
		function getMetaSchemaOptions() {
		    const metaOpts = { ...this.opts };
		    for (const opt of META_IGNORE_OPTIONS)
		        delete metaOpts[opt];
		    return metaOpts;
		}
		const noLogs = { log() { }, warn() { }, error() { } };
		function getLogger(logger) {
		    if (logger === false)
		        return noLogs;
		    if (logger === undefined)
		        return console;
		    if (logger.log && logger.warn && logger.error)
		        return logger;
		    throw new Error("logger must implement log, warn and error methods");
		}
		const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
		function checkKeyword(keyword, def) {
		    const { RULES } = this;
		    (0, util_1.eachItem)(keyword, (kwd) => {
		        if (RULES.keywords[kwd])
		            throw new Error(`Keyword ${kwd} is already defined`);
		        if (!KEYWORD_NAME.test(kwd))
		            throw new Error(`Keyword ${kwd} has invalid name`);
		    });
		    if (!def)
		        return;
		    if (def.$data && !("code" in def || "validate" in def)) {
		        throw new Error('$data keyword must have "code" or "validate" function');
		    }
		}
		function addRule(keyword, definition, dataType) {
		    var _a;
		    const post = definition === null || definition === void 0 ? void 0 : definition.post;
		    if (dataType && post)
		        throw new Error('keyword with "post" flag cannot have "type"');
		    const { RULES } = this;
		    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
		    if (!ruleGroup) {
		        ruleGroup = { type: dataType, rules: [] };
		        RULES.rules.push(ruleGroup);
		    }
		    RULES.keywords[keyword] = true;
		    if (!definition)
		        return;
		    const rule = {
		        keyword,
		        definition: {
		            ...definition,
		            type: (0, dataType_1.getJSONTypes)(definition.type),
		            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
		        },
		    };
		    if (definition.before)
		        addBeforeRule.call(this, ruleGroup, rule, definition.before);
		    else
		        ruleGroup.rules.push(rule);
		    RULES.all[keyword] = rule;
		    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
		}
		function addBeforeRule(ruleGroup, rule, before) {
		    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		    if (i >= 0) {
		        ruleGroup.rules.splice(i, 0, rule);
		    }
		    else {
		        ruleGroup.rules.push(rule);
		        this.logger.warn(`rule ${before} is not defined`);
		    }
		}
		function keywordMetaschema(def) {
		    let { metaSchema } = def;
		    if (metaSchema === undefined)
		        return;
		    if (def.$data && this.opts.$data)
		        metaSchema = schemaOrData(metaSchema);
		    def.validateSchema = this.compile(metaSchema, true);
		}
		const $dataRef = {
		    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		};
		function schemaOrData(schema) {
		    return { anyOf: [schema, $dataRef] };
		}
		
	} (core$1));
	return core$1;
}

var draft7 = {};

var core = {};

var id = {};

var hasRequiredId;

function requireId () {
	if (hasRequiredId) return id;
	hasRequiredId = 1;
	Object.defineProperty(id, "__esModule", { value: true });
	const def = {
	    keyword: "id",
	    code() {
	        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
	    },
	};
	id.default = def;
	
	return id;
}

var ref = {};

var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;
	Object.defineProperty(ref, "__esModule", { value: true });
	ref.callRef = ref.getValidate = void 0;
	const ref_error_1 = requireRef_error();
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const compile_1 = requireCompile();
	const util_1 = requireUtil();
	const def = {
	    keyword: "$ref",
	    schemaType: "string",
	    code(cxt) {
	        const { gen, schema: $ref, it } = cxt;
	        const { baseId, schemaEnv: env, validateName, opts, self } = it;
	        const { root } = env;
	        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
	            return callRootRef();
	        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
	        if (schOrEnv === undefined)
	            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
	        if (schOrEnv instanceof compile_1.SchemaEnv)
	            return callValidate(schOrEnv);
	        return inlineRefSchema(schOrEnv);
	        function callRootRef() {
	            if (env === root)
	                return callRef(cxt, validateName, env, env.$async);
	            const rootName = gen.scopeValue("root", { ref: root });
	            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);
	        }
	        function callValidate(sch) {
	            const v = getValidate(cxt, sch);
	            callRef(cxt, v, sch, sch.$async);
	        }
	        function inlineRefSchema(sch) {
	            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
	            const valid = gen.name("valid");
	            const schCxt = cxt.subschema({
	                schema: sch,
	                dataTypes: [],
	                schemaPath: codegen_1.nil,
	                topSchemaRef: schName,
	                errSchemaPath: $ref,
	            }, valid);
	            cxt.mergeEvaluated(schCxt);
	            cxt.ok(valid);
	        }
	    },
	};
	function getValidate(cxt, sch) {
	    const { gen } = cxt;
	    return sch.validate
	        ? gen.scopeValue("validate", { ref: sch.validate })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	ref.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
	    const { gen, it } = cxt;
	    const { allErrors, schemaEnv: env, opts } = it;
	    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
	    if ($async)
	        callAsyncRef();
	    else
	        callSyncRef();
	    function callAsyncRef() {
	        if (!env.$async)
	            throw new Error("async schema referenced by sync schema");
	        const valid = gen.let("valid");
	        gen.try(() => {
	            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
	            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
	            if (!allErrors)
	                gen.assign(valid, true);
	        }, (e) => {
	            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
	            addErrorsFrom(e);
	            if (!allErrors)
	                gen.assign(valid, false);
	        });
	        cxt.ok(valid);
	    }
	    function callSyncRef() {
	        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
	    }
	    function addErrorsFrom(source) {
	        const errs = (0, codegen_1._) `${source}.errors`;
	        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
	        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	    }
	    function addEvaluatedFrom(source) {
	        var _a;
	        if (!it.opts.unevaluated)
	            return;
	        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
	        // TODO refactor
	        if (it.props !== true) {
	            if (schEvaluated && !schEvaluated.dynamicProps) {
	                if (schEvaluated.props !== undefined) {
	                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
	                }
	            }
	            else {
	                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);
	                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
	            }
	        }
	        if (it.items !== true) {
	            if (schEvaluated && !schEvaluated.dynamicItems) {
	                if (schEvaluated.items !== undefined) {
	                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
	                }
	            }
	            else {
	                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);
	                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
	            }
	        }
	    }
	}
	ref.callRef = callRef;
	ref.default = def;
	
	return ref;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	Object.defineProperty(core, "__esModule", { value: true });
	const id_1 = requireId();
	const ref_1 = requireRef();
	const core$1 = [
	    "$schema",
	    "$id",
	    "$defs",
	    "$vocabulary",
	    { keyword: "$comment" },
	    "definitions",
	    id_1.default,
	    ref_1.default,
	];
	core.default = core$1;
	
	return core;
}

var validation = {};

var limitNumber = {};

var hasRequiredLimitNumber;

function requireLimitNumber () {
	if (hasRequiredLimitNumber) return limitNumber;
	hasRequiredLimitNumber = 1;
	Object.defineProperty(limitNumber, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const ops = codegen_1.operators;
	const KWDs = {
	    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
	    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
	    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
	    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
	};
	const error = {
	    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
	    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: Object.keys(KWDs),
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
	    },
	};
	limitNumber.default = def;
	
	return limitNumber;
}

var multipleOf = {};

var hasRequiredMultipleOf;

function requireMultipleOf () {
	if (hasRequiredMultipleOf) return multipleOf;
	hasRequiredMultipleOf = 1;
	Object.defineProperty(multipleOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,
	};
	const def = {
	    keyword: "multipleOf",
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, schemaCode, it } = cxt;
	        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
	        const prec = it.opts.multipleOfPrecision;
	        const res = gen.let("res");
	        const invalid = prec
	            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
	            : (0, codegen_1._) `${res} !== parseInt(${res})`;
	        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
	    },
	};
	multipleOf.default = def;
	
	return multipleOf;
}

var limitLength = {};

var ucs2length = {};

var hasRequiredUcs2length;

function requireUcs2length () {
	if (hasRequiredUcs2length) return ucs2length;
	hasRequiredUcs2length = 1;
	Object.defineProperty(ucs2length, "__esModule", { value: true });
	// https://mathiasbynens.be/notes/javascript-encoding
	// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
	function ucs2length$1(str) {
	    const len = str.length;
	    let length = 0;
	    let pos = 0;
	    let value;
	    while (pos < len) {
	        length++;
	        value = str.charCodeAt(pos++);
	        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
	            // high surrogate, and there is a next character
	            value = str.charCodeAt(pos);
	            if ((value & 0xfc00) === 0xdc00)
	                pos++; // low surrogate
	        }
	    }
	    return length;
	}
	ucs2length.default = ucs2length$1;
	ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
	
	return ucs2length;
}

var hasRequiredLimitLength;

function requireLimitLength () {
	if (hasRequiredLimitLength) return limitLength;
	hasRequiredLimitLength = 1;
	Object.defineProperty(limitLength, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const ucs2length_1 = requireUcs2length();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxLength" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxLength", "minLength"],
	    type: "string",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode, it } = cxt;
	        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
	        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);
	    },
	};
	limitLength.default = def;
	
	return limitLength;
}

var pattern = {};

var hasRequiredPattern;

function requirePattern () {
	if (hasRequiredPattern) return pattern;
	hasRequiredPattern = 1;
	Object.defineProperty(pattern, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,
	};
	const def = {
	    keyword: "pattern",
	    type: "string",
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt) {
	        const { data, $data, schema, schemaCode, it } = cxt;
	        // TODO regexp should be wrapped in try/catchs
	        const u = it.opts.unicodeRegExp ? "u" : "";
	        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
	        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);
	    },
	};
	pattern.default = def;
	
	return pattern;
}

var limitProperties = {};

var hasRequiredLimitProperties;

function requireLimitProperties () {
	if (hasRequiredLimitProperties) return limitProperties;
	hasRequiredLimitProperties = 1;
	Object.defineProperty(limitProperties, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxProperties" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxProperties", "minProperties"],
	    type: "object",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);
	    },
	};
	limitProperties.default = def;
	
	return limitProperties;
}

var required = {};

var hasRequiredRequired;

function requireRequired () {
	if (hasRequiredRequired) return required;
	hasRequiredRequired = 1;
	Object.defineProperty(required, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,
	    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,
	};
	const def = {
	    keyword: "required",
	    type: "object",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, schema, schemaCode, data, $data, it } = cxt;
	        const { opts } = it;
	        if (!$data && schema.length === 0)
	            return;
	        const useLoop = schema.length >= opts.loopRequired;
	        if (it.allErrors)
	            allErrorsMode();
	        else
	            exitOnErrorMode();
	        if (opts.strictRequired) {
	            const props = cxt.parentSchema.properties;
	            const { definedProperties } = cxt.it;
	            for (const requiredKey of schema) {
	                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
	                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
	                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
	                }
	            }
	        }
	        function allErrorsMode() {
	            if (useLoop || $data) {
	                cxt.block$data(codegen_1.nil, loopAllRequired);
	            }
	            else {
	                for (const prop of schema) {
	                    (0, code_1.checkReportMissingProp)(cxt, prop);
	                }
	            }
	        }
	        function exitOnErrorMode() {
	            const missing = gen.let("missing");
	            if (useLoop || $data) {
	                const valid = gen.let("valid", true);
	                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
	                cxt.ok(valid);
	            }
	            else {
	                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
	                (0, code_1.reportMissingProp)(cxt, missing);
	                gen.else();
	            }
	        }
	        function loopAllRequired() {
	            gen.forOf("prop", schemaCode, (prop) => {
	                cxt.setParams({ missingProperty: prop });
	                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
	            });
	        }
	        function loopUntilMissing(missing, valid) {
	            cxt.setParams({ missingProperty: missing });
	            gen.forOf(missing, schemaCode, () => {
	                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
	                gen.if((0, codegen_1.not)(valid), () => {
	                    cxt.error();
	                    gen.break();
	                });
	            }, codegen_1.nil);
	        }
	    },
	};
	required.default = def;
	
	return required;
}

var limitItems = {};

var hasRequiredLimitItems;

function requireLimitItems () {
	if (hasRequiredLimitItems) return limitItems;
	hasRequiredLimitItems = 1;
	Object.defineProperty(limitItems, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxItems" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxItems", "minItems"],
	    type: "array",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);
	    },
	};
	limitItems.default = def;
	
	return limitItems;
}

var uniqueItems = {};

var equal = {};

var hasRequiredEqual;

function requireEqual () {
	if (hasRequiredEqual) return equal;
	hasRequiredEqual = 1;
	Object.defineProperty(equal, "__esModule", { value: true });
	// https://github.com/ajv-validator/ajv/issues/889
	const equal$1 = requireFastDeepEqual();
	equal$1.code = 'require("ajv/dist/runtime/equal").default';
	equal.default = equal$1;
	
	return equal;
}

var hasRequiredUniqueItems;

function requireUniqueItems () {
	if (hasRequiredUniqueItems) return uniqueItems;
	hasRequiredUniqueItems = 1;
	Object.defineProperty(uniqueItems, "__esModule", { value: true });
	const dataType_1 = requireDataType();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const equal_1 = requireEqual();
	const error = {
	    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
	    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,
	};
	const def = {
	    keyword: "uniqueItems",
	    type: "array",
	    schemaType: "boolean",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
	        if (!$data && !schema)
	            return;
	        const valid = gen.let("valid");
	        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
	        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);
	        cxt.ok(valid);
	        function validateUniqueItems() {
	            const i = gen.let("i", (0, codegen_1._) `${data}.length`);
	            const j = gen.let("j");
	            cxt.setParams({ i, j });
	            gen.assign(valid, true);
	            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
	        }
	        function canOptimize() {
	            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
	        }
	        function loopN(i, j) {
	            const item = gen.name("item");
	            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
	            const indices = gen.const("indices", (0, codegen_1._) `{}`);
	            gen.for((0, codegen_1._) `;${i}--;`, () => {
	                gen.let(item, (0, codegen_1._) `${data}[${i}]`);
	                gen.if(wrongType, (0, codegen_1._) `continue`);
	                if (itemTypes.length > 1)
	                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);
	                gen
	                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {
	                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);
	                    cxt.error();
	                    gen.assign(valid, false).break();
	                })
	                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);
	            });
	        }
	        function loopN2(i, j) {
	            const eql = (0, util_1.useFunc)(gen, equal_1.default);
	            const outer = gen.name("outer");
	            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
	                cxt.error();
	                gen.assign(valid, false).break(outer);
	            })));
	        }
	    },
	};
	uniqueItems.default = def;
	
	return uniqueItems;
}

var _const = {};

var hasRequired_const;

function require_const () {
	if (hasRequired_const) return _const;
	hasRequired_const = 1;
	Object.defineProperty(_const, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to constant",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,
	};
	const def = {
	    keyword: "const",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schemaCode, schema } = cxt;
	        if ($data || (schema && typeof schema == "object")) {
	            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
	        }
	        else {
	            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);
	        }
	    },
	};
	_const.default = def;
	
	return _const;
}

var _enum = {};

var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	Object.defineProperty(_enum, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to one of the allowed values",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
	};
	const def = {
	    keyword: "enum",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        if (!$data && schema.length === 0)
	            throw new Error("enum must have non-empty array");
	        const useLoop = schema.length >= it.opts.loopEnum;
	        let eql;
	        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));
	        let valid;
	        if (useLoop || $data) {
	            valid = gen.let("valid");
	            cxt.block$data(valid, loopEnum);
	        }
	        else {
	            /* istanbul ignore if */
	            if (!Array.isArray(schema))
	                throw new Error("ajv implementation error");
	            const vSchema = gen.const("vSchema", schemaCode);
	            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
	        }
	        cxt.pass(valid);
	        function loopEnum() {
	            gen.assign(valid, false);
	            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
	        }
	        function equalCode(vSchema, i) {
	            const sch = schema[i];
	            return typeof sch === "object" && sch !== null
	                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`
	                : (0, codegen_1._) `${data} === ${sch}`;
	        }
	    },
	};
	_enum.default = def;
	
	return _enum;
}

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation;
	hasRequiredValidation = 1;
	Object.defineProperty(validation, "__esModule", { value: true });
	const limitNumber_1 = requireLimitNumber();
	const multipleOf_1 = requireMultipleOf();
	const limitLength_1 = requireLimitLength();
	const pattern_1 = requirePattern();
	const limitProperties_1 = requireLimitProperties();
	const required_1 = requireRequired();
	const limitItems_1 = requireLimitItems();
	const uniqueItems_1 = requireUniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum();
	const validation$1 = [
	    // number
	    limitNumber_1.default,
	    multipleOf_1.default,
	    // string
	    limitLength_1.default,
	    pattern_1.default,
	    // object
	    limitProperties_1.default,
	    required_1.default,
	    // array
	    limitItems_1.default,
	    uniqueItems_1.default,
	    // any
	    { keyword: "type", schemaType: ["string", "array"] },
	    { keyword: "nullable", schemaType: "boolean" },
	    const_1.default,
	    enum_1.default,
	];
	validation.default = validation$1;
	
	return validation;
}

var applicator = {};

var additionalItems = {};

var hasRequiredAdditionalItems;

function requireAdditionalItems () {
	if (hasRequiredAdditionalItems) return additionalItems;
	hasRequiredAdditionalItems = 1;
	Object.defineProperty(additionalItems, "__esModule", { value: true });
	additionalItems.validateAdditionalItems = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "additionalItems",
	    type: "array",
	    schemaType: ["boolean", "object"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { parentSchema, it } = cxt;
	        const { items } = parentSchema;
	        if (!Array.isArray(items)) {
	            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
	            return;
	        }
	        validateAdditionalItems(cxt, items);
	    },
	};
	function validateAdditionalItems(cxt, items) {
	    const { gen, schema, data, keyword, it } = cxt;
	    it.items = true;
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    if (schema === false) {
	        cxt.setParams({ len: items.length });
	        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);
	    }
	    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var
	        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
	        cxt.ok(valid);
	    }
	    function validateItems(valid) {
	        gen.forRange("i", items.length, len, (i) => {
	            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
	            if (!it.allErrors)
	                gen.if((0, codegen_1.not)(valid), () => gen.break());
	        });
	    }
	}
	additionalItems.validateAdditionalItems = validateAdditionalItems;
	additionalItems.default = def;
	
	return additionalItems;
}

var prefixItems = {};

var items = {};

var hasRequiredItems;

function requireItems () {
	if (hasRequiredItems) return items;
	hasRequiredItems = 1;
	Object.defineProperty(items, "__esModule", { value: true });
	items.validateTuple = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const code_1 = requireCode();
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "array", "boolean"],
	    before: "uniqueItems",
	    code(cxt) {
	        const { schema, it } = cxt;
	        if (Array.isArray(schema))
	            return validateTuple(cxt, "additionalItems", schema);
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
	    const { gen, parentSchema, data, keyword, it } = cxt;
	    checkStrictTuple(parentSchema);
	    if (it.opts.unevaluated && schArr.length && it.items !== true) {
	        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
	    }
	    const valid = gen.name("valid");
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    schArr.forEach((sch, i) => {
	        if ((0, util_1.alwaysValidSchema)(it, sch))
	            return;
	        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({
	            keyword,
	            schemaProp: i,
	            dataProp: i,
	        }, valid));
	        cxt.ok(valid);
	    });
	    function checkStrictTuple(sch) {
	        const { opts, errSchemaPath } = it;
	        const l = schArr.length;
	        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
	        if (opts.strictTuples && !fullTuple) {
	            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
	            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
	        }
	    }
	}
	items.validateTuple = validateTuple;
	items.default = def;
	
	return items;
}

var hasRequiredPrefixItems;

function requirePrefixItems () {
	if (hasRequiredPrefixItems) return prefixItems;
	hasRequiredPrefixItems = 1;
	Object.defineProperty(prefixItems, "__esModule", { value: true });
	const items_1 = requireItems();
	const def = {
	    keyword: "prefixItems",
	    type: "array",
	    schemaType: ["array"],
	    before: "uniqueItems",
	    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
	};
	prefixItems.default = def;
	
	return prefixItems;
}

var items2020 = {};

var hasRequiredItems2020;

function requireItems2020 () {
	if (hasRequiredItems2020) return items2020;
	hasRequiredItems2020 = 1;
	Object.defineProperty(items2020, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const code_1 = requireCode();
	const additionalItems_1 = requireAdditionalItems();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { schema, parentSchema, it } = cxt;
	        const { prefixItems } = parentSchema;
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        if (prefixItems)
	            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
	        else
	            cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	items2020.default = def;
	
	return items2020;
}

var contains = {};

var hasRequiredContains;

function requireContains () {
	if (hasRequiredContains) return contains;
	hasRequiredContains = 1;
	Object.defineProperty(contains, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params: { min, max } }) => max === undefined
	        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`
	        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
	    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,
	};
	const def = {
	    keyword: "contains",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        let min;
	        let max;
	        const { minContains, maxContains } = parentSchema;
	        if (it.opts.next) {
	            min = minContains === undefined ? 1 : minContains;
	            max = maxContains;
	        }
	        else {
	            min = 1;
	        }
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        cxt.setParams({ min, max });
	        if (max === undefined && min === 0) {
	            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
	            return;
	        }
	        if (max !== undefined && min > max) {
	            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
	            cxt.fail();
	            return;
	        }
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            let cond = (0, codegen_1._) `${len} >= ${min}`;
	            if (max !== undefined)
	                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;
	            cxt.pass(cond);
	            return;
	        }
	        it.items = true;
	        const valid = gen.name("valid");
	        if (max === undefined && min === 1) {
	            validateItems(valid, () => gen.if(valid, () => gen.break()));
	        }
	        else if (min === 0) {
	            gen.let(valid, true);
	            if (max !== undefined)
	                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);
	        }
	        else {
	            gen.let(valid, false);
	            validateItemsWithCount();
	        }
	        cxt.result(valid, () => cxt.reset());
	        function validateItemsWithCount() {
	            const schValid = gen.name("_valid");
	            const count = gen.let("count", 0);
	            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
	        }
	        function validateItems(_valid, block) {
	            gen.forRange("i", 0, len, (i) => {
	                cxt.subschema({
	                    keyword: "contains",
	                    dataProp: i,
	                    dataPropType: util_1.Type.Num,
	                    compositeRule: true,
	                }, _valid);
	                block();
	            });
	        }
	        function checkLimits(count) {
	            gen.code((0, codegen_1._) `${count}++`);
	            if (max === undefined) {
	                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
	            }
	            else {
	                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());
	                if (min === 1)
	                    gen.assign(valid, true);
	                else
	                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));
	            }
	        }
	    },
	};
	contains.default = def;
	
	return contains;
}

var dependencies = {};

var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies;
	hasRequiredDependencies = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil();
		const code_1 = requireCode();
		exports.error = {
		    message: ({ params: { property, depsCount, deps } }) => {
		        const property_ies = depsCount === 1 ? "property" : "properties";
		        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
		    },
		    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
		};
		const def = {
		    keyword: "dependencies",
		    type: "object",
		    schemaType: "object",
		    error: exports.error,
		    code(cxt) {
		        const [propDeps, schDeps] = splitDependencies(cxt);
		        validatePropertyDeps(cxt, propDeps);
		        validateSchemaDeps(cxt, schDeps);
		    },
		};
		function splitDependencies({ schema }) {
		    const propertyDeps = {};
		    const schemaDeps = {};
		    for (const key in schema) {
		        if (key === "__proto__")
		            continue;
		        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
		        deps[key] = schema[key];
		    }
		    return [propertyDeps, schemaDeps];
		}
		function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		    const { gen, data, it } = cxt;
		    if (Object.keys(propertyDeps).length === 0)
		        return;
		    const missing = gen.let("missing");
		    for (const prop in propertyDeps) {
		        const deps = propertyDeps[prop];
		        if (deps.length === 0)
		            continue;
		        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
		        cxt.setParams({
		            property: prop,
		            depsCount: deps.length,
		            deps: deps.join(", "),
		        });
		        if (it.allErrors) {
		            gen.if(hasProperty, () => {
		                for (const depProp of deps) {
		                    (0, code_1.checkReportMissingProp)(cxt, depProp);
		                }
		            });
		        }
		        else {
		            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
		            (0, code_1.reportMissingProp)(cxt, missing);
		            gen.else();
		        }
		    }
		}
		exports.validatePropertyDeps = validatePropertyDeps;
		function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		    const { gen, data, keyword, it } = cxt;
		    const valid = gen.name("valid");
		    for (const prop in schemaDeps) {
		        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
		            continue;
		        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
		            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
		            cxt.mergeValidEvaluated(schCxt, valid);
		        }, () => gen.var(valid, true) // TODO var
		        );
		        cxt.ok(valid);
		    }
		}
		exports.validateSchemaDeps = validateSchemaDeps;
		exports.default = def;
		
	} (dependencies));
	return dependencies;
}

var propertyNames = {};

var hasRequiredPropertyNames;

function requirePropertyNames () {
	if (hasRequiredPropertyNames) return propertyNames;
	hasRequiredPropertyNames = 1;
	Object.defineProperty(propertyNames, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: "property name must be valid",
	    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,
	};
	const def = {
	    keyword: "propertyNames",
	    type: "object",
	    schemaType: ["object", "boolean"],
	    error,
	    code(cxt) {
	        const { gen, schema, data, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const valid = gen.name("valid");
	        gen.forIn("key", data, (key) => {
	            cxt.setParams({ propertyName: key });
	            cxt.subschema({
	                keyword: "propertyNames",
	                data: key,
	                dataTypes: ["string"],
	                propertyName: key,
	                compositeRule: true,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), () => {
	                cxt.error(true);
	                if (!it.allErrors)
	                    gen.break();
	            });
	        });
	        cxt.ok(valid);
	    },
	};
	propertyNames.default = def;
	
	return propertyNames;
}

var additionalProperties = {};

var hasRequiredAdditionalProperties;

function requireAdditionalProperties () {
	if (hasRequiredAdditionalProperties) return additionalProperties;
	hasRequiredAdditionalProperties = 1;
	Object.defineProperty(additionalProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const util_1 = requireUtil();
	const error = {
	    message: "must NOT have additional properties",
	    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,
	};
	const def = {
	    keyword: "additionalProperties",
	    type: ["object"],
	    schemaType: ["boolean", "object"],
	    allowUndefined: true,
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
	        /* istanbul ignore if */
	        if (!errsCount)
	            throw new Error("ajv implementation error");
	        const { allErrors, opts } = it;
	        it.props = true;
	        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
	        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
	        checkAdditionalProperties();
	        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	        function checkAdditionalProperties() {
	            gen.forIn("key", data, (key) => {
	                if (!props.length && !patProps.length)
	                    additionalPropertyCode(key);
	                else
	                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
	            });
	        }
	        function isAdditional(key) {
	            let definedProp;
	            if (props.length > 8) {
	                // TODO maybe an option instead of hard-coded 8?
	                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
	                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
	            }
	            else if (props.length) {
	                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));
	            }
	            else {
	                definedProp = codegen_1.nil;
	            }
	            if (patProps.length) {
	                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
	            }
	            return (0, codegen_1.not)(definedProp);
	        }
	        function deleteAdditional(key) {
	            gen.code((0, codegen_1._) `delete ${data}[${key}]`);
	        }
	        function additionalPropertyCode(key) {
	            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
	                deleteAdditional(key);
	                return;
	            }
	            if (schema === false) {
	                cxt.setParams({ additionalProperty: key });
	                cxt.error();
	                if (!allErrors)
	                    gen.break();
	                return;
	            }
	            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	                const valid = gen.name("valid");
	                if (opts.removeAdditional === "failing") {
	                    applyAdditionalSchema(key, valid, false);
	                    gen.if((0, codegen_1.not)(valid), () => {
	                        cxt.reset();
	                        deleteAdditional(key);
	                    });
	                }
	                else {
	                    applyAdditionalSchema(key, valid);
	                    if (!allErrors)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                }
	            }
	        }
	        function applyAdditionalSchema(key, valid, errors) {
	            const subschema = {
	                keyword: "additionalProperties",
	                dataProp: key,
	                dataPropType: util_1.Type.Str,
	            };
	            if (errors === false) {
	                Object.assign(subschema, {
	                    compositeRule: true,
	                    createErrors: false,
	                    allErrors: false,
	                });
	            }
	            cxt.subschema(subschema, valid);
	        }
	    },
	};
	additionalProperties.default = def;
	
	return additionalProperties;
}

var properties$1 = {};

var hasRequiredProperties;

function requireProperties () {
	if (hasRequiredProperties) return properties$1;
	hasRequiredProperties = 1;
	Object.defineProperty(properties$1, "__esModule", { value: true });
	const validate_1 = requireValidate();
	const code_1 = requireCode();
	const util_1 = requireUtil();
	const additionalProperties_1 = requireAdditionalProperties();
	const def = {
	    keyword: "properties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
	            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
	        }
	        const allProps = (0, code_1.allSchemaProperties)(schema);
	        for (const prop of allProps) {
	            it.definedProperties.add(prop);
	        }
	        if (it.opts.unevaluated && allProps.length && it.props !== true) {
	            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
	        }
	        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (properties.length === 0)
	            return;
	        const valid = gen.name("valid");
	        for (const prop of properties) {
	            if (hasDefault(prop)) {
	                applyPropertySchema(prop);
	            }
	            else {
	                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
	                applyPropertySchema(prop);
	                if (!it.allErrors)
	                    gen.else().var(valid, true);
	                gen.endIf();
	            }
	            cxt.it.definedProperties.add(prop);
	            cxt.ok(valid);
	        }
	        function hasDefault(prop) {
	            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
	        }
	        function applyPropertySchema(prop) {
	            cxt.subschema({
	                keyword: "properties",
	                schemaProp: prop,
	                dataProp: prop,
	            }, valid);
	        }
	    },
	};
	properties$1.default = def;
	
	return properties$1;
}

var patternProperties = {};

var hasRequiredPatternProperties;

function requirePatternProperties () {
	if (hasRequiredPatternProperties) return patternProperties;
	hasRequiredPatternProperties = 1;
	Object.defineProperty(patternProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const util_2 = requireUtil();
	const def = {
	    keyword: "patternProperties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, data, parentSchema, it } = cxt;
	        const { opts } = it;
	        const patterns = (0, code_1.allSchemaProperties)(schema);
	        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (patterns.length === 0 ||
	            (alwaysValidPatterns.length === patterns.length &&
	                (!it.opts.unevaluated || it.props === true))) {
	            return;
	        }
	        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
	        const valid = gen.name("valid");
	        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
	            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
	        }
	        const { props } = it;
	        validatePatternProperties();
	        function validatePatternProperties() {
	            for (const pat of patterns) {
	                if (checkProperties)
	                    checkMatchingProperties(pat);
	                if (it.allErrors) {
	                    validateProperties(pat);
	                }
	                else {
	                    gen.var(valid, true); // TODO var
	                    validateProperties(pat);
	                    gen.if(valid);
	                }
	            }
	        }
	        function checkMatchingProperties(pat) {
	            for (const prop in checkProperties) {
	                if (new RegExp(pat).test(prop)) {
	                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
	                }
	            }
	        }
	        function validateProperties(pat) {
	            gen.forIn("key", data, (key) => {
	                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
	                    const alwaysValid = alwaysValidPatterns.includes(pat);
	                    if (!alwaysValid) {
	                        cxt.subschema({
	                            keyword: "patternProperties",
	                            schemaProp: pat,
	                            dataProp: key,
	                            dataPropType: util_2.Type.Str,
	                        }, valid);
	                    }
	                    if (it.opts.unevaluated && props !== true) {
	                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);
	                    }
	                    else if (!alwaysValid && !it.allErrors) {
	                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
	                        // or if all properties were evaluated (props === true)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                    }
	                });
	            });
	        }
	    },
	};
	patternProperties.default = def;
	
	return patternProperties;
}

var not = {};

var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	Object.defineProperty(not, "__esModule", { value: true });
	const util_1 = requireUtil();
	const def = {
	    keyword: "not",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            cxt.fail();
	            return;
	        }
	        const valid = gen.name("valid");
	        cxt.subschema({
	            keyword: "not",
	            compositeRule: true,
	            createErrors: false,
	            allErrors: false,
	        }, valid);
	        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
	    },
	    error: { message: "must NOT be valid" },
	};
	not.default = def;
	
	return not;
}

var anyOf = {};

var hasRequiredAnyOf;

function requireAnyOf () {
	if (hasRequiredAnyOf) return anyOf;
	hasRequiredAnyOf = 1;
	Object.defineProperty(anyOf, "__esModule", { value: true });
	const code_1 = requireCode();
	const def = {
	    keyword: "anyOf",
	    schemaType: "array",
	    trackErrors: true,
	    code: code_1.validateUnion,
	    error: { message: "must match a schema in anyOf" },
	};
	anyOf.default = def;
	
	return anyOf;
}

var oneOf = {};

var hasRequiredOneOf;

function requireOneOf () {
	if (hasRequiredOneOf) return oneOf;
	hasRequiredOneOf = 1;
	Object.defineProperty(oneOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: "must match exactly one schema in oneOf",
	    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,
	};
	const def = {
	    keyword: "oneOf",
	    schemaType: "array",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        if (it.opts.discriminator && parentSchema.discriminator)
	            return;
	        const schArr = schema;
	        const valid = gen.let("valid", false);
	        const passing = gen.let("passing", null);
	        const schValid = gen.name("_valid");
	        cxt.setParams({ passing });
	        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
	        gen.block(validateOneOf);
	        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	        function validateOneOf() {
	            schArr.forEach((sch, i) => {
	                let schCxt;
	                if ((0, util_1.alwaysValidSchema)(it, sch)) {
	                    gen.var(schValid, true);
	                }
	                else {
	                    schCxt = cxt.subschema({
	                        keyword: "oneOf",
	                        schemaProp: i,
	                        compositeRule: true,
	                    }, schValid);
	                }
	                if (i > 0) {
	                    gen
	                        .if((0, codegen_1._) `${schValid} && ${valid}`)
	                        .assign(valid, false)
	                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)
	                        .else();
	                }
	                gen.if(schValid, () => {
	                    gen.assign(valid, true);
	                    gen.assign(passing, i);
	                    if (schCxt)
	                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
	                });
	            });
	        }
	    },
	};
	oneOf.default = def;
	
	return oneOf;
}

var allOf = {};

var hasRequiredAllOf;

function requireAllOf () {
	if (hasRequiredAllOf) return allOf;
	hasRequiredAllOf = 1;
	Object.defineProperty(allOf, "__esModule", { value: true });
	const util_1 = requireUtil();
	const def = {
	    keyword: "allOf",
	    schemaType: "array",
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        const valid = gen.name("valid");
	        schema.forEach((sch, i) => {
	            if ((0, util_1.alwaysValidSchema)(it, sch))
	                return;
	            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
	            cxt.ok(valid);
	            cxt.mergeEvaluated(schCxt);
	        });
	    },
	};
	allOf.default = def;
	
	return allOf;
}

var _if = {};

var hasRequired_if;

function require_if () {
	if (hasRequired_if) return _if;
	hasRequired_if = 1;
	Object.defineProperty(_if, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,
	    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,
	};
	const def = {
	    keyword: "if",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, parentSchema, it } = cxt;
	        if (parentSchema.then === undefined && parentSchema.else === undefined) {
	            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
	        }
	        const hasThen = hasSchema(it, "then");
	        const hasElse = hasSchema(it, "else");
	        if (!hasThen && !hasElse)
	            return;
	        const valid = gen.let("valid", true);
	        const schValid = gen.name("_valid");
	        validateIf();
	        cxt.reset();
	        if (hasThen && hasElse) {
	            const ifClause = gen.let("ifClause");
	            cxt.setParams({ ifClause });
	            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
	        }
	        else if (hasThen) {
	            gen.if(schValid, validateClause("then"));
	        }
	        else {
	            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
	        }
	        cxt.pass(valid, () => cxt.error(true));
	        function validateIf() {
	            const schCxt = cxt.subschema({
	                keyword: "if",
	                compositeRule: true,
	                createErrors: false,
	                allErrors: false,
	            }, schValid);
	            cxt.mergeEvaluated(schCxt);
	        }
	        function validateClause(keyword, ifClause) {
	            return () => {
	                const schCxt = cxt.subschema({ keyword }, schValid);
	                gen.assign(valid, schValid);
	                cxt.mergeValidEvaluated(schCxt, valid);
	                if (ifClause)
	                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);
	                else
	                    cxt.setParams({ ifClause: keyword });
	            };
	        }
	    },
	};
	function hasSchema(it, keyword) {
	    const schema = it.schema[keyword];
	    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
	}
	_if.default = def;
	
	return _if;
}

var thenElse = {};

var hasRequiredThenElse;

function requireThenElse () {
	if (hasRequiredThenElse) return thenElse;
	hasRequiredThenElse = 1;
	Object.defineProperty(thenElse, "__esModule", { value: true });
	const util_1 = requireUtil();
	const def = {
	    keyword: ["then", "else"],
	    schemaType: ["object", "boolean"],
	    code({ keyword, parentSchema, it }) {
	        if (parentSchema.if === undefined)
	            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
	    },
	};
	thenElse.default = def;
	
	return thenElse;
}

var hasRequiredApplicator;

function requireApplicator () {
	if (hasRequiredApplicator) return applicator;
	hasRequiredApplicator = 1;
	Object.defineProperty(applicator, "__esModule", { value: true });
	const additionalItems_1 = requireAdditionalItems();
	const prefixItems_1 = requirePrefixItems();
	const items_1 = requireItems();
	const items2020_1 = requireItems2020();
	const contains_1 = requireContains();
	const dependencies_1 = requireDependencies();
	const propertyNames_1 = requirePropertyNames();
	const additionalProperties_1 = requireAdditionalProperties();
	const properties_1 = requireProperties();
	const patternProperties_1 = requirePatternProperties();
	const not_1 = requireNot();
	const anyOf_1 = requireAnyOf();
	const oneOf_1 = requireOneOf();
	const allOf_1 = requireAllOf();
	const if_1 = require_if();
	const thenElse_1 = requireThenElse();
	function getApplicator(draft2020 = false) {
	    const applicator = [
	        // any
	        not_1.default,
	        anyOf_1.default,
	        oneOf_1.default,
	        allOf_1.default,
	        if_1.default,
	        thenElse_1.default,
	        // object
	        propertyNames_1.default,
	        additionalProperties_1.default,
	        dependencies_1.default,
	        properties_1.default,
	        patternProperties_1.default,
	    ];
	    // array
	    if (draft2020)
	        applicator.push(prefixItems_1.default, items2020_1.default);
	    else
	        applicator.push(additionalItems_1.default, items_1.default);
	    applicator.push(contains_1.default);
	    return applicator;
	}
	applicator.default = getApplicator;
	
	return applicator;
}

var format$1 = {};

var format = {};

var hasRequiredFormat$1;

function requireFormat$1 () {
	if (hasRequiredFormat$1) return format;
	hasRequiredFormat$1 = 1;
	Object.defineProperty(format, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,
	};
	const def = {
	    keyword: "format",
	    type: ["number", "string"],
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt, ruleType) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        const { opts, errSchemaPath, schemaEnv, self } = it;
	        if (!opts.validateFormats)
	            return;
	        if ($data)
	            validate$DataFormat();
	        else
	            validateFormat();
	        function validate$DataFormat() {
	            const fmts = gen.scopeValue("formats", {
	                ref: self.formats,
	                code: opts.code.formats,
	            });
	            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);
	            const fType = gen.let("fType");
	            const format = gen.let("format");
	            // TODO simplify
	            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
	            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
	            function unknownFmt() {
	                if (opts.strictSchema === false)
	                    return codegen_1.nil;
	                return (0, codegen_1._) `${schemaCode} && !${format}`;
	            }
	            function invalidFmt() {
	                const callFormat = schemaEnv.$async
	                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
	                    : (0, codegen_1._) `${format}(${data})`;
	                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
	                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
	            }
	        }
	        function validateFormat() {
	            const formatDef = self.formats[schema];
	            if (!formatDef) {
	                unknownFormat();
	                return;
	            }
	            if (formatDef === true)
	                return;
	            const [fmtType, format, fmtRef] = getFormat(formatDef);
	            if (fmtType === ruleType)
	                cxt.pass(validCondition());
	            function unknownFormat() {
	                if (opts.strictSchema === false) {
	                    self.logger.warn(unknownMsg());
	                    return;
	                }
	                throw new Error(unknownMsg());
	                function unknownMsg() {
	                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
	                }
	            }
	            function getFormat(fmtDef) {
	                const code = fmtDef instanceof RegExp
	                    ? (0, codegen_1.regexpCode)(fmtDef)
	                    : opts.code.formats
	                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
	                        : undefined;
	                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
	                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
	                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];
	                }
	                return ["string", fmtDef, fmt];
	            }
	            function validCondition() {
	                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
	                    if (!schemaEnv.$async)
	                        throw new Error("async format in sync schema");
	                    return (0, codegen_1._) `await ${fmtRef}(${data})`;
	                }
	                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;
	            }
	        }
	    },
	};
	format.default = def;
	
	return format;
}

var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format$1;
	hasRequiredFormat = 1;
	Object.defineProperty(format$1, "__esModule", { value: true });
	const format_1 = requireFormat$1();
	const format = [format_1.default];
	format$1.default = format;
	
	return format$1;
}

var metadata = {};

var hasRequiredMetadata;

function requireMetadata () {
	if (hasRequiredMetadata) return metadata;
	hasRequiredMetadata = 1;
	Object.defineProperty(metadata, "__esModule", { value: true });
	metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
	metadata.metadataVocabulary = [
	    "title",
	    "description",
	    "default",
	    "deprecated",
	    "readOnly",
	    "writeOnly",
	    "examples",
	];
	metadata.contentVocabulary = [
	    "contentMediaType",
	    "contentEncoding",
	    "contentSchema",
	];
	
	return metadata;
}

var hasRequiredDraft7;

function requireDraft7 () {
	if (hasRequiredDraft7) return draft7;
	hasRequiredDraft7 = 1;
	Object.defineProperty(draft7, "__esModule", { value: true });
	const core_1 = requireCore();
	const validation_1 = requireValidation();
	const applicator_1 = requireApplicator();
	const format_1 = requireFormat();
	const metadata_1 = requireMetadata();
	const draft7Vocabularies = [
	    core_1.default,
	    validation_1.default,
	    (0, applicator_1.default)(),
	    format_1.default,
	    metadata_1.metadataVocabulary,
	    metadata_1.contentVocabulary,
	];
	draft7.default = draft7Vocabularies;
	
	return draft7;
}

var discriminator = {};

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	Object.defineProperty(types, "__esModule", { value: true });
	types.DiscrError = void 0;
	var DiscrError;
	(function (DiscrError) {
	    DiscrError["Tag"] = "tag";
	    DiscrError["Mapping"] = "mapping";
	})(DiscrError || (types.DiscrError = DiscrError = {}));
	
	return types;
}

var hasRequiredDiscriminator;

function requireDiscriminator () {
	if (hasRequiredDiscriminator) return discriminator;
	hasRequiredDiscriminator = 1;
	Object.defineProperty(discriminator, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const types_1 = requireTypes();
	const compile_1 = requireCompile();
	const ref_error_1 = requireRef_error();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
	        ? `tag "${tagName}" must be string`
	        : `value of tag "${tagName}" must be in oneOf`,
	    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
	};
	const def = {
	    keyword: "discriminator",
	    type: "object",
	    schemaType: "object",
	    error,
	    code(cxt) {
	        const { gen, data, schema, parentSchema, it } = cxt;
	        const { oneOf } = parentSchema;
	        if (!it.opts.discriminator) {
	            throw new Error("discriminator: requires discriminator option");
	        }
	        const tagName = schema.propertyName;
	        if (typeof tagName != "string")
	            throw new Error("discriminator: requires propertyName");
	        if (schema.mapping)
	            throw new Error("discriminator: mapping is not supported");
	        if (!oneOf)
	            throw new Error("discriminator: requires oneOf keyword");
	        const valid = gen.let("valid", false);
	        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
	        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
	        cxt.ok(valid);
	        function validateMapping() {
	            const mapping = getMapping();
	            gen.if(false);
	            for (const tagValue in mapping) {
	                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	                gen.assign(valid, applyTagSchema(mapping[tagValue]));
	            }
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
	            gen.endIf();
	        }
	        function applyTagSchema(schemaProp) {
	            const _valid = gen.name("valid");
	            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
	            cxt.mergeEvaluated(schCxt, codegen_1.Name);
	            return _valid;
	        }
	        function getMapping() {
	            var _a;
	            const oneOfMapping = {};
	            const topRequired = hasRequired(parentSchema);
	            let tagRequired = true;
	            for (let i = 0; i < oneOf.length; i++) {
	                let sch = oneOf[i];
	                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
	                    const ref = sch.$ref;
	                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
	                    if (sch instanceof compile_1.SchemaEnv)
	                        sch = sch.schema;
	                    if (sch === undefined)
	                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
	                }
	                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
	                if (typeof propSch != "object") {
	                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
	                }
	                tagRequired = tagRequired && (topRequired || hasRequired(sch));
	                addMappings(propSch, i);
	            }
	            if (!tagRequired)
	                throw new Error(`discriminator: "${tagName}" must be required`);
	            return oneOfMapping;
	            function hasRequired({ required }) {
	                return Array.isArray(required) && required.includes(tagName);
	            }
	            function addMappings(sch, i) {
	                if (sch.const) {
	                    addMapping(sch.const, i);
	                }
	                else if (sch.enum) {
	                    for (const tagValue of sch.enum) {
	                        addMapping(tagValue, i);
	                    }
	                }
	                else {
	                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
	                }
	            }
	            function addMapping(tagValue, i) {
	                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
	                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
	                }
	                oneOfMapping[tagValue] = i;
	            }
	        }
	    },
	};
	discriminator.default = def;
	
	return discriminator;
}

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$3 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": true
};

var hasRequiredAjv;

function requireAjv () {
	if (hasRequiredAjv) return ajv.exports;
	hasRequiredAjv = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
		const core_1 = requireCore$1();
		const draft7_1 = requireDraft7();
		const discriminator_1 = requireDiscriminator();
		const draft7MetaSchema = require$$3;
		const META_SUPPORT_DATA = ["/properties"];
		const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
		class Ajv extends core_1.default {
		    _addVocabularies() {
		        super._addVocabularies();
		        draft7_1.default.forEach((v) => this.addVocabulary(v));
		        if (this.opts.discriminator)
		            this.addKeyword(discriminator_1.default);
		    }
		    _addDefaultMetaSchema() {
		        super._addDefaultMetaSchema();
		        if (!this.opts.meta)
		            return;
		        const metaSchema = this.opts.$data
		            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
		            : draft7MetaSchema;
		        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
		        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		    }
		    defaultMeta() {
		        return (this.opts.defaultMeta =
		            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
		    }
		}
		exports.Ajv = Ajv;
		module.exports = exports = Ajv;
		module.exports.Ajv = Ajv;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = Ajv;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		var validation_error_1 = requireValidation_error();
		Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
		var ref_error_1 = requireRef_error();
		Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
		
	} (ajv, ajv.exports));
	return ajv.exports;
}

var ajvExports = requireAjv();

const unit = Object.create(null);
const m = 60000, h = m * 60, d = h * 24, y = d * 365.25;

unit.year = unit.yr = unit.y = y;
unit.month = unit.mo = unit.mth = y / 12;
unit.week = unit.wk = unit.w = d * 7;
unit.day = unit.d = d;
unit.hour = unit.hr = unit.h = h;
unit.minute = unit.min = unit.m = m;
unit.second = unit.sec = unit.s = 1000;
unit.millisecond = unit.millisec = unit.ms = 1;
unit.microsecond = unit.microsec =  unit.us = unit.s = 1e-3;
unit.nanosecond = unit.nanosec = unit.ns = 1e-6;

unit.group = ',';
unit.decimal = '.';
unit.placeholder = ' _';

const durationRE = /((?:\d{1,16}(?:\.\d{1,16})?|\.\d{1,16})(?:[eE][-+]?\d{1,4})?)\s?([\p{L}]{0,14})/gu;

parse.unit = unit;

/**
 * convert `str` to ms
 *
 * @param {string} str
 * @param {string} format
 * @return {number|null}
 */
function parse(str = '', format = 'ms') {
  let result = null, prevUnits;

  String(str)
    .replace(new RegExp(`(\\d)[${parse.unit.placeholder}${parse.unit.group}](\\d)`, 'g'), '$1$2')  // clean up group separators / placeholders
    .replace(parse.unit.decimal, '.') // normalize decimal separator
    .replace(durationRE, (_, n, units) => {
    // if no units, find next smallest units or fall back to format value
    // eg. 1h30 -> 1h30m
    if (!units) {
      if (prevUnits) {
        for (const u in parse.unit) if (parse.unit[u] < prevUnits) { units = u; break }
      }
      else units = format;
    }
    else units = units.toLowerCase();

    prevUnits = units = parse.unit[units] || parse.unit[units.replace(/s$/, '')];

    if (units) result = (result || 0) + n * units;
  });

  return result && ((result / (parse.unit[format] || 1)) * (str[0] === '-' ? -1 : 1))
}

const configSchema = {
  type: "object",
  properties: {
    coin: { type: "string" },
    redis: {
      type: "object",
      properties: {
        endpoint: { type: "string" }
      }
    },
    unlocker: {
      type: "object",
      properties: {
        poolFee: { type: "number" },
        poolFeeAddress: { type: "string" },
        depth: { type: "number" },
        immatureDepth: { type: "number" },
        window: { type: "number" },
        blockWindow: { type: "number" },
        interval: { type: "string" },
        daemon: { type: "string" },
        timeout: { type: "string" }
      }
    },
    payouts: {
      type: "object",
      properties: {
        address: { type: "string" },
        thresold: { type: "number" },
        bgsave: { type: "boolean" }
      }
    }
  },
  required: ["coin"]
};
function getConfig() {
  const configFile = process$1.env.CONFIG_FILE || "config.json";
  if (!existsSync(configFile)) {
    throw new Error("Config file not found");
  }
  const config = JSON.parse(readFileSync(configFile, { encoding: "utf8" }));
  const ajv = new ajvExports.Ajv();
  if (!ajv.compile(configSchema)(config)) {
    throw new Error("Invalid config, check the config.example.json and verify if config is valid");
  }
  return {
    redisUrl: config.redis?.endpoint || "127.0.0.1:6379",
    bgSave: config.payouts?.bgsave ?? true,
    providerUrl: config.unlocker?.daemon || "http://localhost:8545",
    providerTimeout: parse(config.unlocker?.timeout || "0") ?? 60 * 1e3,
    coin: config.coin,
    poolFee: BigInt(config.unlocker?.poolFee || 0) || void 0,
    poolFeeAddress: config.unlocker?.poolFeeAddress ? getAddress(config.unlocker?.poolFeeAddress) : void 0,
    depth: config.unlocker?.depth || 32,
    immatureDepth: config.unlocker?.immatureDepth || 16,
    window: config.unlocker?.window || 86400,
    blockWindow: config.unlocker?.blockWindow || 1e3,
    interval: parse(config.unlocker?.interval || "0") || 600 * 1e3,
    // default to 10 minutes
    coinbase: config.payouts?.address ? getAddress(config.payouts?.address) : void 0,
    thresold: BigInt(config.payouts?.thresold || 0) || parseEther("0.01")
  };
}

async function start() {
  const config = getConfig();
  console.log("Pool Unlocker:", config);
  const unlocker = new Unlocker(config);
  await unlocker.unlock();
  setInterval(async () => {
    await unlocker.unlock();
  }, unlocker.interval);
}
start();
